{"version":3,"file":"bitcoin-vendor-GUW4GuwG.js","sources":["../../node_modules/bitcoinjs-lib/src/networks.js","../../node_modules/bitcoinjs-lib/src/bip66.js","../../node_modules/bitcoinjs-lib/src/ops.js","../../node_modules/bitcoinjs-lib/src/push_data.js","../../node_modules/bitcoinjs-lib/src/script_number.js","../../node_modules/bitcoinjs-lib/src/types.js","../../node_modules/bitcoinjs-lib/src/script_signature.js","../../node_modules/bitcoinjs-lib/src/script.js","../../node_modules/bitcoinjs-lib/src/payments/lazy.js","../../node_modules/bitcoinjs-lib/src/payments/embed.js","../../node_modules/bitcoinjs-lib/src/payments/p2ms.js","../../node_modules/bitcoinjs-lib/src/payments/p2pk.js","../../node_modules/bitcoinjs-lib/src/crypto.js","../../node_modules/bitcoinjs-lib/src/payments/p2pkh.js","../../node_modules/bitcoinjs-lib/src/payments/p2sh.js","../../node_modules/bitcoinjs-lib/src/payments/p2wpkh.js","../../node_modules/bitcoinjs-lib/src/payments/p2wsh.js","../../node_modules/bitcoinjs-lib/src/ecc_lib.js","../../node_modules/bitcoinjs-lib/src/bufferutils.js","../../node_modules/bitcoinjs-lib/src/payments/bip341.js","../../node_modules/bitcoinjs-lib/src/payments/p2tr.js","../../node_modules/bitcoinjs-lib/src/payments/index.js","../../node_modules/bitcoinjs-lib/src/address.js","../../node_modules/bitcoinjs-lib/src/merkle.js","../../node_modules/bitcoinjs-lib/src/transaction.js","../../node_modules/bitcoinjs-lib/src/block.js","../../node_modules/bitcoinjs-lib/src/psbt/psbtutils.js","../../node_modules/bitcoinjs-lib/src/psbt/bip371.js","../../node_modules/bitcoinjs-lib/src/psbt.js","../../node_modules/bitcoinjs-lib/src/index.js","../../node_modules/@bitcoinerlab/secp256k1/dist/index.js"],"sourcesContent":["'use strict';\n// https://en.bitcoin.it/wiki/List_of_address_prefixes\n// Dogecoin BIP32 is a proposed standard: https://bitcointalk.org/index.php?topic=409731\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.testnet = exports.regtest = exports.bitcoin = void 0;\n/**\n * Represents the Bitcoin network configuration.\n */\nexports.bitcoin = {\n  /**\n   * The message prefix used for signing Bitcoin messages.\n   */\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  /**\n   * The Bech32 prefix used for Bitcoin addresses.\n   */\n  bech32: 'bc',\n  /**\n   * The BIP32 key prefixes for Bitcoin.\n   */\n  bip32: {\n    /**\n     * The public key prefix for BIP32 extended public keys.\n     */\n    public: 0x0488b21e,\n    /**\n     * The private key prefix for BIP32 extended private keys.\n     */\n    private: 0x0488ade4,\n  },\n  /**\n   * The prefix for Bitcoin public key hashes.\n   */\n  pubKeyHash: 0x00,\n  /**\n   * The prefix for Bitcoin script hashes.\n   */\n  scriptHash: 0x05,\n  /**\n   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.\n   */\n  wif: 0x80,\n};\n/**\n * Represents the regtest network configuration.\n */\nexports.regtest = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bcrt',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n/**\n * Represents the testnet network configuration.\n */\nexports.testnet = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'tb',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n","'use strict';\n// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki\n// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n// NOTE: SIGHASH byte ignored AND restricted, truncate before use\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.encode = exports.decode = exports.check = void 0;\nfunction check(buffer) {\n  if (buffer.length < 8) return false;\n  if (buffer.length > 72) return false;\n  if (buffer[0] !== 0x30) return false;\n  if (buffer[1] !== buffer.length - 2) return false;\n  if (buffer[2] !== 0x02) return false;\n  const lenR = buffer[3];\n  if (lenR === 0) return false;\n  if (5 + lenR >= buffer.length) return false;\n  if (buffer[4 + lenR] !== 0x02) return false;\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) return false;\n  if (6 + lenR + lenS !== buffer.length) return false;\n  if (buffer[4] & 0x80) return false;\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;\n  if (buffer[lenR + 6] & 0x80) return false;\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    return false;\n  return true;\n}\nexports.check = check;\nfunction decode(buffer) {\n  if (buffer.length < 8) throw new Error('DER sequence length is too short');\n  if (buffer.length > 72) throw new Error('DER sequence length is too long');\n  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');\n  if (buffer[1] !== buffer.length - 2)\n    throw new Error('DER sequence length is invalid');\n  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');\n  const lenR = buffer[3];\n  if (lenR === 0) throw new Error('R length is zero');\n  if (5 + lenR >= buffer.length) throw new Error('R length is too long');\n  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) throw new Error('S length is zero');\n  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');\n  if (buffer[4] & 0x80) throw new Error('R value is negative');\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))\n    throw new Error('R value excessively padded');\n  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    throw new Error('S value excessively padded');\n  // non-BIP66 - extract R, S values\n  return {\n    r: buffer.slice(4, 4 + lenR),\n    s: buffer.slice(6 + lenR),\n  };\n}\nexports.decode = decode;\n/*\n * Expects r and s to be positive DER integers.\n *\n * The DER format uses the most significant bit as a sign bit (& 0x80).\n * If the significant bit is set AND the integer is positive, a 0x00 is prepended.\n *\n * Examples:\n *\n *      0 =>     0x00\n *      1 =>     0x01\n *     -1 =>     0xff\n *    127 =>     0x7f\n *   -127 =>     0x81\n *    128 =>   0x0080\n *   -128 =>     0x80\n *    255 =>   0x00ff\n *   -255 =>   0xff01\n *  16300 =>   0x3fac\n * -16300 =>   0xc054\n *  62300 => 0x00f35c\n * -62300 => 0xff0ca4\n */\nfunction encode(r, s) {\n  const lenR = r.length;\n  const lenS = s.length;\n  if (lenR === 0) throw new Error('R length is zero');\n  if (lenS === 0) throw new Error('S length is zero');\n  if (lenR > 33) throw new Error('R length is too long');\n  if (lenS > 33) throw new Error('S length is too long');\n  if (r[0] & 0x80) throw new Error('R value is negative');\n  if (s[0] & 0x80) throw new Error('S value is negative');\n  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))\n    throw new Error('R value excessively padded');\n  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))\n    throw new Error('S value excessively padded');\n  const signature = Buffer.allocUnsafe(6 + lenR + lenS);\n  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n  signature[0] = 0x30;\n  signature[1] = signature.length - 2;\n  signature[2] = 0x02;\n  signature[3] = r.length;\n  r.copy(signature, 4);\n  signature[4 + lenR] = 0x02;\n  signature[5 + lenR] = s.length;\n  s.copy(signature, 6 + lenR);\n  return signature;\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.REVERSE_OPS = exports.OPS = void 0;\nconst OPS = {\n  OP_FALSE: 0,\n  OP_0: 0,\n  OP_PUSHDATA1: 76,\n  OP_PUSHDATA2: 77,\n  OP_PUSHDATA4: 78,\n  OP_1NEGATE: 79,\n  OP_RESERVED: 80,\n  OP_TRUE: 81,\n  OP_1: 81,\n  OP_2: 82,\n  OP_3: 83,\n  OP_4: 84,\n  OP_5: 85,\n  OP_6: 86,\n  OP_7: 87,\n  OP_8: 88,\n  OP_9: 89,\n  OP_10: 90,\n  OP_11: 91,\n  OP_12: 92,\n  OP_13: 93,\n  OP_14: 94,\n  OP_15: 95,\n  OP_16: 96,\n  OP_NOP: 97,\n  OP_VER: 98,\n  OP_IF: 99,\n  OP_NOTIF: 100,\n  OP_VERIF: 101,\n  OP_VERNOTIF: 102,\n  OP_ELSE: 103,\n  OP_ENDIF: 104,\n  OP_VERIFY: 105,\n  OP_RETURN: 106,\n  OP_TOALTSTACK: 107,\n  OP_FROMALTSTACK: 108,\n  OP_2DROP: 109,\n  OP_2DUP: 110,\n  OP_3DUP: 111,\n  OP_2OVER: 112,\n  OP_2ROT: 113,\n  OP_2SWAP: 114,\n  OP_IFDUP: 115,\n  OP_DEPTH: 116,\n  OP_DROP: 117,\n  OP_DUP: 118,\n  OP_NIP: 119,\n  OP_OVER: 120,\n  OP_PICK: 121,\n  OP_ROLL: 122,\n  OP_ROT: 123,\n  OP_SWAP: 124,\n  OP_TUCK: 125,\n  OP_CAT: 126,\n  OP_SUBSTR: 127,\n  OP_LEFT: 128,\n  OP_RIGHT: 129,\n  OP_SIZE: 130,\n  OP_INVERT: 131,\n  OP_AND: 132,\n  OP_OR: 133,\n  OP_XOR: 134,\n  OP_EQUAL: 135,\n  OP_EQUALVERIFY: 136,\n  OP_RESERVED1: 137,\n  OP_RESERVED2: 138,\n  OP_1ADD: 139,\n  OP_1SUB: 140,\n  OP_2MUL: 141,\n  OP_2DIV: 142,\n  OP_NEGATE: 143,\n  OP_ABS: 144,\n  OP_NOT: 145,\n  OP_0NOTEQUAL: 146,\n  OP_ADD: 147,\n  OP_SUB: 148,\n  OP_MUL: 149,\n  OP_DIV: 150,\n  OP_MOD: 151,\n  OP_LSHIFT: 152,\n  OP_RSHIFT: 153,\n  OP_BOOLAND: 154,\n  OP_BOOLOR: 155,\n  OP_NUMEQUAL: 156,\n  OP_NUMEQUALVERIFY: 157,\n  OP_NUMNOTEQUAL: 158,\n  OP_LESSTHAN: 159,\n  OP_GREATERTHAN: 160,\n  OP_LESSTHANOREQUAL: 161,\n  OP_GREATERTHANOREQUAL: 162,\n  OP_MIN: 163,\n  OP_MAX: 164,\n  OP_WITHIN: 165,\n  OP_RIPEMD160: 166,\n  OP_SHA1: 167,\n  OP_SHA256: 168,\n  OP_HASH160: 169,\n  OP_HASH256: 170,\n  OP_CODESEPARATOR: 171,\n  OP_CHECKSIG: 172,\n  OP_CHECKSIGVERIFY: 173,\n  OP_CHECKMULTISIG: 174,\n  OP_CHECKMULTISIGVERIFY: 175,\n  OP_NOP1: 176,\n  OP_NOP2: 177,\n  OP_CHECKLOCKTIMEVERIFY: 177,\n  OP_NOP3: 178,\n  OP_CHECKSEQUENCEVERIFY: 178,\n  OP_NOP4: 179,\n  OP_NOP5: 180,\n  OP_NOP6: 181,\n  OP_NOP7: 182,\n  OP_NOP8: 183,\n  OP_NOP9: 184,\n  OP_NOP10: 185,\n  OP_CHECKSIGADD: 186,\n  OP_PUBKEYHASH: 253,\n  OP_PUBKEY: 254,\n  OP_INVALIDOPCODE: 255,\n};\nexports.OPS = OPS;\nconst REVERSE_OPS = {};\nexports.REVERSE_OPS = REVERSE_OPS;\nfor (const op of Object.keys(OPS)) {\n  const code = OPS[op];\n  REVERSE_OPS[code] = op;\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.decode = exports.encode = exports.encodingLength = void 0;\nconst ops_1 = require('./ops');\n/**\n * Calculates the encoding length of a number used for push data in Bitcoin transactions.\n * @param i The number to calculate the encoding length for.\n * @returns The encoding length of the number.\n */\nfunction encodingLength(i) {\n  return i < ops_1.OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;\n}\nexports.encodingLength = encodingLength;\n/**\n * Encodes a number into a buffer using a variable-length encoding scheme.\n * The encoded buffer is written starting at the specified offset.\n * Returns the size of the encoded buffer.\n *\n * @param buffer - The buffer to write the encoded data into.\n * @param num - The number to encode.\n * @param offset - The offset at which to start writing the encoded buffer.\n * @returns The size of the encoded buffer.\n */\nfunction encode(buffer, num, offset) {\n  const size = encodingLength(num);\n  // ~6 bit\n  if (size === 1) {\n    buffer.writeUInt8(num, offset);\n    // 8 bit\n  } else if (size === 2) {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);\n    buffer.writeUInt8(num, offset + 1);\n    // 16 bit\n  } else if (size === 3) {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);\n    buffer.writeUInt16LE(num, offset + 1);\n    // 32 bit\n  } else {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);\n    buffer.writeUInt32LE(num, offset + 1);\n  }\n  return size;\n}\nexports.encode = encode;\n/**\n * Decodes a buffer and returns information about the opcode, number, and size.\n * @param buffer - The buffer to decode.\n * @param offset - The offset within the buffer to start decoding.\n * @returns An object containing the opcode, number, and size, or null if decoding fails.\n */\nfunction decode(buffer, offset) {\n  const opcode = buffer.readUInt8(offset);\n  let num;\n  let size;\n  // ~6 bit\n  if (opcode < ops_1.OPS.OP_PUSHDATA1) {\n    num = opcode;\n    size = 1;\n    // 8 bit\n  } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {\n    if (offset + 2 > buffer.length) return null;\n    num = buffer.readUInt8(offset + 1);\n    size = 2;\n    // 16 bit\n  } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {\n    if (offset + 3 > buffer.length) return null;\n    num = buffer.readUInt16LE(offset + 1);\n    size = 3;\n    // 32 bit\n  } else {\n    if (offset + 5 > buffer.length) return null;\n    if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode');\n    num = buffer.readUInt32LE(offset + 1);\n    size = 5;\n  }\n  return {\n    opcode,\n    number: num,\n    size,\n  };\n}\nexports.decode = decode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.encode = exports.decode = void 0;\n/**\n * Decodes a script number from a buffer.\n *\n * @param buffer - The buffer containing the script number.\n * @param maxLength - The maximum length of the script number. Defaults to 4.\n * @param minimal - Whether the script number should be minimal. Defaults to true.\n * @returns The decoded script number.\n * @throws {TypeError} If the script number overflows the maximum length.\n * @throws {Error} If the script number is not minimally encoded when minimal is true.\n */\nfunction decode(buffer, maxLength, minimal) {\n  maxLength = maxLength || 4;\n  minimal = minimal === undefined ? true : minimal;\n  const length = buffer.length;\n  if (length === 0) return 0;\n  if (length > maxLength) throw new TypeError('Script number overflow');\n  if (minimal) {\n    if ((buffer[length - 1] & 0x7f) === 0) {\n      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)\n        throw new Error('Non-minimally encoded script number');\n    }\n  }\n  // 40-bit\n  if (length === 5) {\n    const a = buffer.readUInt32LE(0);\n    const b = buffer.readUInt8(4);\n    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);\n    return b * 0x100000000 + a;\n  }\n  // 32-bit / 24-bit / 16-bit / 8-bit\n  let result = 0;\n  for (let i = 0; i < length; ++i) {\n    result |= buffer[i] << (8 * i);\n  }\n  if (buffer[length - 1] & 0x80)\n    return -(result & ~(0x80 << (8 * (length - 1))));\n  return result;\n}\nexports.decode = decode;\nfunction scriptNumSize(i) {\n  return i > 0x7fffffff\n    ? 5\n    : i > 0x7fffff\n    ? 4\n    : i > 0x7fff\n    ? 3\n    : i > 0x7f\n    ? 2\n    : i > 0x00\n    ? 1\n    : 0;\n}\n/**\n * Encodes a number into a Buffer using a specific format.\n *\n * @param _number - The number to encode.\n * @returns The encoded number as a Buffer.\n */\nfunction encode(_number) {\n  let value = Math.abs(_number);\n  const size = scriptNumSize(value);\n  const buffer = Buffer.allocUnsafe(size);\n  const negative = _number < 0;\n  for (let i = 0; i < size; ++i) {\n    buffer.writeUInt8(value & 0xff, i);\n    value >>= 8;\n  }\n  if (buffer[size - 1] & 0x80) {\n    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);\n  } else if (negative) {\n    buffer[size - 1] |= 0x80;\n  }\n  return buffer;\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.oneOf =\n  exports.Null =\n  exports.BufferN =\n  exports.Function =\n  exports.UInt32 =\n  exports.UInt8 =\n  exports.tuple =\n  exports.maybe =\n  exports.Hex =\n  exports.Buffer =\n  exports.String =\n  exports.Boolean =\n  exports.Array =\n  exports.Number =\n  exports.Hash256bit =\n  exports.Hash160bit =\n  exports.Buffer256bit =\n  exports.isTaptree =\n  exports.isTapleaf =\n  exports.TAPLEAF_VERSION_MASK =\n  exports.Satoshi =\n  exports.isPoint =\n  exports.stacksEqual =\n  exports.typeforce =\n    void 0;\nconst buffer_1 = require('buffer');\nexports.typeforce = require('typeforce');\nconst ZERO32 = buffer_1.Buffer.alloc(32, 0);\nconst EC_P = buffer_1.Buffer.from(\n  'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',\n  'hex',\n);\n/**\n * Checks if two arrays of Buffers are equal.\n * @param a - The first array of Buffers.\n * @param b - The second array of Buffers.\n * @returns True if the arrays are equal, false otherwise.\n */\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\nexports.stacksEqual = stacksEqual;\n/**\n * Checks if the given value is a valid elliptic curve point.\n * @param p - The value to check.\n * @returns True if the value is a valid elliptic curve point, false otherwise.\n */\nfunction isPoint(p) {\n  if (!buffer_1.Buffer.isBuffer(p)) return false;\n  if (p.length < 33) return false;\n  const t = p[0];\n  const x = p.slice(1, 33);\n  if (x.compare(ZERO32) === 0) return false;\n  if (x.compare(EC_P) >= 0) return false;\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    return true;\n  }\n  const y = p.slice(33);\n  if (y.compare(ZERO32) === 0) return false;\n  if (y.compare(EC_P) >= 0) return false;\n  if (t === 0x04 && p.length === 65) return true;\n  return false;\n}\nexports.isPoint = isPoint;\nconst SATOSHI_MAX = 21 * 1e14;\nfunction Satoshi(value) {\n  return exports.typeforce.UInt53(value) && value <= SATOSHI_MAX;\n}\nexports.Satoshi = Satoshi;\nexports.TAPLEAF_VERSION_MASK = 0xfe;\nfunction isTapleaf(o) {\n  if (!o || !('output' in o)) return false;\n  if (!buffer_1.Buffer.isBuffer(o.output)) return false;\n  if (o.version !== undefined)\n    return (o.version & exports.TAPLEAF_VERSION_MASK) === o.version;\n  return true;\n}\nexports.isTapleaf = isTapleaf;\nfunction isTaptree(scriptTree) {\n  if (!(0, exports.Array)(scriptTree)) return isTapleaf(scriptTree);\n  if (scriptTree.length !== 2) return false;\n  return scriptTree.every(t => isTaptree(t));\n}\nexports.isTaptree = isTaptree;\nexports.Buffer256bit = exports.typeforce.BufferN(32);\nexports.Hash160bit = exports.typeforce.BufferN(20);\nexports.Hash256bit = exports.typeforce.BufferN(32);\nexports.Number = exports.typeforce.Number;\nexports.Array = exports.typeforce.Array;\nexports.Boolean = exports.typeforce.Boolean;\nexports.String = exports.typeforce.String;\nexports.Buffer = exports.typeforce.Buffer;\nexports.Hex = exports.typeforce.Hex;\nexports.maybe = exports.typeforce.maybe;\nexports.tuple = exports.typeforce.tuple;\nexports.UInt8 = exports.typeforce.UInt8;\nexports.UInt32 = exports.typeforce.UInt32;\nexports.Function = exports.typeforce.Function;\nexports.BufferN = exports.typeforce.BufferN;\nexports.Null = exports.typeforce.Null;\nexports.oneOf = exports.typeforce.oneOf;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.encode = exports.decode = void 0;\nconst bip66 = require('./bip66');\nconst script_1 = require('./script');\nconst types = require('./types');\nconst { typeforce } = types;\nconst ZERO = Buffer.alloc(1, 0);\n/**\n * Converts a buffer to a DER-encoded buffer.\n * @param x - The buffer to be converted.\n * @returns The DER-encoded buffer.\n */\nfunction toDER(x) {\n  let i = 0;\n  while (x[i] === 0) ++i;\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);\n  return x;\n}\n/**\n * Converts a DER-encoded signature to a buffer.\n * If the first byte of the input buffer is 0x00, it is skipped.\n * The resulting buffer is 32 bytes long, filled with zeros if necessary.\n * @param x - The DER-encoded signature.\n * @returns The converted buffer.\n */\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = Buffer.alloc(32, 0);\n  const bstart = Math.max(0, 32 - x.length);\n  x.copy(buffer, bstart);\n  return buffer;\n}\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\n/**\n * Decodes a buffer into a ScriptSignature object.\n * @param buffer - The buffer to decode.\n * @returns The decoded ScriptSignature object.\n * @throws Error if the hashType is invalid.\n */\nfunction decode(buffer) {\n  const hashType = buffer.readUInt8(buffer.length - 1);\n  if (!(0, script_1.isDefinedHashType)(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const decoded = bip66.decode(buffer.slice(0, -1));\n  const r = fromDER(decoded.r);\n  const s = fromDER(decoded.s);\n  const signature = Buffer.concat([r, s], 64);\n  return { signature, hashType };\n}\nexports.decode = decode;\n/**\n * Encodes a signature and hash type into a buffer.\n * @param signature - The signature to encode.\n * @param hashType - The hash type to encode.\n * @returns The encoded buffer.\n * @throws Error if the hashType is invalid.\n */\nfunction encode(signature, hashType) {\n  typeforce(\n    {\n      signature: types.BufferN(64),\n      hashType: types.UInt8,\n    },\n    { signature, hashType },\n  );\n  if (!(0, script_1.isDefinedHashType)(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const hashTypeBuffer = Buffer.allocUnsafe(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.signature =\n  exports.number =\n  exports.isCanonicalScriptSignature =\n  exports.isDefinedHashType =\n  exports.isCanonicalPubKey =\n  exports.toStack =\n  exports.fromASM =\n  exports.toASM =\n  exports.decompile =\n  exports.compile =\n  exports.countNonPushOnlyOPs =\n  exports.isPushOnly =\n  exports.OPS =\n    void 0;\n/**\n * Script tools, including decompile, compile, toASM, fromASM, toStack, isCanonicalPubKey, isCanonicalScriptSignature\n * @packageDocumentation\n */\nconst bip66 = require('./bip66');\nconst ops_1 = require('./ops');\nObject.defineProperty(exports, 'OPS', {\n  enumerable: true,\n  get: function () {\n    return ops_1.OPS;\n  },\n});\nconst pushdata = require('./push_data');\nconst scriptNumber = require('./script_number');\nconst scriptSignature = require('./script_signature');\nconst types = require('./types');\nconst { typeforce } = types;\nconst OP_INT_BASE = ops_1.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return (\n    types.Number(value) &&\n    (value === ops_1.OPS.OP_0 ||\n      (value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16) ||\n      value === ops_1.OPS.OP_1NEGATE)\n  );\n}\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction countNonPushOnlyOPs(value) {\n  return value.length - value.filter(isPushOnlyChunk).length;\n}\nexports.countNonPushOnlyOPs = countNonPushOnlyOPs;\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return ops_1.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return ops_1.OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\n/**\n * Compiles an array of chunks into a Buffer.\n *\n * @param chunks - The array of chunks to compile.\n * @returns The compiled Buffer.\n * @throws Error if the compilation fails.\n */\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nexports.decompile = decompile;\n/**\n * Converts the given chunks into an ASM (Assembly) string representation.\n * If the chunks parameter is a Buffer, it will be decompiled into a Stack before conversion.\n * @param chunks - The chunks to convert into ASM.\n * @returns The ASM string representation of the chunks.\n */\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  if (!chunks) {\n    throw new Error('Could not convert invalid chunks to ASM');\n  }\n  return chunks\n    .map(chunk => {\n      // data?\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return chunk.toString('hex');\n        chunk = op;\n      }\n      // opcode!\n      return ops_1.REVERSE_OPS[chunk];\n    })\n    .join(' ');\n}\nexports.toASM = toASM;\n/**\n * Converts an ASM string to a Buffer.\n * @param asm The ASM string to convert.\n * @returns The converted Buffer.\n */\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(\n    asm.split(' ').map(chunkStr => {\n      // opcode?\n      if (ops_1.OPS[chunkStr] !== undefined) return ops_1.OPS[chunkStr];\n      typeforce(types.Hex, chunkStr);\n      // data!\n      return Buffer.from(chunkStr, 'hex');\n    }),\n  );\n}\nexports.fromASM = fromASM;\n/**\n * Converts the given chunks into a stack of buffers.\n *\n * @param chunks - The chunks to convert.\n * @returns The stack of buffers.\n */\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === ops_1.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexports.toStack = toStack;\nfunction isCanonicalPubKey(buffer) {\n  return types.isPoint(buffer);\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature;\nexports.number = scriptNumber;\nexports.signature = scriptSignature;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.value = exports.prop = void 0;\nfunction prop(object, name, f) {\n  Object.defineProperty(object, name, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      const _value = f.call(this);\n      this[name] = _value;\n      return _value;\n    },\n    set(_value) {\n      Object.defineProperty(this, name, {\n        configurable: true,\n        enumerable: true,\n        value: _value,\n        writable: true,\n      });\n    },\n  });\n}\nexports.prop = prop;\nfunction value(f) {\n  let _value;\n  return () => {\n    if (_value !== undefined) return _value;\n    _value = f();\n    return _value;\n  };\n}\nexports.value = value;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2data = void 0;\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst OPS = bscript.OPS;\n// output: OP_RETURN ...\n/**\n * Embeds data in a Bitcoin payment.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The modified payment object.\n * @throws {TypeError} If there is not enough data or if the output is invalid.\n */\nfunction p2data(a, opts) {\n  if (!a.data && !a.output) throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      data: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'embed', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.data) return;\n    return bscript.compile([OPS.OP_RETURN].concat(a.data));\n  });\n  lazy.prop(o, 'data', () => {\n    if (!a.output) return;\n    return bscript.decompile(a.output).slice(1);\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      const chunks = bscript.decompile(a.output);\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');\n      if (!chunks.slice(1).every(types_1.typeforce.Buffer))\n        throw new TypeError('Output is invalid');\n      if (a.data && !(0, types_1.stacksEqual)(a.data, o.data))\n        throw new TypeError('Data mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2data = p2data;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2ms = void 0;\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst OPS = bscript.OPS;\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\n// input: OP_0 [signatures ...]\n// output: m [pubKeys ...] n OP_CHECKMULTISIG\n/**\n * Represents a function that creates a Pay-to-Multisig (P2MS) payment object.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The created payment object.\n * @throws {TypeError} If the provided data is not valid.\n */\nfunction p2ms(a, opts) {\n  if (\n    !a.input &&\n    !a.output &&\n    !(a.pubkeys && a.m !== undefined) &&\n    !a.signatures\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  function isAcceptableSignature(x) {\n    return (\n      bscript.isCanonicalScriptSignature(x) ||\n      (opts.allowIncomplete && x === OPS.OP_0) !== undefined\n    );\n  }\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      m: types_1.typeforce.maybe(types_1.typeforce.Number),\n      n: types_1.typeforce.maybe(types_1.typeforce.Number),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      pubkeys: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.isPoint),\n      ),\n      signatures: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(isAcceptableSignature),\n      ),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { network };\n  let chunks = [];\n  let decoded = false;\n  function decode(output) {\n    if (decoded) return;\n    decoded = true;\n    chunks = bscript.decompile(output);\n    o.m = chunks[0] - OP_INT_BASE;\n    o.n = chunks[chunks.length - 2] - OP_INT_BASE;\n    o.pubkeys = chunks.slice(1, -2);\n  }\n  lazy.prop(o, 'output', () => {\n    if (!a.m) return;\n    if (!o.n) return;\n    if (!a.pubkeys) return;\n    return bscript.compile(\n      [].concat(\n        OP_INT_BASE + a.m,\n        a.pubkeys,\n        OP_INT_BASE + o.n,\n        OPS.OP_CHECKMULTISIG,\n      ),\n    );\n  });\n  lazy.prop(o, 'm', () => {\n    if (!o.output) return;\n    decode(o.output);\n    return o.m;\n  });\n  lazy.prop(o, 'n', () => {\n    if (!o.pubkeys) return;\n    return o.pubkeys.length;\n  });\n  lazy.prop(o, 'pubkeys', () => {\n    if (!a.output) return;\n    decode(a.output);\n    return o.pubkeys;\n  });\n  lazy.prop(o, 'signatures', () => {\n    if (!a.input) return;\n    return bscript.decompile(a.input).slice(1);\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signatures) return;\n    return bscript.compile([OPS.OP_0].concat(a.signatures));\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  lazy.prop(o, 'name', () => {\n    if (!o.m || !o.n) return;\n    return `p2ms(${o.m} of ${o.n})`;\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      decode(a.output);\n      if (!types_1.typeforce.Number(chunks[0]))\n        throw new TypeError('Output is invalid');\n      if (!types_1.typeforce.Number(chunks[chunks.length - 2]))\n        throw new TypeError('Output is invalid');\n      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)\n        throw new TypeError('Output is invalid');\n      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)\n        throw new TypeError('Output is invalid');\n      if (!o.pubkeys.every(x => (0, types_1.isPoint)(x)))\n        throw new TypeError('Output is invalid');\n      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');\n      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');\n      if (a.pubkeys && !(0, types_1.stacksEqual)(a.pubkeys, o.pubkeys))\n        throw new TypeError('Pubkeys mismatch');\n    }\n    if (a.pubkeys) {\n      if (a.n !== undefined && a.n !== a.pubkeys.length)\n        throw new TypeError('Pubkey count mismatch');\n      o.n = a.pubkeys.length;\n      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');\n    }\n    if (a.signatures) {\n      if (a.signatures.length < o.m)\n        throw new TypeError('Not enough signatures provided');\n      if (a.signatures.length > o.m)\n        throw new TypeError('Too many signatures provided');\n    }\n    if (a.input) {\n      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');\n      if (\n        o.signatures.length === 0 ||\n        !o.signatures.every(isAcceptableSignature)\n      )\n        throw new TypeError('Input has invalid signature(s)');\n      if (a.signatures && !(0, types_1.stacksEqual)(a.signatures, o.signatures))\n        throw new TypeError('Signature mismatch');\n      if (a.m !== undefined && a.m !== a.signatures.length)\n        throw new TypeError('Signature count mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2ms = p2ms;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2pk = void 0;\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst OPS = bscript.OPS;\n// input: {signature}\n// output: {pubKey} OP_CHECKSIG\n/**\n * Creates a pay-to-public-key (P2PK) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PK payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2pk(a, opts) {\n  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pk', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.pubkey) return;\n    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.output) return;\n    return a.output.slice(1, -1);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signature) return;\n    return bscript.compile([a.signature]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)\n        throw new TypeError('Output is invalid');\n      if (!(0, types_1.isPoint)(o.pubkey))\n        throw new TypeError('Output pubkey is invalid');\n      if (a.pubkey && !a.pubkey.equals(o.pubkey))\n        throw new TypeError('Pubkey mismatch');\n    }\n    if (a.signature) {\n      if (a.input && !a.input.equals(o.input))\n        throw new TypeError('Signature mismatch');\n    }\n    if (a.input) {\n      if (_chunks().length !== 1) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(o.signature))\n        throw new TypeError('Input has invalid signature');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pk = p2pk;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.taggedHash =\n  exports.TAGGED_HASH_PREFIXES =\n  exports.TAGS =\n  exports.hash256 =\n  exports.hash160 =\n  exports.sha256 =\n  exports.sha1 =\n  exports.ripemd160 =\n    void 0;\n/**\n * A module for hashing functions.\n * include ripemd160、sha1、sha256、hash160、hash256、taggedHash\n *\n * @packageDocumentation\n */\nconst ripemd160_1 = require('@noble/hashes/ripemd160');\nconst sha1_1 = require('@noble/hashes/sha1');\nconst sha256_1 = require('@noble/hashes/sha256');\nfunction ripemd160(buffer) {\n  return Buffer.from((0, ripemd160_1.ripemd160)(Uint8Array.from(buffer)));\n}\nexports.ripemd160 = ripemd160;\nfunction sha1(buffer) {\n  return Buffer.from((0, sha1_1.sha1)(Uint8Array.from(buffer)));\n}\nexports.sha1 = sha1;\nfunction sha256(buffer) {\n  return Buffer.from((0, sha256_1.sha256)(Uint8Array.from(buffer)));\n}\nexports.sha256 = sha256;\nfunction hash160(buffer) {\n  return Buffer.from(\n    (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(Uint8Array.from(buffer))),\n  );\n}\nexports.hash160 = hash160;\nfunction hash256(buffer) {\n  return Buffer.from(\n    (0, sha256_1.sha256)((0, sha256_1.sha256)(Uint8Array.from(buffer))),\n  );\n}\nexports.hash256 = hash256;\nexports.TAGS = [\n  'BIP0340/challenge',\n  'BIP0340/aux',\n  'BIP0340/nonce',\n  'TapLeaf',\n  'TapBranch',\n  'TapSighash',\n  'TapTweak',\n  'KeyAgg list',\n  'KeyAgg coefficient',\n];\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\n/**\n * Defines the tagged hash prefixes used in the crypto module.\n */\nexports.TAGGED_HASH_PREFIXES = {\n  'BIP0340/challenge': Buffer.from([\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n  ]),\n  'BIP0340/aux': Buffer.from([\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n  ]),\n  'BIP0340/nonce': Buffer.from([\n    7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244,\n    52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73,\n    119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215,\n    62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47,\n  ]),\n  TapLeaf: Buffer.from([\n    174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211,\n    95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143,\n    220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181,\n    64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238,\n  ]),\n  TapBranch: Buffer.from([\n    25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247,\n    33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25,\n    65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33,\n    111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21,\n  ]),\n  TapSighash: Buffer.from([\n    244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61,\n    149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244,\n    10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149,\n    253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49,\n  ]),\n  TapTweak: Buffer.from([\n    232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66,\n    156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232,\n    15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156,\n    188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233,\n  ]),\n  'KeyAgg list': Buffer.from([\n    72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126,\n    215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28,\n    151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49,\n    156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240,\n  ]),\n  'KeyAgg coefficient': Buffer.from([\n    191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100,\n    130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191,\n    201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130,\n    78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129,\n  ]),\n};\nfunction taggedHash(prefix, data) {\n  return sha256(Buffer.concat([exports.TAGGED_HASH_PREFIXES[prefix], data]));\n}\nexports.taggedHash = taggedHash;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2pkh = void 0;\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst bs58check = require('bs58check');\nconst OPS = bscript.OPS;\n// input: {signature} {pubkey}\n// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG\n/**\n * Creates a Pay-to-Public-Key-Hash (P2PKH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PKH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2pkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const payload = Buffer.from(bs58check.decode(a.address));\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(network.pubKeyHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(3, 23);\n    if (a.address) return _address().hash;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      o.hash,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_CHECKSIG,\n    ]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.input) return;\n    return _chunks()[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return bscript.compile([a.signature, a.pubkey]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.pubKeyHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 25 ||\n        a.output[0] !== OPS.OP_DUP ||\n        a.output[1] !== OPS.OP_HASH160 ||\n        a.output[2] !== 0x14 ||\n        a.output[23] !== OPS.OP_EQUALVERIFY ||\n        a.output[24] !== OPS.OP_CHECKSIG\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(3, 23);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n    }\n    if (a.input) {\n      const chunks = _chunks();\n      if (chunks.length !== 2) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(chunks[0]))\n        throw new TypeError('Input has invalid signature');\n      if (!(0, types_1.isPoint)(chunks[1]))\n        throw new TypeError('Input has invalid pubkey');\n      if (a.signature && !a.signature.equals(chunks[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(chunks[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(chunks[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pkh = p2pkh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2sh = void 0;\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst bs58check = require('bs58check');\nconst OPS = bscript.OPS;\n// input: [redeemScriptSig ...] {redeemScript}\n// witness: <?>\n// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL\n/**\n * Creates a Pay-to-Script-Hash (P2SH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2SH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2sh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),\n      redeem: types_1.typeforce.maybe({\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  const _address = lazy.value(() => {\n    const payload = Buffer.from(bs58check.decode(a.address));\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const _redeem = lazy.value(() => {\n    const chunks = _chunks();\n    const lastChunk = chunks[chunks.length - 1];\n    return {\n      network,\n      output: lastChunk === OPS.OP_FALSE ? Buffer.from([]) : lastChunk,\n      input: bscript.compile(chunks.slice(0, -1)),\n      witness: a.witness || [],\n    };\n  });\n  // output dependents\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(o.network.scriptHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    // in order of least effort\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().hash;\n    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);\n  });\n  // input dependents\n  lazy.prop(o, 'redeem', () => {\n    if (!a.input) return;\n    return _redeem();\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;\n    return bscript.compile(\n      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),\n    );\n  });\n  lazy.prop(o, 'witness', () => {\n    if (o.redeem && o.redeem.witness) return o.redeem.witness;\n    if (o.input) return [];\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2sh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.scriptHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 23 ||\n        a.output[0] !== OPS.OP_HASH160 ||\n        a.output[1] !== 0x14 ||\n        a.output[22] !== OPS.OP_EQUAL\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2, 22);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    // inlined to prevent 'no-inner-declarations' failing\n    const checkRedeem = redeem => {\n      // is the redeem output empty/invalid?\n      if (redeem.output) {\n        const decompile = bscript.decompile(redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output too short');\n        if (redeem.output.byteLength > 520)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 520 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = bcrypto.hash160(redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (redeem.input) {\n        const hasInput = redeem.input.length > 0;\n        const hasWitness = redeem.witness && redeem.witness.length > 0;\n        if (!hasInput && !hasWitness) throw new TypeError('Empty input');\n        if (hasInput && hasWitness)\n          throw new TypeError('Input and witness provided');\n        if (hasInput) {\n          const richunks = bscript.decompile(redeem.input);\n          if (!bscript.isPushOnly(richunks))\n            throw new TypeError('Non push-only scriptSig');\n        }\n      }\n    };\n    if (a.input) {\n      const chunks = _chunks();\n      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');\n      if (!Buffer.isBuffer(_redeem().output))\n        throw new TypeError('Input is invalid');\n      checkRedeem(_redeem());\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      if (a.input) {\n        const redeem = _redeem();\n        if (a.redeem.output && !a.redeem.output.equals(redeem.output))\n          throw new TypeError('Redeem.output mismatch');\n        if (a.redeem.input && !a.redeem.input.equals(redeem.input))\n          throw new TypeError('Redeem.input mismatch');\n      }\n      checkRedeem(a.redeem);\n    }\n    if (a.witness) {\n      if (\n        a.redeem &&\n        a.redeem.witness &&\n        !(0, types_1.stacksEqual)(a.redeem.witness, a.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2sh = p2sh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2wpkh = void 0;\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst bech32_1 = require('bech32');\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = Buffer.alloc(0);\n// witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\n/**\n * Creates a pay-to-witness-public-key-hash (p2wpkh) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The p2wpkh payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nfunction p2wpkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32_1.bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32_1.bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2wpkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32_1.bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32_1.bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().data;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (!a.witness) return;\n    return a.witness[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.witness) return;\n    return a.witness[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return [a.signature, a.pubkey];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 20)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 22 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x14\n      )\n        throw new TypeError('Output is invalid');\n      if (hash.length > 0 && !hash.equals(a.output.slice(2)))\n        throw new TypeError('Hash mismatch');\n      else hash = a.output.slice(2);\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n      if (!(0, types_1.isPoint)(a.pubkey) || a.pubkey.length !== 33)\n        throw new TypeError('Invalid pubkey for p2wpkh');\n    }\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');\n      if (!bscript.isCanonicalScriptSignature(a.witness[0]))\n        throw new TypeError('Witness has invalid signature');\n      if (!(0, types_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33)\n        throw new TypeError('Witness has invalid pubkey');\n      if (a.signature && !a.signature.equals(a.witness[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(a.witness[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(a.witness[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wpkh = p2wpkh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2wsh = void 0;\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst bech32_1 = require('bech32');\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = Buffer.alloc(0);\nfunction chunkHasUncompressedPubkey(chunk) {\n  if (\n    Buffer.isBuffer(chunk) &&\n    chunk.length === 65 &&\n    chunk[0] === 0x04 &&\n    (0, types_1.isPoint)(chunk)\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n// input: <>\n// witness: [redeemScriptSig ...] {redeemScript}\n// output: OP_0 {sha256(redeemScript)}\n/**\n * Creates a Pay-to-Witness-Script-Hash (P2WSH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2WSH payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nfunction p2wsh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),\n      redeem: types_1.typeforce.maybe({\n        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32_1.bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32_1.bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const _rchunks = lazy.value(() => {\n    return bscript.decompile(a.redeem.input);\n  });\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32_1.bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32_1.bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'redeem', () => {\n    if (!a.witness) return;\n    return {\n      output: a.witness[a.witness.length - 1],\n      input: EMPTY_BUFFER,\n      witness: a.witness.slice(0, -1),\n    };\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    // transform redeem input to witness stack?\n    if (\n      a.redeem &&\n      a.redeem.input &&\n      a.redeem.input.length > 0 &&\n      a.redeem.output &&\n      a.redeem.output.length > 0\n    ) {\n      const stack = bscript.toStack(_rchunks());\n      // assign, and blank the existing input\n      o.redeem = Object.assign({ witness: stack }, a.redeem);\n      o.redeem.input = EMPTY_BUFFER;\n      return [].concat(stack, a.redeem.output);\n    }\n    if (!a.redeem) return;\n    if (!a.redeem.output) return;\n    if (!a.redeem.witness) return;\n    return [].concat(a.redeem.witness, a.redeem.output);\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2wsh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().prefix !== network.bech32)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      // is there two redeem sources?\n      if (\n        a.redeem.input &&\n        a.redeem.input.length > 0 &&\n        a.redeem.witness &&\n        a.redeem.witness.length > 0\n      )\n        throw new TypeError('Ambiguous witness source');\n      // is the redeem output non-empty/valid?\n      if (a.redeem.output) {\n        const decompile = bscript.decompile(a.redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output is invalid');\n        if (a.redeem.output.byteLength > 3600)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 3600 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = bcrypto.sha256(a.redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))\n        throw new TypeError('Non push-only scriptSig');\n      if (\n        a.witness &&\n        a.redeem.witness &&\n        !(0, types_1.stacksEqual)(a.witness, a.redeem.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n      if (\n        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||\n        (a.redeem.output &&\n          (bscript.decompile(a.redeem.output) || []).some(\n            chunkHasUncompressedPubkey,\n          ))\n      ) {\n        throw new TypeError(\n          'redeem.input or redeem.output contains uncompressed pubkey',\n        );\n      }\n    }\n    if (a.witness && a.witness.length > 0) {\n      const wScript = a.witness[a.witness.length - 1];\n      if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))\n        throw new TypeError('Witness and redeem.output mismatch');\n      if (\n        a.witness.some(chunkHasUncompressedPubkey) ||\n        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)\n      )\n        throw new TypeError('Witness contains uncompressed pubkey');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wsh = p2wsh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.getEccLib = exports.initEccLib = void 0;\nconst _ECCLIB_CACHE = {};\n/**\n * Initializes the ECC library with the provided instance.\n * If `eccLib` is `undefined`, the library will be cleared.\n * If `eccLib` is a new instance, it will be verified before setting it as the active library.\n *\n * @param eccLib The instance of the ECC library to initialize.\n * @param opts Extra initialization options. Use {DANGER_DO_NOT_VERIFY_ECCLIB:true} if ecc verification should not be executed. Not recommended!\n */\nfunction initEccLib(eccLib, opts) {\n  if (!eccLib) {\n    // allow clearing the library\n    _ECCLIB_CACHE.eccLib = eccLib;\n  } else if (eccLib !== _ECCLIB_CACHE.eccLib) {\n    if (!opts?.DANGER_DO_NOT_VERIFY_ECCLIB)\n      // new instance, verify it\n      verifyEcc(eccLib);\n    _ECCLIB_CACHE.eccLib = eccLib;\n  }\n}\nexports.initEccLib = initEccLib;\n/**\n * Retrieves the ECC Library instance.\n * Throws an error if the ECC Library is not provided.\n * You must call initEccLib() with a valid TinySecp256k1Interface instance before calling this function.\n * @returns The ECC Library instance.\n * @throws Error if the ECC Library is not provided.\n */\nfunction getEccLib() {\n  if (!_ECCLIB_CACHE.eccLib)\n    throw new Error(\n      'No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance',\n    );\n  return _ECCLIB_CACHE.eccLib;\n}\nexports.getEccLib = getEccLib;\nconst h = hex => Buffer.from(hex, 'hex');\n/**\n * Verifies the ECC functionality.\n *\n * @param ecc - The TinySecp256k1Interface object.\n */\nfunction verifyEcc(ecc) {\n  assert(typeof ecc.isXOnlyPoint === 'function');\n  assert(\n    ecc.isXOnlyPoint(\n      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000001'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000000'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    ),\n  );\n  assert(typeof ecc.xOnlyPointAddTweak === 'function');\n  tweakAddVectors.forEach(t => {\n    const r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));\n    if (t.result === null) {\n      assert(r === null);\n    } else {\n      assert(r !== null);\n      assert(r.parity === t.parity);\n      assert(Buffer.from(r.xOnlyPubkey).equals(h(t.result)));\n    }\n  });\n}\nfunction assert(bool) {\n  if (!bool) throw new Error('ecc library invalid');\n}\nconst tweakAddVectors = [\n  {\n    pubkey: '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    tweak: 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',\n    parity: -1,\n    result: null,\n  },\n  {\n    pubkey: '1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b',\n    tweak: 'a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac',\n    parity: 1,\n    result: 'e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf',\n  },\n  {\n    pubkey: '2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991',\n    tweak: '823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47',\n    parity: 0,\n    result: '9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c',\n  },\n];\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.BufferReader =\n  exports.BufferWriter =\n  exports.cloneBuffer =\n  exports.reverseBuffer =\n  exports.writeUInt64LE =\n  exports.readUInt64LE =\n  exports.varuint =\n    void 0;\nconst types = require('./types');\nconst { typeforce } = types;\nconst varuint = require('varuint-bitcoin');\nexports.varuint = varuint;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\n/**\n * Writes a 64-bit unsigned integer in little-endian format to the specified buffer at the given offset.\n *\n * @param buffer - The buffer to write the value to.\n * @param value - The 64-bit unsigned integer value to write.\n * @param offset - The offset in the buffer where the value should be written.\n * @returns The new offset after writing the value.\n */\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\n/**\n * Reverses the order of bytes in a buffer.\n * @param buffer - The buffer to reverse.\n * @returns A new buffer with the bytes reversed.\n */\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction cloneBuffer(buffer) {\n  const clone = Buffer.allocUnsafe(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\nexports.cloneBuffer = cloneBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n  static withCapacity(size) {\n    return new BufferWriter(Buffer.alloc(size));\n  }\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  writeUInt8(i) {\n    this.offset = this.buffer.writeUInt8(i, this.offset);\n  }\n  writeInt32(i) {\n    this.offset = this.buffer.writeInt32LE(i, this.offset);\n  }\n  writeUInt32(i) {\n    this.offset = this.buffer.writeUInt32LE(i, this.offset);\n  }\n  writeUInt64(i) {\n    this.offset = writeUInt64LE(this.buffer, i, this.offset);\n  }\n  writeVarInt(i) {\n    varuint.encode(i, this.buffer, this.offset);\n    this.offset += varuint.encode.bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.offset += slice.copy(this.buffer, this.offset);\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n  end() {\n    if (this.buffer.length === this.offset) {\n      return this.buffer;\n    }\n    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);\n  }\n}\nexports.BufferWriter = BufferWriter;\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  readUInt8() {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt64() {\n    const result = readUInt64LE(this.buffer, this.offset);\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n  readSlice(n) {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\nexports.BufferReader = BufferReader;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.tweakKey =\n  exports.tapTweakHash =\n  exports.tapleafHash =\n  exports.findScriptPath =\n  exports.toHashTree =\n  exports.rootHashFromPath =\n  exports.MAX_TAPTREE_DEPTH =\n  exports.LEAF_VERSION_TAPSCRIPT =\n    void 0;\nconst buffer_1 = require('buffer');\nconst ecc_lib_1 = require('../ecc_lib');\nconst bcrypto = require('../crypto');\nconst bufferutils_1 = require('../bufferutils');\nconst types_1 = require('../types');\nexports.LEAF_VERSION_TAPSCRIPT = 0xc0;\nexports.MAX_TAPTREE_DEPTH = 128;\nconst isHashBranch = ht => 'left' in ht && 'right' in ht;\n/**\n * Calculates the root hash from a given control block and leaf hash.\n * @param controlBlock - The control block buffer.\n * @param leafHash - The leaf hash buffer.\n * @returns The root hash buffer.\n * @throws {TypeError} If the control block length is less than 33.\n */\nfunction rootHashFromPath(controlBlock, leafHash) {\n  if (controlBlock.length < 33)\n    throw new TypeError(\n      `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n    );\n  const m = (controlBlock.length - 33) / 32;\n  let kj = leafHash;\n  for (let j = 0; j < m; j++) {\n    const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);\n    if (kj.compare(ej) < 0) {\n      kj = tapBranchHash(kj, ej);\n    } else {\n      kj = tapBranchHash(ej, kj);\n    }\n  }\n  return kj;\n}\nexports.rootHashFromPath = rootHashFromPath;\n/**\n * Build a hash tree of merkle nodes from the scripts binary tree.\n * @param scriptTree - the tree of scripts to pairwise hash.\n */\nfunction toHashTree(scriptTree) {\n  if ((0, types_1.isTapleaf)(scriptTree))\n    return { hash: tapleafHash(scriptTree) };\n  const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];\n  hashes.sort((a, b) => a.hash.compare(b.hash));\n  const [left, right] = hashes;\n  return {\n    hash: tapBranchHash(left.hash, right.hash),\n    left,\n    right,\n  };\n}\nexports.toHashTree = toHashTree;\n/**\n * Given a HashTree, finds the path from a particular hash to the root.\n * @param node - the root of the tree\n * @param hash - the hash to search for\n * @returns - array of sibling hashes, from leaf (inclusive) to root\n * (exclusive) needed to prove inclusion of the specified hash. undefined if no\n * path is found\n */\nfunction findScriptPath(node, hash) {\n  if (isHashBranch(node)) {\n    const leftPath = findScriptPath(node.left, hash);\n    if (leftPath !== undefined) return [...leftPath, node.right.hash];\n    const rightPath = findScriptPath(node.right, hash);\n    if (rightPath !== undefined) return [...rightPath, node.left.hash];\n  } else if (node.hash.equals(hash)) {\n    return [];\n  }\n  return undefined;\n}\nexports.findScriptPath = findScriptPath;\nfunction tapleafHash(leaf) {\n  const version = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;\n  return bcrypto.taggedHash(\n    'TapLeaf',\n    buffer_1.Buffer.concat([\n      buffer_1.Buffer.from([version]),\n      serializeScript(leaf.output),\n    ]),\n  );\n}\nexports.tapleafHash = tapleafHash;\nfunction tapTweakHash(pubKey, h) {\n  return bcrypto.taggedHash(\n    'TapTweak',\n    buffer_1.Buffer.concat(h ? [pubKey, h] : [pubKey]),\n  );\n}\nexports.tapTweakHash = tapTweakHash;\nfunction tweakKey(pubKey, h) {\n  if (!buffer_1.Buffer.isBuffer(pubKey)) return null;\n  if (pubKey.length !== 32) return null;\n  if (h && h.length !== 32) return null;\n  const tweakHash = tapTweakHash(pubKey, h);\n  const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);\n  if (!res || res.xOnlyPubkey === null) return null;\n  return {\n    parity: res.parity,\n    x: buffer_1.Buffer.from(res.xOnlyPubkey),\n  };\n}\nexports.tweakKey = tweakKey;\nfunction tapBranchHash(a, b) {\n  return bcrypto.taggedHash('TapBranch', buffer_1.Buffer.concat([a, b]));\n}\nfunction serializeScript(s) {\n  const varintLen = bufferutils_1.varuint.encodingLength(s.length);\n  const buffer = buffer_1.Buffer.allocUnsafe(varintLen); // better\n  bufferutils_1.varuint.encode(s.length, buffer);\n  return buffer_1.Buffer.concat([buffer, s]);\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2tr = void 0;\nconst buffer_1 = require('buffer');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst ecc_lib_1 = require('../ecc_lib');\nconst bip341_1 = require('./bip341');\nconst lazy = require('./lazy');\nconst bech32_1 = require('bech32');\nconst address_1 = require('../address');\nconst OPS = bscript.OPS;\nconst TAPROOT_WITNESS_VERSION = 0x01;\nconst ANNEX_PREFIX = 0x50;\n/**\n * Creates a Pay-to-Taproot (P2TR) payment object.\n *\n * @param a - The payment object containing the necessary data for P2TR.\n * @param opts - Optional payment options.\n * @returns The P2TR payment object.\n * @throws {TypeError} If the provided data is invalid or insufficient.\n */\nfunction p2tr(a, opts) {\n  if (\n    !a.address &&\n    !a.output &&\n    !a.pubkey &&\n    !a.internalPubkey &&\n    !(a.witness && a.witness.length > 1)\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),\n      internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      signature: types_1.typeforce.maybe(\n        types_1.typeforce.anyOf(\n          types_1.typeforce.BufferN(64),\n          types_1.typeforce.BufferN(65),\n        ),\n      ),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n      scriptTree: types_1.typeforce.maybe(types_1.isTaptree),\n      redeem: types_1.typeforce.maybe({\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    return (0, address_1.fromBech32)(a.address);\n  });\n  // remove annex if present, ignored by taproot\n  const _witness = lazy.value(() => {\n    if (!a.witness || !a.witness.length) return;\n    if (\n      a.witness.length >= 2 &&\n      a.witness[a.witness.length - 1][0] === ANNEX_PREFIX\n    ) {\n      return a.witness.slice(0, -1);\n    }\n    return a.witness.slice();\n  });\n  const _hashTree = lazy.value(() => {\n    if (a.scriptTree) return (0, bip341_1.toHashTree)(a.scriptTree);\n    if (a.hash) return { hash: a.hash };\n    return;\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2tr', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.pubkey) return;\n    const words = bech32_1.bech32m.toWords(o.pubkey);\n    words.unshift(TAPROOT_WITNESS_VERSION);\n    return bech32_1.bech32m.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    const hashTree = _hashTree();\n    if (hashTree) return hashTree.hash;\n    const w = _witness();\n    if (w && w.length > 1) {\n      const controlBlock = w[w.length - 1];\n      const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n      const script = w[w.length - 2];\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: script,\n        version: leafVersion,\n      });\n      return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n    }\n    return null;\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.pubkey) return;\n    return bscript.compile([OPS.OP_1, o.pubkey]);\n  });\n  lazy.prop(o, 'redeemVersion', () => {\n    if (a.redeemVersion) return a.redeemVersion;\n    if (\n      a.redeem &&\n      a.redeem.redeemVersion !== undefined &&\n      a.redeem.redeemVersion !== null\n    ) {\n      return a.redeem.redeemVersion;\n    }\n    return bip341_1.LEAF_VERSION_TAPSCRIPT;\n  });\n  lazy.prop(o, 'redeem', () => {\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length < 2) return;\n    return {\n      output: witness[witness.length - 2],\n      witness: witness.slice(0, -2),\n      redeemVersion:\n        witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK,\n    };\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.internalPubkey) {\n      const tweakedKey = (0, bip341_1.tweakKey)(o.internalPubkey, o.hash);\n      if (tweakedKey) return tweakedKey.x;\n    }\n  });\n  lazy.prop(o, 'internalPubkey', () => {\n    if (a.internalPubkey) return a.internalPubkey;\n    const witness = _witness();\n    if (witness && witness.length > 1)\n      return witness[witness.length - 1].slice(1, 33);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (a.signature) return a.signature;\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length !== 1) return;\n    return witness[0];\n  });\n  lazy.prop(o, 'witness', () => {\n    if (a.witness) return a.witness;\n    const hashTree = _hashTree();\n    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);\n      if (!path) return;\n      const outputKey = (0, bip341_1.tweakKey)(a.internalPubkey, hashTree.hash);\n      if (!outputKey) return;\n      const controlBock = buffer_1.Buffer.concat(\n        [\n          buffer_1.Buffer.from([o.redeemVersion | outputKey.parity]),\n          a.internalPubkey,\n        ].concat(path),\n      );\n      return [a.redeem.output, controlBock];\n    }\n    if (a.signature) return [a.signature];\n  });\n  // extended validation\n  if (opts.validate) {\n    let pubkey = buffer_1.Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== TAPROOT_WITNESS_VERSION)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      pubkey = _address().data;\n    }\n    if (a.pubkey) {\n      if (pubkey.length > 0 && !pubkey.equals(a.pubkey))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.pubkey;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_1 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2)))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.output.slice(2);\n    }\n    if (a.internalPubkey) {\n      const tweakedKey = (0, bip341_1.tweakKey)(a.internalPubkey, o.hash);\n      if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = tweakedKey.x;\n    }\n    if (pubkey && pubkey.length) {\n      if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))\n        throw new TypeError('Invalid pubkey for p2tr');\n    }\n    const hashTree = _hashTree();\n    if (a.hash && hashTree) {\n      if (!a.hash.equals(hashTree.hash)) throw new TypeError('Hash mismatch');\n    }\n    if (a.redeem && a.redeem.output && hashTree) {\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))\n        throw new TypeError('Redeem script not in tree');\n    }\n    const witness = _witness();\n    // compare the provided redeem data with the one computed from witness\n    if (a.redeem && o.redeem) {\n      if (a.redeem.redeemVersion) {\n        if (a.redeem.redeemVersion !== o.redeem.redeemVersion)\n          throw new TypeError('Redeem.redeemVersion and witness mismatch');\n      }\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0)\n          throw new TypeError('Redeem.output is invalid');\n        // output redeem is constructed from the witness\n        if (o.redeem.output && !a.redeem.output.equals(o.redeem.output))\n          throw new TypeError('Redeem.output and witness mismatch');\n      }\n      if (a.redeem.witness) {\n        if (\n          o.redeem.witness &&\n          !(0, types_1.stacksEqual)(a.redeem.witness, o.redeem.witness)\n        )\n          throw new TypeError('Redeem.witness and witness mismatch');\n      }\n    }\n    if (witness && witness.length) {\n      if (witness.length === 1) {\n        // key spending\n        if (a.signature && !a.signature.equals(witness[0]))\n          throw new TypeError('Signature mismatch');\n      } else {\n        // script path spending\n        const controlBlock = witness[witness.length - 1];\n        if (controlBlock.length < 33)\n          throw new TypeError(\n            `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n          );\n        if ((controlBlock.length - 33) % 32 !== 0)\n          throw new TypeError(\n            `The control-block length of ${controlBlock.length} is incorrect!`,\n          );\n        const m = (controlBlock.length - 33) / 32;\n        if (m > 128)\n          throw new TypeError(\n            `The script path is too long. Got ${m}, expected max 128.`,\n          );\n        const internalPubkey = controlBlock.slice(1, 33);\n        if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey))\n          throw new TypeError('Internal pubkey mismatch');\n        if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey))\n          throw new TypeError('Invalid internalPubkey for p2tr witness');\n        const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n        const script = witness[witness.length - 2];\n        const leafHash = (0, bip341_1.tapleafHash)({\n          output: script,\n          version: leafVersion,\n        });\n        const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n        const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);\n        if (!outputKey)\n          // todo: needs test data\n          throw new TypeError('Invalid outputKey for p2tr witness');\n        if (pubkey.length && !pubkey.equals(outputKey.x))\n          throw new TypeError('Pubkey mismatch for p2tr witness');\n        if (outputKey.parity !== (controlBlock[0] & 1))\n          throw new Error('Incorrect parity');\n      }\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2tr = p2tr;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2tr =\n  exports.p2wsh =\n  exports.p2wpkh =\n  exports.p2sh =\n  exports.p2pkh =\n  exports.p2pk =\n  exports.p2ms =\n  exports.embed =\n    void 0;\nconst embed_1 = require('./embed');\nObject.defineProperty(exports, 'embed', {\n  enumerable: true,\n  get: function () {\n    return embed_1.p2data;\n  },\n});\nconst p2ms_1 = require('./p2ms');\nObject.defineProperty(exports, 'p2ms', {\n  enumerable: true,\n  get: function () {\n    return p2ms_1.p2ms;\n  },\n});\nconst p2pk_1 = require('./p2pk');\nObject.defineProperty(exports, 'p2pk', {\n  enumerable: true,\n  get: function () {\n    return p2pk_1.p2pk;\n  },\n});\nconst p2pkh_1 = require('./p2pkh');\nObject.defineProperty(exports, 'p2pkh', {\n  enumerable: true,\n  get: function () {\n    return p2pkh_1.p2pkh;\n  },\n});\nconst p2sh_1 = require('./p2sh');\nObject.defineProperty(exports, 'p2sh', {\n  enumerable: true,\n  get: function () {\n    return p2sh_1.p2sh;\n  },\n});\nconst p2wpkh_1 = require('./p2wpkh');\nObject.defineProperty(exports, 'p2wpkh', {\n  enumerable: true,\n  get: function () {\n    return p2wpkh_1.p2wpkh;\n  },\n});\nconst p2wsh_1 = require('./p2wsh');\nObject.defineProperty(exports, 'p2wsh', {\n  enumerable: true,\n  get: function () {\n    return p2wsh_1.p2wsh;\n  },\n});\nconst p2tr_1 = require('./p2tr');\nObject.defineProperty(exports, 'p2tr', {\n  enumerable: true,\n  get: function () {\n    return p2tr_1.p2tr;\n  },\n});\n// TODO\n// witness commitment\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.toOutputScript =\n  exports.fromOutputScript =\n  exports.toBech32 =\n  exports.toBase58Check =\n  exports.fromBech32 =\n  exports.fromBase58Check =\n    void 0;\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst types_1 = require('./types');\nconst bech32_1 = require('bech32');\nconst bs58check = require('bs58check');\nconst FUTURE_SEGWIT_MAX_SIZE = 40;\nconst FUTURE_SEGWIT_MIN_SIZE = 2;\nconst FUTURE_SEGWIT_MAX_VERSION = 16;\nconst FUTURE_SEGWIT_MIN_VERSION = 2;\nconst FUTURE_SEGWIT_VERSION_DIFF = 0x50;\nconst FUTURE_SEGWIT_VERSION_WARNING =\n  'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +\n  'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +\n  'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +\n  'then decide when it is safe to use which version of segwit.';\nfunction _toFutureSegwitAddress(output, network) {\n  const data = output.slice(2);\n  if (\n    data.length < FUTURE_SEGWIT_MIN_SIZE ||\n    data.length > FUTURE_SEGWIT_MAX_SIZE\n  )\n    throw new TypeError('Invalid program length for segwit address');\n  const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;\n  if (\n    version < FUTURE_SEGWIT_MIN_VERSION ||\n    version > FUTURE_SEGWIT_MAX_VERSION\n  )\n    throw new TypeError('Invalid version for segwit address');\n  if (output[1] !== data.length)\n    throw new TypeError('Invalid script for segwit address');\n  console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n  return toBech32(data, version, network.bech32);\n}\n/**\n * decode address with base58 specification,  return address version and address hash if valid\n */\nfunction fromBase58Check(address) {\n  const payload = Buffer.from(bs58check.decode(address));\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return { version, hash };\n}\nexports.fromBase58Check = fromBase58Check;\n/**\n * decode address with bech32 specification,  return address version、address prefix and address data if valid\n */\nfunction fromBech32(address) {\n  let result;\n  let version;\n  try {\n    result = bech32_1.bech32.decode(address);\n  } catch (e) {}\n  if (result) {\n    version = result.words[0];\n    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');\n  } else {\n    result = bech32_1.bech32m.decode(address);\n    version = result.words[0];\n    if (version === 0) throw new TypeError(address + ' uses wrong encoding');\n  }\n  const data = bech32_1.bech32.fromWords(result.words.slice(1));\n  return {\n    version,\n    prefix: result.prefix,\n    data: Buffer.from(data),\n  };\n}\nexports.fromBech32 = fromBech32;\n/**\n * encode address hash to base58 address with version\n */\nfunction toBase58Check(hash, version) {\n  (0, types_1.typeforce)(\n    (0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8),\n    arguments,\n  );\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\nexports.toBase58Check = toBase58Check;\n/**\n * encode address hash to bech32 address with version and prefix\n */\nfunction toBech32(data, version, prefix) {\n  const words = bech32_1.bech32.toWords(data);\n  words.unshift(version);\n  return version === 0\n    ? bech32_1.bech32.encode(prefix, words)\n    : bech32_1.bech32m.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\n/**\n * decode address from output script with network, return address if matched\n */\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2tr({ output, network }).address;\n  } catch (e) {}\n  try {\n    return _toFutureSegwitAddress(output, network);\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\nexports.fromOutputScript = fromOutputScript;\n/**\n * encodes address to output script with network, return output script if address matched\n */\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      } else if (decodeBech32.version === 1) {\n        if (decodeBech32.data.length === 32)\n          return payments.p2tr({ pubkey: decodeBech32.data }).output;\n      } else if (\n        decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&\n        decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&\n        decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&\n        decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE\n      ) {\n        console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n        return bscript.compile([\n          decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,\n          decodeBech32.data,\n        ]);\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\nexports.toOutputScript = toOutputScript;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.fastMerkleRoot = void 0;\n/**\n * Calculates the Merkle root of an array of buffers using a specified digest function.\n *\n * @param values - The array of buffers.\n * @param digestFn - The digest function used to calculate the hash of the concatenated buffers.\n * @returns The Merkle root as a buffer.\n * @throws {TypeError} If the values parameter is not an array or the digestFn parameter is not a function.\n */\nfunction fastMerkleRoot(values, digestFn) {\n  if (!Array.isArray(values)) throw TypeError('Expected values Array');\n  if (typeof digestFn !== 'function')\n    throw TypeError('Expected digest Function');\n  let length = values.length;\n  const results = values.concat();\n  while (length > 1) {\n    let j = 0;\n    for (let i = 0; i < length; i += 2, ++j) {\n      const left = results[i];\n      const right = i + 1 === length ? left : results[i + 1];\n      const data = Buffer.concat([left, right]);\n      results[j] = digestFn(data);\n    }\n    length = j;\n  }\n  return results[0];\n}\nexports.fastMerkleRoot = fastMerkleRoot;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.Transaction = void 0;\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst types = require('./types');\nconst { typeforce } = types;\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return bufferutils_1.varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    bufferutils_1.varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_BUFFER = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'hex',\n);\nconst ONE = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n  'hex',\n);\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_BUFFER,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\n/**\n * Represents a Bitcoin transaction.\n */\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(\n      types.tuple(\n        types.Hash256bit,\n        types.UInt32,\n        types.maybe(types.UInt32),\n        types.maybe(types.Buffer),\n      ),\n      arguments,\n    );\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_BUFFER,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  stripWitnesses() {\n    this.ins.forEach(input => {\n      input.witness = EMPTY_WITNESS; // Set witness data to an empty array\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      bufferutils_1.varuint.encodingLength(this.ins.length) +\n      bufferutils_1.varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),\n      arguments,\n    );\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== script_1.OPS.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_BUFFER;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message\n    typeforce(\n      types.tuple(\n        types.UInt32,\n        typeforce.arrayOf(types.Buffer),\n        typeforce.arrayOf(types.Satoshi),\n        types.UInt32,\n      ),\n      arguments,\n    );\n    if (\n      values.length !== this.ins.length ||\n      prevOutScripts.length !== this.ins.length\n    ) {\n      throw new Error('Must supply prevout script and value for all inputs');\n    }\n    const outputType =\n      hashType === Transaction.SIGHASH_DEFAULT\n        ? Transaction.SIGHASH_ALL\n        : hashType & Transaction.SIGHASH_OUTPUT_MASK;\n    const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;\n    const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;\n    const isNone = outputType === Transaction.SIGHASH_NONE;\n    const isSingle = outputType === Transaction.SIGHASH_SINGLE;\n    let hashPrevouts = EMPTY_BUFFER;\n    let hashAmounts = EMPTY_BUFFER;\n    let hashScriptPubKeys = EMPTY_BUFFER;\n    let hashSequences = EMPTY_BUFFER;\n    let hashOutputs = EMPTY_BUFFER;\n    if (!isAnyoneCanPay) {\n      let bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        36 * this.ins.length,\n      );\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        8 * this.ins.length,\n      );\n      values.forEach(value => bufferWriter.writeUInt64(value));\n      hashAmounts = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        prevOutScripts.map(varSliceSize).reduce((a, b) => a + b),\n      );\n      prevOutScripts.forEach(prevOutScript =>\n        bufferWriter.writeVarSlice(prevOutScript),\n      );\n      hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        4 * this.ins.length,\n      );\n      this.ins.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));\n      hashSequences = bcrypto.sha256(bufferWriter.end());\n    }\n    if (!(isNone || isSingle)) {\n      const txOutsSize = this.outs\n        .map(output => 8 + varSliceSize(output.script))\n        .reduce((a, b) => a + b);\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.sha256(bufferWriter.end());\n    } else if (isSingle && inIndex < this.outs.length) {\n      const output = this.outs[inIndex];\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        8 + varSliceSize(output.script),\n      );\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.sha256(bufferWriter.end());\n    }\n    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);\n    // Length calculation from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14\n    // With extension from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation\n    const sigMsgSize =\n      174 -\n      (isAnyoneCanPay ? 49 : 0) -\n      (isNone ? 32 : 0) +\n      (annex ? 32 : 0) +\n      (leafHash ? 37 : 0);\n    const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);\n    sigMsgWriter.writeUInt8(hashType);\n    // Transaction\n    sigMsgWriter.writeInt32(this.version);\n    sigMsgWriter.writeUInt32(this.locktime);\n    sigMsgWriter.writeSlice(hashPrevouts);\n    sigMsgWriter.writeSlice(hashAmounts);\n    sigMsgWriter.writeSlice(hashScriptPubKeys);\n    sigMsgWriter.writeSlice(hashSequences);\n    if (!(isNone || isSingle)) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // Input\n    sigMsgWriter.writeUInt8(spendType);\n    if (isAnyoneCanPay) {\n      const input = this.ins[inIndex];\n      sigMsgWriter.writeSlice(input.hash);\n      sigMsgWriter.writeUInt32(input.index);\n      sigMsgWriter.writeUInt64(values[inIndex]);\n      sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);\n      sigMsgWriter.writeUInt32(input.sequence);\n    } else {\n      sigMsgWriter.writeUInt32(inIndex);\n    }\n    if (annex) {\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        varSliceSize(annex),\n      );\n      bufferWriter.writeVarSlice(annex);\n      sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));\n    }\n    // Output\n    if (isSingle) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // BIP342 extension\n    if (leafHash) {\n      sigMsgWriter.writeSlice(leafHash);\n      sigMsgWriter.writeUInt8(0);\n      sigMsgWriter.writeUInt32(0xffffffff);\n    }\n    // Extra zero byte because:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19\n    return bcrypto.taggedHash(\n      'TapSighash',\n      Buffer.concat([Buffer.from([0x00]), sigMsgWriter.end()]),\n    );\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),\n      arguments,\n    );\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(\n      'hex',\n    );\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(\n      buffer,\n      initialOffset || 0,\n    );\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\nexports.Transaction = Transaction;\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_DEFAULT = 0x00;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.SIGHASH_OUTPUT_MASK = 0x03;\nTransaction.SIGHASH_INPUT_MASK = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.Block = void 0;\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst merkle_1 = require('./merkle');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst { typeforce } = types;\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{ getHash: types.Function }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = (0, merkle_1.fastMerkleRoot)(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(out =>\n        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Buffer &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      bufferutils_1.varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString('hex');\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    bufferutils_1.varuint.encode(\n      this.transactions.length,\n      buffer,\n      bufferWriter.offset,\n    );\n    bufferWriter.offset += bufferutils_1.varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n}\nexports.Block = Block;\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.signatureBlocksAction =\n  exports.checkInputForSig =\n  exports.pubkeyInScript =\n  exports.pubkeyPositionInScript =\n  exports.witnessStackToScriptWitness =\n  exports.isP2TR =\n  exports.isP2SHScript =\n  exports.isP2WSHScript =\n  exports.isP2WPKH =\n  exports.isP2PKH =\n  exports.isP2PK =\n  exports.isP2MS =\n    void 0;\nconst varuint = require('bip174/src/lib/converter/varint');\nconst bscript = require('../script');\nconst transaction_1 = require('../transaction');\nconst crypto_1 = require('../crypto');\nconst payments = require('../payments');\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nexports.isP2MS = isPaymentFactory(payments.p2ms);\nexports.isP2PK = isPaymentFactory(payments.p2pk);\nexports.isP2PKH = isPaymentFactory(payments.p2pkh);\nexports.isP2WPKH = isPaymentFactory(payments.p2wpkh);\nexports.isP2WSHScript = isPaymentFactory(payments.p2wsh);\nexports.isP2SHScript = isPaymentFactory(payments.p2sh);\nexports.isP2TR = isPaymentFactory(payments.p2tr);\n/**\n * Converts a witness stack to a script witness.\n * @param witness The witness stack to convert.\n * @returns The script witness as a Buffer.\n */\n/**\n * Converts a witness stack to a script witness.\n * @param witness The witness stack to convert.\n * @returns The converted script witness.\n */\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\nexports.witnessStackToScriptWitness = witnessStackToScriptWitness;\n/**\n * Finds the position of a public key in a script.\n * @param pubkey The public key to search for.\n * @param script The script to search in.\n * @returns The index of the public key in the script, or -1 if not found.\n * @throws {Error} If there is an unknown script error.\n */\nfunction pubkeyPositionInScript(pubkey, script) {\n  const pubkeyHash = (0, crypto_1.hash160)(pubkey);\n  const pubkeyXOnly = pubkey.slice(1, 33); // slice before calling?\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  return decompiled.findIndex(element => {\n    if (typeof element === 'number') return false;\n    return (\n      element.equals(pubkey) ||\n      element.equals(pubkeyHash) ||\n      element.equals(pubkeyXOnly)\n    );\n  });\n}\nexports.pubkeyPositionInScript = pubkeyPositionInScript;\n/**\n * Checks if a public key is present in a script.\n * @param pubkey The public key to check.\n * @param script The script to search in.\n * @returns A boolean indicating whether the public key is present in the script.\n */\nfunction pubkeyInScript(pubkey, script) {\n  return pubkeyPositionInScript(pubkey, script) !== -1;\n}\nexports.pubkeyInScript = pubkeyInScript;\n/**\n * Checks if an input contains a signature for a specific action.\n * @param input - The input to check.\n * @param action - The action to check for.\n * @returns A boolean indicating whether the input contains a signature for the specified action.\n */\nfunction checkInputForSig(input, action) {\n  const pSigs = extractPartialSigs(input);\n  return pSigs.some(pSig =>\n    signatureBlocksAction(pSig, bscript.signature.decode, action),\n  );\n}\nexports.checkInputForSig = checkInputForSig;\n/**\n * Determines if a given action is allowed for a signature block.\n * @param signature - The signature block.\n * @param signatureDecodeFn - The function used to decode the signature.\n * @param action - The action to be checked.\n * @returns True if the action is allowed, false otherwise.\n */\nfunction signatureBlocksAction(signature, signatureDecodeFn, action) {\n  const { hashType } = signatureDecodeFn(signature);\n  const whitelist = [];\n  const isAnyoneCanPay =\n    hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n  if (isAnyoneCanPay) whitelist.push('addInput');\n  const hashMod = hashType & 0x1f;\n  switch (hashMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n    case transaction_1.Transaction.SIGHASH_NONE:\n      whitelist.push('addOutput');\n      whitelist.push('setInputSequence');\n      break;\n  }\n  if (whitelist.indexOf(action) === -1) {\n    return true;\n  }\n  return false;\n}\nexports.signatureBlocksAction = signatureBlocksAction;\n/**\n * Extracts the signatures from a PsbtInput object.\n * If the input has partial signatures, it returns an array of the signatures.\n * If the input does not have partial signatures, it checks if it has a finalScriptSig or finalScriptWitness.\n * If it does, it extracts the signatures from the final scripts and returns them.\n * If none of the above conditions are met, it returns an empty array.\n *\n * @param input - The PsbtInput object from which to extract the signatures.\n * @returns An array of signatures extracted from the PsbtInput object.\n */\nfunction extractPartialSigs(input) {\n  let pSigs = [];\n  if ((input.partialSig || []).length === 0) {\n    if (!input.finalScriptSig && !input.finalScriptWitness) return [];\n    pSigs = getPsigsFromInputFinalScripts(input);\n  } else {\n    pSigs = input.partialSig;\n  }\n  return pSigs.map(p => p.signature);\n}\n/**\n * Retrieves the partial signatures (Psigs) from the input's final scripts.\n * Psigs are extracted from both the final scriptSig and final scriptWitness of the input.\n * Only canonical script signatures are considered.\n *\n * @param input - The PsbtInput object representing the input.\n * @returns An array of PartialSig objects containing the extracted Psigs.\n */\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n    })\n    .map(sig => ({ signature: sig }));\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.checkTaprootInputForSigs =\n  exports.tapTreeFromList =\n  exports.tapTreeToList =\n  exports.tweakInternalPubKey =\n  exports.checkTaprootOutputFields =\n  exports.checkTaprootInputFields =\n  exports.isTaprootOutput =\n  exports.isTaprootInput =\n  exports.serializeTaprootSignature =\n  exports.tapScriptFinalizer =\n  exports.toXOnly =\n    void 0;\nconst types_1 = require('../types');\nconst transaction_1 = require('../transaction');\nconst psbtutils_1 = require('./psbtutils');\nconst bip341_1 = require('../payments/bip341');\nconst payments_1 = require('../payments');\nconst psbtutils_2 = require('./psbtutils');\nconst toXOnly = pubKey => (pubKey.length === 32 ? pubKey : pubKey.slice(1, 33));\nexports.toXOnly = toXOnly;\n/**\n * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.\n * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.\n * @param inputIndex the position of the PSBT input.\n * @param input the PSBT input.\n * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash\n *                              and will try to build the finalScriptWitness.\n * @returns the finalScriptWitness or throws an exception if no tapleaf found.\n */\nfunction tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {\n  const tapLeaf = findTapLeafToFinalize(\n    input,\n    inputIndex,\n    tapLeafHashToFinalize,\n  );\n  try {\n    const sigs = sortSignatures(input, tapLeaf);\n    const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);\n    return {\n      finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness),\n    };\n  } catch (err) {\n    throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);\n  }\n}\nexports.tapScriptFinalizer = tapScriptFinalizer;\nfunction serializeTaprootSignature(sig, sighashType) {\n  const sighashTypeByte = sighashType\n    ? Buffer.from([sighashType])\n    : Buffer.from([]);\n  return Buffer.concat([sig, sighashTypeByte]);\n}\nexports.serializeTaprootSignature = serializeTaprootSignature;\nfunction isTaprootInput(input) {\n  return (\n    input &&\n    !!(\n      input.tapInternalKey ||\n      input.tapMerkleRoot ||\n      (input.tapLeafScript && input.tapLeafScript.length) ||\n      (input.tapBip32Derivation && input.tapBip32Derivation.length) ||\n      (input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script))\n    )\n  );\n}\nexports.isTaprootInput = isTaprootInput;\nfunction isTaprootOutput(output, script) {\n  return (\n    output &&\n    !!(\n      output.tapInternalKey ||\n      output.tapTree ||\n      (output.tapBip32Derivation && output.tapBip32Derivation.length) ||\n      (script && (0, psbtutils_1.isP2TR)(script))\n    )\n  );\n}\nexports.isTaprootOutput = isTaprootOutput;\nfunction checkTaprootInputFields(inputData, newInputData, action) {\n  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);\n  checkIfTapLeafInTree(inputData, newInputData, action);\n}\nexports.checkTaprootInputFields = checkTaprootInputFields;\nfunction checkTaprootOutputFields(outputData, newOutputData, action) {\n  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);\n  checkTaprootScriptPubkey(outputData, newOutputData);\n}\nexports.checkTaprootOutputFields = checkTaprootOutputFields;\nfunction checkTaprootScriptPubkey(outputData, newOutputData) {\n  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;\n  const tapInternalKey =\n    newOutputData.tapInternalKey || outputData.tapInternalKey;\n  const tapTree = newOutputData.tapTree || outputData.tapTree;\n  if (tapInternalKey) {\n    const { script: scriptPubkey } = outputData;\n    const script = getTaprootScripPubkey(tapInternalKey, tapTree);\n    if (scriptPubkey && !scriptPubkey.equals(script))\n      throw new Error('Error adding output. Script or address missmatch.');\n  }\n}\nfunction getTaprootScripPubkey(tapInternalKey, tapTree) {\n  const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);\n  const { output } = (0, payments_1.p2tr)({\n    internalPubkey: tapInternalKey,\n    scriptTree,\n  });\n  return output;\n}\nfunction tweakInternalPubKey(inputIndex, input) {\n  const tapInternalKey = input.tapInternalKey;\n  const outputKey =\n    tapInternalKey &&\n    (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);\n  if (!outputKey)\n    throw new Error(\n      `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${\n        tapInternalKey && tapInternalKey.toString('hex')\n      }`,\n    );\n  return outputKey.x;\n}\nexports.tweakInternalPubKey = tweakInternalPubKey;\n/**\n * Convert a binary tree to a BIP371 type list. Each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @param tree the binary tap tree\n * @returns a list of BIP 371 tapleaves\n */\nfunction tapTreeToList(tree) {\n  if (!(0, types_1.isTaptree)(tree))\n    throw new Error(\n      'Cannot convert taptree to tapleaf list. Expecting a tapree structure.',\n    );\n  return _tapTreeToList(tree);\n}\nexports.tapTreeToList = tapTreeToList;\n/**\n * Convert a BIP371 TapLeaf list to a TapTree (binary).\n * @param leaves a list of tapleaves where each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed\n */\nfunction tapTreeFromList(leaves = []) {\n  if (leaves.length === 1 && leaves[0].depth === 0)\n    return {\n      output: leaves[0].script,\n      version: leaves[0].leafVersion,\n    };\n  return instertLeavesInTree(leaves);\n}\nexports.tapTreeFromList = tapTreeFromList;\nfunction checkTaprootInputForSigs(input, action) {\n  const sigs = extractTaprootSigs(input);\n  return sigs.some(sig =>\n    (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action),\n  );\n}\nexports.checkTaprootInputForSigs = checkTaprootInputForSigs;\nfunction decodeSchnorrSignature(signature) {\n  return {\n    signature: signature.slice(0, 64),\n    hashType:\n      signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT,\n  };\n}\nfunction extractTaprootSigs(input) {\n  const sigs = [];\n  if (input.tapKeySig) sigs.push(input.tapKeySig);\n  if (input.tapScriptSig)\n    sigs.push(...input.tapScriptSig.map(s => s.signature));\n  if (!sigs.length) {\n    const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);\n    if (finalTapKeySig) sigs.push(finalTapKeySig);\n  }\n  return sigs;\n}\nfunction getTapKeySigFromWithness(finalScriptWitness) {\n  if (!finalScriptWitness) return;\n  const witness = finalScriptWitness.slice(2);\n  // todo: add schnorr signature validation\n  if (witness.length === 64 || witness.length === 65) return witness;\n}\nfunction _tapTreeToList(tree, leaves = [], depth = 0) {\n  if (depth > bip341_1.MAX_TAPTREE_DEPTH)\n    throw new Error('Max taptree depth exceeded.');\n  if (!tree) return [];\n  if ((0, types_1.isTapleaf)(tree)) {\n    leaves.push({\n      depth,\n      leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,\n      script: tree.output,\n    });\n    return leaves;\n  }\n  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);\n  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);\n  return leaves;\n}\nfunction instertLeavesInTree(leaves) {\n  let tree;\n  for (const leaf of leaves) {\n    tree = instertLeafInTree(leaf, tree);\n    if (!tree) throw new Error(`No room left to insert tapleaf in tree`);\n  }\n  return tree;\n}\nfunction instertLeafInTree(leaf, tree, depth = 0) {\n  if (depth > bip341_1.MAX_TAPTREE_DEPTH)\n    throw new Error('Max taptree depth exceeded.');\n  if (leaf.depth === depth) {\n    if (!tree)\n      return {\n        output: leaf.script,\n        version: leaf.leafVersion,\n      };\n    return;\n  }\n  if ((0, types_1.isTapleaf)(tree)) return;\n  const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);\n  if (leftSide) return [leftSide, tree && tree[1]];\n  const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);\n  if (rightSide) return [tree && tree[0], rightSide];\n}\nfunction checkMixedTaprootAndNonTaprootInputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootInput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootInput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootInput(newInputData) &&\n    hasNonTaprootFields(newInputData); // todo: bad? use !===\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\nfunction checkMixedTaprootAndNonTaprootOutputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootOutput(newInputData) &&\n    hasNonTaprootFields(newInputData);\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\n/**\n * Checks if the tap leaf is part of the tap tree for the given input data.\n * Throws an error if the tap leaf is not part of the tap tree.\n * @param inputData - The original PsbtInput data.\n * @param newInputData - The new PsbtInput data.\n * @param action - The action being performed.\n * @throws {Error} - If the tap leaf is not part of the tap tree.\n */\nfunction checkIfTapLeafInTree(inputData, newInputData, action) {\n  if (newInputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    const oldLeafsInTree = (inputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree || !oldLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  } else if (inputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, inputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  }\n}\n/**\n * Checks if a TapLeafScript is present in a Merkle tree.\n * @param tapLeaf The TapLeafScript to check.\n * @param merkleRoot The Merkle root of the tree. If not provided, the function assumes the TapLeafScript is present.\n * @returns A boolean indicating whether the TapLeafScript is present in the tree.\n */\nfunction isTapLeafInTree(tapLeaf, merkleRoot) {\n  if (!merkleRoot) return true;\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  const rootHash = (0, bip341_1.rootHashFromPath)(\n    tapLeaf.controlBlock,\n    leafHash,\n  );\n  return rootHash.equals(merkleRoot);\n}\n/**\n * Sorts the signatures in the input's tapScriptSig array based on their position in the tapLeaf script.\n *\n * @param input - The PsbtInput object.\n * @param tapLeaf - The TapLeafScript object.\n * @returns An array of sorted signatures as Buffers.\n */\nfunction sortSignatures(input, tapLeaf) {\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  return (input.tapScriptSig || [])\n    .filter(tss => tss.leafHash.equals(leafHash))\n    .map(tss => addPubkeyPositionInScript(tapLeaf.script, tss))\n    .sort((t1, t2) => t2.positionInScript - t1.positionInScript)\n    .map(t => t.signature);\n}\n/**\n * Adds the position of a public key in a script to a TapScriptSig object.\n * @param script The script in which to find the position of the public key.\n * @param tss The TapScriptSig object to add the position to.\n * @returns A TapScriptSigWitPosition object with the added position.\n */\nfunction addPubkeyPositionInScript(script, tss) {\n  return Object.assign(\n    {\n      positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(\n        tss.pubkey,\n        script,\n      ),\n    },\n    tss,\n  );\n}\n/**\n * Find tapleaf by hash, or get the signed tapleaf with the shortest path.\n */\nfunction findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {\n  if (!input.tapScriptSig || !input.tapScriptSig.length)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`,\n    );\n  const tapLeaf = (input.tapLeafScript || [])\n    .sort((a, b) => a.controlBlock.length - b.controlBlock.length)\n    .find(leaf =>\n      canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize),\n    );\n  if (!tapLeaf)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`,\n    );\n  return tapLeaf;\n}\n/**\n * Determines whether a TapLeafScript can be finalized.\n *\n * @param leaf - The TapLeafScript to check.\n * @param tapScriptSig - The array of TapScriptSig objects.\n * @param hash - The optional hash to compare with the leaf hash.\n * @returns A boolean indicating whether the TapLeafScript can be finalized.\n */\nfunction canFinalizeLeaf(leaf, tapScriptSig, hash) {\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: leaf.script,\n    version: leaf.leafVersion,\n  });\n  const whiteListedHash = !hash || hash.equals(leafHash);\n  return (\n    whiteListedHash &&\n    tapScriptSig.find(tss => tss.leafHash.equals(leafHash)) !== undefined\n  );\n}\n/**\n * Checks if the given PsbtInput or PsbtOutput has non-taproot fields.\n * Non-taproot fields include redeemScript, witnessScript, and bip32Derivation.\n * @param io The PsbtInput or PsbtOutput to check.\n * @returns A boolean indicating whether the given input or output has non-taproot fields.\n */\nfunction hasNonTaprootFields(io) {\n  return (\n    io &&\n    !!(\n      io.redeemScript ||\n      io.witnessScript ||\n      (io.bip32Derivation && io.bip32Derivation.length)\n    )\n  );\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.Psbt = void 0;\nconst bip174_1 = require('bip174');\nconst varuint = require('bip174/src/lib/converter/varint');\nconst utils_1 = require('bip174/src/lib/utils');\nconst address_1 = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst networks_1 = require('./networks');\nconst payments = require('./payments');\nconst bip341_1 = require('./payments/bip341');\nconst bscript = require('./script');\nconst transaction_1 = require('./transaction');\nconst bip371_1 = require('./psbt/bip371');\nconst psbtutils_1 = require('./psbt/psbtutils');\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000, // satoshi per byte\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n *\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n *\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n *\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n *\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n *\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nclass Psbt {\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Psbt's predecessor (TransactionBuilder - now removed) behavior\n      // was to not confirm input values  before signing.\n      // Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: (0, bufferutils_1.cloneBuffer)(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = (0, address_1.fromOutputScript)(\n          output.script,\n          this.opts.network,\n        );\n      } catch (_) {}\n      return {\n        script: (0, bufferutils_1.cloneBuffer)(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    (0, bip371_1.checkTaprootInputFields)(inputData, inputData, 'addInput');\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = (0, address_1.toOutputScript)(address, network);\n      outputData = Object.assign({}, outputData, { script });\n    }\n    (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, 'addOutput');\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        undefined,\n        finalScriptsFunc,\n      );\n    return this._finalizeInput(inputIndex, input, finalScriptsFunc);\n  }\n  finalizeTaprootInput(\n    inputIndex,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = bip371_1.tapScriptFinalizer,\n  ) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n        finalScriptsFunc,\n      );\n    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);\n  }\n  _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  _finalizeTaprootInput(\n    inputIndex,\n    input,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = bip371_1.tapScriptFinalizer,\n  ) {\n    if (!input.witnessUtxo)\n      throw new Error(\n        `Cannot finalize input #${inputIndex}. Missing withness utxo.`,\n      );\n    // Check key spend first. Increased privacy and reduced block space.\n    if (input.tapKeySig) {\n      const payment = payments.p2tr({\n        output: input.witnessUtxo.script,\n        signature: input.tapKeySig,\n      });\n      const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        payment.witness,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    } else {\n      const { finalScriptWitness } = finalScriptsFunc(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    }\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(\n      script,\n      inputIndex,\n      'input',\n      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),\n      input.witnessScript ||\n        redeemFromFinalWitnessScript(input.finalScriptWitness),\n    );\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  validateSignaturesOfAllInputs(validator) {\n    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx, validator),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this.validateSignaturesOfTaprootInput(\n        inputIndex,\n        validator,\n        pubkey,\n      );\n    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);\n  }\n  _validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n              true,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      results.push(validator(pSig.pubkey, hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const tapKeySig = (input || {}).tapKeySig;\n    const tapScriptSig = (input || {}).tapScriptSig;\n    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);\n    const allHashses = pubkey\n      ? getTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          pubkey,\n          this.__CACHE,\n        )\n      : getAllTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          this.__CACHE,\n        );\n    if (!allHashses.length) throw new Error('No signatures for this pubkey');\n    const tapKeyHash = allHashses.find(h => !h.leafHash);\n    let validationResultCount = 0;\n    if (tapKeySig && tapKeyHash) {\n      const isValidTapkeySig = validator(\n        tapKeyHash.pubkey,\n        tapKeyHash.hash,\n        trimTaprootSig(tapKeySig),\n      );\n      if (!isValidTapkeySig) return false;\n      validationResultCount++;\n    }\n    if (tapScriptSig) {\n      for (const tapSig of tapScriptSig) {\n        const tapSigHash = allHashses.find(h => tapSig.pubkey.equals(h.pubkey));\n        if (tapSigHash) {\n          const isValidTapScriptSig = validator(\n            tapSig.pubkey,\n            tapSigHash.hash,\n            trimTaprootSig(tapSig.signature),\n          );\n          if (!isValidTapScriptSig) return false;\n          validationResultCount++;\n        }\n      }\n    }\n    return validationResultCount > 0;\n  }\n  signAllInputsHD(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(keyPair, sighashTypes) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(inputIndex, keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input)) {\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        undefined,\n        sighashTypes,\n      );\n    }\n    return this._signInput(inputIndex, keyPair, sighashTypes);\n  }\n  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        tapLeafHashToSign,\n        sighashTypes,\n      );\n    throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n  }\n  _signInput(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  _signTaprootInput(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    const tapKeySig = hashesForSig\n      .filter(h => !h.leafHash)\n      .map(h =>\n        (0, bip371_1.serializeTaprootSignature)(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n      )[0];\n    const tapScriptSig = hashesForSig\n      .filter(h => !!h.leafHash)\n      .map(h => ({\n        pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n        signature: (0, bip371_1.serializeTaprootSignature)(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n        leafHash: h.leafHash,\n      }));\n    if (tapKeySig) {\n      this.data.updateInput(inputIndex, { tapKeySig });\n    }\n    if (tapScriptSig.length) {\n      this.data.updateInput(inputIndex, { tapScriptSig });\n    }\n    return this;\n  }\n  signInputAsync(inputIndex, keyPair, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n      if ((0, bip371_1.isTaprootInput)(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          undefined,\n          sighashTypes,\n        );\n      return this._signInputAsync(inputIndex, keyPair, sighashTypes);\n    });\n  }\n  signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n      if ((0, bip371_1.isTaprootInput)(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          tapLeafHash,\n          sighashTypes,\n        );\n      throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n    });\n  }\n  _signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    return Promise.resolve(keyPair.sign(hash)).then(signature => {\n      const partialSig = [\n        {\n          pubkey: keyPair.publicKey,\n          signature: bscript.signature.encode(signature, sighashType),\n        },\n      ];\n      this.data.updateInput(inputIndex, { partialSig });\n    });\n  }\n  async _signTaprootInputAsync(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHash,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHash,\n      sighashTypes,\n    );\n    const signaturePromises = [];\n    const tapKeyHash = hashesForSig.filter(h => !h.leafHash)[0];\n    if (tapKeyHash) {\n      const tapKeySigPromise = Promise.resolve(\n        keyPair.signSchnorr(tapKeyHash.hash),\n      ).then(sig => {\n        return {\n          tapKeySig: (0, bip371_1.serializeTaprootSignature)(\n            sig,\n            input.sighashType,\n          ),\n        };\n      });\n      signaturePromises.push(tapKeySigPromise);\n    }\n    const tapScriptHashes = hashesForSig.filter(h => !!h.leafHash);\n    if (tapScriptHashes.length) {\n      const tapScriptSigPromises = tapScriptHashes.map(tsh => {\n        return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(\n          signature => {\n            const tapScriptSig = [\n              {\n                pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n                signature: (0, bip371_1.serializeTaprootSignature)(\n                  signature,\n                  input.sighashType,\n                ),\n                leafHash: tsh.leafHash,\n              },\n            ];\n            return { tapScriptSig };\n          },\n        );\n      });\n      signaturePromises.push(...tapScriptSigPromises);\n    }\n    return Promise.all(signaturePromises).then(results => {\n      results.forEach(v => this.data.updateInput(inputIndex, v));\n    });\n  }\n  checkTaprootHashesForSig(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes,\n  ) {\n    if (typeof keyPair.signSchnorr !== 'function')\n      throw new Error(\n        `Need Schnorr Signer to sign taproot input #${inputIndex}.`,\n      );\n    const hashesForSig = getTaprootHashesForSig(\n      inputIndex,\n      input,\n      this.data.inputs,\n      keyPair.publicKey,\n      this.__CACHE,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    if (!hashesForSig || !hashesForSig.length)\n      throw new Error(\n        `Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString(\n          'hex',\n        )}`,\n      );\n    return hashesForSig;\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    (0, bip371_1.checkTaprootInputFields)(\n      this.data.inputs[inputIndex],\n      updateData,\n      'updateInput',\n    );\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const outputData = this.data.outputs[outputIndex];\n    (0, bip371_1.checkTaprootOutputFields)(\n      outputData,\n      updateData,\n      'updateOutput',\n    );\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, 'hex'))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !Buffer.isBuffer(output.script) ||\n      typeof output.value !== 'number'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = compressPubkey(pkey);\n        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (!d.masterFingerprint.equals(root.fingerprint)) return false;\n    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    const throws = (0, bip371_1.isTaprootInput)(input)\n      ? (0, bip371_1.checkTaprootInputForSigs)(input, action)\n      : (0, psbtutils_1.checkInputForSig)(input, action);\n    if (throws)\n      throw new Error('Can not modify transaction, signatures exist.');\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString('hex') +\n    ':' +\n    input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        p2wsh.witness,\n      );\n    } else {\n      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        payment.witness,\n      );\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    false,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n  checkSighashTypeAllowed(sighashType, sighashTypes);\n  let hash;\n  let prevout;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const { meaningfulScript, type } = getMeaningfulScript(\n    prevout.script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      meaningfulScript,\n      prevout.value,\n      sighashType,\n    );\n  } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({\n      hash: meaningfulScript.slice(2),\n    }).output;\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      signingScript,\n      prevout.value,\n      sighashType,\n    );\n  } else {\n    // non-segwit\n    if (\n      input.nonWitnessUtxo === undefined &&\n      cache.__UNSAFE_SIGN_NONSEGWIT === false\n    )\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${meaningfulScript.toString('hex')}`,\n      );\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n      console.warn(\n        'Warning: Signing non-segwit inputs without the full parent transaction ' +\n          'means there is a chance that a miner could feed you incorrect information ' +\n          \"to trick you into paying large fees. This behavior is the same as Psbt's predecessor \" +\n          '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +\n          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n          'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n          '*********************',\n      );\n    hash = unsignedTx.hashForSignature(\n      inputIndex,\n      meaningfulScript,\n      sighashType,\n    );\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash,\n  };\n}\nfunction getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {\n  const allPublicKeys = [];\n  if (input.tapInternalKey) {\n    const key = getPrevoutTaprootKey(inputIndex, input, cache);\n    if (key) {\n      allPublicKeys.push(key);\n    }\n  }\n  if (input.tapScriptSig) {\n    const tapScriptPubkeys = input.tapScriptSig.map(tss => tss.pubkey);\n    allPublicKeys.push(...tapScriptPubkeys);\n  }\n  const allHashes = allPublicKeys.map(pubicKey =>\n    getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache),\n  );\n  return allHashes.flat();\n}\nfunction getPrevoutTaprootKey(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;\n}\nfunction trimTaprootSig(signature) {\n  return signature.length === 64 ? signature : signature.subarray(0, 64);\n}\nfunction getTaprootHashesForSig(\n  inputIndex,\n  input,\n  inputs,\n  pubkey,\n  cache,\n  tapLeafHashToSign,\n  allowedSighashTypes,\n) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;\n  checkSighashTypeAllowed(sighashType, allowedSighashTypes);\n  const prevOuts = inputs.map((i, index) =>\n    getScriptAndAmountFromUtxo(index, i, cache),\n  );\n  const signingScripts = prevOuts.map(o => o.script);\n  const values = prevOuts.map(o => o.value);\n  const hashes = [];\n  if (input.tapInternalKey && !tapLeafHashToSign) {\n    const outputKey =\n      getPrevoutTaprootKey(inputIndex, input, cache) || Buffer.from([]);\n    if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {\n      const tapKeyHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n      );\n      hashes.push({ pubkey, hash: tapKeyHash });\n    }\n  }\n  const tapLeafHashes = (input.tapLeafScript || [])\n    .filter(tapLeaf => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script))\n    .map(tapLeaf => {\n      const hash = (0, bip341_1.tapleafHash)({\n        output: tapLeaf.script,\n        version: tapLeaf.leafVersion,\n      });\n      return Object.assign({ hash }, tapLeaf);\n    })\n    .filter(\n      tapLeaf => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash),\n    )\n    .map(tapLeaf => {\n      const tapScriptHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n        tapLeaf.hash,\n      );\n      return {\n        pubkey,\n        hash: tapScriptHash,\n        leafHash: tapLeaf.hash,\n      };\n    });\n  return hashes.concat(tapLeafHashes);\n}\nfunction checkSighashTypeAllowed(sighashType, sighashTypes) {\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return ps.pubkey.equals(pk);\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return script;\n}\nfunction getScriptAndAmountFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return {\n      script: input.witnessUtxo.script,\n      value: input.witnessUtxo.value,\n    };\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];\n    return { script: o.script, value: o.value };\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    outputIndex,\n    'output',\n    output.redeemScript,\n    output.witnessScript,\n  );\n  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (\n    !Buffer.isBuffer(lastItem) ||\n    isPubkeyLike(lastItem) ||\n    isSigLike(lastItem)\n  )\n    return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction compressPubkey(pubkey) {\n  if (pubkey.length === 65) {\n    const parity = pubkey[64] & 1;\n    const newKey = pubkey.slice(0, 33);\n    newKey[0] = 2 | parity;\n    return newKey;\n  }\n  return pubkey.slice();\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(\n  script,\n  index,\n  ioType,\n  redeemScript,\n  witnessScript,\n) {\n  const isP2SH = (0, psbtutils_1.isP2SHScript)(script);\n  const isP2SHP2WSH =\n    isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);\n  const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);\n  if (isP2SH && redeemScript === undefined)\n    throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n    throw new Error(\n      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',\n    );\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH\n      ? 'p2sh-p2wsh'\n      : isP2SH\n      ? 'p2sh'\n      : isP2WSH\n      ? 'p2wsh'\n      : 'raw',\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if (\n    (0, psbtutils_1.isP2WPKH)(script) ||\n    (0, psbtutils_1.isP2SHScript)(script)\n  ) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction classifyScript(script) {\n  if ((0, psbtutils_1.isP2WPKH)(script)) return 'witnesspubkeyhash';\n  if ((0, psbtutils_1.isP2PKH)(script)) return 'pubkeyhash';\n  if ((0, psbtutils_1.isP2MS)(script)) return 'multisig';\n  if ((0, psbtutils_1.isP2PK)(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.initEccLib =\n  exports.Transaction =\n  exports.opcodes =\n  exports.Psbt =\n  exports.Block =\n  exports.script =\n  exports.payments =\n  exports.networks =\n  exports.crypto =\n  exports.address =\n    void 0;\nconst address = require('./address');\nexports.address = address;\nconst crypto = require('./crypto');\nexports.crypto = crypto;\nconst networks = require('./networks');\nexports.networks = networks;\nconst payments = require('./payments');\nexports.payments = payments;\nconst script = require('./script');\nexports.script = script;\nvar block_1 = require('./block');\nObject.defineProperty(exports, 'Block', {\n  enumerable: true,\n  get: function () {\n    return block_1.Block;\n  },\n});\nvar psbt_1 = require('./psbt');\nObject.defineProperty(exports, 'Psbt', {\n  enumerable: true,\n  get: function () {\n    return psbt_1.Psbt;\n  },\n});\n/** @hidden */\nvar ops_1 = require('./ops');\nObject.defineProperty(exports, 'opcodes', {\n  enumerable: true,\n  get: function () {\n    return ops_1.OPS;\n  },\n});\nvar transaction_1 = require('./transaction');\nObject.defineProperty(exports, 'Transaction', {\n  enumerable: true,\n  get: function () {\n    return transaction_1.Transaction;\n  },\n});\nvar ecc_lib_1 = require('./ecc_lib');\nObject.defineProperty(exports, 'initEccLib', {\n  enumerable: true,\n  get: function () {\n    return ecc_lib_1.initEccLib;\n  },\n});\n","'use strict';\n\nvar secp256k1 = require('@noble/curves/secp256k1');\nvar mod = require('@noble/curves/abstract/modular');\nvar utils = require('@noble/curves/abstract/utils');\n\nfunction _interopNamespaceDefault(e) {\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\n\nvar mod__namespace = /*#__PURE__*/_interopNamespaceDefault(mod);\nvar utils__namespace = /*#__PURE__*/_interopNamespaceDefault(utils);\n\n/*\n * Copyright (c) 2023 Jose-Luis Landabaso\n * Distributed under the MIT software license.\n *\n * This file includes code from the following sources:\n *  * Paul Miller's @noble/secp256k1 (specifically, the privateAdd,\n *    privateNegate, pointAddScalar, and pointMultiply functions).\n *  * Some pieces from tiny-secp256k1\n *    (https://github.com/bitcoinjs/tiny-secp256k1)\n *  * It also uses code from BitGo's BitGoJS library\n *    (https://github.com/BitGo/BitGoJS)\n *\n * This package's tests are based on modified versions of tests from\n * tiny-secp256k1 (https://github.com/bitcoinjs/tiny-secp256k1/tests).\n */\n\nconst Point = secp256k1.secp256k1.ProjectivePoint;\n\nconst THROW_BAD_PRIVATE = \"Expected Private\";\nconst THROW_BAD_POINT = \"Expected Point\";\nconst THROW_BAD_TWEAK = \"Expected Tweak\";\nconst THROW_BAD_HASH = \"Expected Hash\";\nconst THROW_BAD_SIGNATURE = \"Expected Signature\";\nconst THROW_BAD_EXTRA_DATA = \"Expected Extra Data (32 bytes)\";\nconst THROW_BAD_SCALAR = \"Expected Scalar\";\nconst THROW_BAD_RECOVERY_ID = \"Bad Recovery Id\";\n\nconst HASH_SIZE = 32;\nconst TWEAK_SIZE = 32;\nconst BN32_N = new Uint8Array([\n  255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n  254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65,\n]);\nconst EXTRA_DATA_SIZE = 32;\nconst BN32_ZERO = new Uint8Array(32);\nconst BN32_P_MINUS_N = new Uint8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 69, 81, 35, 25, 80, 183, 95,\n  196, 64, 45, 161, 114, 47, 201, 186, 238,\n]);\nconst _1n = BigInt(1);\n\nfunction isUint8Array(value) {\n  return value instanceof Uint8Array;\n}\n\nfunction cmpBN32(data1, data2) {\n  for (let i = 0; i < 32; ++i) {\n    if (data1[i] !== data2[i]) {\n      return data1[i] < data2[i] ? -1 : 1;\n    }\n  }\n  return 0;\n}\n\nfunction isZero(x) {\n  return cmpBN32(x, BN32_ZERO) === 0;\n}\n\nfunction isTweak(tweak) {\n  if (\n    !(tweak instanceof Uint8Array) ||\n    tweak.length !== TWEAK_SIZE ||\n    cmpBN32(tweak, BN32_N) >= 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isSignature(signature) {\n  return (\n    signature instanceof Uint8Array &&\n    signature.length === 64 &&\n    cmpBN32(signature.subarray(0, 32), BN32_N) < 0 &&\n    cmpBN32(signature.subarray(32, 64), BN32_N) < 0\n  );\n}\n\nfunction isSigrLessThanPMinusN(signature) {\n  return (\n    isUint8Array(signature) &&\n    signature.length === 64 &&\n    cmpBN32(signature.subarray(0, 32), BN32_P_MINUS_N) < 0\n  );\n}\n\nfunction isSignatureNonzeroRS(signature) {\n  return !(\n    isZero(signature.subarray(0, 32)) || isZero(signature.subarray(32, 64))\n  );\n}\n\nfunction isHash(h) {\n  return h instanceof Uint8Array && h.length === HASH_SIZE;\n}\n\nfunction isExtraData(e) {\n  return (\n    e === undefined || (e instanceof Uint8Array && e.length === EXTRA_DATA_SIZE)\n  );\n}\n\nfunction normalizeScalar(scalar) {\n  let num;\n  if (typeof scalar === \"bigint\") {\n    num = scalar;\n  } else if (\n    typeof scalar === \"number\" &&\n    Number.isSafeInteger(scalar) &&\n    scalar >= 0\n  ) {\n    num = BigInt(scalar);\n  } else if (typeof scalar === \"string\") {\n    if (scalar.length !== 64)\n      throw new Error(\"Expected 32 bytes of private scalar\");\n    num = utils__namespace.hexToNumber(scalar);\n  } else if (scalar instanceof Uint8Array) {\n    if (scalar.length !== 32)\n      throw new Error(\"Expected 32 bytes of private scalar\");\n    num = utils__namespace.bytesToNumberBE(scalar);\n  } else {\n    throw new TypeError(\"Expected valid private scalar\");\n  }\n  if (num < 0) throw new Error(\"Expected private scalar >= 0\");\n  return num;\n}\n\nfunction normalizePrivateKey(privateKey) {\n  return secp256k1.secp256k1.utils.normPrivateKeyToScalar(privateKey);\n}\n\nfunction _privateAdd(privateKey, tweak) {\n  const p = normalizePrivateKey(privateKey);\n  const t = normalizeScalar(tweak);\n  const add = utils__namespace.numberToBytesBE(mod__namespace.mod(p + t, secp256k1.secp256k1.CURVE.n), 32);\n  return secp256k1.secp256k1.utils.isValidPrivateKey(add) ? add : null;\n}\n\nfunction _privateSub(privateKey, tweak) {\n  const p = normalizePrivateKey(privateKey);\n  const t = normalizeScalar(tweak);\n  const sub = utils__namespace.numberToBytesBE(mod__namespace.mod(p - t, secp256k1.secp256k1.CURVE.n), 32);\n  return secp256k1.secp256k1.utils.isValidPrivateKey(sub) ? sub : null;\n}\n\nfunction _privateNegate(privateKey) {\n  const p = normalizePrivateKey(privateKey);\n  const not = utils__namespace.numberToBytesBE(secp256k1.secp256k1.CURVE.n - p, 32);\n  return secp256k1.secp256k1.utils.isValidPrivateKey(not) ? not : null;\n}\n\nfunction _pointAddScalar(p, tweak, isCompressed) {\n  const P = fromHex(p);\n  const t = normalizeScalar(tweak);\n  // multiplyAndAddUnsafe(P, scalar, 1) = P + scalar*G\n  const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);\n  if (!Q) throw new Error(\"Tweaked point at infinity\");\n  return Q.toRawBytes(isCompressed);\n}\n\nfunction _pointMultiply(p, tweak, isCompressed) {\n  const P = fromHex(p);\n  const h = typeof tweak === \"string\" ? tweak : utils__namespace.bytesToHex(tweak);\n  const t = utils__namespace.hexToNumber(h);\n  return P.multiply(t).toRawBytes(isCompressed);\n}\n\nfunction assumeCompression(compressed, p) {\n  if (compressed === undefined) {\n    return p !== undefined ? isPointCompressed(p) : true;\n  }\n  return !!compressed;\n}\n\nfunction throwToNull(fn) {\n  try {\n    return fn();\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction fromXOnly(bytes) {\n  return secp256k1.schnorr.utils.lift_x(utils__namespace.bytesToNumberBE(bytes));\n}\n\nfunction fromHex(bytes) {\n  return bytes.length === 32 ? fromXOnly(bytes) : Point.fromHex(bytes);\n}\n\nfunction _isPoint(p, xOnly) {\n  if ((p.length === 32) !== xOnly) return false;\n  try {\n    if (xOnly) return !!fromXOnly(p);\n    else return !!Point.fromHex(p);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isPoint(p) {\n  return _isPoint(p, false);\n}\n\nfunction isPointCompressed(p) {\n  const PUBLIC_KEY_COMPRESSED_SIZE = 33;\n  return _isPoint(p, false) && p.length === PUBLIC_KEY_COMPRESSED_SIZE;\n}\n\nfunction isPrivate(d) {\n  return secp256k1.secp256k1.utils.isValidPrivateKey(d);\n}\n\nfunction isXOnlyPoint(p) {\n  return _isPoint(p, true);\n}\n\nfunction xOnlyPointAddTweak(p, tweak) {\n  if (!isXOnlyPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() => {\n    const P = _pointAddScalar(p, tweak, true);\n    const parity = P[0] % 2 === 1 ? 1 : 0;\n    return { parity, xOnlyPubkey: P.slice(1) };\n  });\n}\n\nfunction xOnlyPointFromPoint(p) {\n  if (!isPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  return p.slice(1, 33);\n}\n\nfunction pointFromScalar(sk, compressed) {\n  if (!isPrivate(sk)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  return throwToNull(() =>\n    secp256k1.secp256k1.getPublicKey(sk, assumeCompression(compressed)),\n  );\n}\n\nfunction xOnlyPointFromScalar(d) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  return xOnlyPointFromPoint(pointFromScalar(d));\n}\n\nfunction pointCompress(p, compressed) {\n  if (!isPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  return fromHex(p).toRawBytes(assumeCompression(compressed, p));\n}\n\nfunction pointMultiply(a, tweak, compressed) {\n  if (!isPoint(a)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() =>\n    _pointMultiply(a, tweak, assumeCompression(compressed, a)),\n  );\n}\n\nfunction pointAdd(a, b, compressed) {\n  if (!isPoint(a) || !isPoint(b)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  return throwToNull(() => {\n    const A = fromHex(a);\n    const B = fromHex(b);\n    if (A.equals(B.negate())) {\n      return null;\n    } else {\n      return A.add(B).toRawBytes(assumeCompression(compressed, a));\n    }\n  });\n}\n\nfunction pointAddScalar(p, tweak, compressed) {\n  if (!isPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() =>\n    _pointAddScalar(p, tweak, assumeCompression(compressed, p)),\n  );\n}\n\nfunction privateAdd(d, tweak) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() => _privateAdd(d, tweak));\n}\n\nfunction privateSub(d, tweak) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() => _privateSub(d, tweak));\n}\n\nfunction privateNegate(d) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  return _privateNegate(d);\n}\n\nfunction sign(h, d, e) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  if (!isExtraData(e)) {\n    throw new Error(THROW_BAD_EXTRA_DATA);\n  }\n  return secp256k1.secp256k1.sign(h, d, { extraEntropy: e }).toCompactRawBytes();\n}\n\nfunction signRecoverable(h, d, e) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  if (!isExtraData(e)) {\n    throw new Error(THROW_BAD_EXTRA_DATA);\n  }\n  const sig = secp256k1.secp256k1.sign(h, d, { extraEntropy: e });\n  return {\n    signature: sig.toCompactRawBytes(),\n    recoveryId: sig.recovery,\n  };\n}\n\nfunction signSchnorr(h, d, e) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  if (!isExtraData(e)) {\n    throw new Error(THROW_BAD_EXTRA_DATA);\n  }\n  return secp256k1.schnorr.sign(h, d, e);\n}\n\nfunction recover(h, signature, recoveryId, compressed) {\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_HASH);\n  }\n\n  if (!isSignature(signature) || !isSignatureNonzeroRS(signature)) {\n    throw new Error(THROW_BAD_SIGNATURE);\n  }\n\n  if (recoveryId & 2) {\n    if (!isSigrLessThanPMinusN(signature))\n      throw new Error(THROW_BAD_RECOVERY_ID);\n  }\n  if (!isXOnlyPoint(signature.subarray(0, 32))) {\n    throw new Error(THROW_BAD_SIGNATURE);\n  }\n\n  const s =\n    secp256k1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(recoveryId);\n  const Q = s.recoverPublicKey(h);\n  if (!Q) throw new Error(THROW_BAD_SIGNATURE);\n  return Q.toRawBytes(assumeCompression(compressed));\n}\n\nfunction verify(h, Q, signature, strict) {\n  if (!isPoint(Q)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isSignature(signature)) {\n    throw new Error(THROW_BAD_SIGNATURE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  return secp256k1.secp256k1.verify(signature, h, Q, { lowS: strict });\n}\n\nfunction verifySchnorr(h, Q, signature) {\n  if (!isXOnlyPoint(Q)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isSignature(signature)) {\n    throw new Error(THROW_BAD_SIGNATURE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  return secp256k1.schnorr.verify(signature, h, Q);\n}\n\nexports.isPoint = isPoint;\nexports.isPointCompressed = isPointCompressed;\nexports.isPrivate = isPrivate;\nexports.isXOnlyPoint = isXOnlyPoint;\nexports.pointAdd = pointAdd;\nexports.pointAddScalar = pointAddScalar;\nexports.pointCompress = pointCompress;\nexports.pointFromScalar = pointFromScalar;\nexports.pointMultiply = pointMultiply;\nexports.privateAdd = privateAdd;\nexports.privateNegate = privateNegate;\nexports.privateSub = privateSub;\nexports.recover = recover;\nexports.sign = sign;\nexports.signRecoverable = signRecoverable;\nexports.signSchnorr = signSchnorr;\nexports.verify = verify;\nexports.verifySchnorr = verifySchnorr;\nexports.xOnlyPointAddTweak = xOnlyPointAddTweak;\nexports.xOnlyPointFromPoint = xOnlyPointFromPoint;\nexports.xOnlyPointFromScalar = xOnlyPointFromScalar;\n"],"names":["networks","bip66","check","buffer","lenR","lenS","decode","encode","r","s","signature","Buffer","ops","OPS","REVERSE_OPS","op","code","push_data","ops_1","require$$0","encodingLength","i","num","offset","size","opcode","script_number","maxLength","minimal","length","b","result","scriptNumSize","_number","value","negative","exports","buffer_1","require$$1","ZERO32","EC_P","stacksEqual","a","x","isPoint","p","t","y","SATOSHI_MAX","Satoshi","isTapleaf","o","isTaptree","scriptTree","script_signature","script_1","types","require$$2","typeforce","ZERO","toDER","fromDER","bstart","hashType","decoded","hashTypeBuffer","pushdata","scriptNumber","require$$3","scriptSignature","require$$4","require$$5","OP_INT_BASE","isOPInt","isPushOnlyChunk","isPushOnly","countNonPushOnlyOPs","asMinimalOP","chunksIsBuffer","buf","chunksIsArray","singleChunkIsBuffer","compile","chunks","bufferSize","accum","chunk","decompile","d","data","toASM","fromASM","asm","chunkStr","toStack","isCanonicalPubKey","isDefinedHashType","hashTypeMod","isCanonicalScriptSignature","lazy","prop","object","name","_value","f","embed","networks_1","bscript","types_1","p2data","opts","p2ms_1","p2ms","isAcceptableSignature","output","p2pk_1","p2pk","_chunks","ripemd160_1","sha1_1","sha256_1","ripemd160","sha1","sha256","hash160","hash256","taggedHash","prefix","p2pkh_1","bcrypto","bs58check","p2pkh","_address","payload","version","hash","network","hash2","pkh","p2sh_1","p2sh","_redeem","lastChunk","nameParts","checkRedeem","redeem","hasInput","hasWitness","richunks","p2wpkh_1","bech32_1","EMPTY_BUFFER","p2wpkh","words","p2wsh_1","chunkHasUncompressedPubkey","p2wsh","_rchunks","stack","wScript","ecc_lib","_ECCLIB_CACHE","initEccLib","eccLib","verifyEcc","getEccLib","h","hex","ecc","assert","tweakAddVectors","bool","bufferutils","varuint","verifuint","max","readUInt64LE","writeUInt64LE","reverseBuffer","j","tmp","cloneBuffer","clone","BufferWriter","slice","vector","BufferReader","vi","n","count","ecc_lib_1","bufferutils_1","isHashBranch","ht","rootHashFromPath","controlBlock","leafHash","m","kj","ej","tapBranchHash","toHashTree","tapleafHash","hashes","left","right","findScriptPath","node","leftPath","rightPath","leaf","serializeScript","tapTweakHash","pubKey","tweakKey","tweakHash","res","varintLen","p2tr_1","bip341_1","require$$6","require$$7","address_1","require$$8","TAPROOT_WITNESS_VERSION","ANNEX_PREFIX","p2tr","_witness","_hashTree","hashTree","w","leafVersion","script","witness","tweakedKey","path","outputKey","controlBock","pubkey","internalPubkey","embed_1","address","payments","FUTURE_SEGWIT_MAX_SIZE","FUTURE_SEGWIT_MIN_SIZE","FUTURE_SEGWIT_MAX_VERSION","FUTURE_SEGWIT_MIN_VERSION","FUTURE_SEGWIT_VERSION_DIFF","FUTURE_SEGWIT_VERSION_WARNING","_toFutureSegwitAddress","toBech32","fromBase58Check","fromBech32","toBase58Check","fromOutputScript","toOutputScript","decodeBase58","decodeBech32","merkle","fastMerkleRoot","values","digestFn","results","transaction","varSliceSize","someScript","vectorSize","someVector","sum","EMPTY_WITNESS","ONE","VALUE_UINT64_MAX","BLANK_OUTPUT","isOutput","out","Transaction","_NO_STRICT","bufferReader","tx","marker","flag","hasWitnesses","vinLen","voutLen","index","sequence","scriptSig","scriptPubKey","input","base","total","_ALLOW_WITNESS","newTx","txIn","txOut","inIndex","prevOutScript","ourScript","txTmp","prevOutScripts","annex","outputType","isAnyoneCanPay","isNone","isSingle","hashPrevouts","hashAmounts","hashScriptPubKeys","hashSequences","hashOutputs","bufferWriter","txOutsSize","spendType","sigMsgSize","sigMsgWriter","tbuffer","hashSequence","forWitness","initialOffset","block","merkle_1","transaction_1","errorMerkleNoTxes","errorWitnessNotSegwit","Block","readTransaction","nTransactions","witnessCommit","bits","exponent","mantissa","target","transactions","txesHaveWitnessCommit","rootHash","witnessCommits","anyTxHasWitness","headersOnly","allowWitness","date","txSize","hasWitnessCommit","actualMerkleRoot","actualWitnessCommit","psbtutils","crypto_1","isPaymentFactory","payment","witnessStackToScriptWitness","writeSlice","writeVarInt","currentLen","writeVarSlice","writeVector","pubkeyPositionInScript","pubkeyHash","pubkeyXOnly","decompiled","element","pubkeyInScript","checkInputForSig","action","extractPartialSigs","pSig","signatureBlocksAction","signatureDecodeFn","whitelist","pSigs","getPsigsFromInputFinalScripts","scriptItems","witnessItems","item","sig","bip371","psbtutils_1","payments_1","psbtutils_2","toXOnly","tapScriptFinalizer","inputIndex","tapLeafHashToFinalize","tapLeaf","findTapLeafToFinalize","sortSignatures","err","serializeTaprootSignature","sighashType","sighashTypeByte","isTaprootInput","isTaprootOutput","checkTaprootInputFields","inputData","newInputData","checkMixedTaprootAndNonTaprootInputFields","checkIfTapLeafInTree","checkTaprootOutputFields","outputData","newOutputData","checkMixedTaprootAndNonTaprootOutputFields","checkTaprootScriptPubkey","tapInternalKey","tapTree","scriptPubkey","getTaprootScripPubkey","tapTreeFromList","tweakInternalPubKey","tapTreeToList","tree","_tapTreeToList","leaves","instertLeavesInTree","checkTaprootInputForSigs","extractTaprootSigs","decodeSchnorrSignature","sigs","finalTapKeySig","getTapKeySigFromWithness","finalScriptWitness","depth","instertLeafInTree","leftSide","rightSide","isBadTaprootUpdate","hasNonTaprootFields","isBadNonTaprootUpdate","hasMixedFields","newLeafsInTree","l","isTapLeafInTree","oldLeafsInTree","merkleRoot","tss","addPubkeyPositionInScript","t1","t2","leafHashToFinalize","canFinalizeLeaf","tapScriptSig","io","psbt","bip174_1","utils_1","require$$9","bip371_1","require$$10","require$$11","DEFAULT_OPTS","Psbt","psbtBase","transactionFromBuffer","checkTxForDupeIns","PsbtTransaction","dpew","obj","attr","enumerable","writable","locktime","those","satoshiPerByte","check32Bit","checkInputsForPartialSig","c","inputDatas","checkInvalidP2WSH","checkTxInputCache","addNonWitnessTxCache","outputDatas","disableFeeCheck","isFinalized","checkFees","inputFinalizeGetAmts","getTxCacheValue","range","idx","finalScriptsFunc","getFinalScripts","isP2SH","isP2WSH","isSegwit","getScriptFromInput","checkPartialSigSighashes","finalScriptSig","getScriptFromUtxo","getMeaningfulScript","redeemFromFinalScriptSig","redeemFromFinalWitnessScript","type","mainType","classifyScript","pubkeyInInput","root","derivationIsMine","bip32DerivationIsMine","outputIndex","pubkeyInOutput","validator","final","partialSig","mySigs","hashCache","scriptCache","sighashCache","getHashForSig","checkScriptForPubkey","tapKeySig","allHashses","getTaprootHashesForSig","getAllTaprootHashesForSig","tapKeyHash","validationResultCount","trimTaprootSig","tapSig","tapSigHash","hdKeyPair","sighashTypes","v","resolve","reject","promises","getSignersFromHD","signer","keyPair","tapLeafHashToSign","getHashAndSighashType","allowedSighashTypes","hashesForSig","tapLeafHash","signaturePromises","tapKeySigPromise","tapScriptHashes","tapScriptSigPromises","tsh","checkCache","updateData","keyVal","checkTxEmpty","canFinalize","scriptType","hasSigs","cache","neededSigs","pubkeys","pkey","compressPubkey","feeRate","vsize","satoshis","inputs","key","scriptCheckerFactory","paymentScriptName","redeemScript","ioType","redeemScriptOutput","checkRedeemScript","checkWitnessScript","mustFinalize","prepareFinalScripts","getPayment","forValidate","unsignedTx","checkSighashTypeAllowed","prevout","nonWitnessUtxoTx","nonWitnessUtxoTxFromCache","prevoutHash","utxoHash","prevoutIndex","meaningfulScript","signingScript","allPublicKeys","getPrevoutTaprootKey","tapScriptPubkeys","pubicKey","getScriptAndAmountFromUtxo","prevOuts","signingScripts","tapLeafHashes","tapScriptHash","str","sighashTypeToString","getSortedSigs","myDerivations","bipDv","pk","ps","scriptWitnessToWitnessStack","readSlice","readVarInt","readVarSlice","readVector","text","self","selfIndex","txCache","newBuf","inputAmount","nwTx","vout","outputAmount","fee","bytes","finalScript","decomp","lastItem","isPubkeyLike","isSigLike","parity","newKey","witnessScript","isP2SHP2WSH","crypto","block_1","psbt_1","secp256k1","mod","utils","_interopNamespaceDefault","e","k","mod__namespace","utils__namespace","Point","THROW_BAD_PRIVATE","THROW_BAD_POINT","THROW_BAD_TWEAK","THROW_BAD_HASH","THROW_BAD_SIGNATURE","THROW_BAD_EXTRA_DATA","THROW_BAD_SCALAR","THROW_BAD_RECOVERY_ID","HASH_SIZE","TWEAK_SIZE","BN32_N","EXTRA_DATA_SIZE","BN32_ZERO","BN32_P_MINUS_N","_1n","isUint8Array","cmpBN32","data1","data2","isZero","isTweak","tweak","isSignature","isSigrLessThanPMinusN","isSignatureNonzeroRS","isHash","isExtraData","normalizeScalar","scalar","normalizePrivateKey","privateKey","_privateAdd","add","_privateSub","sub","_privateNegate","not","_pointAddScalar","isCompressed","P","fromHex","Q","_pointMultiply","assumeCompression","compressed","isPointCompressed","throwToNull","fn","fromXOnly","_isPoint","xOnly","isPrivate","isXOnlyPoint","xOnlyPointAddTweak","xOnlyPointFromPoint","pointFromScalar","sk","xOnlyPointFromScalar","pointCompress","pointMultiply","pointAdd","A","B","pointAddScalar","privateAdd","privateSub","privateNegate","sign","signRecoverable","signSchnorr","recover","recoveryId","verify","strict","verifySchnorr","dist"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]}