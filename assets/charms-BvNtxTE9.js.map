{"version":3,"file":"charms-BvNtxTE9.js","sources":["../../src/utils/cache.ts","../../src/services/BitcoinService.ts","../../src/utils/charms.ts","../../src/application/ports.ts","../../src/utils/logger.ts","../../src/services/CharmsService.ts"],"sourcesContent":["interface CacheEntry<T> {\n  value: T;\n  expiresAt: number;\n}\n\nclass SimpleCache<T> {\n  private cache = new Map<string, CacheEntry<T>>();\n  private defaultTtlMs: number;\n\n  constructor(defaultTtlMs = 60000) {\n    this.defaultTtlMs = defaultTtlMs;\n  }\n\n  // Simple get - returns undefined if not cached or expired\n  get(key: string): T | undefined;\n  // Get with async loader - fetches if not cached\n  get<R extends T>(key: string, loader: () => Promise<R>, ttlMs?: number): Promise<R>;\n  get<R extends T>(key: string, loader?: () => Promise<R>, ttlMs?: number): T | undefined | Promise<R> {\n    const entry = this.cache.get(key);\n    \n    // Check if we have a valid cached entry\n    if (entry && Date.now() <= entry.expiresAt) {\n      if (loader) {\n        return Promise.resolve(entry.value as R);\n      }\n      return entry.value;\n    }\n    \n    // If no loader, just return undefined\n    if (!loader) {\n      if (entry) this.cache.delete(key);\n      return undefined;\n    }\n    \n    // Fetch via loader and cache\n    return loader().then((value) => {\n      this.set(key, value, ttlMs);\n      return value;\n    });\n  }\n\n  set(key: string, value: T, ttlMs?: number): void {\n    this.cache.set(key, {\n      value,\n      expiresAt: Date.now() + (ttlMs ?? this.defaultTtlMs),\n    });\n  }\n\n  has(key: string): boolean {\n    const entry = this.cache.get(key);\n    if (!entry) return false;\n    if (Date.now() > entry.expiresAt) {\n      this.cache.delete(key);\n      return false;\n    }\n    return true;\n  }\n\n  delete(key: string): void {\n    this.cache.delete(key);\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n}\n\n// Export cache instances used by services\nexport const utxoCache = new SimpleCache<UtxoInfo[]>(30000); // 30 seconds\nexport const txCache = new SimpleCache<string>(300000); // 5 minutes\nexport const blockHeightCache = new SimpleCache<number>(10000); // 10 seconds\nexport const addressInfoCache = new SimpleCache<AddressInfo>(60000); // 1 minute\n\n// Types needed for cache\nimport type { UtxoInfo } from '../application/ports';\n\ninterface AddressInfo {\n  address: string;\n  pubkey: string;\n  scriptPubKey?: string;\n}\n","\n\nimport { IBitcoinPort, Network, UtxoInfo } from '../application/ports';\nimport { utxoCache, txCache, blockHeightCache, addressInfoCache } from '../utils/cache';\n\nexport interface IBitcoinService extends IBitcoinPort {\n  getAddressInfo(address: string): Promise<AddressInfo>;\n}\n\nexport interface AddressInfo {\n  address: string;\n  pubkey: string;\n  scriptPubKey?: string;\n}\n\n// MEMPOOL.SPACE IMPLEMENTATION\n\nconst MEMPOOL_ENDPOINTS: Record<Network, string> = {\n  mainnet: 'https://mempool.space/api',\n  testnet4: 'https://mempool.space/testnet4/api',\n  signet: 'https://mempool.space/signet/api',\n  regtest: 'http://localhost:3001/api', // Via proxy\n};\n\nexport class MempoolBitcoinService implements IBitcoinService {\n  async fetchUtxos(address: string, network: Network): Promise<UtxoInfo[]> {\n    const cacheKey = `utxos:${network}:${address}`;\n\n    return utxoCache.get(cacheKey, async () => {\n      const baseUrl = MEMPOOL_ENDPOINTS[network];\n      const response = await fetch(`${baseUrl}/address/${address}/utxo`);\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch UTXOs: ${response.statusText}`);\n      }\n\n      const utxos = await response.json();\n      return utxos.map((utxo: any) => ({\n        txid: utxo.txid,\n        vout: utxo.vout,\n        value: utxo.value,\n      }));\n    });\n  }\n  \n  async fetchTransaction(txid: string, network: Network): Promise<string> {\n    const cacheKey = `tx:${network}:${txid}`;\n\n    return txCache.get(cacheKey, async () => {\n      const baseUrl = MEMPOOL_ENDPOINTS[network];\n      const response = await fetch(`${baseUrl}/tx/${txid}/hex`);\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch transaction: ${response.statusText}`);\n      }\n\n      return response.text();\n    }, 300000); // 5 minutes - transactions are immutable once confirmed\n  }\n  \n  async broadcast(txHex: string, network: Network): Promise<string> {\n    const baseUrl = MEMPOOL_ENDPOINTS[network];\n    const response = await fetch(`${baseUrl}/tx`, {\n      method: 'POST',\n      body: txHex,\n    });\n    \n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Broadcast failed: ${error}`);\n    }\n    \n    return response.text(); // Returns txid\n  }\n  \n  async getCurrentBlockHeight(network: Network): Promise<number> {\n    const cacheKey = `blockHeight:${network}`;\n\n    return blockHeightCache.get(cacheKey, async () => {\n      const baseUrl = MEMPOOL_ENDPOINTS[network];\n      const response = await fetch(`${baseUrl}/blocks/tip/height`);\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch block height: ${response.statusText}`);\n      }\n\n      return parseInt(await response.text(), 10);\n    }, 30000); // 30 seconds - balance between freshness and API calls\n  }\n  \n  async getAddressInfo(_address: string): Promise<AddressInfo> {\n    // Mempool.space doesn't provide pubkey info\n    throw new Error('getAddressInfo not supported by Mempool.space');\n  }\n}\n\nexport class ProxyBitcoinService implements IBitcoinService {\n  constructor(private proxyUrl: string = 'http://localhost:3001') {}\n\n  async fetchUtxos(address: string, _network: Network): Promise<UtxoInfo[]> {\n    const cacheKey = `utxos:proxy:${address}`;\n\n    return utxoCache.get(cacheKey, async () => {\n      const response = await fetch(`${this.proxyUrl}/api/wallet/utxos?address=${address}`);\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch UTXOs: ${response.statusText}`);\n      }\n\n      return response.json();\n    });\n  }\n  \n  async fetchTransaction(txid: string, _network: Network): Promise<string> {\n    const cacheKey = `tx:proxy:${txid}`;\n\n    return txCache.get(cacheKey, async () => {\n      const response = await fetch(`${this.proxyUrl}/api/tx/${txid}/hex`);\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch transaction: ${response.statusText}`);\n      }\n\n      return response.text();\n    }, 300000); // 5 minutes - transactions are immutable\n  }\n  \n  async broadcast(txHex: string, _network: Network): Promise<string> {\n    const response = await fetch(`${this.proxyUrl}/api/tx/broadcast`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ txHex }),\n    });\n    \n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Broadcast failed: ${error}`);\n    }\n    \n    const result = await response.json();\n    return result.txid;\n  }\n  \n  async getCurrentBlockHeight(_network: Network): Promise<number> {\n    const cacheKey = `blockHeight:proxy`;\n\n    return blockHeightCache.get(cacheKey, async () => {\n      const response = await fetch(`${this.proxyUrl}/api/blockchain/height`);\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch block height: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n      return result.height;\n    }, 30000); // 30 seconds\n  }\n  \n  async getAddressInfo(address: string): Promise<AddressInfo> {\n    const cacheKey = `addressInfo:proxy:${address}`;\n\n    return addressInfoCache.get(cacheKey, async () => {\n      const response = await fetch(`${this.proxyUrl}/api/wallet/address/${address}/info`);\n\n      if (!response.ok) {\n        throw new Error(`Failed to get address info: ${response.statusText}`);\n      }\n\n      return response.json();\n    }, 300000); // 5 minutes\n  }\n  \n  async getNewAddress(label: string = 'veil'): Promise<string> {\n    const response = await fetch(\n      `${this.proxyUrl}/api/wallet/address?label=${label}&type=bech32m`\n    );\n    \n    if (!response.ok) {\n      throw new Error(`Failed to get new address: ${response.statusText}`);\n    }\n    \n    const result = await response.json();\n    return result.address;\n  }\n  \n  async isAvailable(): Promise<boolean> {\n    try {\n      const response = await fetch(`${this.proxyUrl}/health`);\n      return response.ok;\n    } catch {\n      return false;\n    }\n  }\n}\n\nexport function createBitcoinService(\n  mode: 'mempool' | 'proxy',\n  proxyUrl?: string\n): IBitcoinService {\n  if (mode === 'proxy') {\n    return new ProxyBitcoinService(proxyUrl);\n  }\n  return new MempoolBitcoinService();\n}\n\n// Default instance for convenience\nexport const bitcoinService = new MempoolBitcoinService();\nexport const proxyBitcoinService = new ProxyBitcoinService();\n","\n// CHARMS UTILITIES - Pure Helpers\n\n// Pure functions for Charms protocol operations.\n\n//\n\n// use CharmsService from services/CharmsService.ts\n\nimport type { VeilBadge, RiskFlags } from '../domain/types';\n\nexport interface CharmsApp {\n  tag: 'n' | 't';\n  identity: string; // hex-encoded 32 bytes\n  vk: string; // hex-encoded 32 bytes\n}\n\nexport interface ParsedSpell {\n  version: number;\n  tx: {\n    ins: string[]; // UTXO IDs: \"txid:vout\"\n    outs: Map<number, unknown>[]; // Output index -> charm data\n  };\n  app_public_inputs: Map<string, unknown>; // App spec string -> public inputs\n}\n\nexport interface CharmOutput {\n  appSpec: string; // \"tag/identity/vk\"\n  data: VeilBadge | number | unknown; // NFT data, token amount, or raw data\n}\n\nexport interface CharmScanResult {\n  hasCharms: boolean;\n  charms: CharmOutput[];\n  rawSpell?: ParsedSpell;\n}\n\nexport const VEIL_APP_TAG = 'n';\n\n/**\n * Decode risk flags from a bitfield number to a RiskFlags object.\n * Bit positions match the Rust enum order:\n * - bit 0 (0b00000001): acceleration\n * - bit 1 (0b00000010): extraction\n * - bit 2 (0b00000100): isolated\n * - bit 3 (0b00001000): too_clean\n * - bit 4 (0b00010000): erratic\n * - bit 5 (0b00100000): new_badge\n */\nexport function decodeRiskFlags(flags: number): RiskFlags {\n  return {\n    acceleration: (flags & 0b00000001) !== 0,\n    extraction: (flags & 0b00000010) !== 0,\n    isolated: (flags & 0b00000100) !== 0,\n    too_clean: (flags & 0b00001000) !== 0,\n    erratic: (flags & 0b00010000) !== 0,\n    new_badge: (flags & 0b00100000) !== 0,\n  };\n}\n\nexport function parseAppSpec(appSpec: string): CharmsApp | null {\n  const parts = appSpec.split('/');\n  if (parts.length !== 3) return null;\n\n  const [tag, identity, vk] = parts;\n  if (tag !== 'n' && tag !== 't') return null;\n  if (identity.length !== 64) return null; // 32 bytes hex\n  if (vk.length !== 64) return null; // 32 bytes hex\n\n  return { tag, identity, vk };\n}\n\nexport function buildAppSpec(app: CharmsApp): string {\n  return `${app.tag}/${app.identity}/${app.vk}`;\n}\n\n/**\n * Find the first NFT app spec in the spell (any VK)\n * Used when we need to extract a badge but don't know/care which VK it uses\n */\nexport function findFirstNftAppSpec(spell: ParsedSpell): string | null {\n  if (!spell?.app_public_inputs) return null;\n\n  for (const [appSpec] of spell.app_public_inputs) {\n    const parts = appSpec.split('/');\n    // Must be NFT (tag 'n') with valid 64-char identity and vk\n    if (parts.length === 3 && parts[0] === 'n' && parts[1].length === 64 && parts[2].length === 64) {\n      return appSpec;\n    }\n  }\n  return null;\n}\n\nexport function hasVeilBadge(spell: ParsedSpell, veilAppId: string): boolean {\n  if (!spell?.app_public_inputs) return false;\n\n  const parts = veilAppId.split('/');\n  if (parts.length !== 3 || parts[0] !== 'n') {\n    // Fallback to exact match for invalid format\n    return spell.app_public_inputs.has(veilAppId);\n  }\n\n  const targetVk = parts[2];\n\n  for (const [appSpec] of spell.app_public_inputs) {\n    const appParts = appSpec.split('/');\n    if (appParts.length === 3 && appParts[0] === 'n' && appParts[2] === targetVk) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function hasVeilBadgeByVk(spell: ParsedSpell, veilVk: string): boolean {\n  if (!spell?.app_public_inputs) return false;\n\n  for (const [appSpec] of spell.app_public_inputs) {\n    const parts = appSpec.split('/');\n    if (parts.length === 3 && parts[0] === 'n' && parts[2] === veilVk) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function extractVeilBadge(\n  spell: ParsedSpell,\n  veilAppId: string,\n  outputIndex: number\n): VeilBadge | null {\n  if (!spell?.tx?.outs) return null;\n  if (outputIndex < 0 || outputIndex >= spell.tx.outs.length) return null;\n\n  const outputMap = spell.tx.outs[outputIndex];\n  if (!(outputMap instanceof Map)) return null;\n\n  const parts = veilAppId.split('/');\n  if (parts.length !== 3 || parts[0] !== 'n') return null;\n  const targetVk = parts[2];\n\n  let appIndex = 0;\n  let found = false;\n  for (const [appSpec] of spell.app_public_inputs) {\n    const appParts = appSpec.split('/');\n\n    if (appParts.length === 3 && appParts[0] === 'n' && appParts[2] === targetVk) {\n      found = true;\n      break;\n    }\n    appIndex++;\n  }\n\n  if (!found) return null;\n\n  const charmData = outputMap.get(appIndex);\n  if (!charmData || typeof charmData !== 'object') return null;\n\n  // WASM may return badge data as a Map - convert to plain object\n  let badge: Record<string, unknown>;\n  if (charmData instanceof Map) {\n    badge = Object.fromEntries(charmData);\n  } else {\n    badge = charmData as Record<string, unknown>;\n  }\n\n  // Validate that the object has required VeilBadge properties\n  if (typeof badge.id !== 'string' || !badge.id) {\n    console.warn('[extractVeilBadge] Invalid badge: missing or invalid id', badge);\n    return null;\n  }\n\n  // Ensure volume_sum_squares is a BigInt (WASM may return number or BigInt)\n  if (badge.volume_sum_squares !== undefined) {\n    badge.volume_sum_squares = BigInt(badge.volume_sum_squares as number | bigint);\n  }\n\n  // Convert flags from bitfield number to RiskFlags object if needed\n  if (typeof badge.flags === 'number') {\n    badge.flags = decodeRiskFlags(badge.flags);\n  }\n\n  return badge as unknown as VeilBadge;\n}\n","\n\nimport { VeilBadge, PubKey, B32, BlockHeight } from '../domain/types';\n\nexport type Network = 'mainnet' | 'testnet4' | 'signet' | 'regtest';\n\nexport interface UtxoInfo {\n  txid: string;\n  vout: number;\n  value: number;\n  scriptPubKey?: string;\n  badge?: VeilBadge;\n}\n\nexport interface IBitcoinPort {\n  fetchUtxos(address: string, network: Network): Promise<UtxoInfo[]>;\n  fetchTransaction(txid: string, network: Network): Promise<string>;\n  broadcast(txHex: string, network: Network): Promise<string>;\n  getCurrentBlockHeight(network: Network): Promise<BlockHeight>;\n}\n\nexport interface ProveParams {\n  spellYaml: string;\n  prevTxs: string[];\n  fundingUtxo: { txid: string; vout: number };\n  fundingUtxoValue: number;\n  changeAddress: string;\n  feeRate: number;\n  signingPubkey?: string; // Optional: x-only pubkey for Taproot signing (32 bytes hex)\n}\n\nexport interface ProveResult {\n  success: boolean;\n  commitTx?: string;\n  spellTx?: string;\n  error?: string;\n  isMock?: boolean; // True if this is a mock proof (not for real broadcast)\n}\n\nexport interface IProverPort {\n  prove(params: ProveParams): Promise<ProveResult>;\n  isAvailable(): Promise<boolean>;\n}\n\nexport interface IWalletPort {\n  connect(): Promise<{ address: string; pubkey: PubKey }>;\n  disconnect(): void;\n  signMessage(message: string): Promise<string>;\n  signPsbt(psbtBase64: string, signInputs?: Record<string, number[]>): Promise<string>;\n  getPublicKey(): Promise<PubKey>;\n  isConnected(): boolean;\n}\n\nexport interface ICryptoPort {\n  sha256Hex(data: string): Promise<B32>;\n  generateNonce(): Promise<B32>;\n  generateBadgeId(utxoString: string): Promise<B32>;\n}\n\n// Minimal storage for burned UTXO tracking\nexport interface IStoragePort {\n  getBurnedUtxos?(): { utxoId: string; burnedAt: number }[];\n  addBurnedUtxo?(utxoId: string): void;\n  isUtxoBurned?(utxoId: string): boolean;\n}\n\nexport interface UseCaseResult<T> {\n  success: boolean;\n  data?: T;\n  error?: string;\n}\n\n// PROGRESS & LOGGING CALLBACKS\n\nexport type ProgressCallback = (message: string) => void;\n\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n}\n\nexport interface ILoggerPort {\n  debug(message: string, ...args: unknown[]): void;\n  info(message: string, ...args: unknown[]): void;\n  warn(message: string, ...args: unknown[]): void;\n  error(message: string, ...args: unknown[]): void;\n}\n\nexport interface UseCaseContext {\n  bitcoin: IBitcoinPort;\n  prover: IProverPort;\n  wallet: IWalletPort;\n  crypto: ICryptoPort;\n  storage: IStoragePort;\n  network: Network;\n  onProgress?: ProgressCallback;\n  logger?: ILoggerPort;\n}\n\n","\n// LOGGER UTILITY - Infrastructure Layer\n\n//\n// Architecture:\n\n// - Domain layer remains pure (no logging)\n\nimport { ILoggerPort, LogLevel } from '../application/ports';\n\nexport { LogLevel } from '../application/ports';\n\ninterface LoggerConfig {\n  defaultLevel: LogLevel;\n  moduleOverrides?: Record<string, LogLevel>;\n  enableTimestamps?: boolean;\n  enableColors?: boolean;\n}\n\nconst DEFAULT_CONFIG: LoggerConfig = {\n  defaultLevel: import.meta.env.DEV ? LogLevel.DEBUG : LogLevel.INFO,\n  enableTimestamps: true,\n  enableColors: true,\n};\n\n// Global configuration\nlet globalConfig: LoggerConfig = { ...DEFAULT_CONFIG };\n\n// ANSI color codes for browser console\nconst COLORS = {\n  DEBUG: '#808080', // Gray\n  INFO: '#2196F3',  // Blue\n  WARN: '#FF9800',  // Orange\n  ERROR: '#F44336', // Red\n  RESET: '',\n};\n\nexport function configureLogger(config: Partial<LoggerConfig>): void {\n  globalConfig = { ...globalConfig, ...config };\n}\n\nexport function configureLoggerFromEnv(): void {\n  const envLogLevel = import.meta.env.VITE_LOG_LEVEL;\n  if (!envLogLevel) return;\n\n  const moduleOverrides: Record<string, LogLevel> = {};\n\n  const parts = envLogLevel.split(',');\n\n  for (const part of parts) {\n    const [module, levelStr] = part.includes(':') ? part.split(':') : ['', part];\n    const level = LogLevel[levelStr.toUpperCase() as keyof typeof LogLevel];\n\n    if (level !== undefined) {\n      if (module) {\n        moduleOverrides[module] = level;\n      } else {\n        globalConfig.defaultLevel = level;\n      }\n    }\n  }\n\n  if (Object.keys(moduleOverrides).length > 0) {\n    globalConfig.moduleOverrides = moduleOverrides;\n  }\n}\n\nexport class Logger implements ILoggerPort {\n  constructor(private moduleName: string) {}\n\n  private getLogLevel(): LogLevel {\n    return globalConfig.moduleOverrides?.[this.moduleName] ?? globalConfig.defaultLevel;\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    return level >= this.getLogLevel();\n  }\n\n  private formatMessage(...args: unknown[]): unknown[] {\n    const timestamp = globalConfig.enableTimestamps\n      ? new Date().toISOString().slice(11, 23) // HH:MM:SS.mmm\n      : '';\n\n    const prefix = timestamp\n      ? `[${timestamp}] [${this.moduleName}]`\n      : `[${this.moduleName}]`;\n\n    return [prefix, ...args];\n  }\n\n  debug(message: string, ...args: unknown[]): void {\n    if (!this.shouldLog(LogLevel.DEBUG)) return;\n\n    const formatted = this.formatMessage(message, ...args);\n    if (globalConfig.enableColors) {\n      console.log(`%c${formatted[0]}`, `color: ${COLORS.DEBUG}`, ...formatted.slice(1));\n    } else {\n      console.log(...formatted);\n    }\n  }\n\n  info(message: string, ...args: unknown[]): void {\n    if (!this.shouldLog(LogLevel.INFO)) return;\n\n    const formatted = this.formatMessage(message, ...args);\n    if (globalConfig.enableColors) {\n      console.info(`%c${formatted[0]}`, `color: ${COLORS.INFO}`, ...formatted.slice(1));\n    } else {\n      console.info(...formatted);\n    }\n  }\n\n  warn(message: string, ...args: unknown[]): void {\n    if (!this.shouldLog(LogLevel.WARN)) return;\n\n    const formatted = this.formatMessage(message, ...args);\n    if (globalConfig.enableColors) {\n      console.warn(`%c${formatted[0]}`, `color: ${COLORS.WARN}`, ...formatted.slice(1));\n    } else {\n      console.warn(...formatted);\n    }\n  }\n\n  error(message: string, ...args: unknown[]): void {\n    if (!this.shouldLog(LogLevel.ERROR)) return;\n\n    const formatted = this.formatMessage(message, ...args);\n    if (globalConfig.enableColors) {\n      console.error(`%c${formatted[0]}`, `color: ${COLORS.ERROR}`, ...formatted.slice(1));\n    } else {\n      console.error(...formatted);\n    }\n  }\n}\n\nexport function createLogger(moduleName: string): Logger {\n  return new Logger(moduleName);\n}\n\n// Initialize from environment on module load\nconfigureLoggerFromEnv();\n","\n\n//\n// This service provides:\n// - WASM module initialization and lifecycle\n// - Spell extraction and verification via WASM FFI\n// - Badge discovery from UTXOs\n// - Transaction scanning with rate limiting\n\nimport type { VeilBadge } from '../domain/types';\nimport type { Network } from '../application/ports';\nimport { createBitcoinService } from './BitcoinService';\nimport { hasVeilBadge, extractVeilBadge, findFirstNftAppSpec } from '../utils/charms';\nimport { createLogger } from '../utils/logger';\n\nconst logger = createLogger('CharmsService');\n\nexport interface CharmsApp {\n  tag: 'n' | 't';\n  identity: string; // hex-encoded 32 bytes\n  vk: string; // hex-encoded 32 bytes\n}\n\nexport interface ParsedSpell {\n  version: number;\n  tx: {\n    ins: string[]; // UTXO IDs: \"txid:vout\"\n    outs: Map<number, unknown>[]; // Output index -> charm data\n  };\n  app_public_inputs: Map<string, unknown>; // App spec string -> public inputs\n}\n\nexport interface CharmOutput {\n  appSpec: string; // \"tag/identity/vk\"\n  data: VeilBadge | number | unknown; // NFT data, token amount, or raw data\n}\n\nexport interface CharmScanResult {\n  hasCharms: boolean;\n  charms: CharmOutput[];\n  rawSpell?: ParsedSpell;\n}\n\nexport interface ICharmsService {\n  /**\n   * Initialize the WASM module\n   */\n  initWasm(wasmPath?: string): Promise<void>;\n\n  /**\n   * Check if WASM is ready\n   */\n  isReady(): boolean;\n\n  /**\n   * Extract and verify a spell from a Bitcoin transaction\n   */\n  extractAndVerifySpell(txHex: string, mock?: boolean): Promise<ParsedSpell | null>;\n\n  /**\n   * Scan a UTXO for badges\n   */\n  scanUtxoForBadge(\n    txid: string,\n    vout: number,\n    veilAppId: string,\n    network: Network\n  ): Promise<VeilBadge | null>;\n\n  /**\n   * Discover badges in multiple UTXOs with rate limiting\n   */\n  discoverBadgesInUtxos(\n    utxos: Array<{ txid: string; vout: number }>,\n    veilAppId: string,\n    network: Network,\n    onProgress?: (current: number, total: number) => void\n  ): Promise<Array<{ txid: string; vout: number; badge: VeilBadge }>>;\n}\n\nlet wasmInitialized = false;\nlet wasmInitPromise: Promise<void> | null = null;\nlet wasmBindings: any = null;\n\n// Cache for spell extraction results (txid -> spell or null)\n// Prevents re-parsing the same transaction multiple times (~500ms each)\nconst spellCache = new Map<string, ParsedSpell | null>();\nconst SPELL_CACHE_MAX_SIZE = 100;\n\nfunction getSpellCacheKey(txHex: string): string {\n  // Use first 64 chars of txHex as cache key (unique enough)\n  return txHex.slice(0, 64);\n}\n\nexport class WasmCharmsService implements ICharmsService {\n  async initWasm(): Promise<void> {\n    if (wasmInitialized) return;\n\n    if (wasmInitPromise) {\n      return wasmInitPromise;\n    }\n\n    wasmInitPromise = (async () => {\n      try {\n        console.log('[CharmsService] Initializing WASM...');\n        \n        const base = import.meta.env.BASE_URL || '/';\n        const jsPath = `${base}wasm/charms_lib.js`;\n        const wasmPath = `${base}wasm/charms_lib_bg.wasm`;\n        \n        console.log('[CharmsService] Loading JS from:', jsPath);\n        console.log('[CharmsService] Loading WASM from:', wasmPath);\n        \n        // Fetch and execute the JS bindings\n        const jsResponse = await fetch(jsPath);\n        if (!jsResponse.ok) throw new Error(`Failed to load ${jsPath}: ${jsResponse.status}`);\n        const jsCode = await jsResponse.text();\n        \n        // Create a blob URL for the JS module\n        const blob = new Blob([jsCode], { type: 'application/javascript' });\n        const blobUrl = URL.createObjectURL(blob);\n        \n        // Import the module\n        const module = await import(/* @vite-ignore */ blobUrl);\n        URL.revokeObjectURL(blobUrl);\n        \n        // Fetch the WASM file\n        const wasmResponse = await fetch(wasmPath);\n        if (!wasmResponse.ok) throw new Error(`Failed to load ${wasmPath}: ${wasmResponse.status}`);\n        const wasmBytes = await wasmResponse.arrayBuffer();\n        \n        // Initialize WASM with the bytes\n        await module.default(wasmBytes);\n        \n        wasmBindings = module;\n        wasmInitialized = true;\n        console.log('[CharmsService] WASM initialized successfully');\n      } catch (error) {\n        wasmInitPromise = null;\n        console.error('[CharmsService] Failed to initialize WASM:', error);\n        throw error;\n      }\n    })();\n\n    return wasmInitPromise;\n  }\n\n  isReady(): boolean {\n    return wasmInitialized;\n  }\n\n  async extractAndVerifySpell(txHex: string, mock = false): Promise<ParsedSpell | null> {\n    if (!wasmBindings) {\n      throw new Error('WASM module not initialized. Call initWasm() first.');\n    }\n\n    // Check cache first\n    const cacheKey = getSpellCacheKey(txHex);\n    if (spellCache.has(cacheKey)) {\n      const cached = spellCache.get(cacheKey);\n      logger.debug('[extractSpell] Cache hit for', txHex.slice(0, 16));\n      return cached ?? null;\n    }\n\n    try {\n      logger.debug('[extractSpell] Attempting extraction, txHex length:', txHex.length, 'first 20 chars:', txHex.slice(0, 20));\n      // WASM expects a tagged union object: { bitcoin: txHex } for Bitcoin transactions\n      const result = wasmBindings.extractAndVerifySpell({ bitcoin: txHex }, mock);\n      logger.debug('[extractSpell] Result:', result ? 'spell found' : 'null');\n      \n      // Cache the result\n      if (spellCache.size >= SPELL_CACHE_MAX_SIZE) {\n        // Evict oldest entry\n        const firstKey = spellCache.keys().next().value;\n        if (firstKey) spellCache.delete(firstKey);\n      }\n      spellCache.set(cacheKey, result as ParsedSpell);\n      \n      return result as ParsedSpell;\n    } catch (error) {\n      // Log ALL errors for debugging\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      logger.debug('[extractSpell] Error:', errorMsg.slice(0, 200));\n      \n      // Cache failures too (e.g., \"no control block\" for non-charms txs)\n      if (spellCache.size >= SPELL_CACHE_MAX_SIZE) {\n        const firstKey = spellCache.keys().next().value;\n        if (firstKey) spellCache.delete(firstKey);\n      }\n      spellCache.set(cacheKey, null);\n      \n      return null;\n    }\n  }\n\n  async scanUtxoForBadge(\n    txid: string,\n    vout: number,\n    veilAppId: string,\n    network: Network\n  ): Promise<VeilBadge | null> {\n    try {\n      // Fetch transaction using BitcoinService\n      const bitcoinService = createBitcoinService('mempool');\n\n      // Fetch the transaction hex\n      const txHex = await bitcoinService.fetchTransaction(txid, network);\n      logger.debug(`[scanUtxo] Scanning ${txid.slice(0,8)}:${vout}`);\n\n      const spell = await this.extractAndVerifySpell(txHex, false);\n      if (!spell) {\n        logger.debug(`[scanUtxo] No spell found in ${txid.slice(0,8)}`);\n        return null;\n      }\n      \n      logger.debug(`[scanUtxo] Spell found! outs=${spell.tx.outs.length}, app_public_inputs keys:`, \n        spell.app_public_inputs ? [...spell.app_public_inputs.keys()] : 'none');\n\n      // Check if this output has a charm for our app\n      const charmData = spell.tx.outs[vout];\n      if (!charmData) {\n        logger.debug(`[scanUtxo] No charm data at vout ${vout}`);\n        return null;\n      }\n      \n      logger.debug(`[scanUtxo] Charm data at vout ${vout}:`, charmData);\n\n      // Verify it's a Veil badge\n      if (!hasVeilBadge(spell, veilAppId)) {\n        logger.debug(`[scanUtxo] hasVeilBadge returned false. Looking for veilAppId=${veilAppId}`);\n        return null;\n      }\n\n      const badge = extractVeilBadge(spell, veilAppId, vout);\n      logger.debug(`[scanUtxo] extractVeilBadge returned:`, badge);\n      return badge;\n    } catch (error) {\n\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      logger.warn('Error scanning UTXO', txid.slice(0, 8), ':', errorMsg.slice(0, 100));\n      return null;\n    }\n  }\n\n  /**\n   * Scan a UTXO for ANY NFT badge (regardless of VK).\n   * Use this when fetching a counterparty's badge that may have been minted with a different VK.\n   */\n  async scanUtxoForAnyBadge(\n    txid: string,\n    vout: number,\n    network: Network\n  ): Promise<VeilBadge | null> {\n    try {\n      const bitcoinService = createBitcoinService('mempool');\n      const txHex = await bitcoinService.fetchTransaction(txid, network);\n      logger.debug(`[scanUtxoAny] Scanning ${txid.slice(0,8)}:${vout}`);\n\n      const spell = await this.extractAndVerifySpell(txHex, false);\n      if (!spell) {\n        logger.debug(`[scanUtxoAny] No spell found in ${txid.slice(0,8)}`);\n        return null;\n      }\n      \n      logger.debug(`[scanUtxoAny] Spell found! outs=${spell.tx.outs.length}, app_public_inputs keys:`, \n        spell.app_public_inputs ? [...spell.app_public_inputs.keys()] : 'none');\n\n      // Find ANY NFT app spec in this spell\n      const nftAppSpec = findFirstNftAppSpec(spell);\n      if (!nftAppSpec) {\n        logger.debug(`[scanUtxoAny] No NFT app found in spell`);\n        return null;\n      }\n      \n      logger.debug(`[scanUtxoAny] Found NFT app: ${nftAppSpec.slice(0, 20)}...`);\n\n      // Extract badge using the found app spec\n      const badge = extractVeilBadge(spell, nftAppSpec, vout);\n      logger.debug(`[scanUtxoAny] extractVeilBadge returned:`, badge);\n      return badge;\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      logger.warn('Error scanning UTXO (any badge)', txid.slice(0, 8), ':', errorMsg.slice(0, 100));\n      return null;\n    }\n  }\n\n  async discoverBadgesInUtxos(\n    utxos: Array<{ txid: string; vout: number }>,\n    veilAppId: string,\n    network: Network,\n    onProgress?: (current: number, total: number) => void\n  ): Promise<Array<{ txid: string; vout: number; badge: VeilBadge }>> {\n    logger.debug(`[discoverBadges] Starting discovery with ${utxos.length} UTXOs, veilAppId=${veilAppId}, network=${network}`);\n    \n    const results: Array<{ txid: string; vout: number; badge: VeilBadge }> = [];\n\n    const BATCH_SIZE = 10;\n\n    const RATE_LIMIT_MS = 100;\n\n    for (let i = 0; i < utxos.length; i += BATCH_SIZE) {\n      const batch = utxos.slice(i, i + BATCH_SIZE);\n\n      // Process batch in parallel\n      const batchResults = await Promise.all(\n        batch.map(async (utxo) => {\n          const badge = await this.scanUtxoForBadge(utxo.txid, utxo.vout, veilAppId, network);\n          return badge ? { ...utxo, badge } : null;\n        })\n      );\n\n      // Add successful results\n      results.push(...batchResults.filter((r): r is { txid: string; vout: number; badge: VeilBadge } => r !== null));\n\n      // Report progress\n      if (onProgress) {\n        onProgress(Math.min(i + BATCH_SIZE, utxos.length), utxos.length);\n      }\n\n      // Rate limiting between batches\n      if (i + BATCH_SIZE < utxos.length) {\n        await new Promise((resolve) => setTimeout(resolve, RATE_LIMIT_MS));\n      }\n    }\n\n    return results;\n  }\n}\n\nexport class MockCharmsService implements ICharmsService {\n  private ready = false;\n\n  async initWasm(): Promise<void> {\n    console.log('[MockCharmsService] Mock WASM initialization');\n    this.ready = true;\n  }\n\n  isReady(): boolean {\n    return this.ready;\n  }\n\n  async extractAndVerifySpell(_txHex: string, _mock?: boolean): Promise<ParsedSpell | null> {\n    console.log('[MockCharmsService] Mock spell extraction');\n    return null;\n  }\n\n  async scanUtxoForBadge(): Promise<VeilBadge | null> {\n    console.log('[MockCharmsService] Mock UTXO scan');\n    return null;\n  }\n\n  async discoverBadgesInUtxos(): Promise<Array<{ txid: string; vout: number; badge: VeilBadge }>> {\n    console.log('[MockCharmsService] Mock badge discovery');\n    return [];\n  }\n}\n\nexport function createCharmsService(mode: 'wasm' | 'mock' = 'wasm'): ICharmsService {\n  if (mode === 'mock') {\n    return new MockCharmsService();\n  }\n  return new WasmCharmsService();\n}\n\n// Default instance for convenience\nexport const charmsService = new WasmCharmsService();\n"],"names":["SimpleCache","defaultTtlMs","key","loader","ttlMs","entry","value","utxoCache","txCache","blockHeightCache","MEMPOOL_ENDPOINTS","MempoolBitcoinService","address","network","cacheKey","baseUrl","response","utxo","txid","txHex","error","_address","createBitcoinService","mode","proxyUrl","decodeRiskFlags","flags","findFirstNftAppSpec","spell","appSpec","parts","hasVeilBadge","veilAppId","targetVk","appParts","extractVeilBadge","outputIndex","outputMap","appIndex","found","charmData","badge","LogLevel","DEFAULT_CONFIG","globalConfig","COLORS","configureLoggerFromEnv","envLogLevel","moduleOverrides","part","module","levelStr","level","Logger","moduleName","args","timestamp","message","formatted","createLogger","logger","wasmInitialized","wasmInitPromise","wasmBindings","spellCache","SPELL_CACHE_MAX_SIZE","getSpellCacheKey","WasmCharmsService","base","jsPath","wasmPath","jsResponse","jsCode","blob","blobUrl","wasmResponse","wasmBytes","mock","cached","result","firstKey","errorMsg","vout","nftAppSpec","utxos","onProgress","results","BATCH_SIZE","RATE_LIMIT_MS","batch","batchResults","r","resolve","charmsService"],"mappings":"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"}