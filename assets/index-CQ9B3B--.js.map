{"version":3,"mappings":";;AAqEY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8JE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA,4BAQN,iBACAA,EAAO,KAAK;AAuCR;AAAA;AAAA;AAAA;AAAA;ACpNH;AAAA;AAAA,YAGGC,EAAO;AAAqB;AAAA;AAAA,gBAGxBC,CAAW;AAAA;AAAA;AAAA;AAAA,kBAIE;AAAA;AACQ;AAAA;AAAA,eAGtBC,EAAM,MAAE;AAAA,6BACK,MAAU;AAAA,mBACnBA;AAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8BAsBb,QAAU;AAAA,uBAChBA,MAAM,OAAW;AAAA;AAAA;AAAA;AAAA;AAAA,iBAKvBC,CAAW;AAAA,mCACW;AAAA,CAEvC,CAEA,eAAsBC,GACpBC,EACAC,MAEA,EAAM,CAAE,QAAAC,EAAS;ACdM;AAAA,kBAEPC,IACE;AAEJ,sBAGF,QAAAC,GAAC,OAAI,UAAU;AClDb;AAAA;AAAA,YAGJC,CAAa,IAAIC,CAAK;AAAA;AACA;AAAA;AAAA;AAAA;AAI8B;AAAA;AAAA,EAG9DC,CAAe;AAAA;AAAA;AAAA,sBAGqB,IAAIC;AAAsB;AAAA;AAAA,EAG9DC,CAAe;AAAA;AAAA;AAAA;AAAA;AAIc;AACJ;AAAA;AAAA,EAGzBC,CAAe;AAAA;AAAA;AAAA,gBAGDC,CAAe;AAAA,YACnBC,QAAe;AAAA;AAAA;AAAA,EAGzBC,CAAe;AAAA;AAAA;AAAA;AAAA;AAAA,yBAKe;AAAA,kBACZ;AAAA;AACM,uBACHC,CAAY;AAAA;AACa,uBACzBC,CAAY;AAAA;AAAA;AAAA;AAGH;AACZ,sBACM;AAAA;AACS;AACa,uBACzBA,MAAY;AAAA,EAGjCrB;AAmH6C,CAAI,CACnD,KAEA,KAASsB","names":["logger","config","genesisUtxo","badge","ownerPubkey","mintBadge","input","ctx","bitcoin","active","jsxs","proposerAppId","appVk","proposerOldYaml","acceptorBadgeUtxo","acceptorOldYaml","proposerNewYaml","acceptorAddress","DUST_LIMIT_SATS","acceptorNewYaml","windowBlocks","currentBlock","serializeVouchesYaml"],"ignoreList":[],"sources":["../../src/services/WalletService.ts","../../src/application/mintBadge.ts","../../src/components/RiskFlags.tsx","../../src/utils/spellGenerator.ts"],"sourcesContent":["\n// WALLET SERVICE - Implements IWalletPort\n\nimport { IWalletPort } from '../application/ports';\nimport { PubKey } from '../types';\nimport { createLogger } from '../utils/logger';\n\nconst logger = createLogger('WalletService');\n\ninterface BitcoinProvider {\n  requestAccounts: () => Promise<string[]>;\n  getPublicKey: () => Promise<string>;\n  signMessage: (message: string) => Promise<string>;\n  signPsbt: (psbtHex: string, options?: any) => Promise<string>;\n  getNetwork?: () => Promise<string>;\n}\n\n// UniSat-specific interface\ninterface UnisatProvider {\n  requestAccounts: () => Promise<string[]>;\n  getAccounts: () => Promise<string[]>;\n  getPublicKey: () => Promise<string>;\n  signMessage: (message: string, type?: string) => Promise<string>;\n  signPsbt: (psbtHex: string, options?: { autoFinalized?: boolean; toSignInputs?: Array<{ index: number; address?: string; publicKey?: string; sighashTypes?: number[] }> }) => Promise<string>;\n  getNetwork: () => Promise<string>;\n  switchNetwork: (network: string) => Promise<void>;\n  getBalance: () => Promise<{ confirmed: number; unconfirmed: number; total: number }>;\n}\n\ninterface XverseProvider {\n  request: (method: string, params?: any) => Promise<any>;\n}\n\ninterface XverseProviders {\n  BitcoinProvider?: XverseProvider;\n}\n\ndeclare global {\n  interface Window {\n    unisat?: UnisatProvider;\n    xverse?: BitcoinProvider;\n    leather?: BitcoinProvider;\n    bitcoin?: BitcoinProvider;\n    XverseProviders?: XverseProviders;\n    BitcoinProvider?: any;\n  }\n}\n\n// UniSat Wallet Adapter - handles UniSat's specific API\nclass UnisatAdapter implements BitcoinProvider {\n  constructor(private unisatProvider: UnisatProvider) {}\n\n  async requestAccounts(): Promise<string[]> {\n    logger.debug('[UnisatAdapter] Requesting accounts...');\n    try {\n      const accounts = await this.unisatProvider.requestAccounts();\n      logger.debug('[UnisatAdapter] Got accounts:', accounts);\n      \n      // UniSat returns Taproot addresses by default when in Taproot mode\n      if (accounts && accounts.length > 0) {\n        const address = accounts[0];\n        logger.info('[UnisatAdapter] Connected address:', address);\n        \n        // Check if it's a Taproot address\n        if (address.startsWith('tb1p') || address.startsWith('bc1p')) {\n          logger.info('[UnisatAdapter] ✅ Taproot address detected - compatible with Charms');\n        } else if (address.startsWith('tb1q') || address.startsWith('bc1q')) {\n          logger.warn('[UnisatAdapter] ⚠️ SegWit address detected. For Charms, switch to Taproot in UniSat settings.');\n          throw new Error(\n            'Charms requires a Taproot address (bc1p.../tb1p...).\\n\\n' +\n            'To switch to Taproot in UniSat:\\n' +\n            '1. Click on your address at the top of UniSat\\n' +\n            '2. Select \"Taproot (P2TR)\" address type\\n' +\n            '3. Reconnect your wallet\\n\\n' +\n            `Current address: ${address}`\n          );\n        }\n      }\n      \n      return accounts;\n    } catch (err) {\n      logger.error('[UnisatAdapter] Failed to get accounts:', err);\n      throw err;\n    }\n  }\n\n  async getPublicKey(): Promise<string> {\n    logger.debug('[UnisatAdapter] Getting public key...');\n    try {\n      const pubkey = await this.unisatProvider.getPublicKey();\n      logger.debug('[UnisatAdapter] Got public key:', pubkey);\n      return pubkey;\n    } catch (err) {\n      logger.error('[UnisatAdapter] Failed to get public key:', err);\n      throw err;\n    }\n  }\n\n  async signMessage(message: string): Promise<string> {\n    logger.debug('[UnisatAdapter] Signing message...');\n    try {\n      // UniSat uses 'bip322-simple' for Taproot signing by default\n      const signature = await this.unisatProvider.signMessage(message, 'bip322-simple');\n      logger.debug('[UnisatAdapter] Message signed');\n      return signature;\n    } catch (err) {\n      logger.error('[UnisatAdapter] Failed to sign message:', err);\n      throw err;\n    }\n  }\n\n  async signPsbt(psbtHex: string, signInputs?: Record<string, number[]>): Promise<string> {\n    logger.debug('[UnisatAdapter] Signing PSBT...', {\n      psbtLength: psbtHex.length,\n      signInputs: signInputs || 'all inputs',\n    });\n    \n    try {\n      // UniSat expects hex format for PSBT\n      // Convert from base64 to hex if needed\n      let psbtToSign = psbtHex;\n      \n      // Check if it's base64 (contains non-hex chars or ends with =)\n      if (!/^[0-9a-fA-F]+$/.test(psbtHex)) {\n        logger.debug('[UnisatAdapter] Converting PSBT from base64 to hex');\n        const binary = atob(psbtHex);\n        psbtToSign = Array.from(binary, (char) => char.charCodeAt(0).toString(16).padStart(2, '0')).join('');\n      }\n      \n      // Build UniSat-specific options\n      const options: any = {\n        autoFinalized: false, // Don't auto-finalize so we can control the process\n      };\n      \n      // If specific inputs are specified, convert to UniSat format\n      if (signInputs) {\n        const toSignInputs: Array<{ index: number; address?: string }> = [];\n        for (const [address, indexes] of Object.entries(signInputs)) {\n          for (const index of indexes) {\n            toSignInputs.push({ index, address });\n          }\n        }\n        if (toSignInputs.length > 0) {\n          options.toSignInputs = toSignInputs;\n        }\n      }\n      \n      logger.debug('[UnisatAdapter] Calling signPsbt with options:', options);\n      const signedPsbtHex = await this.unisatProvider.signPsbt(psbtToSign, options);\n      logger.debug('[UnisatAdapter] PSBT signed, length:', signedPsbtHex.length);\n      \n      // UniSat returns hex, but our code expects base64\n      // Convert back to base64\n      const bytes = new Uint8Array(signedPsbtHex.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16)));\n      const base64 = btoa(String.fromCharCode(...bytes));\n      \n      logger.debug('[UnisatAdapter] Converted signed PSBT to base64');\n      return base64;\n    } catch (err) {\n      logger.error('[UnisatAdapter] Failed to sign PSBT:', err);\n      throw err;\n    }\n  }\n\n  async getNetwork(): Promise<string> {\n    try {\n      return await this.unisatProvider.getNetwork();\n    } catch {\n      return 'unknown';\n    }\n  }\n}\n\nclass XverseAdapter implements BitcoinProvider {\n  constructor(private xverseProvider: any) {}\n\n  async requestAccounts(): Promise<string[]> {\n    logger.debug('[XverseAdapter] Requesting accounts with wallet_requestPermissions...');\n    try {\n      // First, request permissions/connection\n      logger.debug('[XverseAdapter] Calling wallet_requestPermissions...');\n      const permissionResponse = await this.xverseProvider.request('wallet_requestPermissions');\n      logger.debug('[XverseAdapter] Permission response:', permissionResponse);\n\n      // Then get addresses\n      logger.debug('[XverseAdapter] Calling getAddresses...');\n      const response = await this.xverseProvider.request('getAddresses', {\n        purposes: ['payment', 'ordinals'],\n      });\n      logger.debug('[XverseAdapter] getAddresses response:', response);\n\n      // Check for error in response\n      if (response?.error) {\n        throw new Error(`Xverse error: ${response.error.message}`);\n      }\n\n      // Extract addresses from the result\n      // Prefer ordinals (Taproot) address for Charms compatibility\n      if (response?.result?.addresses && Array.isArray(response.result.addresses)) {\n        // Log all addresses for debugging\n        response.result.addresses.forEach((addr: any, i: number) => {\n          logger.debug(`[XverseAdapter] Address ${i}:`, {\n            address: addr.address,\n            purpose: addr.purpose,\n            addressType: addr.addressType,\n          });\n        });\n        \n        // Find the ordinals/Taproot address (tb1p...) - needed for Charms\n        const ordinalsAddr = response.result.addresses.find(\n          (addr: any) => addr.purpose === 'ordinals' || addr.address?.startsWith('tb1p') || addr.address?.startsWith('bc1p')\n        );\n        \n        // For Charms, we NEED a Taproot address - fail if not found\n        if (!ordinalsAddr) {\n          logger.error('[XverseAdapter] ⚠️ NO TAPROOT ADDRESS FOUND!');\n          logger.error('[XverseAdapter] Charms requires a Taproot (bc1p.../tb1p...) address');\n          logger.error('[XverseAdapter] Available addresses:', response.result.addresses.map((a: any) => a.address));\n          \n          // Provide clear instructions based on what we received\n          const availableAddrs = response.result.addresses.map((a: any) => a.address).join(', ');\n          const hasPaymentOnly = response.result.addresses.every(\n            (a: any) => a.address?.startsWith('tb1q') || a.address?.startsWith('bc1q')\n          );\n          \n          if (hasPaymentOnly) {\n            throw new Error(\n              'Charms requires a Taproot (bc1p.../tb1p...) address, but your wallet only provided SegWit addresses.\\n\\n' +\n              'To enable Taproot addresses in Xverse:\\n' +\n              '1. Open Xverse wallet settings\\n' +\n              '2. Enable \"Bitcoin\" and \"Ordinals & BRC-20\"\\n' +\n              '3. Disconnect and reconnect your wallet\\n\\n' +\n              `Current addresses: ${availableAddrs}`\n            );\n          } else {\n            throw new Error(\n              'No Taproot address found. Charms requires a Taproot (bc1p.../tb1p...) address.\\n\\n' +\n              'Please ensure your wallet supports Taproot/Ordinals and try reconnecting.\\n\\n' +\n              `Available addresses: ${availableAddrs}`\n            );\n          }\n        }\n        \n        // Use the ordinals/Taproot address\n        const selectedAddr = ordinalsAddr;\n        logger.info('[XverseAdapter] ✅ Using ordinals/Taproot address for Charms:', selectedAddr.address);\n        \n        return [selectedAddr.address];\n      }\n\n      // Fallback for different response format\n      if (Array.isArray(response)) {\n        return response.map((account: any) => account.address || account);\n      }\n\n      logger.error('[XverseAdapter] Unexpected response format:', response);\n      throw new Error('Unexpected response format from Xverse wallet');\n    } catch (err) {\n      logger.error('[XverseAdapter] Failed to get accounts:', err);\n      throw err;\n    }\n  }\n\n  async getPublicKey(): Promise<string> {\n    logger.debug('[XverseAdapter] Getting public key...');\n    try {\n      const response = await this.xverseProvider.request('getAddresses', {\n        purposes: ['payment', 'ordinals'],\n      });\n      logger.debug('[XverseAdapter] getAddresses for pubkey:', response);\n\n      if (response?.error) {\n        throw new Error(`Xverse error: ${response.error.message}`);\n      }\n\n      if (response?.result?.addresses && Array.isArray(response.result.addresses)) {\n        // Use ordinals/Taproot address's pubkey for Charms compatibility\n        const ordinalsAddr = response.result.addresses.find(\n          (addr: any) => addr.purpose === 'ordinals' || addr.address?.startsWith('tb1p') || addr.address?.startsWith('bc1p')\n        );\n        \n        // For Charms, we NEED a Taproot pubkey - fail if not found\n        if (!ordinalsAddr) {\n          throw new Error(\n            'Charms requires a Taproot (bc1p.../tb1p...) address, but your wallet only provided SegWit addresses.\\n\\n' +\n            'To enable Taproot addresses in Xverse:\\n' +\n            '1. Open Xverse wallet settings\\n' +\n            '2. Enable \"Bitcoin\" and \"Ordinals & BRC-20\"\\n' +\n            '3. Disconnect and reconnect your wallet'\n          );\n        }\n        \n        const pubkey = ordinalsAddr.publicKey || ordinalsAddr.pubkey;\n        logger.debug('[XverseAdapter] Extracted pubkey from ordinals address:', {\n          purpose: ordinalsAddr.purpose,\n          address: ordinalsAddr.address,\n          pubkey,\n        });\n        return pubkey;\n      }\n\n      if (Array.isArray(response)) {\n        return response[0].publicKey || response[0].pubkey;\n      }\n\n      throw new Error('Could not extract public key from response');\n    } catch (err) {\n      logger.error('[XverseAdapter] Failed to get public key:', err);\n      throw err;\n    }\n  }\n\n  async signMessage(message: string): Promise<string> {\n    const response = await this.xverseProvider.request('signMessage', {\n      message,\n      address: '' // Will need to be filled in with current address\n    });\n\n    if (response?.error) {\n      throw new Error(`Xverse error: ${response.error.message}`);\n    }\n\n    return response?.result?.signature || response?.signature || response;\n  }\n\n  async signPsbt(psbtBase64: string, signInputs?: Record<string, number[]>): Promise<string> {\n    logger.debug('[XverseAdapter] Signing PSBT:', {\n      psbtLength: psbtBase64.length,\n      signInputs: signInputs || 'all inputs',\n    });\n    \n    const requestParams: any = {\n      psbt: psbtBase64,\n      broadcast: false,\n    };\n    \n    // If signInputs is specified, only sign those specific inputs\n    // This is critical for spell transactions where we must preserve the prover's witness\n    if (signInputs) {\n      requestParams.signInputs = signInputs;\n    }\n    \n    const response = await this.xverseProvider.request('signPsbt', requestParams);\n\n    if (response?.error) {\n      throw new Error(`Xverse error: ${response.error.message}`);\n    }\n\n    return response?.result?.psbt || response?.psbt || response;\n  }\n}\n\nexport class BrowserWalletService implements IWalletPort {\n  private provider: BitcoinProvider | null = null;\n  private currentAddress: string | null = null;\n  private currentPubkey: PubKey | null = null;\n\n  /**\n   * Connect to a browser wallet (Unisat, Xverse, Leather, etc.).\n   *\n   * @returns Address and pubkey from the connected wallet\n   * @throws Error if no wallet found or connection fails\n   */\n  async connect(): Promise<{ address: string; pubkey: PubKey }> {\n    const provider = this.getProvider();\n    if (!provider) {\n      throw new Error(\n        'No Bitcoin wallet found. Please install Unisat, Xverse, or Leather.'\n      );\n    }\n\n    const accounts = await provider.requestAccounts();\n    if (!accounts || accounts.length === 0) {\n      throw new Error('No accounts returned from wallet');\n    }\n\n    const address = accounts[0];\n    const pubkey = await provider.getPublicKey();\n\n    this.provider = provider;\n    this.currentAddress = address;\n    this.currentPubkey = pubkey;\n\n    return { address, pubkey };\n  }\n\n  /**\n   * Disconnect from the wallet.\n   */\n  disconnect(): void {\n    this.provider = null;\n    this.currentAddress = null;\n    this.currentPubkey = null;\n  }\n\n  /**\n   * Sign a message with the wallet's private key.\n   *\n   * @param message - Message to sign\n   * @returns Signature as hex string\n   * @throws Error if wallet not connected\n   */\n  async signMessage(message: string): Promise<string> {\n    // Auto-connect if not connected\n    if (!this.provider) {\n      logger.debug('[WalletService] Auto-connecting before signMessage...');\n      await this.connect();\n    }\n    if (!this.provider) {\n      throw new Error('Wallet not connected');\n    }\n    return this.provider.signMessage(message);\n  }\n\n  /**\n   * Sign a PSBT (Partially Signed Bitcoin Transaction).\n   *\n   * @param psbtBase64 - PSBT in base64 format\n   * @param signInputs - Optional: map of address -> input indexes to sign.\n   *                     If not provided, all inputs will be signed.\n   *                     Use this to selectively sign specific inputs while\n   *                     preserving existing witnesses on other inputs.\n   * @returns Signed PSBT in base64 format\n   * @throws Error if wallet not connected or doesn't support PSBT signing\n   */\n  async signPsbt(psbtBase64: string, signInputs?: Record<string, number[]>): Promise<string> {\n    // Auto-connect if not connected\n    if (!this.provider) {\n      logger.debug('[WalletService] Auto-connecting before signPsbt...');\n      await this.connect();\n    }\n    if (!this.provider) {\n      throw new Error('Wallet not connected');\n    }\n    if (!this.provider.signPsbt) {\n      throw new Error('Wallet does not support PSBT signing');\n    }\n    // Pass through signInputs if the provider supports it (XverseAdapter does)\n    return (this.provider as any).signPsbt(psbtBase64, signInputs);\n  }\n\n  /**\n   * Get the current public key.\n   *\n   * @returns Public key as hex string\n   * @throws Error if wallet not connected\n   */\n  async getPublicKey(): Promise<PubKey> {\n    // Auto-connect if not connected\n    if (!this.currentPubkey) {\n      logger.debug('[WalletService] Auto-connecting before getPublicKey...');\n      await this.connect();\n    }\n    if (!this.currentPubkey) {\n      throw new Error('Wallet not connected');\n    }\n    return this.currentPubkey;\n  }\n\n  /**\n   * Check if wallet is currently connected.\n   */\n  isConnected(): boolean {\n    return this.provider !== null && this.currentAddress !== null;\n  }\n\n  /**\n   * Get the first available Bitcoin wallet provider.\n   *\n   * @returns Provider or null if none found\n   */\n  private getProvider(): BitcoinProvider | null {\n    if (typeof window === 'undefined') return null;\n\n    // Debug: Log what wallet providers are available\n    logger.debug('[WalletService] Checking for wallet providers:', {\n      unisat: !!window.unisat,\n      xverse: !!window.xverse,\n      leather: !!window.leather,\n      bitcoin: !!window.bitcoin,\n      // Check for alternative Xverse API locations\n      XverseProviders: !!window.XverseProviders,\n      BitcoinProvider: !!window.BitcoinProvider,\n    });\n\n    if (window.unisat) {\n      logger.debug('[WalletService] Using Unisat wallet');\n      return new UnisatAdapter(window.unisat);\n    }\n\n    // Try Xverse - might be under different property\n    if (window.xverse) {\n      logger.debug('[WalletService] Using Xverse wallet (window.xverse)');\n      return window.xverse;\n    }\n\n    // Xverse also exposes via XverseProviders.BitcoinProvider\n    if (window.XverseProviders?.BitcoinProvider) {\n      logger.debug('[WalletService] Using Xverse wallet (XverseProviders)');\n      logger.debug('[WalletService] XverseProviders object:', window.XverseProviders);\n      logger.debug('[WalletService] BitcoinProvider object:', window.XverseProviders.BitcoinProvider);\n      return new XverseAdapter(window.XverseProviders.BitcoinProvider);\n    }\n\n    if (window.leather) {\n      logger.debug('[WalletService] Using Leather wallet');\n      return window.leather;\n    }\n\n    if (window.bitcoin) {\n      logger.debug('[WalletService] Using generic bitcoin provider');\n      return window.bitcoin;\n    }\n\n    logger.error('[WalletService] No Bitcoin wallet provider found');\n    return null;\n  }\n}\n\nexport class MockWalletService implements IWalletPort {\n  private connected = false;\n  private readonly mockAddress = 'tb1qw508d6qejxtdg4y5r3zarvary0c5xw7kxpjzsx';\n  private readonly mockPubkey: PubKey = '0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798';\n\n  async connect(): Promise<{ address: string; pubkey: PubKey }> {\n    this.connected = true;\n    return { address: this.mockAddress, pubkey: this.mockPubkey };\n  }\n\n  disconnect(): void {\n    this.connected = false;\n  }\n\n  async signMessage(message: string): Promise<string> {\n    if (!this.connected) {\n      throw new Error('Wallet not connected');\n    }\n\n    return `mock_signature_${message.slice(0, 16)}`;\n  }\n\n  async signPsbt(psbtHex: string): Promise<string> {\n    if (!this.connected) {\n      throw new Error('Wallet not connected');\n    }\n\n    return psbtHex;\n  }\n\n  async getPublicKey(): Promise<PubKey> {\n    if (!this.connected) {\n      throw new Error('Wallet not connected');\n    }\n    return this.mockPubkey;\n  }\n\n  isConnected(): boolean {\n    return this.connected;\n  }\n}\n\nexport function createWalletService(mode: 'browser' | 'mock' = 'browser'): IWalletPort {\n  return mode === 'mock' ? new MockWalletService() : new BrowserWalletService();\n}\n","\n\n// Orchestrates the badge minting flow:\n// 1. Validate inputs\n// 2. Select funding UTXO\n// 3. Generate badge ID\n// 4. Build spell\n// 5. Get ZK proof\n// 6. Sign and broadcast\n//\n\nimport {\n  VeilBadge,\n  createNewBadge,\n  validateMint,\n  validateFundingUtxo,\n  CONSTANTS,\n  selectFundingUtxo,\n  VEIL_APP_VK,\n} from '../domain';\nimport {\n  UseCaseContext,\n  UseCaseResult,\n} from './ports';\nimport { createLogger } from '../utils/logger';\nimport {\n  signCommitTransaction,\n  signSpellTransaction,\n} from '../services/TransactionSigningService';\nimport {\n  hasSeedPhrase,\n  getPrimaryAddress,\n} from '../services/TaprootKeyService';\n\nconst logger = createLogger('mintBadge');\n\nexport interface MintBadgeInput {\n  address: string;\n  pubkey: string;\n}\n\nexport interface MintBadgeOutput {\n  badge: VeilBadge;\n  txid: string;\n  commitTxid?: string;\n}\n\ninterface SpellConfig {\n  appId: string;\n  appVk: string;\n}\n\n// Default Veil app configuration\n\nconst VEIL_APP_CONFIG: SpellConfig = {\n  appId: '0'.repeat(64), // Overridden with SHA256(genesisUtxo) during minting\n  appVk: VEIL_APP_VK, // Real verification key from compiled app\n};\n\nfunction buildMintSpellYaml(\n  genesisUtxo: string,\n  outputAddress: string,\n  ownerPubkey: string,\n  badge: VeilBadge,\n  config: SpellConfig = VEIL_APP_CONFIG\n): string {\n\n  // isolated = 0b00000100 = 4\n  // new_badge = 0b00100000 = 32\n  // isolated + new_badge = 36\n  const flagsBits = 0b00100100; // NEW_BADGE | ISOLATED for new badges\n\n  return `version: 8\n\napps:\n  $00: \"n/${config.appId}/${config.appVk}\"\n\nins:\n  - utxo_id: \"${genesisUtxo}\"\n    charms: {}\n\nouts:\n  - address: \"${outputAddress}\"\n    sats: ${CONSTANTS.DUST_LIMIT_SATS}\n    charms:\n      $00:\n        id: \"${badge.id}\"\n        created_at: ${badge.created_at}\n        pubkey: \"${badge.pubkey}\"\n        tx_total: 0\n        tx_positive: 0\n        tx_negative: 0\n        volume_total: 0\n        volume_sum_squares: 0\n        window_tx_count: 0\n        window_volume: 0\n        window_start: ${badge.window_start}\n        counterparty_count: 0\n        backing:\n          backed_count: 0\n          unbacked_count: 0\n          backed_volume: 0\n          unbacked_volume: 0\n        vouches_out: []\n        vouches_in: []\n        cascade_damage: 0\n        active_transactions: []\n        reporting_transactions: []\n        outcomes:\n          mutual_positive: 0\n          mutual_negative: 0\n          contested_i_positive: 0\n          contested_i_negative: 0\n          timeout: 0\n          mutual_timeout: 0\n        trust: 15\n        risk: 35\n        flags: ${flagsBits}\n        last_nonce: \"${badge.last_nonce}\"\n        last_update: ${badge.last_update}\n\npublic_args:\n  $00:\n    Mint:\n      pubkey: \"${ownerPubkey}\"\n      current_block: ${badge.created_at}\n`;\n}\n\nexport async function mintBadge(\n  input: MintBadgeInput,\n  ctx: UseCaseContext\n): Promise<UseCaseResult<MintBadgeOutput>> {\n  const { bitcoin, prover, storage, crypto, network, onProgress } = ctx;\n  const progress = onProgress || (() => {});\n  \n  try {\n    // ========================================================================\n    // STEP 1: Validate inputs\n    // ========================================================================\n    progress('Validating inputs...');\n    \n    const mintValidation = validateMint(input.address, input.pubkey);\n    if (!mintValidation.valid) {\n      return {\n        success: false,\n        error: `Validation failed: ${mintValidation.errors.join(', ')}`,\n      };\n    }\n    \n    // ========================================================================\n    // STEP 2: Fetch UTXOs and select genesis + funding UTXOs\n    // ========================================================================\n    progress('Fetching UTXOs...');\n\n    // Use seed phrase address for UTXOs if available\n    let fundingAddress = input.address;\n    if (hasSeedPhrase()) {\n      const seedAddress = await getPrimaryAddress(\n        localStorage.getItem('veil_seed_phrase')!,\n        network === 'testnet4'\n      );\n      logger.info(`Using seed phrase address for UTXOs: ${seedAddress}`);\n      fundingAddress = seedAddress;\n    }\n\n    const utxos = await bitcoin.fetchUtxos(fundingAddress, network);\n\n    // Get list of burned UTXOs (already sent to prover, can't be reused)\n    // The Charms prover caches requests by funding UTXO\n    const burnedUtxos = storage.getBurnedUtxos?.() ?? [];\n    const burnedUtxoIds = burnedUtxos.map(u => u.utxoId);\n    \n    if (burnedUtxoIds.length > 0) {\n      logger.info(`Filtering out ${burnedUtxoIds.length} burned UTXOs from prover cache`);\n    }\n\n    // For minting, we need TWO separate UTXOs:\n    // 1. Genesis UTXO - consumed by spell input, becomes the NFT identity\n    // 2. Funding UTXO - separate plain BTC UTXO to pay transaction fees\n    // \n    // Filter out burned UTXOs first, then sort by value ascending\n    const availableUtxos = utxos.filter(utxo => {\n      const utxoId = `${utxo.txid}:${utxo.vout}`;\n      return !burnedUtxoIds.includes(utxoId);\n    });\n    \n    const sortedUtxos = [...availableUtxos].sort((a, b) => a.value - b.value);\n    \n    // Need at least 2 UTXOs\n    if (sortedUtxos.length < 2) {\n      const burnedMsg = burnedUtxoIds.length > 0 \n        ? ` (${burnedUtxoIds.length} UTXOs are burned from previous prover attempts - they expire after 24h)`\n        : '';\n      return {\n        success: false,\n        error: `Need at least 2 available UTXOs for minting: one for genesis (spell input) and one for funding (fees). Found ${sortedUtxos.length}.${burnedMsg}`,\n      };\n    }\n\n    // Use smallest UTXO as genesis (just needs to exist, value doesn't matter much)\n    const genesisUtxoInfo = sortedUtxos[0];\n    \n    // Find a funding UTXO from remaining UTXOs (needs enough value for fees)\n    const remainingUtxos = sortedUtxos.slice(1);\n    const fundingUtxo = selectFundingUtxo(remainingUtxos, undefined, CONSTANTS.MIN_FUNDING_SATS, burnedUtxoIds);\n    if (!fundingUtxo) {\n      return {\n        success: false,\n        error: `No suitable funding UTXO found. Need at least ${CONSTANTS.MIN_FUNDING_SATS} sats (excluding genesis UTXO and burned UTXOs).`,\n      };\n    }\n    \n    const utxoValidation = validateFundingUtxo(fundingUtxo);\n    if (!utxoValidation.valid) {\n      return {\n        success: false,\n        error: utxoValidation.errors.join(', '),\n      };\n    }\n    \n    // ========================================================================\n    // STEP 3: Generate badge ID and app ID from genesis UTXO\n    // ========================================================================\n    progress('Generating badge ID...');\n\n    // Genesis UTXO is the spell input - its hash becomes the NFT/badge identity\n    const genesisUtxo = `${genesisUtxoInfo.txid}:${genesisUtxoInfo.vout}`;\n    const badgeId = await crypto.generateBadgeId(genesisUtxo);\n\n    const appId = await crypto.sha256Hex(genesisUtxo);\n\n    // ========================================================================\n    // STEP 4: Get current block height\n    // ========================================================================\n    progress('Getting current block height...');\n\n    const currentBlock = await bitcoin.getCurrentBlockHeight(network);\n\n    // ========================================================================\n\n    // ========================================================================\n    progress('Creating badge...');\n\n    const newBadge = createNewBadge(badgeId, input.pubkey, currentBlock);\n\n    // ========================================================================\n    // STEP 6: Build the spell with generated app ID\n    // ========================================================================\n    progress('Building spell...');\n\n    const spellYaml = buildMintSpellYaml(\n      genesisUtxo,\n      input.address,\n      input.pubkey,\n      newBadge,\n      {\n        appId,\n        appVk: VEIL_APP_VK, // Use real verification key from compiled app\n      }\n    );\n    \n    // ========================================================================\n\n    // ========================================================================\n    progress('Fetching previous transactions...');\n    \n    // Need prev_txs for the genesis UTXO (spell input) to verify ownership\n    // The funding UTXO doesn't need to be in prev_txs - it's handled separately by the prover\n    const genesisPrevTxHex = await bitcoin.fetchTransaction(genesisUtxoInfo.txid, network);\n    \n    // ========================================================================\n    // STEP 8: Generate ZK proof\n    // ========================================================================\n    progress('Generating ZK proof...');\n\n    const proverAvailable = await prover.isAvailable();\n    if (!proverAvailable) {\n      return {\n        success: false,\n        error: 'Prover service is not available',\n      };\n    }\n\n    // Mark both genesis and funding UTXOs as burned BEFORE calling prover\n    // The Charms prover caches requests by UTXO - once sent, they can't be reused\n    // even if the transaction fails or user cancels signing\n    const fundingUtxoId = `${fundingUtxo.txid}:${fundingUtxo.vout}`;\n    if (storage.addBurnedUtxo) {\n      storage.addBurnedUtxo(genesisUtxo);\n      storage.addBurnedUtxo(fundingUtxoId);\n      logger.info(`Marked UTXOs as burned before prover call: genesis=${genesisUtxo}, funding=${fundingUtxoId}`);\n    }\n\n    // Convert compressed pubkey (33 bytes) to x-only pubkey (32 bytes) for Taproot\n    // Compressed pubkeys start with 02 or 03, x-only removes this prefix\n    let signingPubkey: string | undefined;\n    if (input.pubkey && input.pubkey.length === 66) {\n      // Remove the 02/03 prefix to get x-only pubkey\n      signingPubkey = input.pubkey.slice(2);\n      logger.info('Converted compressed pubkey to x-only for Taproot:', {\n        compressedPubkey: input.pubkey.substring(0, 10) + '...',\n        xOnlyPubkey: signingPubkey.substring(0, 10) + '...',\n      });\n    } else if (input.pubkey && input.pubkey.length === 64) {\n      // Already x-only format\n      signingPubkey = input.pubkey;\n      logger.info('Pubkey already in x-only format');\n    }\n\n    const proofResult = await prover.prove({\n      spellYaml,\n      prevTxs: [genesisPrevTxHex], // prev_txs for the spell input (genesis UTXO)\n      fundingUtxo: { txid: fundingUtxo.txid, vout: fundingUtxo.vout },\n      fundingUtxoValue: fundingUtxo.value,\n      changeAddress: input.address,\n      feeRate: 2.0,\n      signingPubkey, // Pass x-only pubkey for Taproot commit address derivation\n    });\n    \n    if (!proofResult.success || !proofResult.spellTx) {\n      let errorMsg = `Proof generation failed: ${proofResult.error || 'Unknown error'}`;\n      \n      // Check for duplicate UTXO error - this means the prover has cached these UTXOs\n      if (proofResult.error?.includes('duplicate funding UTXO')) {\n        errorMsg = 'These UTXOs have already been used in a previous prover request. ' +\n          'The Charms prover caches requests for ~24 hours. ' +\n          'Please wait for more UTXOs or try again later.';\n      }\n      \n      logger.error('Mint badge proof generation failed:', {\n        error: proofResult.error,\n        spellYaml: spellYaml.substring(0, 500), // Log first 500 chars of spell\n        genesisUtxo,\n        fundingUtxo,\n        changeAddress: input.address,\n      });\n      \n      return {\n        success: false,\n        error: errorMsg,\n      };\n    }\n    \n    // ========================================================================\n    // STEP 9: Sign and Broadcast transactions\n    // ========================================================================\n    // The Charms prover returns UNSIGNED transactions that must be signed\n    // by the wallet before broadcasting.\n    // See: https://docs.charms.dev/guides/wallet-integration/transactions/signing/\n    // ========================================================================\n    progress('Preparing transactions for signing...');\n\n    let commitTxid: string | undefined;\n    let spellTxid: string;\n\n    // Validate transactions before processing\n    logger.info('Proof result transactions:', {\n      hasCommitTx: !!proofResult.commitTx,\n      commitTxLength: proofResult.commitTx?.length || 0,\n      hasSpellTx: !!proofResult.spellTx,\n      spellTxLength: proofResult.spellTx?.length || 0,\n    });\n\n    if (proofResult.isMock) {\n      // Mock mode: Skip signing and broadcast, generate fake txids\n      progress('Mock mode: Simulating broadcast...');\n      commitTxid = proofResult.commitTx ? '0000000000000000000000000000000000000000000000000000000000000000' : undefined;\n      spellTxid = '1111111111111111111111111111111111111111111111111111111111111111';\n      progress(`Mock TX: ${spellTxid.slice(0, 8)}...`);\n    } else {\n      // ========================================================================\n      // SEED PHRASE SIGNING: Use seed phrase-derived Taproot keys\n      // ========================================================================\n      // This approach uses BIP-86 Taproot key derivation:\n      // 1. Store seed phrase locally (user imports it)\n      // 2. Derive Taproot keys using BIP-86 path\n      // 3. Find which derived address matches each UTXO script\n      // 4. Sign with the corresponding tweaked private key\n      // ========================================================================\n      \n      // Check if user has imported a seed phrase\n      if (!hasSeedPhrase()) {\n        return {\n          success: false,\n          error: 'No seed phrase found. Please import your seed phrase in Settings to enable transaction signing.',\n        };\n      }\n      \n      const isTestnet = network !== 'mainnet';\n      \n      // STEP 9a: Sign and broadcast commit transaction\n      if (proofResult.commitTx && proofResult.commitTx.length > 0) {\n        // Validate it looks like a valid hex transaction\n        if (!/^[0-9a-fA-F]+$/.test(proofResult.commitTx)) {\n          return {\n            success: false,\n            error: `Invalid commit transaction format (not hex): ${proofResult.commitTx.substring(0, 50)}...`,\n          };\n        }\n        \n        progress('Signing commit transaction...');\n        \n        try {\n          // The commit transaction spends the funding UTXO\n          // We need the funding transaction hex to derive the correct signing key\n          const fundingTxHex = await bitcoin.fetchTransaction(fundingUtxo.txid, network);\n          \n          const commitResult = await signCommitTransaction(\n            proofResult.commitTx,\n            fundingTxHex,\n            isTestnet\n          );\n          \n          logger.info('Commit transaction signed:', {\n            txid: commitResult.txid,\n            signedHexLength: commitResult.signedHex.length,\n          });\n          \n          // Broadcast the signed commit transaction\n          progress('Broadcasting commit transaction...');\n          commitTxid = await bitcoin.broadcast(commitResult.signedHex, network);\n          progress(`Commit TX: ${commitTxid.slice(0, 8)}...`);\n          \n        } catch (signError) {\n          const errorMsg = signError instanceof Error ? signError.message : String(signError);\n          logger.error('Failed to sign commit transaction:', {\n            error: errorMsg,\n            fundingUtxo,\n          });\n          return {\n            success: false,\n            error: `Failed to sign commit transaction: ${errorMsg}`,\n          };\n        }\n\n        // CRITICAL: Add delay to ensure commit TX propagates before spell TX\n        progress('Waiting for commit TX to propagate...');\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n      \n      // STEP 9b: Sign and broadcast spell transaction\n      if (!proofResult.spellTx || proofResult.spellTx.length === 0) {\n        return {\n          success: false,\n          error: 'Prover returned empty spell transaction',\n        };\n      }\n      \n      if (!/^[0-9a-fA-F]+$/.test(proofResult.spellTx)) {\n        return {\n          success: false,\n          error: `Invalid spell transaction format (not hex): ${proofResult.spellTx.substring(0, 50)}...`,\n        };\n      }\n      \n      progress('Signing spell transaction...');\n      \n      try {\n        // Get the signed commit transaction hex\n        const signedCommitTxHex = await bitcoin.fetchTransaction(commitTxid!, network);\n        \n        // Collect all previous transactions that the spell TX might spend\n        // This includes genesis UTXO and funding UTXO transactions\n        const prevTxsHex: string[] = [];\n        \n        // Add genesis TX\n        const genesisTxHex = await bitcoin.fetchTransaction(genesisUtxoInfo.txid, network);\n        prevTxsHex.push(genesisTxHex);\n        \n        // Add funding TX if different from genesis\n        if (fundingUtxo.txid !== genesisUtxoInfo.txid) {\n          const fundingTxHex = await bitcoin.fetchTransaction(fundingUtxo.txid, network);\n          prevTxsHex.push(fundingTxHex);\n        }\n        \n        logger.info('Passing prev TXs to spell signing:', {\n          count: prevTxsHex.length,\n          genesisTxid: genesisUtxoInfo.txid,\n          fundingTxid: fundingUtxo.txid,\n        });\n        \n        const spellResult = await signSpellTransaction(\n          proofResult.spellTx,\n          signedCommitTxHex,\n          prevTxsHex,\n          isTestnet\n        );\n        \n        logger.info('Spell transaction signed:', {\n          txid: spellResult.txid,\n          signedHexLength: spellResult.signedHex.length,\n        });\n        \n        // Broadcast the signed spell transaction\n        progress('Broadcasting spell transaction...');\n        spellTxid = await bitcoin.broadcast(spellResult.signedHex, network);\n        progress(`Spell TX: ${spellTxid.slice(0, 8)}...`);\n        \n      } catch (signError) {\n        const errorMsg = signError instanceof Error ? signError.message : String(signError);\n        logger.error('Failed to sign spell transaction:', {\n          error: errorMsg,\n          stack: signError instanceof Error ? signError.stack : undefined,\n        });\n        return {\n          success: false,\n          error: `Failed to sign spell transaction: ${errorMsg}`,\n        };\n      }\n    }\n    \n    // ========================================================================\n    // STEP 10: Add UTXO info to badge and persist to storage\n    // ========================================================================\n    progress('Finalizing badge...');\n    \n    // Store the UTXO where this badge lives (spell tx output 0)\n    newBadge.utxo = {\n      txid: spellTxid,\n      vout: 0, // Badge is always at output 0 in spell tx\n      value: CONSTANTS.DUST_LIMIT_SATS, // Store the actual value for localStorage persistence\n    };\n    \n    // Note: Badge persistence is handled by the calling code (useWallet hook)\n    \n    // ========================================================================\n    // SUCCESS\n    // ========================================================================\n    progress('Badge minted successfully!');\n    \n    return {\n      success: true,\n      data: {\n        badge: newBadge,\n        txid: spellTxid,\n        commitTxid,\n      },\n    };\n    \n  } catch (error) {\n    const message = error instanceof Error ? error.message : 'Unknown error';\n    return {\n      success: false,\n      error: message,\n    };\n  }\n}\n","import React from 'react';\nimport {\n  AlertTriangle,\n  TrendingUp,\n  Wallet,\n  Users,\n  Sparkles,\n  Activity,\n  Clock\n} from 'lucide-react';\nimport { RiskFlags as RiskFlagsType, RISK_WEIGHTS } from '../types';\nimport { getRiskLevel } from '../utils/formatting';\n\ninterface RiskFlagsProps {\n  flags: RiskFlagsType;\n  risk: number;\n  compact?: boolean;\n}\n\nconst flagConfig = {\n  acceleration: {\n    icon: TrendingUp,\n    label: 'Acceleration',\n    description: 'Recent activity velocity exceeds historical average by 3x',\n    weight: RISK_WEIGHTS.acceleration,\n  },\n  extraction: {\n    icon: Wallet,\n    label: 'Extraction',\n    description: 'Proposed value exceeds 10x average transaction',\n    weight: RISK_WEIGHTS.extraction,\n  },\n  isolated: {\n    icon: Users,\n    label: 'Isolated',\n    description: 'Low network score from incoming vouches',\n    weight: RISK_WEIGHTS.isolated,\n  },\n  too_clean: {\n    icon: Sparkles,\n    label: 'Too Clean',\n    description: 'High transaction count with zero negative outcomes',\n    weight: RISK_WEIGHTS.too_clean,\n  },\n  erratic: {\n    icon: Activity,\n    label: 'Erratic',\n    description: 'High variance in transaction values (CV > 2.0)',\n    weight: RISK_WEIGHTS.erratic,\n  },\n  new_badge: {\n    icon: Clock,\n    label: 'New Badge',\n    description: 'Account age less than 90 days',\n    weight: RISK_WEIGHTS.new_badge,\n  },\n};\n\nconst riskColors = {\n  minimal: 'text-green-400 bg-green-500/10 border-green-500/20',\n  low: 'text-cyan-400 bg-cyan-500/10 border-cyan-500/20',\n  moderate: 'text-yellow-400 bg-yellow-500/10 border-yellow-500/20',\n  high: 'text-orange-400 bg-orange-500/10 border-orange-500/20',\n  critical: 'text-red-400 bg-red-500/10 border-red-500/20',\n};\n\nexport const RiskFlagsDisplay = React.memo(function RiskFlagsDisplay({ flags, risk, compact = false }: RiskFlagsProps) {\n  const riskLevel = getRiskLevel(risk);\n  const activeFlags = Object.entries(flags).filter(([_, active]) => active);\n  \n  if (compact) {\n    return (\n      <div className=\"flex items-center gap-2\">\n        <div className={`flex items-center gap-1 px-2 py-1 rounded-md border ${riskColors[riskLevel]}`}>\n          <AlertTriangle className=\"w-3 h-3\" />\n          <span className=\"text-xs font-medium\">{risk}</span>\n        </div>\n        <div className=\"flex gap-1\">\n          {activeFlags.map(([key]) => {\n            const config = flagConfig[key as keyof RiskFlagsType];\n            const Icon = config.icon;\n            return (\n              <div\n                key={key}\n                className=\"p-1 rounded bg-gray-800 text-gray-400\"\n                title={config.label}\n              >\n                <Icon className=\"w-3 h-3\" />\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"space-y-3\">\n      {/* Risk Score Header */}\n      <div className={`flex items-center justify-between p-3 rounded-lg border ${riskColors[riskLevel]}`}>\n        <div className=\"flex items-center gap-2\">\n          <AlertTriangle className=\"w-5 h-5\" />\n          <span className=\"font-medium\">Risk Score</span>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <span className=\"text-2xl font-bold\">{risk}</span>\n          <span className=\"text-xs uppercase tracking-wide opacity-75\">{riskLevel}</span>\n        </div>\n      </div>\n      \n      {/* Flag Grid */}\n      <div className=\"grid grid-cols-2 gap-2\">\n        {Object.entries(flagConfig).map(([key, config]) => {\n          const active = flags[key as keyof RiskFlagsType];\n          const Icon = config.icon;\n          \n          return (\n            <div\n              key={key}\n              className={`\n                p-3 rounded-lg border transition-all\n                ${active \n                  ? 'bg-red-500/10 border-red-500/30 text-red-400' \n                  : 'bg-gray-800/50 border-gray-700 text-gray-500'\n                }\n              `}\n            >\n              <div className=\"flex items-center justify-between mb-1\">\n                <div className=\"flex items-center gap-2\">\n                  <Icon className=\"w-4 h-4\" />\n                  <span className=\"text-sm font-medium\">{config.label}</span>\n                </div>\n                <span className=\"text-xs opacity-75\">+{config.weight}</span>\n              </div>\n              <p className=\"text-xs opacity-60 line-clamp-2\">\n                {config.description}\n              </p>\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n});\n\n","\n\nimport { VeilBadge } from '../domain/types';\nimport {\n  TxCategory,\n  ReportedOutcome,\n  ActiveTransaction,\n  ReportingTransaction,\n} from '../domain/proposal';\nimport { UtxoInfo } from '../application/ports';\nimport { VEIL_APP_VK } from '../domain';\nimport { createLogger } from './logger';\n\nconst logger = createLogger('SpellGenerator');\nconst DUST_LIMIT_SATS = 546;\n\nexport interface AcceptProposalSpellParams {\n  // Acceptor (my) badge\n  acceptorBadgeUtxo: UtxoInfo;\n  acceptorOldBadge: VeilBadge;\n  acceptorNewBadge: VeilBadge;\n  acceptorAddress: string;\n  \n  // Proposer's badge\n  proposerBadgeUtxo: UtxoInfo;\n  proposerOldBadge: VeilBadge;\n  proposerNewBadge: VeilBadge;\n  proposerAddress: string;\n  \n  // Transaction details\n  proposalId: string;\n  value: number;\n  category: TxCategory;\n  windowBlocks: number;\n  reportWindowBlocks: number;\n  currentBlock: number;\n}\n\nexport function generateAcceptProposalSpell(params: AcceptProposalSpellParams): string {\n  const {\n    acceptorBadgeUtxo,\n    acceptorOldBadge,\n    acceptorNewBadge,\n    acceptorAddress,\n    proposerBadgeUtxo,\n    proposerOldBadge,\n    proposerNewBadge,\n    proposerAddress,\n    proposalId,\n    value,\n    category,\n    windowBlocks,\n    reportWindowBlocks,\n    currentBlock,\n  } = params;\n\n  logger.info('Generating AcceptProposal spell (atomic):', {\n    proposerUtxo: `${proposerBadgeUtxo.txid.slice(0, 8)}:${proposerBadgeUtxo.vout}`,\n    proposerBadgeId: proposerOldBadge.id.slice(0, 16),\n    acceptorUtxo: `${acceptorBadgeUtxo.txid.slice(0, 8)}:${acceptorBadgeUtxo.vout}`,\n    acceptorBadgeId: acceptorOldBadge.id.slice(0, 16),\n    proposalId: proposalId.slice(0, 16),\n    value,\n    category,\n  });\n\n  // Both badges use their own app ID (genesis UTXO hash)\n  const proposerAppId = proposerOldBadge.id;\n  const acceptorAppId = acceptorOldBadge.id;\n  const appVk = VEIL_APP_VK;\n\n  // Serialize badge states\n  const proposerOldYaml = serializeBadgeStateYaml(proposerOldBadge);\n  const proposerNewYaml = serializeBadgeStateYaml(proposerNewBadge);\n  const acceptorOldYaml = serializeBadgeStateYaml(acceptorOldBadge);\n  const acceptorNewYaml = serializeBadgeStateYaml(acceptorNewBadge);\n\n  const spell = `version: 8\n\napps:\n  $00: \"n/${proposerAppId}/${appVk}\"\n  $01: \"n/${acceptorAppId}/${appVk}\"\n\nins:\n  # Input 0: Proposer's current badge\n  - utxo_id: \"${proposerBadgeUtxo.txid}:${proposerBadgeUtxo.vout}\"\n    charms:\n      $00:\n${proposerOldYaml}\n\n  # Input 1: Acceptor's current badge\n  - utxo_id: \"${acceptorBadgeUtxo.txid}:${acceptorBadgeUtxo.vout}\"\n    charms:\n      $01:\n${acceptorOldYaml}\n\nouts:\n  # Output 0: Updated proposer badge\n  - address: \"${proposerAddress}\"\n    sats: ${DUST_LIMIT_SATS}\n    charms:\n      $00:\n${proposerNewYaml}\n\n  # Output 1: Updated acceptor badge\n  - address: \"${acceptorAddress}\"\n    sats: ${DUST_LIMIT_SATS}\n    charms:\n      $01:\n${acceptorNewYaml}\n\npublic_args:\n  $00:\n    AcceptProposal:\n      proposal_id: \"${proposalId}\"\n      value: ${value}\n      category: ${category}\n      window_blocks: ${windowBlocks}\n      report_window_blocks: ${reportWindowBlocks}\n      current_block: ${currentBlock}\n  $01:\n    AcceptProposal:\n      proposal_id: \"${proposalId}\"\n      value: ${value}\n      category: ${category}\n      window_blocks: ${windowBlocks}\n      report_window_blocks: ${reportWindowBlocks}\n      current_block: ${currentBlock}\n`;\n\n  logger.debug('Generated atomic AcceptProposal spell YAML');\n  return spell;\n}\n\nexport interface ReportOutcomeSpellParams {\n  badgeUtxo: UtxoInfo;\n  oldBadge: VeilBadge;\n  newBadge: VeilBadge;\n  transactionId: string;\n  outcome: ReportedOutcome;\n  currentBlock: number;\n  destinationAddress: string;\n}\n\nexport function generateReportOutcomeSpell(params: ReportOutcomeSpellParams): string {\n  const {\n    badgeUtxo,\n    oldBadge,\n    newBadge,\n    transactionId,\n    outcome,\n    currentBlock,\n    destinationAddress,\n  } = params;\n\n  logger.info('Generating ReportOutcome spell:', {\n    badgeUtxo: `${badgeUtxo.txid.slice(0, 8)}:${badgeUtxo.vout}`,\n    badgeId: oldBadge.id.slice(0, 16),\n    transactionId: transactionId.slice(0, 16),\n    outcome,\n    currentBlock,\n  });\n\n  // App identity = badge ID = SHA256(genesis UTXO) from when badge was minted\n  const appId = oldBadge.id;\n  const appVk = VEIL_APP_VK;\n\n  // Serialize badge states in YAML format\n  const oldBadgeYaml = serializeBadgeStateYaml(oldBadge);\n  const newBadgeYaml = serializeBadgeStateYaml(newBadge);\n\n  const spell = `version: 8\n\napps:\n  $00: \"n/${appId}/${appVk}\"\n\nins:\n  - utxo_id: \"${badgeUtxo.txid}:${badgeUtxo.vout}\"\n    charms:\n      $00:\n${oldBadgeYaml}\n\nouts:\n  - address: \"${destinationAddress}\"\n    sats: ${DUST_LIMIT_SATS}\n    charms:\n      $00:\n${newBadgeYaml}\n\npublic_args:\n  $00:\n    ReportOutcome:\n      transaction_id: \"${transactionId}\"\n      outcome: ${outcome}\n      current_block: ${currentBlock}\n`;\n\n  logger.debug('Generated ReportOutcome spell YAML:', spell);\n  return spell;\n}\n\n/**\n * Serialize badge state as indented YAML (for embedding in spell)\n * Each line indented 8 spaces to fit under $00:\n */\nfunction serializeBadgeStateYaml(badge: VeilBadge): string {\n  const indent = '        '; // 8 spaces\n  \n  const lines = [\n    `id: \"${badge.id}\"`,\n    `created_at: ${badge.created_at}`,\n    `pubkey: \"${badge.pubkey}\"`,\n    `tx_total: ${badge.tx_total}`,\n    `tx_positive: ${badge.tx_positive}`,\n    `tx_negative: ${badge.tx_negative}`,\n    `volume_total: ${badge.volume_total}`,\n    `volume_sum_squares: ${badge.volume_sum_squares}`,\n    `window_tx_count: ${badge.window_tx_count}`,\n    `window_volume: ${badge.window_volume}`,\n    `window_start: ${badge.window_start}`,\n    `counterparty_count: ${badge.counterparty_count}`,\n    `backing:`,\n    `  backed_count: ${badge.backing.backed_count}`,\n    `  unbacked_count: ${badge.backing.unbacked_count}`,\n    `  backed_volume: ${badge.backing.backed_volume}`,\n    `  unbacked_volume: ${badge.backing.unbacked_volume}`,\n    `vouches_out: ${serializeVouchesYaml(badge.vouches_out)}`,\n    `vouches_in: ${serializeVouchesYaml(badge.vouches_in)}`,\n    `cascade_damage: ${badge.cascade_damage}`,\n    `active_transactions: ${serializeActiveTransactionsYaml(badge.active_transactions)}`,\n    `reporting_transactions: ${serializeReportingTransactionsYaml(badge.reporting_transactions)}`,\n    `outcomes:`,\n    `  mutual_positive: ${badge.outcomes.mutualPositive}`,\n    `  mutual_negative: ${badge.outcomes.mutualNegative}`,\n    `  contested_i_positive: ${badge.outcomes.contestedIPositive}`,\n    `  contested_i_negative: ${badge.outcomes.contestedINegative}`,\n    `  timeout: ${badge.outcomes.timeout}`,\n    `  mutual_timeout: ${badge.outcomes.mutualTimeout}`,\n    `trust: ${badge.trust}`,\n    `risk: ${badge.risk}`,\n    `flags: ${serializeRiskFlags(badge.flags)}`,\n    `last_nonce: \"${badge.last_nonce}\"`,\n    `last_update: ${badge.last_update}`,\n  ];\n  \n  return lines.map(line => indent + line).join('\\n');\n}\n\nfunction serializeVouchesYaml(vouches: VeilBadge['vouches_out']): string {\n  if (vouches.length === 0) return '[]';\n  const items = vouches.map(v => \n    `{ badge_id: \"${v.badge_id}\", stake_percent: ${v.stake_percent}, created_at: ${v.created_at}, unlock_at: ${v.unlock_at} }`\n  );\n  return `[${items.join(', ')}]`;\n}\n\nfunction serializeActiveTransactionsYaml(txs: ActiveTransaction[]): string {\n  if (txs.length === 0) return '[]';\n  const items = txs.map(tx => \n    `{ id: \"${tx.id}\", counterparty_badge_id: \"${tx.counterpartyBadgeId}\", value: ${tx.value}, category: \"${tx.category}\", started_at: ${tx.startedAt}, window_ends_at: ${tx.windowEndsAt}, report_deadline: ${tx.reportDeadline}, i_am_proposer: ${tx.iAmProposer} }`\n  );\n  return `[${items.join(', ')}]`;\n}\n\nfunction serializeReportingTransactionsYaml(txs: ReportingTransaction[]): string {\n  if (txs.length === 0) return '[]';\n  const items = txs.map(tx => \n    `{ id: \"${tx.id}\", counterparty_badge_id: \"${tx.counterpartyBadgeId}\", value: ${tx.value}, category: \"${tx.category}\", report_deadline: ${tx.reportDeadline}, my_report: ${tx.myReport ? `\"${tx.myReport}\"` : 'null'}, i_am_proposer: ${tx.iAmProposer} }`\n  );\n  return `[${items.join(', ')}]`;\n}\n\nfunction serializeRiskFlags(flags: VeilBadge['flags']): number {\n  let bits = 0;\n  if (flags.acceleration) bits |= 0b00000001;\n  if (flags.extraction) bits |= 0b00000010;\n  if (flags.isolated) bits |= 0b00000100;\n  if (flags.too_clean) bits |= 0b00001000;\n  if (flags.erratic) bits |= 0b00010000;\n  if (flags.new_badge) bits |= 0b00100000;\n  return bits;\n}\n"],"file":"assets/index-CQ9B3B--.js"}