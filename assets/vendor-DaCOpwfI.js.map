{"version":3,"file":"vendor-DaCOpwfI.js","sources":["../../node_modules/scheduler/cjs/scheduler.production.min.js","../../node_modules/scheduler/index.js","../../node_modules/js-yaml/dist/js-yaml.mjs","../../node_modules/vite-plugin-node-polyfills/shims/buffer/dist/index.js","../../node_modules/vite-plugin-node-polyfills/shims/buffer/dist/index.cjs","../../node_modules/typeforce/native.js","../../node_modules/typeforce/errors.js","../../node_modules/typeforce/extra.js","../../node_modules/typeforce/index.js","../../node_modules/@noble/hashes/crypto.js","../../node_modules/@noble/hashes/utils.js","../../node_modules/@noble/hashes/_md.js","../../node_modules/@noble/hashes/legacy.js","../../node_modules/@noble/hashes/ripemd160.js","../../node_modules/@noble/hashes/sha1.js","../../node_modules/@noble/hashes/_u64.js","../../node_modules/@noble/hashes/sha2.js","../../node_modules/@noble/hashes/sha256.js","../../node_modules/base-x/src/index.js","../../node_modules/bs58/index.js","../../node_modules/bs58check/base.js","../../node_modules/bs58check/index.js","../../node_modules/bech32/dist/index.js","../../node_modules/safe-buffer/index.js","../../node_modules/varuint-bitcoin/index.js","../../node_modules/bip174/src/lib/typeFields.js","../../node_modules/bip174/src/lib/converter/global/globalXpub.js","../../node_modules/bip174/src/lib/converter/global/unsignedTx.js","../../node_modules/bip174/src/lib/converter/input/finalScriptSig.js","../../node_modules/bip174/src/lib/converter/input/finalScriptWitness.js","../../node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js","../../node_modules/bip174/src/lib/converter/input/partialSig.js","../../node_modules/bip174/src/lib/converter/input/porCommitment.js","../../node_modules/bip174/src/lib/converter/input/sighashType.js","../../node_modules/bip174/src/lib/converter/input/tapKeySig.js","../../node_modules/bip174/src/lib/converter/input/tapLeafScript.js","../../node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js","../../node_modules/bip174/src/lib/converter/input/tapScriptSig.js","../../node_modules/bip174/src/lib/converter/varint.js","../../node_modules/bip174/src/lib/converter/tools.js","../../node_modules/bip174/src/lib/converter/input/witnessUtxo.js","../../node_modules/bip174/src/lib/converter/output/tapTree.js","../../node_modules/bip174/src/lib/converter/shared/bip32Derivation.js","../../node_modules/bip174/src/lib/converter/shared/checkPubkey.js","../../node_modules/bip174/src/lib/converter/shared/redeemScript.js","../../node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js","../../node_modules/bip174/src/lib/converter/shared/tapInternalKey.js","../../node_modules/bip174/src/lib/converter/shared/witnessScript.js","../../node_modules/bip174/src/lib/converter/index.js","../../node_modules/bip174/src/lib/parser/fromBuffer.js","../../node_modules/bip174/src/lib/parser/toBuffer.js","../../node_modules/bip174/src/lib/parser/index.js","../../node_modules/bip174/src/lib/combiner/index.js","../../node_modules/bip174/src/lib/utils.js","../../node_modules/bip174/src/lib/psbt.js","../../node_modules/@noble/hashes/esm/utils.js","../../node_modules/@noble/hashes/esm/hmac.js","../../node_modules/@noble/hashes/esm/_md.js","../../node_modules/@noble/hashes/esm/legacy.js","../../node_modules/@noble/hashes/esm/ripemd160.js","../../node_modules/@noble/hashes/esm/_u64.js","../../node_modules/@noble/hashes/esm/sha2.js","../../node_modules/@noble/hashes/esm/sha256.js","../../node_modules/@noble/hashes/esm/sha512.js","../../node_modules/bip32/src/esm/crypto.js","../../node_modules/uint8array-tools/src/mjs/browser.js","../../node_modules/bip32/src/esm/testecc.js","../../node_modules/@scure/base/lib/esm/index.js","../../node_modules/valibot/dist/index.js","../../node_modules/bip32/src/esm/types.js","../../node_modules/wif/node_modules/base-x/src/esm/index.js","../../node_modules/wif/node_modules/bs58/src/esm/index.js","../../node_modules/wif/node_modules/bs58check/src/esm/base.js","../../node_modules/wif/node_modules/bs58check/src/esm/index.js","../../node_modules/wif/src/esm/index.js","../../node_modules/bip32/src/esm/bip32.js","../../node_modules/@noble/hashes/sha512.js","../../node_modules/@noble/hashes/hmac.js","../../node_modules/@noble/hashes/pbkdf2.js","../../node_modules/bip39/src/_wordlists.js","../../node_modules/bip39/src/index.js","../../node_modules/@noble/curves/utils.js","../../node_modules/@noble/curves/abstract/modular.js","../../node_modules/@noble/curves/abstract/curve.js","../../node_modules/@noble/curves/abstract/weierstrass.js","../../node_modules/@noble/curves/_shortw_utils.js","../../node_modules/@noble/curves/abstract/hash-to-curve.js","../../node_modules/@noble/curves/secp256k1.js","../../node_modules/@noble/curves/abstract/utils.js","../../node_modules/qrcode/lib/can-promise.js","../../node_modules/qrcode/lib/core/utils.js","../../node_modules/qrcode/lib/core/error-correction-level.js","../../node_modules/qrcode/lib/core/bit-buffer.js","../../node_modules/qrcode/lib/core/bit-matrix.js","../../node_modules/qrcode/lib/core/alignment-pattern.js","../../node_modules/qrcode/lib/core/finder-pattern.js","../../node_modules/qrcode/lib/core/mask-pattern.js","../../node_modules/qrcode/lib/core/error-correction-code.js","../../node_modules/qrcode/lib/core/galois-field.js","../../node_modules/qrcode/lib/core/polynomial.js","../../node_modules/qrcode/lib/core/reed-solomon-encoder.js","../../node_modules/qrcode/lib/core/version-check.js","../../node_modules/qrcode/lib/core/regex.js","../../node_modules/qrcode/lib/core/mode.js","../../node_modules/qrcode/lib/core/version.js","../../node_modules/qrcode/lib/core/format-info.js","../../node_modules/qrcode/lib/core/numeric-data.js","../../node_modules/qrcode/lib/core/alphanumeric-data.js","../../node_modules/qrcode/lib/core/byte-data.js","../../node_modules/qrcode/lib/core/kanji-data.js","../../node_modules/dijkstrajs/dijkstra.js","../../node_modules/qrcode/lib/core/segments.js","../../node_modules/qrcode/lib/core/qrcode.js","../../node_modules/qrcode/lib/renderer/utils.js","../../node_modules/qrcode/lib/renderer/canvas.js","../../node_modules/qrcode/lib/renderer/svg-tag.js","../../node_modules/qrcode/lib/browser.js"],"sourcesContent":["/**\n * @license React\n * scheduler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';function f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,w=e>>>1;d<w;){var m=2*(d+1)-1,C=a[m],n=m+1,x=a[n];if(0>g(C,c))n<e&&0>g(x,C)?(a[d]=x,a[n]=c,d=n):(a[d]=C,a[m]=c,d=m);else if(n<e&&0>g(x,c))a[d]=x,a[n]=c,d=n;else break a}}return b}\nfunction g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}if(\"object\"===typeof performance&&\"function\"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}var r=[],t=[],u=1,v=null,y=3,z=!1,A=!1,B=!1,D=\"function\"===typeof setTimeout?setTimeout:null,E=\"function\"===typeof clearTimeout?clearTimeout:null,F=\"undefined\"!==typeof setImmediate?setImmediate:null;\n\"undefined\"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function G(a){for(var b=h(t);null!==b;){if(null===b.callback)k(t);else if(b.startTime<=a)k(t),b.sortIndex=b.expirationTime,f(r,b);else break;b=h(t)}}function H(a){B=!1;G(a);if(!A)if(null!==h(r))A=!0,I(J);else{var b=h(t);null!==b&&K(H,b.startTime-a)}}\nfunction J(a,b){A=!1;B&&(B=!1,E(L),L=-1);z=!0;var c=y;try{G(b);for(v=h(r);null!==v&&(!(v.expirationTime>b)||a&&!M());){var d=v.callback;if(\"function\"===typeof d){v.callback=null;y=v.priorityLevel;var e=d(v.expirationTime<=b);b=exports.unstable_now();\"function\"===typeof e?v.callback=e:v===h(r)&&k(r);G(b)}else k(r);v=h(r)}if(null!==v)var w=!0;else{var m=h(t);null!==m&&K(H,m.startTime-b);w=!1}return w}finally{v=null,y=c,z=!1}}var N=!1,O=null,L=-1,P=5,Q=-1;\nfunction M(){return exports.unstable_now()-Q<P?!1:!0}function R(){if(null!==O){var a=exports.unstable_now();Q=a;var b=!0;try{b=O(!0,a)}finally{b?S():(N=!1,O=null)}}else N=!1}var S;if(\"function\"===typeof F)S=function(){F(R)};else if(\"undefined\"!==typeof MessageChannel){var T=new MessageChannel,U=T.port2;T.port1.onmessage=R;S=function(){U.postMessage(null)}}else S=function(){D(R,0)};function I(a){O=a;N||(N=!0,S())}function K(a,b){L=D(function(){a(exports.unstable_now())},b)}\nexports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){A||z||(A=!0,I(J))};\nexports.unstable_forceFrameRate=function(a){0>a||125<a?console.error(\"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\"):P=0<a?Math.floor(1E3/a):5};exports.unstable_getCurrentPriorityLevel=function(){return y};exports.unstable_getFirstCallbackNode=function(){return h(r)};exports.unstable_next=function(a){switch(y){case 1:case 2:case 3:var b=3;break;default:b=y}var c=y;y=b;try{return a()}finally{y=c}};exports.unstable_pauseExecution=function(){};\nexports.unstable_requestPaint=function(){};exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=y;y=a;try{return b()}finally{y=c}};\nexports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();\"object\"===typeof c&&null!==c?(c=c.delay,c=\"number\"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:u++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(t,a),null===h(r)&&a===h(t)&&(B?(E(L),L=-1):B=!0,K(H,c-d))):(a.sortIndex=e,f(r,a),A||z||(A=!0,I(J)));return a};\nexports.unstable_shouldYield=M;exports.unstable_wrapCallback=function(a){var b=y;return function(){var c=y;y=b;try{return a.apply(this,arguments)}finally{y=c}}};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/scheduler.production.min.js');\n} else {\n  module.exports = require('./cjs/scheduler.development.js');\n}\n","\n/*! js-yaml 4.1.1 https://github.com/nodeca/js-yaml @license MIT */\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nvar isNothing_1      = isNothing;\nvar isObject_1       = isObject;\nvar toArray_1        = toArray;\nvar repeat_1         = repeat;\nvar isNegativeZero_1 = isNegativeZero;\nvar extend_1         = extend;\n\nvar common = {\n\tisNothing: isNothing_1,\n\tisObject: isObject_1,\n\ttoArray: toArray_1,\n\trepeat: repeat_1,\n\tisNegativeZero: isNegativeZero_1,\n\textend: extend_1\n};\n\n// YAML error class. http://stackoverflow.com/questions/8458984\n\n\nfunction formatError(exception, compact) {\n  var where = '', message = exception.reason || '(unknown reason)';\n\n  if (!exception.mark) return message;\n\n  if (exception.mark.name) {\n    where += 'in \"' + exception.mark.name + '\" ';\n  }\n\n  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n\n  if (!compact && exception.mark.snippet) {\n    where += '\\n\\n' + exception.mark.snippet;\n  }\n\n  return message + ' ' + where;\n}\n\n\nfunction YAMLException$1(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = formatError(this, false);\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException$1.prototype = Object.create(Error.prototype);\nYAMLException$1.prototype.constructor = YAMLException$1;\n\n\nYAMLException$1.prototype.toString = function toString(compact) {\n  return this.name + ': ' + formatError(this, compact);\n};\n\n\nvar exception = YAMLException$1;\n\n// get snippet for a single line, respecting maxLength\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n  var head = '';\n  var tail = '';\n  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n\n  if (position - lineStart > maxHalfLength) {\n    head = ' ... ';\n    lineStart = position - maxHalfLength + head.length;\n  }\n\n  if (lineEnd - position > maxHalfLength) {\n    tail = ' ...';\n    lineEnd = position + maxHalfLength - tail.length;\n  }\n\n  return {\n    str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, 'â†’') + tail,\n    pos: position - lineStart + head.length // relative position\n  };\n}\n\n\nfunction padStart(string, max) {\n  return common.repeat(' ', max - string.length) + string;\n}\n\n\nfunction makeSnippet(mark, options) {\n  options = Object.create(options || null);\n\n  if (!mark.buffer) return null;\n\n  if (!options.maxLength) options.maxLength = 79;\n  if (typeof options.indent      !== 'number') options.indent      = 1;\n  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;\n\n  var re = /\\r?\\n|\\r|\\0/g;\n  var lineStarts = [ 0 ];\n  var lineEnds = [];\n  var match;\n  var foundLineNo = -1;\n\n  while ((match = re.exec(mark.buffer))) {\n    lineEnds.push(match.index);\n    lineStarts.push(match.index + match[0].length);\n\n    if (mark.position <= match.index && foundLineNo < 0) {\n      foundLineNo = lineStarts.length - 2;\n    }\n  }\n\n  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n\n  var result = '', i, line;\n  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n\n  for (i = 1; i <= options.linesBefore; i++) {\n    if (foundLineNo - i < 0) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo - i],\n      lineEnds[foundLineNo - i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n      maxLineLength\n    );\n    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n' + result;\n  }\n\n  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +\n    ' | ' + line.str + '\\n';\n  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n\n  for (i = 1; i <= options.linesAfter; i++) {\n    if (foundLineNo + i >= lineEnds.length) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo + i],\n      lineEnds[foundLineNo + i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n      maxLineLength\n    );\n    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n';\n  }\n\n  return result.replace(/\\n$/, '');\n}\n\n\nvar snippet = makeSnippet;\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'multi',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'representName',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type$1(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.options       = options; // keep original options in case user wants to extend this type later\n  this.tag           = tag;\n  this.kind          = options['kind']          || null;\n  this.resolve       = options['resolve']       || function () { return true; };\n  this.construct     = options['construct']     || function (data) { return data; };\n  this.instanceOf    = options['instanceOf']    || null;\n  this.predicate     = options['predicate']     || null;\n  this.represent     = options['represent']     || null;\n  this.representName = options['representName'] || null;\n  this.defaultStyle  = options['defaultStyle']  || null;\n  this.multi         = options['multi']         || false;\n  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nvar type = Type$1;\n\n/*eslint-disable max-len*/\n\n\n\n\n\nfunction compileList(schema, name) {\n  var result = [];\n\n  schema[name].forEach(function (currentType) {\n    var newIndex = result.length;\n\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag &&\n          previousType.kind === currentType.kind &&\n          previousType.multi === currentType.multi) {\n\n        newIndex = previousIndex;\n      }\n    });\n\n    result[newIndex] = currentType;\n  });\n\n  return result;\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      }, index, length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema$1(definition) {\n  return this.extend(definition);\n}\n\n\nSchema$1.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n  } else {\n    throw new exception('Schema.extend argument should be a Type, [ Type ], ' +\n      'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type$1.loadKind && type$1.loadKind !== 'scalar') {\n      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type$1.multi) {\n      throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n\n  explicit.forEach(function (type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n\n  var result = Object.create(Schema$1.prototype);\n\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n\n  result.compiledImplicit = compileList(result, 'implicit');\n  result.compiledExplicit = compileList(result, 'explicit');\n  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n  return result;\n};\n\n\nvar schema = Schema$1;\n\nvar str = new type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n\nvar seq = new type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n\nvar map = new type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n\nvar failsafe = new schema({\n  explicit: [\n    str,\n    seq,\n    map\n  ]\n});\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nvar _null = new type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; },\n    empty:     function () { return '';     }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nvar bool = new type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'o') {\n      // base 8\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isOctCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n  }\n\n  // base 10 (except 0)\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  return true;\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch;\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nvar int = new type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nvar float = new type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n\nvar json = failsafe.extend({\n  implicit: [\n    _null,\n    bool,\n    int,\n    float\n  ]\n});\n\nvar core = json;\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nvar timestamp = new type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nvar merge = new type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n\n/*eslint-disable no-bitwise*/\n\n\n\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  return new Uint8Array(result);\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';\n}\n\nvar binary = new type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n\nvar _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\nvar _toString$2       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString$2.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty$3.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nvar omap = new type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n\nvar _toString$1 = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString$1.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nvar pairs = new type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n\nvar _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty$2.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nvar set = new type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n\nvar _default = core.extend({\n  implicit: [\n    timestamp,\n    merge\n  ],\n  explicit: [\n    binary,\n    omap,\n    pairs,\n    set\n  ]\n});\n\n/*eslint-disable max-len,no-use-before-define*/\n\n\n\n\n\n\n\nvar _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\n// set a property of a literal object, while protecting against prototype pollution,\n// see https://github.com/nodeca/js-yaml/issues/164 for more details\nfunction setProperty(object, key, value) {\n  // used for this specific key only because Object.defineProperty is slow\n  if (key === '__proto__') {\n    Object.defineProperty(object, key, {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: value\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State$1(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || _default;\n  this.onWarning = options['onWarning'] || null;\n  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n  // if such documents have no explicit %YAML directive\n  this.legacy    = options['legacy']    || false;\n\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  // position of first leading tab in the current line,\n  // used to make sure there are no tabs in the indentation\n  this.firstTabInLine = -1;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  var mark = {\n    name:     state.filename,\n    buffer:   state.input.slice(0, -1), // omit trailing \\0\n    position: state.position,\n    line:     state.line,\n    column:   state.position - state.lineStart\n  };\n\n  mark.snippet = snippet(mark);\n\n  return new exception(message, mark);\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty$1.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    try {\n      prefix = decodeURIComponent(prefix);\n    } catch (err) {\n      throwError(state, 'tag prefix is malformed: ' + prefix);\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty$1.call(destination, key)) {\n      setProperty(destination, key, source[key]);\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,\n  startLine, startLineStart, startPos) {\n\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty$1.call(overridableKeys, keyNode) &&\n        _hasOwnProperty$1.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.lineStart = startLineStart || state.lineStart;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n\n    setProperty(_result, keyNode, valueNode);\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n  state.firstTabInLine = -1;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {\n        state.firstTabInLine = state.position;\n      }\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _lineStart,\n      _pos,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = Object.create(null),\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    } else if (ch === 0x2C/* , */) {\n      // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n      throwError(state, \"expected the node content, but found ','\");\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line; // Save the current line.\n    _lineStart = state.lineStart;\n    _pos = state.position;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _keyLine,\n      _keyLineStart,\n      _keyPos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = Object.create(null),\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (!atExplicitKey && state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else {\n      _keyLine = state.line;\n      _keyLineStart = state.lineStart;\n      _keyPos = state.position;\n\n      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n        // Neither implicit nor explicit notation.\n        // Reading is done. Go to the epilogue.\n        break;\n      }\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (atExplicitKey) {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n      }\n\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  try {\n    tagName = decodeURIComponent(tagName);\n  } catch (err) {\n    throwError(state, 'tag name is malformed: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      typeList,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag === null) {\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = state.result;\n    }\n\n  } else if (state.tag === '?') {\n    // Implicit resolving is not allowed for non-scalar types, and '?'\n    // non-specific tag is only automatically assigned to plain scalars.\n    //\n    // We only need to check kind conformity in case user explicitly assigns '?'\n    // tag, for example like this: \"!<?> [0]\"\n    //\n    if (state.result !== null && state.kind !== 'scalar') {\n      throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n    }\n\n    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n      type = state.implicitTypes[typeIndex];\n\n      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        state.result = type.construct(state.result);\n        state.tag = type.tag;\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n        break;\n      }\n    }\n  } else if (state.tag !== '!') {\n    if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n    } else {\n      // looking for multi type\n      type = null;\n      typeList = state.typeMap.multi[state.kind || 'fallback'];\n\n      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n          type = typeList[typeIndex];\n          break;\n        }\n      }\n    }\n\n    if (!type) {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n\n    if (state.result !== null && type.kind !== state.kind) {\n      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n    }\n\n    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched\n      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n    } else {\n      state.result = type.construct(state.result, state.tag);\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = Object.create(null);\n  state.anchorMap = Object.create(null);\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State$1(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll$1(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load$1(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new exception('expected a single document in the stream, but found more');\n}\n\n\nvar loadAll_1 = loadAll$1;\nvar load_1    = load$1;\n\nvar loader = {\n\tloadAll: loadAll_1,\n\tload: load_1\n};\n\n/*eslint-disable no-use-before-define*/\n\n\n\n\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_BOM                  = 0xFEFF;\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.schema        = options['schema'] || _default;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n  this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes   = options['forceQuotes'] || false;\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isnâ€™t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c)\n    && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out  â‡’ ns-plain-safe-out\n//                             c = flow-in   â‡’ ns-plain-safe-in\n//                             c = block-key â‡’ ns-plain-safe-out\n//                             c = flow-key  â‡’ ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - â€œ:â€ - â€œ#â€ )\n//                            | ( /* An ns-char preceding */ â€œ#â€ )\n//                            | ( â€œ:â€ /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n    // ns-plain-safe\n    inblock ? // c = flow-in\n      cIsNsCharOrWhitespace\n      : cIsNsCharOrWhitespace\n        // - c-flow-indicator\n        && c !== CHAR_COMMA\n        && c !== CHAR_LEFT_SQUARE_BRACKET\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\n        && c !== CHAR_LEFT_CURLY_BRACKET\n        && c !== CHAR_RIGHT_CURLY_BRACKET\n  )\n    // ns-plain-char\n    && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( â€œ?â€ | â€œ:â€ | â€œ-â€ ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // â€œ-â€ | â€œ?â€ | â€œ:â€ | â€œ,â€ | â€œ[â€ | â€œ]â€ | â€œ{â€ | â€œ}â€\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | â€œ#â€ | â€œ&â€ | â€œ*â€ | â€œ!â€ | â€œ|â€ | â€œ=â€ | â€œ>â€ | â€œ'â€ | â€œ\"â€\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | â€œ%â€ | â€œ@â€ | â€œ`â€)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos), second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    â€¢ No ending newline => unaffected; already using strip \"-\" chomping.\n//    â€¢ Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth â‰¤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string) + '\"';\n      default:\n        throw new exception('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlinesâ€”\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level, null, false, false))) {\n\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level + 1, null, true, true, false, true))) {\n\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new exception('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new exception('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && (state.dump.length !== 0)) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new exception('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | â€œ-â€\n      // [39] ns-uri-char     ::=  â€œ%â€ ns-hex-digit ns-hex-digit | ns-word-char | â€œ#â€\n      //                         | â€œ;â€ | â€œ/â€ | â€œ?â€ | â€œ:â€ | â€œ@â€ | â€œ&â€ | â€œ=â€ | â€œ+â€ | â€œ$â€ | â€œ,â€\n      //                         | â€œ_â€ | â€œ.â€ | â€œ!â€ | â€œ~â€ | â€œ*â€ | â€œ'â€ | â€œ(â€ | â€œ)â€ | â€œ[â€ | â€œ]â€\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n      ).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump$1(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({ '': value }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nvar dump_1 = dump$1;\n\nvar dumper = {\n\tdump: dump_1\n};\n\nfunction renamed(from, to) {\n  return function () {\n    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +\n      'Use yaml.' + to + ' instead, which is now safe by default.');\n  };\n}\n\n\nvar Type                = type;\nvar Schema              = schema;\nvar FAILSAFE_SCHEMA     = failsafe;\nvar JSON_SCHEMA         = json;\nvar CORE_SCHEMA         = core;\nvar DEFAULT_SCHEMA      = _default;\nvar load                = loader.load;\nvar loadAll             = loader.loadAll;\nvar dump                = dumper.dump;\nvar YAMLException       = exception;\n\n// Re-export all types in case user wants to create custom schema\nvar types = {\n  binary:    binary,\n  float:     float,\n  map:       map,\n  null:      _null,\n  pairs:     pairs,\n  set:       set,\n  timestamp: timestamp,\n  bool:      bool,\n  int:       int,\n  merge:     merge,\n  omap:      omap,\n  seq:       seq,\n  str:       str\n};\n\n// Removed functions from JS-YAML 3.0.x\nvar safeLoad            = renamed('safeLoad', 'load');\nvar safeLoadAll         = renamed('safeLoadAll', 'loadAll');\nvar safeDump            = renamed('safeDump', 'dump');\n\nvar jsYaml = {\n\tType: Type,\n\tSchema: Schema,\n\tFAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\n\tJSON_SCHEMA: JSON_SCHEMA,\n\tCORE_SCHEMA: CORE_SCHEMA,\n\tDEFAULT_SCHEMA: DEFAULT_SCHEMA,\n\tload: load,\n\tloadAll: loadAll,\n\tdump: dump,\n\tYAMLException: YAMLException,\n\ttypes: types,\n\tsafeLoad: safeLoad,\n\tsafeLoadAll: safeLoadAll,\n\tsafeDump: safeDump\n};\n\nexport { CORE_SCHEMA, DEFAULT_SCHEMA, FAILSAFE_SCHEMA, JSON_SCHEMA, Schema, Type, YAMLException, jsYaml as default, dump, load, loadAll, safeDump, safeLoad, safeLoadAll, types };\n","var buffer = {};\n\nvar base64Js = {};\n\nbase64Js.byteLength = byteLength;\nbase64Js.toByteArray = toByteArray;\nbase64Js.fromByteArray = fromByteArray;\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens (b64) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4);\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n\n  var curByte = 0;\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen;\n\n  var i;\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = (tmp >> 16) & 0xFF;\n    arr[curByte++] = (tmp >> 8) & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[curByte++] = (tmp >> 8) & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    );\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    );\n  }\n\n  return parts.join('')\n}\n\nvar ieee754 = {};\n\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n\nieee754.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = (nBytes * 8) - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? (nBytes - 1) : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n};\n\nieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = (nBytes * 8) - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n  var i = isLE ? 0 : (nBytes - 1);\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n(function (exports) {\n\n\tconst base64 = base64Js;\n\tconst ieee754$1 = ieee754;\n\tconst customInspectSymbol =\n\t  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n\t    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n\t    : null;\n\n\texports.Buffer = Buffer;\n\texports.SlowBuffer = SlowBuffer;\n\texports.INSPECT_MAX_BYTES = 50;\n\n\tconst K_MAX_LENGTH = 0x7fffffff;\n\texports.kMaxLength = K_MAX_LENGTH;\n\tconst { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n\t *               implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * We report that the browser does not support typed arrays if the are not subclassable\n\t * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n\t * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n\t * for __proto__ and has a buggy typed array implementation.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\n\tif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n\t    typeof console.error === 'function') {\n\t  console.error(\n\t    'This browser lacks typed array (Uint8Array) support which is required by ' +\n\t    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n\t  );\n\t}\n\n\tfunction typedArraySupport () {\n\t  // Can typed array instances can be augmented?\n\t  try {\n\t    const arr = new GlobalUint8Array(1);\n\t    const proto = { foo: function () { return 42 } };\n\t    Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n\t    Object.setPrototypeOf(arr, proto);\n\t    return arr.foo() === 42\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\n\tObject.defineProperty(Buffer.prototype, 'parent', {\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!Buffer.isBuffer(this)) return undefined\n\t    return this.buffer\n\t  }\n\t});\n\n\tObject.defineProperty(Buffer.prototype, 'offset', {\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!Buffer.isBuffer(this)) return undefined\n\t    return this.byteOffset\n\t  }\n\t});\n\n\tfunction createBuffer (length) {\n\t  if (length > K_MAX_LENGTH) {\n\t    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n\t  }\n\t  // Return an augmented `Uint8Array` instance\n\t  const buf = new GlobalUint8Array(length);\n\t  Object.setPrototypeOf(buf, Buffer.prototype);\n\t  return buf\n\t}\n\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new TypeError(\n\t        'The \"string\" argument must be of type string. Received type number'\n\t      )\n\t    }\n\t    return allocUnsafe(arg)\n\t  }\n\t  return from(arg, encodingOrOffset, length)\n\t}\n\n\tBuffer.poolSize = 8192; // not used by this implementation\n\n\tfunction from (value, encodingOrOffset, length) {\n\t  if (typeof value === 'string') {\n\t    return fromString(value, encodingOrOffset)\n\t  }\n\n\t  if (GlobalArrayBuffer.isView(value)) {\n\t    return fromArrayView(value)\n\t  }\n\n\t  if (value == null) {\n\t    throw new TypeError(\n\t      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n\t      'or Array-like Object. Received type ' + (typeof value)\n\t    )\n\t  }\n\n\t  if (isInstance(value, GlobalArrayBuffer) ||\n\t      (value && isInstance(value.buffer, GlobalArrayBuffer))) {\n\t    return fromArrayBuffer(value, encodingOrOffset, length)\n\t  }\n\n\t  if (typeof GlobalSharedArrayBuffer !== 'undefined' &&\n\t      (isInstance(value, GlobalSharedArrayBuffer) ||\n\t      (value && isInstance(value.buffer, GlobalSharedArrayBuffer)))) {\n\t    return fromArrayBuffer(value, encodingOrOffset, length)\n\t  }\n\n\t  if (typeof value === 'number') {\n\t    throw new TypeError(\n\t      'The \"value\" argument must not be of type number. Received type number'\n\t    )\n\t  }\n\n\t  const valueOf = value.valueOf && value.valueOf();\n\t  if (valueOf != null && valueOf !== value) {\n\t    return Buffer.from(valueOf, encodingOrOffset, length)\n\t  }\n\n\t  const b = fromObject(value);\n\t  if (b) return b\n\n\t  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n\t      typeof value[Symbol.toPrimitive] === 'function') {\n\t    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n\t  }\n\n\t  throw new TypeError(\n\t    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n\t    'or Array-like Object. Received type ' + (typeof value)\n\t  )\n\t}\n\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(value, encodingOrOffset, length)\n\t};\n\n\t// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n\t// https://github.com/feross/buffer/pull/148\n\tObject.setPrototypeOf(Buffer.prototype, GlobalUint8Array.prototype);\n\tObject.setPrototypeOf(Buffer, GlobalUint8Array);\n\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be of type number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n\t  }\n\t}\n\n\tfunction alloc (size, fill, encoding) {\n\t  assertSize(size);\n\t  if (size <= 0) {\n\t    return createBuffer(size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpreted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(size).fill(fill, encoding)\n\t      : createBuffer(size).fill(fill)\n\t  }\n\t  return createBuffer(size)\n\t}\n\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(size, fill, encoding)\n\t};\n\n\tfunction allocUnsafe (size) {\n\t  assertSize(size);\n\t  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n\t}\n\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(size)\n\t};\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(size)\n\t};\n\n\tfunction fromString (string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8';\n\t  }\n\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('Unknown encoding: ' + encoding)\n\t  }\n\n\t  const length = byteLength(string, encoding) | 0;\n\t  let buf = createBuffer(length);\n\n\t  const actual = buf.write(string, encoding);\n\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    buf = buf.slice(0, actual);\n\t  }\n\n\t  return buf\n\t}\n\n\tfunction fromArrayLike (array) {\n\t  const length = array.length < 0 ? 0 : checked(array.length) | 0;\n\t  const buf = createBuffer(length);\n\t  for (let i = 0; i < length; i += 1) {\n\t    buf[i] = array[i] & 255;\n\t  }\n\t  return buf\n\t}\n\n\tfunction fromArrayView (arrayView) {\n\t  if (isInstance(arrayView, GlobalUint8Array)) {\n\t    const copy = new GlobalUint8Array(arrayView);\n\t    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n\t  }\n\t  return fromArrayLike(arrayView)\n\t}\n\n\tfunction fromArrayBuffer (array, byteOffset, length) {\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\"offset\" is outside of buffer bounds')\n\t  }\n\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\"length\" is outside of buffer bounds')\n\t  }\n\n\t  let buf;\n\t  if (byteOffset === undefined && length === undefined) {\n\t    buf = new GlobalUint8Array(array);\n\t  } else if (length === undefined) {\n\t    buf = new GlobalUint8Array(array, byteOffset);\n\t  } else {\n\t    buf = new GlobalUint8Array(array, byteOffset, length);\n\t  }\n\n\t  // Return an augmented `Uint8Array` instance\n\t  Object.setPrototypeOf(buf, Buffer.prototype);\n\n\t  return buf\n\t}\n\n\tfunction fromObject (obj) {\n\t  if (Buffer.isBuffer(obj)) {\n\t    const len = checked(obj.length) | 0;\n\t    const buf = createBuffer(len);\n\n\t    if (buf.length === 0) {\n\t      return buf\n\t    }\n\n\t    obj.copy(buf, 0, 0, len);\n\t    return buf\n\t  }\n\n\t  if (obj.length !== undefined) {\n\t    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n\t      return createBuffer(0)\n\t    }\n\t    return fromArrayLike(obj)\n\t  }\n\n\t  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n\t    return fromArrayLike(obj.data)\n\t  }\n\t}\n\n\tfunction checked (length) {\n\t  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= K_MAX_LENGTH) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\n\tfunction SlowBuffer (length) {\n\t  if (+length != length) { // eslint-disable-line eqeqeq\n\t    length = 0;\n\t  }\n\t  return Buffer.alloc(+length)\n\t}\n\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return b != null && b._isBuffer === true &&\n\t    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n\t};\n\n\tBuffer.compare = function compare (a, b) {\n\t  if (isInstance(a, GlobalUint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n\t  if (isInstance(b, GlobalUint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError(\n\t      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n\t    )\n\t  }\n\n\t  if (a === b) return 0\n\n\t  let x = a.length;\n\t  let y = b.length;\n\n\t  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i];\n\t      y = b[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t};\n\n\tBuffer.concat = function concat (list, length) {\n\t  if (!Array.isArray(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\n\t  let i;\n\t  if (length === undefined) {\n\t    length = 0;\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length;\n\t    }\n\t  }\n\n\t  const buffer = Buffer.allocUnsafe(length);\n\t  let pos = 0;\n\t  for (i = 0; i < list.length; ++i) {\n\t    let buf = list[i];\n\t    if (isInstance(buf, GlobalUint8Array)) {\n\t      if (pos + buf.length > buffer.length) {\n\t        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);\n\t        buf.copy(buffer, pos);\n\t      } else {\n\t        GlobalUint8Array.prototype.set.call(\n\t          buffer,\n\t          buf,\n\t          pos\n\t        );\n\t      }\n\t    } else if (!Buffer.isBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    } else {\n\t      buf.copy(buffer, pos);\n\t    }\n\t    pos += buf.length;\n\t  }\n\t  return buffer\n\t};\n\n\tfunction byteLength (string, encoding) {\n\t  if (Buffer.isBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    throw new TypeError(\n\t      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n\t      'Received type ' + typeof string\n\t    )\n\t  }\n\n\t  const len = string.length;\n\t  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n\t  if (!mustMatch && len === 0) return 0\n\n\t  // Use a for loop to avoid recursion\n\t  let loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) {\n\t          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n\t        }\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength;\n\n\tfunction slowToString (encoding, start, end) {\n\t  let loweredCase = false;\n\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0;\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length;\n\t  }\n\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\n\t  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0;\n\t  start >>>= 0;\n\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\n\t// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n\t// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n\t// reliably in a browserify context because there could be multiple different\n\t// copies of the 'buffer' package in use. This method works even for Buffer\n\t// instances that were created from another copy of the `buffer` package.\n\t// See: https://github.com/feross/buffer/issues/154\n\tBuffer.prototype._isBuffer = true;\n\n\tfunction swap (b, n, m) {\n\t  const i = b[n];\n\t  b[n] = b[m];\n\t  b[m] = i;\n\t}\n\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  const len = this.length;\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  const len = this.length;\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3);\n\t    swap(this, i + 1, i + 2);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  const len = this.length;\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7);\n\t    swap(this, i + 1, i + 6);\n\t    swap(this, i + 2, i + 5);\n\t    swap(this, i + 3, i + 4);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.toString = function toString () {\n\t  const length = this.length;\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t};\n\n\tBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t};\n\n\tBuffer.prototype.inspect = function inspect () {\n\t  let str = '';\n\t  const max = exports.INSPECT_MAX_BYTES;\n\t  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n\t  if (this.length > max) str += ' ... ';\n\t  return '<Buffer ' + str + '>'\n\t};\n\tif (customInspectSymbol) {\n\t  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;\n\t}\n\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (isInstance(target, GlobalUint8Array)) {\n\t    target = Buffer.from(target, target.offset, target.byteLength);\n\t  }\n\t  if (!Buffer.isBuffer(target)) {\n\t    throw new TypeError(\n\t      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n\t      'Received type ' + (typeof target)\n\t    )\n\t  }\n\n\t  if (start === undefined) {\n\t    start = 0;\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0;\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0;\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length;\n\t  }\n\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\n\t  start >>>= 0;\n\t  end >>>= 0;\n\t  thisStart >>>= 0;\n\t  thisEnd >>>= 0;\n\n\t  if (this === target) return 0\n\n\t  let x = thisEnd - thisStart;\n\t  let y = end - start;\n\t  const len = Math.min(x, y);\n\n\t  const thisCopy = this.slice(thisStart, thisEnd);\n\t  const targetCopy = target.slice(start, end);\n\n\t  for (let i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i];\n\t      y = targetCopy[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset;\n\t    byteOffset = 0;\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff;\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000;\n\t  }\n\t  byteOffset = +byteOffset; // Coerce to Number.\n\t  if (numberIsNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1);\n\t  }\n\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1;\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0;\n\t    else return -1\n\t  }\n\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding);\n\t  }\n\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (Buffer.isBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF; // Search for a byte value [0-255]\n\t    if (typeof GlobalUint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n\t  }\n\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  let indexSize = 1;\n\t  let arrLength = arr.length;\n\t  let valLength = val.length;\n\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase();\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2;\n\t      arrLength /= 2;\n\t      valLength /= 2;\n\t      byteOffset /= 2;\n\t    }\n\t  }\n\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\n\t  let i;\n\t  if (dir) {\n\t    let foundIndex = -1;\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i;\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex;\n\t        foundIndex = -1;\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      let found = true;\n\t      for (let j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false;\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\n\t  return -1\n\t}\n\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t};\n\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t};\n\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t};\n\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0;\n\t  const remaining = buf.length - offset;\n\t  if (!length) {\n\t    length = remaining;\n\t  } else {\n\t    length = Number(length);\n\t    if (length > remaining) {\n\t      length = remaining;\n\t    }\n\t  }\n\n\t  const strLen = string.length;\n\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2;\n\t  }\n\t  let i;\n\t  for (i = 0; i < length; ++i) {\n\t    const parsed = parseInt(string.substr(i * 2, 2), 16);\n\t    if (numberIsNaN(parsed)) return i\n\t    buf[offset + i] = parsed;\n\t  }\n\t  return i\n\t}\n\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8';\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset;\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset >>> 0;\n\t    if (isFinite(length)) {\n\t      length = length >>> 0;\n\t      if (encoding === undefined) encoding = 'utf8';\n\t    } else {\n\t      encoding = length;\n\t      length = undefined;\n\t    }\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\n\t  const remaining = this.length - offset;\n\t  if (length === undefined || length > remaining) length = remaining;\n\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  let loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return asciiWrite(this, string, offset, length)\n\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t};\n\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t};\n\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end);\n\t  const res = [];\n\n\t  let i = start;\n\t  while (i < end) {\n\t    const firstByte = buf[i];\n\t    let codePoint = null;\n\t    let bytesPerSequence = (firstByte > 0xEF)\n\t      ? 4\n\t      : (firstByte > 0xDF)\n\t          ? 3\n\t          : (firstByte > 0xBF)\n\t              ? 2\n\t              : 1;\n\n\t    if (i + bytesPerSequence <= end) {\n\t      let secondByte, thirdByte, fourthByte, tempCodePoint;\n\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte;\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1];\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          fourthByte = buf[i + 3];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t      }\n\t    }\n\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD;\n\t      bytesPerSequence = 1;\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000;\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n\t      codePoint = 0xDC00 | codePoint & 0x3FF;\n\t    }\n\n\t    res.push(codePoint);\n\t    i += bytesPerSequence;\n\t  }\n\n\t  return decodeCodePointsArray(res)\n\t}\n\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tconst MAX_ARGUMENTS_LENGTH = 0x1000;\n\n\tfunction decodeCodePointsArray (codePoints) {\n\t  const len = codePoints.length;\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  let res = '';\n\t  let i = 0;\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    );\n\t  }\n\t  return res\n\t}\n\n\tfunction asciiSlice (buf, start, end) {\n\t  let ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (let i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F);\n\t  }\n\t  return ret\n\t}\n\n\tfunction latin1Slice (buf, start, end) {\n\t  let ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (let i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i]);\n\t  }\n\t  return ret\n\t}\n\n\tfunction hexSlice (buf, start, end) {\n\t  const len = buf.length;\n\n\t  if (!start || start < 0) start = 0;\n\t  if (!end || end < 0 || end > len) end = len;\n\n\t  let out = '';\n\t  for (let i = start; i < end; ++i) {\n\t    out += hexSliceLookupTable[buf[i]];\n\t  }\n\t  return out\n\t}\n\n\tfunction utf16leSlice (buf, start, end) {\n\t  const bytes = buf.slice(start, end);\n\t  let res = '';\n\t  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n\t  for (let i = 0; i < bytes.length - 1; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));\n\t  }\n\t  return res\n\t}\n\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  const len = this.length;\n\t  start = ~~start;\n\t  end = end === undefined ? len : ~~end;\n\n\t  if (start < 0) {\n\t    start += len;\n\t    if (start < 0) start = 0;\n\t  } else if (start > len) {\n\t    start = len;\n\t  }\n\n\t  if (end < 0) {\n\t    end += len;\n\t    if (end < 0) end = 0;\n\t  } else if (end > len) {\n\t    end = len;\n\t  }\n\n\t  if (end < start) end = start;\n\n\t  const newBuf = this.subarray(start, end);\n\t  // Return an augmented `Uint8Array` instance\n\t  Object.setPrototypeOf(newBuf, Buffer.prototype);\n\n\t  return newBuf\n\t};\n\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\n\tBuffer.prototype.readUintLE =\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let val = this[offset];\n\t  let mul = 1;\n\t  let i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readUintBE =\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length);\n\t  }\n\n\t  let val = this[offset + --byteLength];\n\t  let mul = 1;\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readUint8 =\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  return this[offset]\n\t};\n\n\tBuffer.prototype.readUint16LE =\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return this[offset] | (this[offset + 1] << 8)\n\t};\n\n\tBuffer.prototype.readUint16BE =\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return (this[offset] << 8) | this[offset + 1]\n\t};\n\n\tBuffer.prototype.readUint32LE =\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t};\n\n\tBuffer.prototype.readUint32BE =\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t};\n\n\tBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const lo = first +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 24;\n\n\t  const hi = this[++offset] +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    last * 2 ** 24;\n\n\t  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n\t});\n\n\tBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const hi = first * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset];\n\n\t  const lo = this[++offset] * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    last;\n\n\t  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n\t});\n\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let val = this[offset];\n\t  let mul = 1;\n\t  let i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let i = byteLength;\n\t  let mul = 1;\n\t  let val = this[offset + --i];\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t};\n\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  const val = this[offset] | (this[offset + 1] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  const val = this[offset + 1] | (this[offset] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t};\n\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t};\n\n\tBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const val = this[offset + 4] +\n\t    this[offset + 5] * 2 ** 8 +\n\t    this[offset + 6] * 2 ** 16 +\n\t    (last << 24); // Overflow\n\n\t  return (BigInt(val) << BigInt(32)) +\n\t    BigInt(first +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 24)\n\t});\n\n\tBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const val = (first << 24) + // Overflow\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset];\n\n\t  return (BigInt(val) << BigInt(32)) +\n\t    BigInt(this[++offset] * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    last)\n\t});\n\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return ieee754$1.read(this, offset, true, 23, 4)\n\t};\n\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return ieee754$1.read(this, offset, false, 23, 4)\n\t};\n\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return ieee754$1.read(this, offset, true, 52, 8)\n\t};\n\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return ieee754$1.read(this, offset, false, 52, 8)\n\t};\n\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\n\tBuffer.prototype.writeUintLE =\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  let mul = 1;\n\t  let i = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeUintBE =\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  let i = byteLength - 1;\n\t  let mul = 1;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeUint8 =\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tBuffer.prototype.writeUint16LE =\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeUint16BE =\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  this[offset] = (value >>> 8);\n\t  this[offset + 1] = (value & 0xff);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeUint32LE =\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  this[offset + 3] = (value >>> 24);\n\t  this[offset + 2] = (value >>> 16);\n\t  this[offset + 1] = (value >>> 8);\n\t  this[offset] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeUint32BE =\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  this[offset] = (value >>> 24);\n\t  this[offset + 1] = (value >>> 16);\n\t  this[offset + 2] = (value >>> 8);\n\t  this[offset + 3] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n\t  checkIntBI(value, min, max, buf, offset, 7);\n\n\t  let lo = Number(value & BigInt(0xffffffff));\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  return offset\n\t}\n\n\tfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n\t  checkIntBI(value, min, max, buf, offset, 7);\n\n\t  let lo = Number(value & BigInt(0xffffffff));\n\t  buf[offset + 7] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 6] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 5] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 4] = lo;\n\t  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n\t  buf[offset + 3] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset + 2] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset + 1] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset] = hi;\n\t  return offset + 8\n\t}\n\n\tBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n\t  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n\t  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    const limit = Math.pow(2, (8 * byteLength) - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  let i = 0;\n\t  let mul = 1;\n\t  let sub = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    const limit = Math.pow(2, (8 * byteLength) - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  let i = byteLength - 1;\n\t  let mul = 1;\n\t  let sub = 0;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n\t  if (value < 0) value = 0xff + value + 1;\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\t  this[offset] = (value >>> 8);\n\t  this[offset + 1] = (value & 0xff);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  this[offset + 2] = (value >>> 16);\n\t  this[offset + 3] = (value >>> 24);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\t  if (value < 0) value = 0xffffffff + value + 1;\n\t  this[offset] = (value >>> 24);\n\t  this[offset + 1] = (value >>> 16);\n\t  this[offset + 2] = (value >>> 8);\n\t  this[offset + 3] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n\t  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n\t  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n\t});\n\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4);\n\t  }\n\t  ieee754$1.write(buf, value, offset, littleEndian, 23, 4);\n\t  return offset + 4\n\t}\n\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t};\n\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8);\n\t  }\n\t  ieee754$1.write(buf, value, offset, littleEndian, 52, 8);\n\t  return offset + 8\n\t}\n\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t};\n\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n\t  if (!start) start = 0;\n\t  if (!end && end !== 0) end = this.length;\n\t  if (targetStart >= target.length) targetStart = target.length;\n\t  if (!targetStart) targetStart = 0;\n\t  if (end > 0 && end < start) end = start;\n\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length;\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start;\n\t  }\n\n\t  const len = end - start;\n\n\t  if (this === target && typeof GlobalUint8Array.prototype.copyWithin === 'function') {\n\t    // Use built-in when available, missing from IE11\n\t    this.copyWithin(targetStart, start, end);\n\t  } else {\n\t    GlobalUint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, end),\n\t      targetStart\n\t    );\n\t  }\n\n\t  return len\n\t};\n\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start;\n\t      start = 0;\n\t      end = this.length;\n\t    } else if (typeof end === 'string') {\n\t      encoding = end;\n\t      end = this.length;\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t    if (val.length === 1) {\n\t      const code = val.charCodeAt(0);\n\t      if ((encoding === 'utf8' && code < 128) ||\n\t          encoding === 'latin1') {\n\t        // Fast path: If `val` fits into a single byte, use that numeric value.\n\t        val = code;\n\t      }\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255;\n\t  } else if (typeof val === 'boolean') {\n\t    val = Number(val);\n\t  }\n\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\n\t  if (end <= start) {\n\t    return this\n\t  }\n\n\t  start = start >>> 0;\n\t  end = end === undefined ? this.length : end >>> 0;\n\n\t  if (!val) val = 0;\n\n\t  let i;\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val;\n\t    }\n\t  } else {\n\t    const bytes = Buffer.isBuffer(val)\n\t      ? val\n\t      : Buffer.from(val, encoding);\n\t    const len = bytes.length;\n\t    if (len === 0) {\n\t      throw new TypeError('The value \"' + val +\n\t        '\" is invalid for argument \"value\"')\n\t    }\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len];\n\t    }\n\t  }\n\n\t  return this\n\t};\n\n\t// CUSTOM ERRORS\n\t// =============\n\n\t// Simplified versions from Node, changed for Buffer-only usage\n\tconst errors = {};\n\tfunction E (sym, getMessage, Base) {\n\t  errors[sym] = class NodeError extends Base {\n\t    constructor () {\n\t      super();\n\n\t      Object.defineProperty(this, 'message', {\n\t        value: getMessage.apply(this, arguments),\n\t        writable: true,\n\t        configurable: true\n\t      });\n\n\t      // Add the error code to the name to include it in the stack trace.\n\t      this.name = `${this.name} [${sym}]`;\n\t      // Access the stack to generate the error message including the error code\n\t      // from the name.\n\t      this.stack; // eslint-disable-line no-unused-expressions\n\t      // Reset the name to the actual name.\n\t      delete this.name;\n\t    }\n\n\t    get code () {\n\t      return sym\n\t    }\n\n\t    set code (value) {\n\t      Object.defineProperty(this, 'code', {\n\t        configurable: true,\n\t        enumerable: true,\n\t        value,\n\t        writable: true\n\t      });\n\t    }\n\n\t    toString () {\n\t      return `${this.name} [${sym}]: ${this.message}`\n\t    }\n\t  };\n\t}\n\n\tE('ERR_BUFFER_OUT_OF_BOUNDS',\n\t  function (name) {\n\t    if (name) {\n\t      return `${name} is outside of buffer bounds`\n\t    }\n\n\t    return 'Attempt to access memory outside buffer bounds'\n\t  }, RangeError);\n\tE('ERR_INVALID_ARG_TYPE',\n\t  function (name, actual) {\n\t    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n\t  }, TypeError);\n\tE('ERR_OUT_OF_RANGE',\n\t  function (str, range, input) {\n\t    let msg = `The value of \"${str}\" is out of range.`;\n\t    let received = input;\n\t    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n\t      received = addNumericalSeparator(String(input));\n\t    } else if (typeof input === 'bigint') {\n\t      received = String(input);\n\t      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n\t        received = addNumericalSeparator(received);\n\t      }\n\t      received += 'n';\n\t    }\n\t    msg += ` It must be ${range}. Received ${received}`;\n\t    return msg\n\t  }, RangeError);\n\n\tfunction addNumericalSeparator (val) {\n\t  let res = '';\n\t  let i = val.length;\n\t  const start = val[0] === '-' ? 1 : 0;\n\t  for (; i >= start + 4; i -= 3) {\n\t    res = `_${val.slice(i - 3, i)}${res}`;\n\t  }\n\t  return `${val.slice(0, i)}${res}`\n\t}\n\n\t// CHECK FUNCTIONS\n\t// ===============\n\n\tfunction checkBounds (buf, offset, byteLength) {\n\t  validateNumber(offset, 'offset');\n\t  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n\t    boundsError(offset, buf.length - (byteLength + 1));\n\t  }\n\t}\n\n\tfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n\t  if (value > max || value < min) {\n\t    const n = typeof min === 'bigint' ? 'n' : '';\n\t    let range;\n\t    if (byteLength > 3) {\n\t      if (min === 0 || min === BigInt(0)) {\n\t        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n\t      } else {\n\t        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n\t                `${(byteLength + 1) * 8 - 1}${n}`;\n\t      }\n\t    } else {\n\t      range = `>= ${min}${n} and <= ${max}${n}`;\n\t    }\n\t    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n\t  }\n\t  checkBounds(buf, offset, byteLength);\n\t}\n\n\tfunction validateNumber (value, name) {\n\t  if (typeof value !== 'number') {\n\t    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n\t  }\n\t}\n\n\tfunction boundsError (value, length, type) {\n\t  if (Math.floor(value) !== value) {\n\t    validateNumber(value, type);\n\t    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n\t  }\n\n\t  if (length < 0) {\n\t    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n\t  }\n\n\t  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n\t                                    `>= ${type ? 1 : 0} and <= ${length}`,\n\t                                    value)\n\t}\n\n\t// HELPER FUNCTIONS\n\t// ================\n\n\tconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\n\tfunction base64clean (str) {\n\t  // Node takes equal signs as end of the Base64 encoding\n\t  str = str.split('=')[0];\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = str.trim().replace(INVALID_BASE64_RE, '');\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '=';\n\t  }\n\t  return str\n\t}\n\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity;\n\t  let codePoint;\n\t  const length = string.length;\n\t  let leadSurrogate = null;\n\t  const bytes = [];\n\n\t  for (let i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i);\n\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        }\n\n\t        // valid lead\n\t        leadSurrogate = codePoint;\n\n\t        continue\n\t      }\n\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t        leadSurrogate = codePoint;\n\t        continue\n\t      }\n\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t    }\n\n\t    leadSurrogate = null;\n\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint);\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\n\t  return bytes\n\t}\n\n\tfunction asciiToBytes (str) {\n\t  const byteArray = [];\n\t  for (let i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF);\n\t  }\n\t  return byteArray\n\t}\n\n\tfunction utf16leToBytes (str, units) {\n\t  let c, hi, lo;\n\t  const byteArray = [];\n\t  for (let i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\n\t    c = str.charCodeAt(i);\n\t    hi = c >> 8;\n\t    lo = c % 256;\n\t    byteArray.push(lo);\n\t    byteArray.push(hi);\n\t  }\n\n\t  return byteArray\n\t}\n\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  let i;\n\t  for (i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i];\n\t  }\n\t  return i\n\t}\n\n\t// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n\t// the `instanceof` check but they should be treated as of that type.\n\t// See: https://github.com/feross/buffer/issues/166\n\tfunction isInstance (obj, type) {\n\t  return obj instanceof type ||\n\t    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n\t      obj.constructor.name === type.name)\n\t}\n\tfunction numberIsNaN (obj) {\n\t  // For IE11 support\n\t  return obj !== obj // eslint-disable-line no-self-compare\n\t}\n\n\t// Create lookup table for `toString('hex')`\n\t// See: https://github.com/feross/buffer/issues/219\n\tconst hexSliceLookupTable = (function () {\n\t  const alphabet = '0123456789abcdef';\n\t  const table = new Array(256);\n\t  for (let i = 0; i < 16; ++i) {\n\t    const i16 = i * 16;\n\t    for (let j = 0; j < 16; ++j) {\n\t      table[i16 + j] = alphabet[i] + alphabet[j];\n\t    }\n\t  }\n\t  return table\n\t})();\n\n\t// Return not function with Error if BigInt not supported\n\tfunction defineBigIntMethod (fn) {\n\t  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n\t}\n\n\tfunction BufferBigIntNotDefined () {\n\t  throw new Error('BigInt not supported')\n\t} \n} (buffer));\n\nconst Buffer = buffer.Buffer;\n\nconst Blob = buffer.Blob;\nconst BlobOptions = buffer.BlobOptions;\nconst Buffer$1 = buffer.Buffer;\nconst File = buffer.File;\nconst FileOptions = buffer.FileOptions;\nconst INSPECT_MAX_BYTES = buffer.INSPECT_MAX_BYTES;\nconst SlowBuffer = buffer.SlowBuffer;\nconst TranscodeEncoding = buffer.TranscodeEncoding;\nconst atob = buffer.atob;\nconst btoa = buffer.btoa;\nconst constants = buffer.constants;\nconst isAscii = buffer.isAscii;\nconst isUtf8 = buffer.isUtf8;\nconst kMaxLength = buffer.kMaxLength;\nconst kStringMaxLength = buffer.kStringMaxLength;\nconst resolveObjectURL = buffer.resolveObjectURL;\nconst transcode = buffer.transcode;\nexport { Blob, BlobOptions, Buffer$1 as Buffer, File, FileOptions, INSPECT_MAX_BYTES, SlowBuffer, TranscodeEncoding, atob, btoa, constants, Buffer as default, isAscii, isUtf8, kMaxLength, kStringMaxLength, resolveObjectURL, transcode };\n//# sourceMappingURL=index.js.map\n","'use strict';\n\nObject.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: 'Module' } });\n\nvar buffer = {};\n\nvar base64Js = {};\n\nbase64Js.byteLength = byteLength;\nbase64Js.toByteArray = toByteArray;\nbase64Js.fromByteArray = fromByteArray;\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens (b64) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4);\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n\n  var curByte = 0;\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen;\n\n  var i;\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = (tmp >> 16) & 0xFF;\n    arr[curByte++] = (tmp >> 8) & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[curByte++] = (tmp >> 8) & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    );\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    );\n  }\n\n  return parts.join('')\n}\n\nvar ieee754 = {};\n\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n\nieee754.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = (nBytes * 8) - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? (nBytes - 1) : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n};\n\nieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = (nBytes * 8) - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n  var i = isLE ? 0 : (nBytes - 1);\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n(function (exports) {\n\n\tconst base64 = base64Js;\n\tconst ieee754$1 = ieee754;\n\tconst customInspectSymbol =\n\t  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n\t    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n\t    : null;\n\n\texports.Buffer = Buffer;\n\texports.SlowBuffer = SlowBuffer;\n\texports.INSPECT_MAX_BYTES = 50;\n\n\tconst K_MAX_LENGTH = 0x7fffffff;\n\texports.kMaxLength = K_MAX_LENGTH;\n\tconst { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n\t *               implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * We report that the browser does not support typed arrays if the are not subclassable\n\t * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n\t * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n\t * for __proto__ and has a buggy typed array implementation.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\n\tif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n\t    typeof console.error === 'function') {\n\t  console.error(\n\t    'This browser lacks typed array (Uint8Array) support which is required by ' +\n\t    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n\t  );\n\t}\n\n\tfunction typedArraySupport () {\n\t  // Can typed array instances can be augmented?\n\t  try {\n\t    const arr = new GlobalUint8Array(1);\n\t    const proto = { foo: function () { return 42 } };\n\t    Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n\t    Object.setPrototypeOf(arr, proto);\n\t    return arr.foo() === 42\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\n\tObject.defineProperty(Buffer.prototype, 'parent', {\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!Buffer.isBuffer(this)) return undefined\n\t    return this.buffer\n\t  }\n\t});\n\n\tObject.defineProperty(Buffer.prototype, 'offset', {\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!Buffer.isBuffer(this)) return undefined\n\t    return this.byteOffset\n\t  }\n\t});\n\n\tfunction createBuffer (length) {\n\t  if (length > K_MAX_LENGTH) {\n\t    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n\t  }\n\t  // Return an augmented `Uint8Array` instance\n\t  const buf = new GlobalUint8Array(length);\n\t  Object.setPrototypeOf(buf, Buffer.prototype);\n\t  return buf\n\t}\n\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new TypeError(\n\t        'The \"string\" argument must be of type string. Received type number'\n\t      )\n\t    }\n\t    return allocUnsafe(arg)\n\t  }\n\t  return from(arg, encodingOrOffset, length)\n\t}\n\n\tBuffer.poolSize = 8192; // not used by this implementation\n\n\tfunction from (value, encodingOrOffset, length) {\n\t  if (typeof value === 'string') {\n\t    return fromString(value, encodingOrOffset)\n\t  }\n\n\t  if (GlobalArrayBuffer.isView(value)) {\n\t    return fromArrayView(value)\n\t  }\n\n\t  if (value == null) {\n\t    throw new TypeError(\n\t      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n\t      'or Array-like Object. Received type ' + (typeof value)\n\t    )\n\t  }\n\n\t  if (isInstance(value, GlobalArrayBuffer) ||\n\t      (value && isInstance(value.buffer, GlobalArrayBuffer))) {\n\t    return fromArrayBuffer(value, encodingOrOffset, length)\n\t  }\n\n\t  if (typeof GlobalSharedArrayBuffer !== 'undefined' &&\n\t      (isInstance(value, GlobalSharedArrayBuffer) ||\n\t      (value && isInstance(value.buffer, GlobalSharedArrayBuffer)))) {\n\t    return fromArrayBuffer(value, encodingOrOffset, length)\n\t  }\n\n\t  if (typeof value === 'number') {\n\t    throw new TypeError(\n\t      'The \"value\" argument must not be of type number. Received type number'\n\t    )\n\t  }\n\n\t  const valueOf = value.valueOf && value.valueOf();\n\t  if (valueOf != null && valueOf !== value) {\n\t    return Buffer.from(valueOf, encodingOrOffset, length)\n\t  }\n\n\t  const b = fromObject(value);\n\t  if (b) return b\n\n\t  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n\t      typeof value[Symbol.toPrimitive] === 'function') {\n\t    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n\t  }\n\n\t  throw new TypeError(\n\t    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n\t    'or Array-like Object. Received type ' + (typeof value)\n\t  )\n\t}\n\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(value, encodingOrOffset, length)\n\t};\n\n\t// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n\t// https://github.com/feross/buffer/pull/148\n\tObject.setPrototypeOf(Buffer.prototype, GlobalUint8Array.prototype);\n\tObject.setPrototypeOf(Buffer, GlobalUint8Array);\n\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be of type number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n\t  }\n\t}\n\n\tfunction alloc (size, fill, encoding) {\n\t  assertSize(size);\n\t  if (size <= 0) {\n\t    return createBuffer(size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpreted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(size).fill(fill, encoding)\n\t      : createBuffer(size).fill(fill)\n\t  }\n\t  return createBuffer(size)\n\t}\n\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(size, fill, encoding)\n\t};\n\n\tfunction allocUnsafe (size) {\n\t  assertSize(size);\n\t  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n\t}\n\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(size)\n\t};\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(size)\n\t};\n\n\tfunction fromString (string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8';\n\t  }\n\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('Unknown encoding: ' + encoding)\n\t  }\n\n\t  const length = byteLength(string, encoding) | 0;\n\t  let buf = createBuffer(length);\n\n\t  const actual = buf.write(string, encoding);\n\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    buf = buf.slice(0, actual);\n\t  }\n\n\t  return buf\n\t}\n\n\tfunction fromArrayLike (array) {\n\t  const length = array.length < 0 ? 0 : checked(array.length) | 0;\n\t  const buf = createBuffer(length);\n\t  for (let i = 0; i < length; i += 1) {\n\t    buf[i] = array[i] & 255;\n\t  }\n\t  return buf\n\t}\n\n\tfunction fromArrayView (arrayView) {\n\t  if (isInstance(arrayView, GlobalUint8Array)) {\n\t    const copy = new GlobalUint8Array(arrayView);\n\t    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n\t  }\n\t  return fromArrayLike(arrayView)\n\t}\n\n\tfunction fromArrayBuffer (array, byteOffset, length) {\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\"offset\" is outside of buffer bounds')\n\t  }\n\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\"length\" is outside of buffer bounds')\n\t  }\n\n\t  let buf;\n\t  if (byteOffset === undefined && length === undefined) {\n\t    buf = new GlobalUint8Array(array);\n\t  } else if (length === undefined) {\n\t    buf = new GlobalUint8Array(array, byteOffset);\n\t  } else {\n\t    buf = new GlobalUint8Array(array, byteOffset, length);\n\t  }\n\n\t  // Return an augmented `Uint8Array` instance\n\t  Object.setPrototypeOf(buf, Buffer.prototype);\n\n\t  return buf\n\t}\n\n\tfunction fromObject (obj) {\n\t  if (Buffer.isBuffer(obj)) {\n\t    const len = checked(obj.length) | 0;\n\t    const buf = createBuffer(len);\n\n\t    if (buf.length === 0) {\n\t      return buf\n\t    }\n\n\t    obj.copy(buf, 0, 0, len);\n\t    return buf\n\t  }\n\n\t  if (obj.length !== undefined) {\n\t    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n\t      return createBuffer(0)\n\t    }\n\t    return fromArrayLike(obj)\n\t  }\n\n\t  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n\t    return fromArrayLike(obj.data)\n\t  }\n\t}\n\n\tfunction checked (length) {\n\t  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= K_MAX_LENGTH) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\n\tfunction SlowBuffer (length) {\n\t  if (+length != length) { // eslint-disable-line eqeqeq\n\t    length = 0;\n\t  }\n\t  return Buffer.alloc(+length)\n\t}\n\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return b != null && b._isBuffer === true &&\n\t    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n\t};\n\n\tBuffer.compare = function compare (a, b) {\n\t  if (isInstance(a, GlobalUint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n\t  if (isInstance(b, GlobalUint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError(\n\t      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n\t    )\n\t  }\n\n\t  if (a === b) return 0\n\n\t  let x = a.length;\n\t  let y = b.length;\n\n\t  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i];\n\t      y = b[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t};\n\n\tBuffer.concat = function concat (list, length) {\n\t  if (!Array.isArray(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\n\t  let i;\n\t  if (length === undefined) {\n\t    length = 0;\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length;\n\t    }\n\t  }\n\n\t  const buffer = Buffer.allocUnsafe(length);\n\t  let pos = 0;\n\t  for (i = 0; i < list.length; ++i) {\n\t    let buf = list[i];\n\t    if (isInstance(buf, GlobalUint8Array)) {\n\t      if (pos + buf.length > buffer.length) {\n\t        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);\n\t        buf.copy(buffer, pos);\n\t      } else {\n\t        GlobalUint8Array.prototype.set.call(\n\t          buffer,\n\t          buf,\n\t          pos\n\t        );\n\t      }\n\t    } else if (!Buffer.isBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    } else {\n\t      buf.copy(buffer, pos);\n\t    }\n\t    pos += buf.length;\n\t  }\n\t  return buffer\n\t};\n\n\tfunction byteLength (string, encoding) {\n\t  if (Buffer.isBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    throw new TypeError(\n\t      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n\t      'Received type ' + typeof string\n\t    )\n\t  }\n\n\t  const len = string.length;\n\t  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n\t  if (!mustMatch && len === 0) return 0\n\n\t  // Use a for loop to avoid recursion\n\t  let loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) {\n\t          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n\t        }\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength;\n\n\tfunction slowToString (encoding, start, end) {\n\t  let loweredCase = false;\n\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0;\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length;\n\t  }\n\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\n\t  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0;\n\t  start >>>= 0;\n\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\n\t// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n\t// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n\t// reliably in a browserify context because there could be multiple different\n\t// copies of the 'buffer' package in use. This method works even for Buffer\n\t// instances that were created from another copy of the `buffer` package.\n\t// See: https://github.com/feross/buffer/issues/154\n\tBuffer.prototype._isBuffer = true;\n\n\tfunction swap (b, n, m) {\n\t  const i = b[n];\n\t  b[n] = b[m];\n\t  b[m] = i;\n\t}\n\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  const len = this.length;\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  const len = this.length;\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3);\n\t    swap(this, i + 1, i + 2);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  const len = this.length;\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7);\n\t    swap(this, i + 1, i + 6);\n\t    swap(this, i + 2, i + 5);\n\t    swap(this, i + 3, i + 4);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.toString = function toString () {\n\t  const length = this.length;\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t};\n\n\tBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t};\n\n\tBuffer.prototype.inspect = function inspect () {\n\t  let str = '';\n\t  const max = exports.INSPECT_MAX_BYTES;\n\t  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n\t  if (this.length > max) str += ' ... ';\n\t  return '<Buffer ' + str + '>'\n\t};\n\tif (customInspectSymbol) {\n\t  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;\n\t}\n\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (isInstance(target, GlobalUint8Array)) {\n\t    target = Buffer.from(target, target.offset, target.byteLength);\n\t  }\n\t  if (!Buffer.isBuffer(target)) {\n\t    throw new TypeError(\n\t      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n\t      'Received type ' + (typeof target)\n\t    )\n\t  }\n\n\t  if (start === undefined) {\n\t    start = 0;\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0;\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0;\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length;\n\t  }\n\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\n\t  start >>>= 0;\n\t  end >>>= 0;\n\t  thisStart >>>= 0;\n\t  thisEnd >>>= 0;\n\n\t  if (this === target) return 0\n\n\t  let x = thisEnd - thisStart;\n\t  let y = end - start;\n\t  const len = Math.min(x, y);\n\n\t  const thisCopy = this.slice(thisStart, thisEnd);\n\t  const targetCopy = target.slice(start, end);\n\n\t  for (let i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i];\n\t      y = targetCopy[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset;\n\t    byteOffset = 0;\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff;\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000;\n\t  }\n\t  byteOffset = +byteOffset; // Coerce to Number.\n\t  if (numberIsNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1);\n\t  }\n\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1;\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0;\n\t    else return -1\n\t  }\n\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding);\n\t  }\n\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (Buffer.isBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF; // Search for a byte value [0-255]\n\t    if (typeof GlobalUint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n\t  }\n\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  let indexSize = 1;\n\t  let arrLength = arr.length;\n\t  let valLength = val.length;\n\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase();\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2;\n\t      arrLength /= 2;\n\t      valLength /= 2;\n\t      byteOffset /= 2;\n\t    }\n\t  }\n\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\n\t  let i;\n\t  if (dir) {\n\t    let foundIndex = -1;\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i;\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex;\n\t        foundIndex = -1;\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      let found = true;\n\t      for (let j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false;\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\n\t  return -1\n\t}\n\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t};\n\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t};\n\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t};\n\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0;\n\t  const remaining = buf.length - offset;\n\t  if (!length) {\n\t    length = remaining;\n\t  } else {\n\t    length = Number(length);\n\t    if (length > remaining) {\n\t      length = remaining;\n\t    }\n\t  }\n\n\t  const strLen = string.length;\n\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2;\n\t  }\n\t  let i;\n\t  for (i = 0; i < length; ++i) {\n\t    const parsed = parseInt(string.substr(i * 2, 2), 16);\n\t    if (numberIsNaN(parsed)) return i\n\t    buf[offset + i] = parsed;\n\t  }\n\t  return i\n\t}\n\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8';\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset;\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset >>> 0;\n\t    if (isFinite(length)) {\n\t      length = length >>> 0;\n\t      if (encoding === undefined) encoding = 'utf8';\n\t    } else {\n\t      encoding = length;\n\t      length = undefined;\n\t    }\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\n\t  const remaining = this.length - offset;\n\t  if (length === undefined || length > remaining) length = remaining;\n\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  let loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return asciiWrite(this, string, offset, length)\n\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t};\n\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t};\n\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end);\n\t  const res = [];\n\n\t  let i = start;\n\t  while (i < end) {\n\t    const firstByte = buf[i];\n\t    let codePoint = null;\n\t    let bytesPerSequence = (firstByte > 0xEF)\n\t      ? 4\n\t      : (firstByte > 0xDF)\n\t          ? 3\n\t          : (firstByte > 0xBF)\n\t              ? 2\n\t              : 1;\n\n\t    if (i + bytesPerSequence <= end) {\n\t      let secondByte, thirdByte, fourthByte, tempCodePoint;\n\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte;\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1];\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          fourthByte = buf[i + 3];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t      }\n\t    }\n\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD;\n\t      bytesPerSequence = 1;\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000;\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n\t      codePoint = 0xDC00 | codePoint & 0x3FF;\n\t    }\n\n\t    res.push(codePoint);\n\t    i += bytesPerSequence;\n\t  }\n\n\t  return decodeCodePointsArray(res)\n\t}\n\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tconst MAX_ARGUMENTS_LENGTH = 0x1000;\n\n\tfunction decodeCodePointsArray (codePoints) {\n\t  const len = codePoints.length;\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  let res = '';\n\t  let i = 0;\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    );\n\t  }\n\t  return res\n\t}\n\n\tfunction asciiSlice (buf, start, end) {\n\t  let ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (let i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F);\n\t  }\n\t  return ret\n\t}\n\n\tfunction latin1Slice (buf, start, end) {\n\t  let ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (let i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i]);\n\t  }\n\t  return ret\n\t}\n\n\tfunction hexSlice (buf, start, end) {\n\t  const len = buf.length;\n\n\t  if (!start || start < 0) start = 0;\n\t  if (!end || end < 0 || end > len) end = len;\n\n\t  let out = '';\n\t  for (let i = start; i < end; ++i) {\n\t    out += hexSliceLookupTable[buf[i]];\n\t  }\n\t  return out\n\t}\n\n\tfunction utf16leSlice (buf, start, end) {\n\t  const bytes = buf.slice(start, end);\n\t  let res = '';\n\t  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n\t  for (let i = 0; i < bytes.length - 1; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));\n\t  }\n\t  return res\n\t}\n\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  const len = this.length;\n\t  start = ~~start;\n\t  end = end === undefined ? len : ~~end;\n\n\t  if (start < 0) {\n\t    start += len;\n\t    if (start < 0) start = 0;\n\t  } else if (start > len) {\n\t    start = len;\n\t  }\n\n\t  if (end < 0) {\n\t    end += len;\n\t    if (end < 0) end = 0;\n\t  } else if (end > len) {\n\t    end = len;\n\t  }\n\n\t  if (end < start) end = start;\n\n\t  const newBuf = this.subarray(start, end);\n\t  // Return an augmented `Uint8Array` instance\n\t  Object.setPrototypeOf(newBuf, Buffer.prototype);\n\n\t  return newBuf\n\t};\n\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\n\tBuffer.prototype.readUintLE =\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let val = this[offset];\n\t  let mul = 1;\n\t  let i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readUintBE =\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length);\n\t  }\n\n\t  let val = this[offset + --byteLength];\n\t  let mul = 1;\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readUint8 =\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  return this[offset]\n\t};\n\n\tBuffer.prototype.readUint16LE =\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return this[offset] | (this[offset + 1] << 8)\n\t};\n\n\tBuffer.prototype.readUint16BE =\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return (this[offset] << 8) | this[offset + 1]\n\t};\n\n\tBuffer.prototype.readUint32LE =\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t};\n\n\tBuffer.prototype.readUint32BE =\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t};\n\n\tBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const lo = first +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 24;\n\n\t  const hi = this[++offset] +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    last * 2 ** 24;\n\n\t  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n\t});\n\n\tBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const hi = first * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset];\n\n\t  const lo = this[++offset] * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    last;\n\n\t  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n\t});\n\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let val = this[offset];\n\t  let mul = 1;\n\t  let i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let i = byteLength;\n\t  let mul = 1;\n\t  let val = this[offset + --i];\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t};\n\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  const val = this[offset] | (this[offset + 1] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  const val = this[offset + 1] | (this[offset] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t};\n\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t};\n\n\tBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const val = this[offset + 4] +\n\t    this[offset + 5] * 2 ** 8 +\n\t    this[offset + 6] * 2 ** 16 +\n\t    (last << 24); // Overflow\n\n\t  return (BigInt(val) << BigInt(32)) +\n\t    BigInt(first +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 24)\n\t});\n\n\tBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const val = (first << 24) + // Overflow\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset];\n\n\t  return (BigInt(val) << BigInt(32)) +\n\t    BigInt(this[++offset] * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    last)\n\t});\n\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return ieee754$1.read(this, offset, true, 23, 4)\n\t};\n\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return ieee754$1.read(this, offset, false, 23, 4)\n\t};\n\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return ieee754$1.read(this, offset, true, 52, 8)\n\t};\n\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return ieee754$1.read(this, offset, false, 52, 8)\n\t};\n\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\n\tBuffer.prototype.writeUintLE =\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  let mul = 1;\n\t  let i = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeUintBE =\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  let i = byteLength - 1;\n\t  let mul = 1;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeUint8 =\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tBuffer.prototype.writeUint16LE =\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeUint16BE =\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  this[offset] = (value >>> 8);\n\t  this[offset + 1] = (value & 0xff);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeUint32LE =\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  this[offset + 3] = (value >>> 24);\n\t  this[offset + 2] = (value >>> 16);\n\t  this[offset + 1] = (value >>> 8);\n\t  this[offset] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeUint32BE =\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  this[offset] = (value >>> 24);\n\t  this[offset + 1] = (value >>> 16);\n\t  this[offset + 2] = (value >>> 8);\n\t  this[offset + 3] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n\t  checkIntBI(value, min, max, buf, offset, 7);\n\n\t  let lo = Number(value & BigInt(0xffffffff));\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  return offset\n\t}\n\n\tfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n\t  checkIntBI(value, min, max, buf, offset, 7);\n\n\t  let lo = Number(value & BigInt(0xffffffff));\n\t  buf[offset + 7] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 6] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 5] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 4] = lo;\n\t  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n\t  buf[offset + 3] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset + 2] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset + 1] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset] = hi;\n\t  return offset + 8\n\t}\n\n\tBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n\t  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n\t  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    const limit = Math.pow(2, (8 * byteLength) - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  let i = 0;\n\t  let mul = 1;\n\t  let sub = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    const limit = Math.pow(2, (8 * byteLength) - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  let i = byteLength - 1;\n\t  let mul = 1;\n\t  let sub = 0;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n\t  if (value < 0) value = 0xff + value + 1;\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\t  this[offset] = (value >>> 8);\n\t  this[offset + 1] = (value & 0xff);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  this[offset + 2] = (value >>> 16);\n\t  this[offset + 3] = (value >>> 24);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\t  if (value < 0) value = 0xffffffff + value + 1;\n\t  this[offset] = (value >>> 24);\n\t  this[offset + 1] = (value >>> 16);\n\t  this[offset + 2] = (value >>> 8);\n\t  this[offset + 3] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n\t  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n\t  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n\t});\n\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4);\n\t  }\n\t  ieee754$1.write(buf, value, offset, littleEndian, 23, 4);\n\t  return offset + 4\n\t}\n\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t};\n\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8);\n\t  }\n\t  ieee754$1.write(buf, value, offset, littleEndian, 52, 8);\n\t  return offset + 8\n\t}\n\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t};\n\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n\t  if (!start) start = 0;\n\t  if (!end && end !== 0) end = this.length;\n\t  if (targetStart >= target.length) targetStart = target.length;\n\t  if (!targetStart) targetStart = 0;\n\t  if (end > 0 && end < start) end = start;\n\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length;\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start;\n\t  }\n\n\t  const len = end - start;\n\n\t  if (this === target && typeof GlobalUint8Array.prototype.copyWithin === 'function') {\n\t    // Use built-in when available, missing from IE11\n\t    this.copyWithin(targetStart, start, end);\n\t  } else {\n\t    GlobalUint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, end),\n\t      targetStart\n\t    );\n\t  }\n\n\t  return len\n\t};\n\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start;\n\t      start = 0;\n\t      end = this.length;\n\t    } else if (typeof end === 'string') {\n\t      encoding = end;\n\t      end = this.length;\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t    if (val.length === 1) {\n\t      const code = val.charCodeAt(0);\n\t      if ((encoding === 'utf8' && code < 128) ||\n\t          encoding === 'latin1') {\n\t        // Fast path: If `val` fits into a single byte, use that numeric value.\n\t        val = code;\n\t      }\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255;\n\t  } else if (typeof val === 'boolean') {\n\t    val = Number(val);\n\t  }\n\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\n\t  if (end <= start) {\n\t    return this\n\t  }\n\n\t  start = start >>> 0;\n\t  end = end === undefined ? this.length : end >>> 0;\n\n\t  if (!val) val = 0;\n\n\t  let i;\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val;\n\t    }\n\t  } else {\n\t    const bytes = Buffer.isBuffer(val)\n\t      ? val\n\t      : Buffer.from(val, encoding);\n\t    const len = bytes.length;\n\t    if (len === 0) {\n\t      throw new TypeError('The value \"' + val +\n\t        '\" is invalid for argument \"value\"')\n\t    }\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len];\n\t    }\n\t  }\n\n\t  return this\n\t};\n\n\t// CUSTOM ERRORS\n\t// =============\n\n\t// Simplified versions from Node, changed for Buffer-only usage\n\tconst errors = {};\n\tfunction E (sym, getMessage, Base) {\n\t  errors[sym] = class NodeError extends Base {\n\t    constructor () {\n\t      super();\n\n\t      Object.defineProperty(this, 'message', {\n\t        value: getMessage.apply(this, arguments),\n\t        writable: true,\n\t        configurable: true\n\t      });\n\n\t      // Add the error code to the name to include it in the stack trace.\n\t      this.name = `${this.name} [${sym}]`;\n\t      // Access the stack to generate the error message including the error code\n\t      // from the name.\n\t      this.stack; // eslint-disable-line no-unused-expressions\n\t      // Reset the name to the actual name.\n\t      delete this.name;\n\t    }\n\n\t    get code () {\n\t      return sym\n\t    }\n\n\t    set code (value) {\n\t      Object.defineProperty(this, 'code', {\n\t        configurable: true,\n\t        enumerable: true,\n\t        value,\n\t        writable: true\n\t      });\n\t    }\n\n\t    toString () {\n\t      return `${this.name} [${sym}]: ${this.message}`\n\t    }\n\t  };\n\t}\n\n\tE('ERR_BUFFER_OUT_OF_BOUNDS',\n\t  function (name) {\n\t    if (name) {\n\t      return `${name} is outside of buffer bounds`\n\t    }\n\n\t    return 'Attempt to access memory outside buffer bounds'\n\t  }, RangeError);\n\tE('ERR_INVALID_ARG_TYPE',\n\t  function (name, actual) {\n\t    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n\t  }, TypeError);\n\tE('ERR_OUT_OF_RANGE',\n\t  function (str, range, input) {\n\t    let msg = `The value of \"${str}\" is out of range.`;\n\t    let received = input;\n\t    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n\t      received = addNumericalSeparator(String(input));\n\t    } else if (typeof input === 'bigint') {\n\t      received = String(input);\n\t      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n\t        received = addNumericalSeparator(received);\n\t      }\n\t      received += 'n';\n\t    }\n\t    msg += ` It must be ${range}. Received ${received}`;\n\t    return msg\n\t  }, RangeError);\n\n\tfunction addNumericalSeparator (val) {\n\t  let res = '';\n\t  let i = val.length;\n\t  const start = val[0] === '-' ? 1 : 0;\n\t  for (; i >= start + 4; i -= 3) {\n\t    res = `_${val.slice(i - 3, i)}${res}`;\n\t  }\n\t  return `${val.slice(0, i)}${res}`\n\t}\n\n\t// CHECK FUNCTIONS\n\t// ===============\n\n\tfunction checkBounds (buf, offset, byteLength) {\n\t  validateNumber(offset, 'offset');\n\t  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n\t    boundsError(offset, buf.length - (byteLength + 1));\n\t  }\n\t}\n\n\tfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n\t  if (value > max || value < min) {\n\t    const n = typeof min === 'bigint' ? 'n' : '';\n\t    let range;\n\t    if (byteLength > 3) {\n\t      if (min === 0 || min === BigInt(0)) {\n\t        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n\t      } else {\n\t        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n\t                `${(byteLength + 1) * 8 - 1}${n}`;\n\t      }\n\t    } else {\n\t      range = `>= ${min}${n} and <= ${max}${n}`;\n\t    }\n\t    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n\t  }\n\t  checkBounds(buf, offset, byteLength);\n\t}\n\n\tfunction validateNumber (value, name) {\n\t  if (typeof value !== 'number') {\n\t    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n\t  }\n\t}\n\n\tfunction boundsError (value, length, type) {\n\t  if (Math.floor(value) !== value) {\n\t    validateNumber(value, type);\n\t    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n\t  }\n\n\t  if (length < 0) {\n\t    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n\t  }\n\n\t  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n\t                                    `>= ${type ? 1 : 0} and <= ${length}`,\n\t                                    value)\n\t}\n\n\t// HELPER FUNCTIONS\n\t// ================\n\n\tconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\n\tfunction base64clean (str) {\n\t  // Node takes equal signs as end of the Base64 encoding\n\t  str = str.split('=')[0];\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = str.trim().replace(INVALID_BASE64_RE, '');\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '=';\n\t  }\n\t  return str\n\t}\n\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity;\n\t  let codePoint;\n\t  const length = string.length;\n\t  let leadSurrogate = null;\n\t  const bytes = [];\n\n\t  for (let i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i);\n\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        }\n\n\t        // valid lead\n\t        leadSurrogate = codePoint;\n\n\t        continue\n\t      }\n\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t        leadSurrogate = codePoint;\n\t        continue\n\t      }\n\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t    }\n\n\t    leadSurrogate = null;\n\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint);\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\n\t  return bytes\n\t}\n\n\tfunction asciiToBytes (str) {\n\t  const byteArray = [];\n\t  for (let i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF);\n\t  }\n\t  return byteArray\n\t}\n\n\tfunction utf16leToBytes (str, units) {\n\t  let c, hi, lo;\n\t  const byteArray = [];\n\t  for (let i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\n\t    c = str.charCodeAt(i);\n\t    hi = c >> 8;\n\t    lo = c % 256;\n\t    byteArray.push(lo);\n\t    byteArray.push(hi);\n\t  }\n\n\t  return byteArray\n\t}\n\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  let i;\n\t  for (i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i];\n\t  }\n\t  return i\n\t}\n\n\t// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n\t// the `instanceof` check but they should be treated as of that type.\n\t// See: https://github.com/feross/buffer/issues/166\n\tfunction isInstance (obj, type) {\n\t  return obj instanceof type ||\n\t    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n\t      obj.constructor.name === type.name)\n\t}\n\tfunction numberIsNaN (obj) {\n\t  // For IE11 support\n\t  return obj !== obj // eslint-disable-line no-self-compare\n\t}\n\n\t// Create lookup table for `toString('hex')`\n\t// See: https://github.com/feross/buffer/issues/219\n\tconst hexSliceLookupTable = (function () {\n\t  const alphabet = '0123456789abcdef';\n\t  const table = new Array(256);\n\t  for (let i = 0; i < 16; ++i) {\n\t    const i16 = i * 16;\n\t    for (let j = 0; j < 16; ++j) {\n\t      table[i16 + j] = alphabet[i] + alphabet[j];\n\t    }\n\t  }\n\t  return table\n\t})();\n\n\t// Return not function with Error if BigInt not supported\n\tfunction defineBigIntMethod (fn) {\n\t  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n\t}\n\n\tfunction BufferBigIntNotDefined () {\n\t  throw new Error('BigInt not supported')\n\t} \n} (buffer));\n\nconst Buffer = buffer.Buffer;\n\nexports.Blob = buffer.Blob;\nexports.BlobOptions = buffer.BlobOptions;\nexports.Buffer = buffer.Buffer;\nexports.File = buffer.File;\nexports.FileOptions = buffer.FileOptions;\nexports.INSPECT_MAX_BYTES = buffer.INSPECT_MAX_BYTES;\nexports.SlowBuffer = buffer.SlowBuffer;\nexports.TranscodeEncoding = buffer.TranscodeEncoding;\nexports.atob = buffer.atob;\nexports.btoa = buffer.btoa;\nexports.constants = buffer.constants;\nexports.default = Buffer;\nexports.isAscii = buffer.isAscii;\nexports.isUtf8 = buffer.isUtf8;\nexports.kMaxLength = buffer.kMaxLength;\nexports.kStringMaxLength = buffer.kStringMaxLength;\nexports.resolveObjectURL = buffer.resolveObjectURL;\nexports.transcode = buffer.transcode;\n//# sourceMappingURL=index.cjs.map\n","var types = {\n  Array: function (value) { return value !== null && value !== undefined && value.constructor === Array },\n  Boolean: function (value) { return typeof value === 'boolean' },\n  Function: function (value) { return typeof value === 'function' },\n  Nil: function (value) { return value === undefined || value === null },\n  Number: function (value) { return typeof value === 'number' },\n  Object: function (value) { return typeof value === 'object' },\n  String: function (value) { return typeof value === 'string' },\n  '': function () { return true }\n}\n\n// TODO: deprecate\ntypes.Null = types.Nil\n\nfor (var typeName in types) {\n  types[typeName].toJSON = function (t) {\n    return t\n  }.bind(null, typeName)\n}\n\nmodule.exports = types\n","var native = require('./native')\n\nfunction getTypeName (fn) {\n  return fn.name || fn.toString().match(/function (.*?)\\s*\\(/)[1]\n}\n\nfunction getValueTypeName (value) {\n  return native.Nil(value) ? '' : getTypeName(value.constructor)\n}\n\nfunction getValue (value) {\n  if (native.Function(value)) return ''\n  if (native.String(value)) return JSON.stringify(value)\n  if (value && native.Object(value)) return ''\n  return value\n}\n\nfunction captureStackTrace (e, t) {\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(e, t)\n  }\n}\n\nfunction tfJSON (type) {\n  if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)\n  if (native.Array(type)) return 'Array'\n  if (type && native.Object(type)) return 'Object'\n\n  return type !== undefined ? type : ''\n}\n\nfunction tfErrorString (type, value, valueTypeName) {\n  var valueJson = getValue(value)\n\n  return 'Expected ' + tfJSON(type) + ', got' +\n    (valueTypeName !== '' ? ' ' + valueTypeName : '') +\n    (valueJson !== '' ? ' ' + valueJson : '')\n}\n\nfunction TfTypeError (type, value, valueTypeName) {\n  valueTypeName = valueTypeName || getValueTypeName(value)\n  this.message = tfErrorString(type, value, valueTypeName)\n\n  captureStackTrace(this, TfTypeError)\n  this.__type = type\n  this.__value = value\n  this.__valueTypeName = valueTypeName\n}\n\nTfTypeError.prototype = Object.create(Error.prototype)\nTfTypeError.prototype.constructor = TfTypeError\n\nfunction tfPropertyErrorString (type, label, name, value, valueTypeName) {\n  var description = '\" of type '\n  if (label === 'key') description = '\" with key type '\n\n  return tfErrorString('property \"' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)\n}\n\nfunction TfPropertyTypeError (type, property, label, value, valueTypeName) {\n  if (type) {\n    valueTypeName = valueTypeName || getValueTypeName(value)\n    this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)\n  } else {\n    this.message = 'Unexpected property \"' + property + '\"'\n  }\n\n  captureStackTrace(this, TfTypeError)\n  this.__label = label\n  this.__property = property\n  this.__type = type\n  this.__value = value\n  this.__valueTypeName = valueTypeName\n}\n\nTfPropertyTypeError.prototype = Object.create(Error.prototype)\nTfPropertyTypeError.prototype.constructor = TfTypeError\n\nfunction tfCustomError (expected, actual) {\n  return new TfTypeError(expected, {}, actual)\n}\n\nfunction tfSubError (e, property, label) {\n  // sub child?\n  if (e instanceof TfPropertyTypeError) {\n    property = property + '.' + e.__property\n\n    e = new TfPropertyTypeError(\n      e.__type, property, e.__label, e.__value, e.__valueTypeName\n    )\n\n  // child?\n  } else if (e instanceof TfTypeError) {\n    e = new TfPropertyTypeError(\n      e.__type, property, label, e.__value, e.__valueTypeName\n    )\n  }\n\n  captureStackTrace(e)\n  return e\n}\n\nmodule.exports = {\n  TfTypeError: TfTypeError,\n  TfPropertyTypeError: TfPropertyTypeError,\n  tfCustomError: tfCustomError,\n  tfSubError: tfSubError,\n  tfJSON: tfJSON,\n  getValueTypeName: getValueTypeName\n}\n","var NATIVE = require('./native')\nvar ERRORS = require('./errors')\n\nfunction _Buffer (value) {\n  return Buffer.isBuffer(value)\n}\n\nfunction Hex (value) {\n  return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)\n}\n\nfunction _LengthN (type, length) {\n  var name = type.toJSON()\n\n  function Length (value) {\n    if (!type(value)) return false\n    if (value.length === length) return true\n\n    throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')\n  }\n  Length.toJSON = function () { return name }\n\n  return Length\n}\n\nvar _ArrayN = _LengthN.bind(null, NATIVE.Array)\nvar _BufferN = _LengthN.bind(null, _Buffer)\nvar _HexN = _LengthN.bind(null, Hex)\nvar _StringN = _LengthN.bind(null, NATIVE.String)\n\nfunction Range (a, b, f) {\n  f = f || NATIVE.Number\n  function _range (value, strict) {\n    return f(value, strict) && (value > a) && (value < b)\n  }\n  _range.toJSON = function () {\n    return `${f.toJSON()} between [${a}, ${b}]`\n  }\n  return _range\n}\n\nvar INT53_MAX = Math.pow(2, 53) - 1\n\nfunction Finite (value) {\n  return typeof value === 'number' && isFinite(value)\n}\nfunction Int8 (value) { return ((value << 24) >> 24) === value }\nfunction Int16 (value) { return ((value << 16) >> 16) === value }\nfunction Int32 (value) { return (value | 0) === value }\nfunction Int53 (value) {\n  return typeof value === 'number' &&\n    value >= -INT53_MAX &&\n    value <= INT53_MAX &&\n    Math.floor(value) === value\n}\nfunction UInt8 (value) { return (value & 0xff) === value }\nfunction UInt16 (value) { return (value & 0xffff) === value }\nfunction UInt32 (value) { return (value >>> 0) === value }\nfunction UInt53 (value) {\n  return typeof value === 'number' &&\n    value >= 0 &&\n    value <= INT53_MAX &&\n    Math.floor(value) === value\n}\n\nvar types = {\n  ArrayN: _ArrayN,\n  Buffer: _Buffer,\n  BufferN: _BufferN,\n  Finite: Finite,\n  Hex: Hex,\n  HexN: _HexN,\n  Int8: Int8,\n  Int16: Int16,\n  Int32: Int32,\n  Int53: Int53,\n  Range: Range,\n  StringN: _StringN,\n  UInt8: UInt8,\n  UInt16: UInt16,\n  UInt32: UInt32,\n  UInt53: UInt53\n}\n\nfor (var typeName in types) {\n  types[typeName].toJSON = function (t) {\n    return t\n  }.bind(null, typeName)\n}\n\nmodule.exports = types\n","var ERRORS = require('./errors')\nvar NATIVE = require('./native')\n\n// short-hand\nvar tfJSON = ERRORS.tfJSON\nvar TfTypeError = ERRORS.TfTypeError\nvar TfPropertyTypeError = ERRORS.TfPropertyTypeError\nvar tfSubError = ERRORS.tfSubError\nvar getValueTypeName = ERRORS.getValueTypeName\n\nvar TYPES = {\n  arrayOf: function arrayOf (type, options) {\n    type = compile(type)\n    options = options || {}\n\n    function _arrayOf (array, strict) {\n      if (!NATIVE.Array(array)) return false\n      if (NATIVE.Nil(array)) return false\n      if (options.minLength !== undefined && array.length < options.minLength) return false\n      if (options.maxLength !== undefined && array.length > options.maxLength) return false\n      if (options.length !== undefined && array.length !== options.length) return false\n\n      return array.every(function (value, i) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          throw tfSubError(e, i)\n        }\n      })\n    }\n    _arrayOf.toJSON = function () {\n      var str = '[' + tfJSON(type) + ']'\n      if (options.length !== undefined) {\n        str += '{' + options.length + '}'\n      } else if (options.minLength !== undefined || options.maxLength !== undefined) {\n        str += '{' +\n          (options.minLength === undefined ? 0 : options.minLength) + ',' +\n          (options.maxLength === undefined ? Infinity : options.maxLength) + '}'\n      }\n      return str\n    }\n\n    return _arrayOf\n  },\n\n  maybe: function maybe (type) {\n    type = compile(type)\n\n    function _maybe (value, strict) {\n      return NATIVE.Nil(value) || type(value, strict, maybe)\n    }\n    _maybe.toJSON = function () { return '?' + tfJSON(type) }\n\n    return _maybe\n  },\n\n  map: function map (propertyType, propertyKeyType) {\n    propertyType = compile(propertyType)\n    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)\n\n    function _map (value, strict) {\n      if (!NATIVE.Object(value)) return false\n      if (NATIVE.Nil(value)) return false\n\n      for (var propertyName in value) {\n        try {\n          if (propertyKeyType) {\n            typeforce(propertyKeyType, propertyName, strict)\n          }\n        } catch (e) {\n          throw tfSubError(e, propertyName, 'key')\n        }\n\n        try {\n          var propertyValue = value[propertyName]\n          typeforce(propertyType, propertyValue, strict)\n        } catch (e) {\n          throw tfSubError(e, propertyName)\n        }\n      }\n\n      return true\n    }\n\n    if (propertyKeyType) {\n      _map.toJSON = function () {\n        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'\n      }\n    } else {\n      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }\n    }\n\n    return _map\n  },\n\n  object: function object (uncompiled) {\n    var type = {}\n\n    for (var typePropertyName in uncompiled) {\n      type[typePropertyName] = compile(uncompiled[typePropertyName])\n    }\n\n    function _object (value, strict) {\n      if (!NATIVE.Object(value)) return false\n      if (NATIVE.Nil(value)) return false\n\n      var propertyName\n\n      try {\n        for (propertyName in type) {\n          var propertyType = type[propertyName]\n          var propertyValue = value[propertyName]\n\n          typeforce(propertyType, propertyValue, strict)\n        }\n      } catch (e) {\n        throw tfSubError(e, propertyName)\n      }\n\n      if (strict) {\n        for (propertyName in value) {\n          if (type[propertyName]) continue\n\n          throw new TfPropertyTypeError(undefined, propertyName)\n        }\n      }\n\n      return true\n    }\n    _object.toJSON = function () { return tfJSON(type) }\n\n    return _object\n  },\n\n  anyOf: function anyOf () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _anyOf (value, strict) {\n      return types.some(function (type) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          return false\n        }\n      })\n    }\n    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }\n\n    return _anyOf\n  },\n\n  allOf: function allOf () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _allOf (value, strict) {\n      return types.every(function (type) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          return false\n        }\n      })\n    }\n    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }\n\n    return _allOf\n  },\n\n  quacksLike: function quacksLike (type) {\n    function _quacksLike (value) {\n      return type === getValueTypeName(value)\n    }\n    _quacksLike.toJSON = function () { return type }\n\n    return _quacksLike\n  },\n\n  tuple: function tuple () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _tuple (values, strict) {\n      if (NATIVE.Nil(values)) return false\n      if (NATIVE.Nil(values.length)) return false\n      if (strict && (values.length !== types.length)) return false\n\n      return types.every(function (type, i) {\n        try {\n          return typeforce(type, values[i], strict)\n        } catch (e) {\n          throw tfSubError(e, i)\n        }\n      })\n    }\n    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }\n\n    return _tuple\n  },\n\n  value: function value (expected) {\n    function _value (actual) {\n      return actual === expected\n    }\n    _value.toJSON = function () { return expected }\n\n    return _value\n  }\n}\n\n// TODO: deprecate\nTYPES.oneOf = TYPES.anyOf\n\nfunction compile (type) {\n  if (NATIVE.String(type)) {\n    if (type[0] === '?') return TYPES.maybe(type.slice(1))\n\n    return NATIVE[type] || TYPES.quacksLike(type)\n  } else if (type && NATIVE.Object(type)) {\n    if (NATIVE.Array(type)) {\n      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')\n      return TYPES.arrayOf(type[0])\n    }\n\n    return TYPES.object(type)\n  } else if (NATIVE.Function(type)) {\n    return type\n  }\n\n  return TYPES.value(type)\n}\n\nfunction typeforce (type, value, strict, surrogate) {\n  if (NATIVE.Function(type)) {\n    if (type(value, strict)) return true\n\n    throw new TfTypeError(surrogate || type, value)\n  }\n\n  // JIT\n  return typeforce(compile(type), value, strict)\n}\n\n// assign types to typeforce function\nfor (var typeName in NATIVE) {\n  typeforce[typeName] = NATIVE[typeName]\n}\n\nfor (typeName in TYPES) {\n  typeforce[typeName] = TYPES[typeName]\n}\n\nvar EXTRA = require('./extra')\nfor (typeName in EXTRA) {\n  typeforce[typeName] = EXTRA[typeName]\n}\n\ntypeforce.compile = compile\ntypeforce.TfTypeError = TfTypeError\ntypeforce.TfPropertyTypeError = TfPropertyTypeError\n\nmodule.exports = typeforce\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.crypto = void 0;\nexports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map","\"use strict\";\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;\nexports.isBytes = isBytes;\nexports.anumber = anumber;\nexports.abytes = abytes;\nexports.ahash = ahash;\nexports.aexists = aexists;\nexports.aoutput = aoutput;\nexports.u8 = u8;\nexports.u32 = u32;\nexports.clean = clean;\nexports.createView = createView;\nexports.rotr = rotr;\nexports.rotl = rotl;\nexports.byteSwap = byteSwap;\nexports.byteSwap32 = byteSwap32;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.asyncLoop = asyncLoop;\nexports.utf8ToBytes = utf8ToBytes;\nexports.bytesToUtf8 = bytesToUtf8;\nexports.toBytes = toBytes;\nexports.kdfInputToBytes = kdfInputToBytes;\nexports.concatBytes = concatBytes;\nexports.checkOpts = checkOpts;\nexports.createHasher = createHasher;\nexports.createOptHasher = createOptHasher;\nexports.createXOFer = createXOFer;\nexports.randomBytes = randomBytes;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexports.swap8IfBE = exports.isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexports.byteSwapIfBE = exports.swap8IfBE;\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexports.swap32IfBE = exports.isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nfunction kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nclass Hash {\n}\nexports.Hash = Hash;\n/** Wraps hash function, creating an interface on top of it */\nfunction createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructor = createHasher;\nexports.wrapConstructorWithOpts = createOptHasher;\nexports.wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;\nexports.setBigUint64 = setBigUint64;\nexports.Chi = Chi;\nexports.Maj = Maj;\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nconst utils_ts_1 = require(\"./utils.js\");\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nfunction Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nfunction Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends utils_ts_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_ts_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, utils_ts_1.aexists)(this);\n        data = (0, utils_ts_1.toBytes)(data);\n        (0, utils_ts_1.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_ts_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        (0, utils_ts_1.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_ts_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.HashMD = HashMD;\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexports.SHA256_IV = Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexports.SHA224_IV = Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexports.SHA384_IV = Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexports.SHA512_IV = Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;\n/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nconst _md_ts_1 = require(\"./_md.js\");\nconst utils_ts_1 = require(\"./utils.js\");\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */\nclass SHA1 extends _md_ts_1.HashMD {\n    constructor() {\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = (0, _md_ts_1.Chi)(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = (0, _md_ts_1.Maj)(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = ((0, utils_ts_1.rotl)(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = (0, utils_ts_1.rotl)(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA1 = SHA1;\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexports.sha1 = (0, utils_ts_1.createHasher)(() => new SHA1());\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nclass MD5 extends _md_ts_1.HashMD {\n    constructor() {\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [A, B, C, D];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for (let i = 0; i < 64; i++) {\n            let F, g, s;\n            if (i < 16) {\n                F = (0, _md_ts_1.Chi)(B, C, D);\n                g = i;\n                s = [7, 12, 17, 22];\n            }\n            else if (i < 32) {\n                F = (0, _md_ts_1.Chi)(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [5, 9, 14, 20];\n            }\n            else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [4, 11, 16, 23];\n            }\n            else {\n                F = C ^ (B | ~D);\n                g = (7 * i) % 16;\n                s = [6, 10, 15, 21];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.MD5 = MD5;\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexports.md5 = (0, utils_ts_1.createHasher)(() => new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n    const L = [Id160];\n    const R = [Pi160];\n    const res = [L, R];\n    for (let i = 0; i < 4; i++)\n        for (let j of res)\n            j.push(j[i].map((k) => Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    if (group === 1)\n        return (x & y) | (~x & z);\n    if (group === 2)\n        return (x | ~y) ^ z;\n    if (group === 3)\n        return (x & z) | (y & ~z);\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _md_ts_1.HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = ((0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = ((0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\nexports.RIPEMD160 = RIPEMD160;\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexports.ripemd160 = (0, utils_ts_1.createHasher)(() => new RIPEMD160());\n//# sourceMappingURL=legacy.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ripemd160 = exports.RIPEMD160 = void 0;\n/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n * @deprecated\n */\nconst legacy_ts_1 = require(\"./legacy.js\");\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexports.RIPEMD160 = legacy_ts_1.RIPEMD160;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexports.ripemd160 = legacy_ts_1.ripemd160;\n//# sourceMappingURL=ripemd160.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha1 = exports.SHA1 = void 0;\n/**\n * SHA1 (RFC 3174) legacy hash function.\n * @module\n * @deprecated\n */\nconst legacy_ts_1 = require(\"./legacy.js\");\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexports.SHA1 = legacy_ts_1.SHA1;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexports.sha1 = legacy_ts_1.sha1;\n//# sourceMappingURL=sha1.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;\nexports.add = add;\nexports.fromBig = fromBig;\nexports.split = split;\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l) => h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexports.default = u64;\n//# sourceMappingURL=_u64.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nconst _md_ts_1 = require(\"./_md.js\");\nconst u64 = require(\"./_u64.js\");\nconst utils_ts_1 = require(\"./utils.js\");\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_ts_1.HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_ts_1.SHA256_IV[0] | 0;\n        this.B = _md_ts_1.SHA256_IV[1] | 0;\n        this.C = _md_ts_1.SHA256_IV[2] | 0;\n        this.D = _md_ts_1.SHA256_IV[3] | 0;\n        this.E = _md_ts_1.SHA256_IV[4] | 0;\n        this.F = _md_ts_1.SHA256_IV[5] | 0;\n        this.G = _md_ts_1.SHA256_IV[6] | 0;\n        this.H = _md_ts_1.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);\n            const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA256 = SHA256;\nclass SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = _md_ts_1.SHA224_IV[0] | 0;\n        this.B = _md_ts_1.SHA224_IV[1] | 0;\n        this.C = _md_ts_1.SHA224_IV[2] | 0;\n        this.D = _md_ts_1.SHA224_IV[3] | 0;\n        this.E = _md_ts_1.SHA224_IV[4] | 0;\n        this.F = _md_ts_1.SHA224_IV[5] | 0;\n        this.G = _md_ts_1.SHA224_IV[6] | 0;\n        this.H = _md_ts_1.SHA224_IV[7] | 0;\n    }\n}\nexports.SHA224 = SHA224;\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_ts_1.HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_ts_1.SHA512_IV[0] | 0;\n        this.Al = _md_ts_1.SHA512_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA512_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA512_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA512_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA512_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA512_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA512_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA512_IV[8] | 0;\n        this.El = _md_ts_1.SHA512_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA512_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA512_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA512_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA512_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA512_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexports.SHA512 = SHA512;\nclass SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = _md_ts_1.SHA384_IV[0] | 0;\n        this.Al = _md_ts_1.SHA384_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA384_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA384_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA384_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA384_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA384_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA384_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA384_IV[8] | 0;\n        this.El = _md_ts_1.SHA384_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA384_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA384_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA384_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA384_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA384_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA384_IV[15] | 0;\n    }\n}\nexports.SHA384 = SHA384;\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexports.SHA512_224 = SHA512_224;\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\nexports.SHA512_256 = SHA512_256;\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nexports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nconst sha2_ts_1 = require(\"./sha2.js\");\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA256 = sha2_ts_1.SHA256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha256 = sha2_ts_1.sha256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA224 = sha2_ts_1.SHA224;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha224 = sha2_ts_1.sha224;\n//# sourceMappingURL=sha256.js.map","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","'use strict'\n\nvar base58 = require('bs58')\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var payloadU8 = Uint8Array.from(payload)\n    var checksum = checksumFn(payloadU8)\n    var length = payloadU8.length + 4\n    var both = new Uint8Array(length)\n    both.set(payloadU8, 0)\n    both.set(checksum.subarray(0, 4), payloadU8.length)\n    return base58.encode(both, length)\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n","'use strict'\n\nvar { sha256 } = require('@noble/hashes/sha256')\nvar bs58checkBase = require('./base')\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  return sha256(sha256(buffer))\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bech32m = exports.bech32 = void 0;\nconst ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst ALPHABET_MAP = {};\nfor (let z = 0; z < ALPHABET.length; z++) {\n    const x = ALPHABET.charAt(z);\n    ALPHABET_MAP[x] = z;\n}\nfunction polymodStep(pre) {\n    const b = pre >> 25;\n    return (((pre & 0x1ffffff) << 5) ^\n        (-((b >> 0) & 1) & 0x3b6a57b2) ^\n        (-((b >> 1) & 1) & 0x26508e6d) ^\n        (-((b >> 2) & 1) & 0x1ea119fa) ^\n        (-((b >> 3) & 1) & 0x3d4233dd) ^\n        (-((b >> 4) & 1) & 0x2a1462b3));\n}\nfunction prefixChk(prefix) {\n    let chk = 1;\n    for (let i = 0; i < prefix.length; ++i) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            return 'Invalid prefix (' + prefix + ')';\n        chk = polymodStep(chk) ^ (c >> 5);\n    }\n    chk = polymodStep(chk);\n    for (let i = 0; i < prefix.length; ++i) {\n        const v = prefix.charCodeAt(i);\n        chk = polymodStep(chk) ^ (v & 0x1f);\n    }\n    return chk;\n}\nfunction convert(data, inBits, outBits, pad) {\n    let value = 0;\n    let bits = 0;\n    const maxV = (1 << outBits) - 1;\n    const result = [];\n    for (let i = 0; i < data.length; ++i) {\n        value = (value << inBits) | data[i];\n        bits += inBits;\n        while (bits >= outBits) {\n            bits -= outBits;\n            result.push((value >> bits) & maxV);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            result.push((value << (outBits - bits)) & maxV);\n        }\n    }\n    else {\n        if (bits >= inBits)\n            return 'Excess padding';\n        if ((value << (outBits - bits)) & maxV)\n            return 'Non-zero padding';\n    }\n    return result;\n}\nfunction toWords(bytes) {\n    return convert(bytes, 8, 5, true);\n}\nfunction fromWordsUnsafe(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n}\nfunction fromWords(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n    throw new Error(res);\n}\nfunction getLibraryFromEncoding(encoding) {\n    let ENCODING_CONST;\n    if (encoding === 'bech32') {\n        ENCODING_CONST = 1;\n    }\n    else {\n        ENCODING_CONST = 0x2bc830a3;\n    }\n    function encode(prefix, words, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (prefix.length + 7 + words.length > LIMIT)\n            throw new TypeError('Exceeds length limit');\n        prefix = prefix.toLowerCase();\n        // determine chk mod\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            throw new Error(chk);\n        let result = prefix + '1';\n        for (let i = 0; i < words.length; ++i) {\n            const x = words[i];\n            if (x >> 5 !== 0)\n                throw new Error('Non 5-bit word');\n            chk = polymodStep(chk) ^ x;\n            result += ALPHABET.charAt(x);\n        }\n        for (let i = 0; i < 6; ++i) {\n            chk = polymodStep(chk);\n        }\n        chk ^= ENCODING_CONST;\n        for (let i = 0; i < 6; ++i) {\n            const v = (chk >> ((5 - i) * 5)) & 0x1f;\n            result += ALPHABET.charAt(v);\n        }\n        return result;\n    }\n    function __decode(str, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (str.length < 8)\n            return str + ' too short';\n        if (str.length > LIMIT)\n            return 'Exceeds length limit';\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        const uppered = str.toUpperCase();\n        if (str !== lowered && str !== uppered)\n            return 'Mixed-case string ' + str;\n        str = lowered;\n        const split = str.lastIndexOf('1');\n        if (split === -1)\n            return 'No separator character for ' + str;\n        if (split === 0)\n            return 'Missing prefix for ' + str;\n        const prefix = str.slice(0, split);\n        const wordChars = str.slice(split + 1);\n        if (wordChars.length < 6)\n            return 'Data too short';\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            return chk;\n        const words = [];\n        for (let i = 0; i < wordChars.length; ++i) {\n            const c = wordChars.charAt(i);\n            const v = ALPHABET_MAP[c];\n            if (v === undefined)\n                return 'Unknown character ' + c;\n            chk = polymodStep(chk) ^ v;\n            // not in the checksum?\n            if (i + 6 >= wordChars.length)\n                continue;\n            words.push(v);\n        }\n        if (chk !== ENCODING_CONST)\n            return 'Invalid checksum for ' + str;\n        return { prefix, words };\n    }\n    function decodeUnsafe(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n    }\n    function decode(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n        throw new Error(res);\n    }\n    return {\n        decodeUnsafe,\n        decode,\n        encode,\n        toWords,\n        fromWordsUnsafe,\n        fromWords,\n    };\n}\nexports.bech32 = getLibraryFromEncoding('bech32');\nexports.bech32m = getLibraryFromEncoding('bech32m');\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","'use strict'\nvar Buffer = require('safe-buffer').Buffer\n\n// Number.MAX_SAFE_INTEGER\nvar MAX_SAFE_INTEGER = 9007199254740991\n\nfunction checkUInt53 (n) {\n  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range')\n}\n\nfunction encode (number, buffer, offset) {\n  checkUInt53(number)\n\n  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(number))\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')\n  if (!offset) offset = 0\n\n  // 8 bit\n  if (number < 0xfd) {\n    buffer.writeUInt8(number, offset)\n    encode.bytes = 1\n\n  // 16 bit\n  } else if (number <= 0xffff) {\n    buffer.writeUInt8(0xfd, offset)\n    buffer.writeUInt16LE(number, offset + 1)\n    encode.bytes = 3\n\n  // 32 bit\n  } else if (number <= 0xffffffff) {\n    buffer.writeUInt8(0xfe, offset)\n    buffer.writeUInt32LE(number, offset + 1)\n    encode.bytes = 5\n\n  // 64 bit\n  } else {\n    buffer.writeUInt8(0xff, offset)\n    buffer.writeUInt32LE(number >>> 0, offset + 1)\n    buffer.writeUInt32LE((number / 0x100000000) | 0, offset + 5)\n    encode.bytes = 9\n  }\n\n  return buffer\n}\n\nfunction decode (buffer, offset) {\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')\n  if (!offset) offset = 0\n\n  var first = buffer.readUInt8(offset)\n\n  // 8 bit\n  if (first < 0xfd) {\n    decode.bytes = 1\n    return first\n\n  // 16 bit\n  } else if (first === 0xfd) {\n    decode.bytes = 3\n    return buffer.readUInt16LE(offset + 1)\n\n  // 32 bit\n  } else if (first === 0xfe) {\n    decode.bytes = 5\n    return buffer.readUInt32LE(offset + 1)\n\n  // 64 bit\n  } else {\n    decode.bytes = 9\n    var lo = buffer.readUInt32LE(offset + 1)\n    var hi = buffer.readUInt32LE(offset + 5)\n    var number = hi * 0x0100000000 + lo\n    checkUInt53(number)\n\n    return number\n  }\n}\n\nfunction encodingLength (number) {\n  checkUInt53(number)\n\n  return (\n    number < 0xfd ? 1\n      : number <= 0xffff ? 3\n        : number <= 0xffffffff ? 5\n          : 9\n  )\n}\n\nmodule.exports = { encode: encode, decode: decode, encodingLength: encodingLength }\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nvar GlobalTypes;\n(function(GlobalTypes) {\n  GlobalTypes[(GlobalTypes['UNSIGNED_TX'] = 0)] = 'UNSIGNED_TX';\n  GlobalTypes[(GlobalTypes['GLOBAL_XPUB'] = 1)] = 'GLOBAL_XPUB';\n})((GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {})));\nexports.GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'];\nvar InputTypes;\n(function(InputTypes) {\n  InputTypes[(InputTypes['NON_WITNESS_UTXO'] = 0)] = 'NON_WITNESS_UTXO';\n  InputTypes[(InputTypes['WITNESS_UTXO'] = 1)] = 'WITNESS_UTXO';\n  InputTypes[(InputTypes['PARTIAL_SIG'] = 2)] = 'PARTIAL_SIG';\n  InputTypes[(InputTypes['SIGHASH_TYPE'] = 3)] = 'SIGHASH_TYPE';\n  InputTypes[(InputTypes['REDEEM_SCRIPT'] = 4)] = 'REDEEM_SCRIPT';\n  InputTypes[(InputTypes['WITNESS_SCRIPT'] = 5)] = 'WITNESS_SCRIPT';\n  InputTypes[(InputTypes['BIP32_DERIVATION'] = 6)] = 'BIP32_DERIVATION';\n  InputTypes[(InputTypes['FINAL_SCRIPTSIG'] = 7)] = 'FINAL_SCRIPTSIG';\n  InputTypes[(InputTypes['FINAL_SCRIPTWITNESS'] = 8)] = 'FINAL_SCRIPTWITNESS';\n  InputTypes[(InputTypes['POR_COMMITMENT'] = 9)] = 'POR_COMMITMENT';\n  InputTypes[(InputTypes['TAP_KEY_SIG'] = 19)] = 'TAP_KEY_SIG';\n  InputTypes[(InputTypes['TAP_SCRIPT_SIG'] = 20)] = 'TAP_SCRIPT_SIG';\n  InputTypes[(InputTypes['TAP_LEAF_SCRIPT'] = 21)] = 'TAP_LEAF_SCRIPT';\n  InputTypes[(InputTypes['TAP_BIP32_DERIVATION'] = 22)] =\n    'TAP_BIP32_DERIVATION';\n  InputTypes[(InputTypes['TAP_INTERNAL_KEY'] = 23)] = 'TAP_INTERNAL_KEY';\n  InputTypes[(InputTypes['TAP_MERKLE_ROOT'] = 24)] = 'TAP_MERKLE_ROOT';\n})((InputTypes = exports.InputTypes || (exports.InputTypes = {})));\nexports.INPUT_TYPE_NAMES = [\n  'nonWitnessUtxo',\n  'witnessUtxo',\n  'partialSig',\n  'sighashType',\n  'redeemScript',\n  'witnessScript',\n  'bip32Derivation',\n  'finalScriptSig',\n  'finalScriptWitness',\n  'porCommitment',\n  'tapKeySig',\n  'tapScriptSig',\n  'tapLeafScript',\n  'tapBip32Derivation',\n  'tapInternalKey',\n  'tapMerkleRoot',\n];\nvar OutputTypes;\n(function(OutputTypes) {\n  OutputTypes[(OutputTypes['REDEEM_SCRIPT'] = 0)] = 'REDEEM_SCRIPT';\n  OutputTypes[(OutputTypes['WITNESS_SCRIPT'] = 1)] = 'WITNESS_SCRIPT';\n  OutputTypes[(OutputTypes['BIP32_DERIVATION'] = 2)] = 'BIP32_DERIVATION';\n  OutputTypes[(OutputTypes['TAP_INTERNAL_KEY'] = 5)] = 'TAP_INTERNAL_KEY';\n  OutputTypes[(OutputTypes['TAP_TREE'] = 6)] = 'TAP_TREE';\n  OutputTypes[(OutputTypes['TAP_BIP32_DERIVATION'] = 7)] =\n    'TAP_BIP32_DERIVATION';\n})((OutputTypes = exports.OutputTypes || (exports.OutputTypes = {})));\nexports.OUTPUT_TYPE_NAMES = [\n  'redeemScript',\n  'witnessScript',\n  'bip32Derivation',\n  'tapInternalKey',\n  'tapTree',\n  'tapBip32Derivation',\n];\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nconst range = n => [...Array(n).keys()];\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {\n    throw new Error(\n      'Decode Error: could not decode globalXpub with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {\n    throw new Error(\n      'Decode Error: globalXpub has invalid extended pubkey in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if ((keyVal.value.length / 4) % 1 !== 0) {\n    throw new Error(\n      'Decode Error: Global GLOBAL_XPUB value length should be multiple of 4',\n    );\n  }\n  const extendedPubkey = keyVal.key.slice(1);\n  const data = {\n    masterFingerprint: keyVal.value.slice(0, 4),\n    extendedPubkey,\n    path: 'm',\n  };\n  for (const i of range(keyVal.value.length / 4 - 1)) {\n    const val = keyVal.value.readUInt32LE(i * 4 + 4);\n    const isHard = !!(val & 0x80000000);\n    const idx = val & 0x7fffffff;\n    data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n  }\n  return data;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);\n  const key = Buffer.concat([head, data.extendedPubkey]);\n  const splitPath = data.path.split('/');\n  const value = Buffer.allocUnsafe(splitPath.length * 4);\n  data.masterFingerprint.copy(value, 0);\n  let offset = 4;\n  splitPath.slice(1).forEach(level => {\n    const isHard = level.slice(-1) === \"'\";\n    let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n    if (isHard) num += 0x80000000;\n    value.writeUInt32LE(num, offset);\n    offset += 4;\n  });\n  return {\n    key,\n    value,\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }';\nfunction check(data) {\n  const epk = data.extendedPubkey;\n  const mfp = data.masterFingerprint;\n  const p = data.path;\n  return (\n    Buffer.isBuffer(epk) &&\n    epk.length === 78 &&\n    [2, 3].indexOf(epk[45]) > -1 &&\n    Buffer.isBuffer(mfp) &&\n    mfp.length === 4 &&\n    typeof p === 'string' &&\n    !!p.match(/^m(\\/\\d+'?)*$/)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.extendedPubkey.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => v.extendedPubkey.equals(item.extendedPubkey)).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction encode(data) {\n  return {\n    key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),\n    value: data.toBuffer(),\n  };\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {\n    throw new Error(\n      'Decode Error: could not decode finalScriptSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);\n  return {\n    key,\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.finalScriptSig === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {\n    throw new Error(\n      'Decode Error: could not decode finalScriptWitness with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);\n  return {\n    key,\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return (\n    !!currentData && !!newData && currentData.finalScriptWitness === undefined\n  );\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode nonWitnessUtxo with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  return {\n    key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {\n    throw new Error(\n      'Decode Error: could not decode partialSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (\n    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||\n    ![2, 3, 4].includes(keyVal.key[1])\n  ) {\n    throw new Error(\n      'Decode Error: partialSig has invalid pubkey in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const pubkey = keyVal.key.slice(1);\n  return {\n    pubkey,\n    signature: keyVal.value,\n  };\n}\nexports.decode = decode;\nfunction encode(pSig) {\n  const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);\n  return {\n    key: Buffer.concat([head, pSig.pubkey]),\n    value: pSig.signature,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ pubkey: Buffer; signature: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.pubkey) &&\n    Buffer.isBuffer(data.signature) &&\n    [33, 65].includes(data.pubkey.length) &&\n    [2, 3, 4].includes(data.pubkey[0]) &&\n    isDerSigWithSighash(data.signature)\n  );\n}\nexports.check = check;\nfunction isDerSigWithSighash(buf) {\n  if (!Buffer.isBuffer(buf) || buf.length < 9) return false;\n  if (buf[0] !== 0x30) return false;\n  if (buf.length !== buf[1] + 3) return false;\n  if (buf[2] !== 0x02) return false;\n  const rLen = buf[3];\n  if (rLen > 33 || rLen < 1) return false;\n  if (buf[3 + rLen + 1] !== 0x02) return false;\n  const sLen = buf[3 + rLen + 2];\n  if (sLen > 33 || sLen < 1) return false;\n  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;\n  return true;\n}\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.pubkey.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n}\nexports.canAddToArray = canAddToArray;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {\n    throw new Error(\n      'Decode Error: could not decode porCommitment with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value.toString('utf8');\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);\n  return {\n    key,\n    value: Buffer.from(data, 'utf8'),\n  };\n}\nexports.encode = encode;\nexports.expected = 'string';\nfunction check(data) {\n  return typeof data === 'string';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.porCommitment === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {\n    throw new Error(\n      'Decode Error: could not decode sighashType with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value.readUInt32LE(0);\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);\n  const value = Buffer.allocUnsafe(4);\n  value.writeUInt32LE(data, 0);\n  return {\n    key,\n    value,\n  };\n}\nexports.encode = encode;\nexports.expected = 'number';\nfunction check(data) {\n  return typeof data === 'number';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.sighashType === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapKeySig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (!check(keyVal.value)) {\n    throw new Error(\n      'Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature',\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(value) {\n  const key = Buffer.from([typeFields_1.InputTypes.TAP_KEY_SIG]);\n  return { key, value };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapKeySig === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {\n    throw new Error(\n      'Decode Error: could not decode tapLeafScript with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if ((keyVal.key.length - 2) % 32 !== 0) {\n    throw new Error(\n      'Decode Error: tapLeafScript has invalid control block in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const leafVersion = keyVal.value[keyVal.value.length - 1];\n  if ((keyVal.key[1] & 0xfe) !== leafVersion) {\n    throw new Error(\n      'Decode Error: tapLeafScript bad leaf version in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const script = keyVal.value.slice(0, -1);\n  const controlBlock = keyVal.key.slice(1);\n  return { controlBlock, script, leafVersion };\n}\nexports.decode = decode;\nfunction encode(tScript) {\n  const head = Buffer.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);\n  const verBuf = Buffer.from([tScript.leafVersion]);\n  return {\n    key: Buffer.concat([head, tScript.controlBlock]),\n    value: Buffer.concat([tScript.script, verBuf]),\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ controlBlock: Buffer; leafVersion: number, script: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.controlBlock) &&\n    (data.controlBlock.length - 1) % 32 === 0 &&\n    (data.controlBlock[0] & 0xfe) === data.leafVersion &&\n    Buffer.isBuffer(data.script)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.controlBlock.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => v.controlBlock.equals(item.controlBlock)).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapMerkleRoot with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (!check(keyVal.value)) {\n    throw new Error('Decode Error: tapMerkleRoot not a 32-byte hash');\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(value) {\n  const key = Buffer.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);\n  return { key, value };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data) && data.length === 32;\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {\n    throw new Error(\n      'Decode Error: could not decode tapScriptSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.key.length !== 65) {\n    throw new Error(\n      'Decode Error: tapScriptSig has invalid key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {\n    throw new Error(\n      'Decode Error: tapScriptSig has invalid signature in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const pubkey = keyVal.key.slice(1, 33);\n  const leafHash = keyVal.key.slice(33);\n  return {\n    pubkey,\n    leafHash,\n    signature: keyVal.value,\n  };\n}\nexports.decode = decode;\nfunction encode(tSig) {\n  const head = Buffer.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);\n  return {\n    key: Buffer.concat([head, tSig.pubkey, tSig.leafHash]),\n    value: tSig.signature,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.pubkey) &&\n    Buffer.isBuffer(data.leafHash) &&\n    Buffer.isBuffer(data.signature) &&\n    data.pubkey.length === 32 &&\n    data.leafHash.length === 32 &&\n    (data.signature.length === 64 || data.signature.length === 65)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString =\n    item.pubkey.toString('hex') + item.leafHash.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(\n      v => v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash),\n    ).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\n// Number.MAX_SAFE_INTEGER\nconst MAX_SAFE_INTEGER = 9007199254740991;\nfunction checkUInt53(n) {\n  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)\n    throw new RangeError('value out of range');\n}\nfunction encode(_number, buffer, offset) {\n  checkUInt53(_number);\n  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));\n  if (!Buffer.isBuffer(buffer))\n    throw new TypeError('buffer must be a Buffer instance');\n  if (!offset) offset = 0;\n  // 8 bit\n  if (_number < 0xfd) {\n    buffer.writeUInt8(_number, offset);\n    Object.assign(encode, { bytes: 1 });\n    // 16 bit\n  } else if (_number <= 0xffff) {\n    buffer.writeUInt8(0xfd, offset);\n    buffer.writeUInt16LE(_number, offset + 1);\n    Object.assign(encode, { bytes: 3 });\n    // 32 bit\n  } else if (_number <= 0xffffffff) {\n    buffer.writeUInt8(0xfe, offset);\n    buffer.writeUInt32LE(_number, offset + 1);\n    Object.assign(encode, { bytes: 5 });\n    // 64 bit\n  } else {\n    buffer.writeUInt8(0xff, offset);\n    buffer.writeUInt32LE(_number >>> 0, offset + 1);\n    buffer.writeUInt32LE((_number / 0x100000000) | 0, offset + 5);\n    Object.assign(encode, { bytes: 9 });\n  }\n  return buffer;\n}\nexports.encode = encode;\nfunction decode(buffer, offset) {\n  if (!Buffer.isBuffer(buffer))\n    throw new TypeError('buffer must be a Buffer instance');\n  if (!offset) offset = 0;\n  const first = buffer.readUInt8(offset);\n  // 8 bit\n  if (first < 0xfd) {\n    Object.assign(decode, { bytes: 1 });\n    return first;\n    // 16 bit\n  } else if (first === 0xfd) {\n    Object.assign(decode, { bytes: 3 });\n    return buffer.readUInt16LE(offset + 1);\n    // 32 bit\n  } else if (first === 0xfe) {\n    Object.assign(decode, { bytes: 5 });\n    return buffer.readUInt32LE(offset + 1);\n    // 64 bit\n  } else {\n    Object.assign(decode, { bytes: 9 });\n    const lo = buffer.readUInt32LE(offset + 1);\n    const hi = buffer.readUInt32LE(offset + 5);\n    const _number = hi * 0x0100000000 + lo;\n    checkUInt53(_number);\n    return _number;\n  }\n}\nexports.decode = decode;\nfunction encodingLength(_number) {\n  checkUInt53(_number);\n  return _number < 0xfd\n    ? 1\n    : _number <= 0xffff\n    ? 3\n    : _number <= 0xffffffff\n    ? 5\n    : 9;\n}\nexports.encodingLength = encodingLength;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst varuint = require('./varint');\nexports.range = n => [...Array(n).keys()];\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction keyValsToBuffer(keyVals) {\n  const buffers = keyVals.map(keyValToBuffer);\n  buffers.push(Buffer.from([0]));\n  return Buffer.concat(buffers);\n}\nexports.keyValsToBuffer = keyValsToBuffer;\nfunction keyValToBuffer(keyVal) {\n  const keyLen = keyVal.key.length;\n  const valLen = keyVal.value.length;\n  const keyVarIntLen = varuint.encodingLength(keyLen);\n  const valVarIntLen = varuint.encodingLength(valLen);\n  const buffer = Buffer.allocUnsafe(\n    keyVarIntLen + keyLen + valVarIntLen + valLen,\n  );\n  varuint.encode(keyLen, buffer, 0);\n  keyVal.key.copy(buffer, keyVarIntLen);\n  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);\n  keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);\n  return buffer;\n}\nexports.keyValToBuffer = keyValToBuffer;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nconst tools_1 = require('../tools');\nconst varuint = require('../varint');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode witnessUtxo with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const value = tools_1.readUInt64LE(keyVal.value, 0);\n  let _offset = 8;\n  const scriptLen = varuint.decode(keyVal.value, _offset);\n  _offset += varuint.encodingLength(scriptLen);\n  const script = keyVal.value.slice(_offset);\n  if (script.length !== scriptLen) {\n    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');\n  }\n  return {\n    script,\n    value,\n  };\n}\nexports.decode = decode;\nfunction encode(data) {\n  const { script, value } = data;\n  const varintLen = varuint.encodingLength(script.length);\n  const result = Buffer.allocUnsafe(8 + varintLen + script.length);\n  tools_1.writeUInt64LE(result, value, 0);\n  varuint.encode(script.length, result, 8);\n  script.copy(result, 8 + varintLen);\n  return {\n    key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),\n    value: result,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ script: Buffer; value: number; }';\nfunction check(data) {\n  return Buffer.isBuffer(data.script) && typeof data.value === 'number';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.witnessUtxo === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nconst varuint = require('../varint');\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapTree with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  let _offset = 0;\n  const data = [];\n  while (_offset < keyVal.value.length) {\n    const depth = keyVal.value[_offset++];\n    const leafVersion = keyVal.value[_offset++];\n    const scriptLen = varuint.decode(keyVal.value, _offset);\n    _offset += varuint.encodingLength(scriptLen);\n    data.push({\n      depth,\n      leafVersion,\n      script: keyVal.value.slice(_offset, _offset + scriptLen),\n    });\n    _offset += scriptLen;\n  }\n  return { leaves: data };\n}\nexports.decode = decode;\nfunction encode(tree) {\n  const key = Buffer.from([typeFields_1.OutputTypes.TAP_TREE]);\n  const bufs = [].concat(\n    ...tree.leaves.map(tapLeaf => [\n      Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),\n      varuint.encode(tapLeaf.script.length),\n      tapLeaf.script,\n    ]),\n  );\n  return {\n    key,\n    value: Buffer.concat(bufs),\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }';\nfunction check(data) {\n  return (\n    Array.isArray(data.leaves) &&\n    data.leaves.every(\n      tapLeaf =>\n        tapLeaf.depth >= 0 &&\n        tapLeaf.depth <= 128 &&\n        (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion &&\n        Buffer.isBuffer(tapLeaf.script),\n    )\n  );\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapTree === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst range = n => [...Array(n).keys()];\nconst isValidDERKey = pubkey =>\n  (pubkey.length === 33 && [2, 3].includes(pubkey[0])) ||\n  (pubkey.length === 65 && 4 === pubkey[0]);\nfunction makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode bip32Derivation with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    const pubkey = keyVal.key.slice(1);\n    if (!isValidPubkey(pubkey)) {\n      throw new Error(\n        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    if ((keyVal.value.length / 4) % 1 !== 0) {\n      throw new Error(\n        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',\n      );\n    }\n    const data = {\n      masterFingerprint: keyVal.value.slice(0, 4),\n      pubkey,\n      path: 'm',\n    };\n    for (const i of range(keyVal.value.length / 4 - 1)) {\n      const val = keyVal.value.readUInt32LE(i * 4 + 4);\n      const isHard = !!(val & 0x80000000);\n      const idx = val & 0x7fffffff;\n      data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n    }\n    return data;\n  }\n  function encode(data) {\n    const head = Buffer.from([TYPE_BYTE]);\n    const key = Buffer.concat([head, data.pubkey]);\n    const splitPath = data.path.split('/');\n    const value = Buffer.allocUnsafe(splitPath.length * 4);\n    data.masterFingerprint.copy(value, 0);\n    let offset = 4;\n    splitPath.slice(1).forEach(level => {\n      const isHard = level.slice(-1) === \"'\";\n      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n      if (isHard) num += 0x80000000;\n      value.writeUInt32LE(num, offset);\n      offset += 4;\n    });\n    return {\n      key,\n      value,\n    };\n  }\n  const expected =\n    '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';\n  function check(data) {\n    return (\n      Buffer.isBuffer(data.pubkey) &&\n      Buffer.isBuffer(data.masterFingerprint) &&\n      typeof data.path === 'string' &&\n      isValidPubkey(data.pubkey) &&\n      data.masterFingerprint.length === 4\n    );\n  }\n  function canAddToArray(array, item, dupeSet) {\n    const dupeString = item.pubkey.toString('hex');\n    if (dupeSet.has(dupeString)) return false;\n    dupeSet.add(dupeString);\n    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeChecker(pubkeyTypes) {\n  return checkPubkey;\n  function checkPubkey(keyVal) {\n    let pubkey;\n    if (pubkeyTypes.includes(keyVal.key[0])) {\n      pubkey = keyVal.key.slice(1);\n      if (\n        !(pubkey.length === 33 || pubkey.length === 65) ||\n        ![2, 3, 4].includes(pubkey[0])\n      ) {\n        throw new Error(\n          'Format Error: invalid pubkey in key 0x' + keyVal.key.toString('hex'),\n        );\n      }\n    }\n    return pubkey;\n  }\n}\nexports.makeChecker = makeChecker;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode redeemScript with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(data) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return {\n      key,\n      value: data,\n    };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data);\n  }\n  function canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.redeemScript === undefined;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst varuint = require('../varint');\nconst bip32Derivation = require('./bip32Derivation');\nconst isValidBIP340Key = pubkey => pubkey.length === 32;\nfunction makeConverter(TYPE_BYTE) {\n  const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);\n  function decode(keyVal) {\n    const nHashes = varuint.decode(keyVal.value);\n    const nHashesLen = varuint.encodingLength(nHashes);\n    const base = parent.decode({\n      key: keyVal.key,\n      value: keyVal.value.slice(nHashesLen + nHashes * 32),\n    });\n    const leafHashes = new Array(nHashes);\n    for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {\n      leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);\n    }\n    return Object.assign({}, base, { leafHashes });\n  }\n  function encode(data) {\n    const base = parent.encode(data);\n    const nHashesLen = varuint.encodingLength(data.leafHashes.length);\n    const nHashesBuf = Buffer.allocUnsafe(nHashesLen);\n    varuint.encode(data.leafHashes.length, nHashesBuf);\n    const value = Buffer.concat([nHashesBuf, ...data.leafHashes, base.value]);\n    return Object.assign({}, base, { value });\n  }\n  const expected =\n    '{ ' +\n    'masterFingerprint: Buffer; ' +\n    'pubkey: Buffer; ' +\n    'path: string; ' +\n    'leafHashes: Buffer[]; ' +\n    '}';\n  function check(data) {\n    return (\n      Array.isArray(data.leafHashes) &&\n      data.leafHashes.every(\n        leafHash => Buffer.isBuffer(leafHash) && leafHash.length === 32,\n      ) &&\n      parent.check(data)\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray: parent.canAddToArray,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {\n      throw new Error(\n        'Decode Error: could not decode tapInternalKey with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    if (keyVal.value.length !== 32) {\n      throw new Error(\n        'Decode Error: tapInternalKey not a 32-byte x-only pubkey',\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(value) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return { key, value };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data) && data.length === 32;\n  }\n  function canAdd(currentData, newData) {\n    return (\n      !!currentData && !!newData && currentData.tapInternalKey === undefined\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode witnessScript with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(data) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return {\n      key,\n      value: data,\n    };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data);\n  }\n  function canAdd(currentData, newData) {\n    return (\n      !!currentData && !!newData && currentData.witnessScript === undefined\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../typeFields');\nconst globalXpub = require('./global/globalXpub');\nconst unsignedTx = require('./global/unsignedTx');\nconst finalScriptSig = require('./input/finalScriptSig');\nconst finalScriptWitness = require('./input/finalScriptWitness');\nconst nonWitnessUtxo = require('./input/nonWitnessUtxo');\nconst partialSig = require('./input/partialSig');\nconst porCommitment = require('./input/porCommitment');\nconst sighashType = require('./input/sighashType');\nconst tapKeySig = require('./input/tapKeySig');\nconst tapLeafScript = require('./input/tapLeafScript');\nconst tapMerkleRoot = require('./input/tapMerkleRoot');\nconst tapScriptSig = require('./input/tapScriptSig');\nconst witnessUtxo = require('./input/witnessUtxo');\nconst tapTree = require('./output/tapTree');\nconst bip32Derivation = require('./shared/bip32Derivation');\nconst checkPubkey = require('./shared/checkPubkey');\nconst redeemScript = require('./shared/redeemScript');\nconst tapBip32Derivation = require('./shared/tapBip32Derivation');\nconst tapInternalKey = require('./shared/tapInternalKey');\nconst witnessScript = require('./shared/witnessScript');\nconst globals = {\n  unsignedTx,\n  globalXpub,\n  // pass an Array of key bytes that require pubkey beside the key\n  checkPubkey: checkPubkey.makeChecker([]),\n};\nexports.globals = globals;\nconst inputs = {\n  nonWitnessUtxo,\n  partialSig,\n  sighashType,\n  finalScriptSig,\n  finalScriptWitness,\n  porCommitment,\n  witnessUtxo,\n  bip32Derivation: bip32Derivation.makeConverter(\n    typeFields_1.InputTypes.BIP32_DERIVATION,\n  ),\n  redeemScript: redeemScript.makeConverter(\n    typeFields_1.InputTypes.REDEEM_SCRIPT,\n  ),\n  witnessScript: witnessScript.makeConverter(\n    typeFields_1.InputTypes.WITNESS_SCRIPT,\n  ),\n  checkPubkey: checkPubkey.makeChecker([\n    typeFields_1.InputTypes.PARTIAL_SIG,\n    typeFields_1.InputTypes.BIP32_DERIVATION,\n  ]),\n  tapKeySig,\n  tapScriptSig,\n  tapLeafScript,\n  tapBip32Derivation: tapBip32Derivation.makeConverter(\n    typeFields_1.InputTypes.TAP_BIP32_DERIVATION,\n  ),\n  tapInternalKey: tapInternalKey.makeConverter(\n    typeFields_1.InputTypes.TAP_INTERNAL_KEY,\n  ),\n  tapMerkleRoot,\n};\nexports.inputs = inputs;\nconst outputs = {\n  bip32Derivation: bip32Derivation.makeConverter(\n    typeFields_1.OutputTypes.BIP32_DERIVATION,\n  ),\n  redeemScript: redeemScript.makeConverter(\n    typeFields_1.OutputTypes.REDEEM_SCRIPT,\n  ),\n  witnessScript: witnessScript.makeConverter(\n    typeFields_1.OutputTypes.WITNESS_SCRIPT,\n  ),\n  checkPubkey: checkPubkey.makeChecker([\n    typeFields_1.OutputTypes.BIP32_DERIVATION,\n  ]),\n  tapBip32Derivation: tapBip32Derivation.makeConverter(\n    typeFields_1.OutputTypes.TAP_BIP32_DERIVATION,\n  ),\n  tapTree,\n  tapInternalKey: tapInternalKey.makeConverter(\n    typeFields_1.OutputTypes.TAP_INTERNAL_KEY,\n  ),\n};\nexports.outputs = outputs;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nconst varuint = require('../converter/varint');\nconst typeFields_1 = require('../typeFields');\nfunction psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n  function varSlice() {\n    const keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    const key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n  function readUInt32BE() {\n    const num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n  function readUInt8() {\n    const num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value,\n    };\n  }\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n    const isEnd = buffer.readUInt8(offset) === 0;\n    if (isEnd) {\n      offset++;\n    }\n    return isEnd;\n  }\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n  if (readUInt8() !== 0xff) {\n    throw new Error(\n      'Format Error: Magic Number must be followed by 0xff separator',\n    );\n  }\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = keyVal.key.toString('hex');\n    if (globalKeyIndex[hexKey]) {\n      throw new Error(\n        'Format Error: Keys must be unique for global keymap: key ' + hexKey,\n      );\n    }\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n  const unsignedTxMaps = globalMapKeyVals.filter(\n    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,\n  );\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n  const unsignedTx = txGetter(unsignedTxMaps[0].value);\n  // Get input and output counts to loop the respective fields\n  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (inputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each input: ' +\n            'input index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n    inputKeyVals.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (outputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each output: ' +\n            'output index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n    outputKeyVals.push(output);\n  }\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals,\n  });\n}\nexports.psbtFromBuffer = psbtFromBuffer;\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(\n      `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,\n    );\n  }\n}\nexports.checkKeyBuffer = checkKeyBuffer;\nfunction psbtFromKeyVals(\n  unsignedTx,\n  { globalMapKeyVals, inputKeyVals, outputKeyVals },\n) {\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx,\n  };\n  let txCount = 0;\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case typeFields_1.GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer(\n          'global',\n          keyVal.key,\n          typeFields_1.GlobalTypes.UNSIGNED_TX,\n        );\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n        txCount++;\n        break;\n      case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  }\n  // Get input and output counts to loop the respective fields\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const input = {};\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.NON_WITNESS_UTXO,\n          );\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error(\n              'Format Error: Input has multiple NON_WITNESS_UTXO',\n            );\n          }\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_UTXO,\n          );\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.SIGHASH_TYPE,\n          );\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.REDEEM_SCRIPT,\n          );\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_SCRIPT,\n          );\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n          input.bip32Derivation.push(\n            convert.inputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTSIG,\n          );\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,\n          );\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(\n            keyVal,\n          );\n          break;\n        case typeFields_1.InputTypes.POR_COMMITMENT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.POR_COMMITMENT,\n          );\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_KEY_SIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_KEY_SIG,\n          );\n          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_SCRIPT_SIG:\n          if (input.tapScriptSig === undefined) {\n            input.tapScriptSig = [];\n          }\n          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:\n          if (input.tapLeafScript === undefined) {\n            input.tapLeafScript = [];\n          }\n          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:\n          if (input.tapBip32Derivation === undefined) {\n            input.tapBip32Derivation = [];\n          }\n          input.tapBip32Derivation.push(\n            convert.inputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_INTERNAL_KEY,\n          );\n          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_MERKLE_ROOT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_MERKLE_ROOT,\n          );\n          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);\n          break;\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n    inputs.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const output = {};\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.REDEEM_SCRIPT,\n          );\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.WITNESS_SCRIPT,\n          );\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n          output.bip32Derivation.push(\n            convert.outputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_INTERNAL_KEY,\n          );\n          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_TREE:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_TREE,\n          );\n          output.tapTree = convert.outputs.tapTree.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:\n          if (output.tapBip32Derivation === undefined) {\n            output.tapBip32Derivation = [];\n          }\n          output.tapBip32Derivation.push(\n            convert.outputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n    outputs.push(output);\n  }\n  return { globalMap, inputs, outputs };\n}\nexports.psbtFromKeyVals = psbtFromKeyVals;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nfunction psbtToBuffer({ globalMap, inputs, outputs }) {\n  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({\n    globalMap,\n    inputs,\n    outputs,\n  });\n  const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);\n  const keyValsOrEmptyToBuffer = keyVals =>\n    keyVals.length === 0\n      ? [Buffer.from([0])]\n      : keyVals.map(tools_1.keyValsToBuffer);\n  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);\n  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);\n  const header = Buffer.allocUnsafe(5);\n  header.writeUIntBE(0x70736274ff, 0, 5);\n  return Buffer.concat(\n    [header, globalBuffer].concat(inputBuffers, outputBuffers),\n  );\n}\nexports.psbtToBuffer = psbtToBuffer;\nconst sortKeyVals = (a, b) => {\n  return a.key.compare(b.key);\n};\nfunction keyValsFromMap(keyValMap, converterFactory) {\n  const keyHexSet = new Set();\n  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {\n    if (key === 'unknownKeyVals') return result;\n    // We are checking for undefined anyways. So ignore TS error\n    // @ts-ignore\n    const converter = converterFactory[key];\n    if (converter === undefined) return result;\n    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(\n      converter.encode,\n    );\n    const keyHexes = encodedKeyVals.map(kv => kv.key.toString('hex'));\n    keyHexes.forEach(hex => {\n      if (keyHexSet.has(hex))\n        throw new Error('Serialize Error: Duplicate key: ' + hex);\n      keyHexSet.add(hex);\n    });\n    return result.concat(encodedKeyVals);\n  }, []);\n  // Get other keyVals that have not yet been gotten\n  const otherKeyVals = keyValMap.unknownKeyVals\n    ? keyValMap.unknownKeyVals.filter(keyVal => {\n        return !keyHexSet.has(keyVal.key.toString('hex'));\n      })\n    : [];\n  return keyVals.concat(otherKeyVals).sort(sortKeyVals);\n}\nfunction psbtToKeyVals({ globalMap, inputs, outputs }) {\n  // First parse the global keyVals\n  // Get any extra keyvals to pass along\n  return {\n    globalKeyVals: keyValsFromMap(globalMap, convert.globals),\n    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),\n    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),\n  };\n}\nexports.psbtToKeyVals = psbtToKeyVals;\n","'use strict';\nfunction __export(m) {\n  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, '__esModule', { value: true });\n__export(require('./fromBuffer'));\n__export(require('./toBuffer'));\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst parser_1 = require('../parser');\nfunction combine(psbts) {\n  const self = psbts[0];\n  const selfKeyVals = parser_1.psbtToKeyVals(self);\n  const others = psbts.slice(1);\n  if (others.length === 0) throw new Error('Combine: Nothing to combine');\n  const selfTx = getTx(self);\n  if (selfTx === undefined) {\n    throw new Error('Combine: Self missing transaction');\n  }\n  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);\n  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);\n  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);\n  for (const other of others) {\n    const otherTx = getTx(other);\n    if (\n      otherTx === undefined ||\n      !otherTx.toBuffer().equals(selfTx.toBuffer())\n    ) {\n      throw new Error(\n        'Combine: One of the Psbts does not have the same transaction.',\n      );\n    }\n    const otherKeyVals = parser_1.psbtToKeyVals(other);\n    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);\n    otherGlobalSet.forEach(\n      keyPusher(\n        selfGlobalSet,\n        selfKeyVals.globalKeyVals,\n        otherKeyVals.globalKeyVals,\n      ),\n    );\n    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);\n    otherInputSets.forEach((inputSet, idx) =>\n      inputSet.forEach(\n        keyPusher(\n          selfInputSets[idx],\n          selfKeyVals.inputKeyVals[idx],\n          otherKeyVals.inputKeyVals[idx],\n        ),\n      ),\n    );\n    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);\n    otherOutputSets.forEach((outputSet, idx) =>\n      outputSet.forEach(\n        keyPusher(\n          selfOutputSets[idx],\n          selfKeyVals.outputKeyVals[idx],\n          otherKeyVals.outputKeyVals[idx],\n        ),\n      ),\n    );\n  }\n  return parser_1.psbtFromKeyVals(selfTx, {\n    globalMapKeyVals: selfKeyVals.globalKeyVals,\n    inputKeyVals: selfKeyVals.inputKeyVals,\n    outputKeyVals: selfKeyVals.outputKeyVals,\n  });\n}\nexports.combine = combine;\nfunction keyPusher(selfSet, selfKeyVals, otherKeyVals) {\n  return key => {\n    if (selfSet.has(key)) return;\n    const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];\n    selfKeyVals.push(newKv);\n    selfSet.add(key);\n  };\n}\nfunction getTx(psbt) {\n  return psbt.globalMap.unsignedTx;\n}\nfunction getKeySet(keyVals) {\n  const set = new Set();\n  keyVals.forEach(keyVal => {\n    const hex = keyVal.key.toString('hex');\n    if (set.has(hex))\n      throw new Error('Combine: KeyValue Map keys should be unique');\n    set.add(hex);\n  });\n  return set;\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst converter = require('./converter');\nfunction checkForInput(inputs, inputIndex) {\n  const input = inputs[inputIndex];\n  if (input === undefined) throw new Error(`No input #${inputIndex}`);\n  return input;\n}\nexports.checkForInput = checkForInput;\nfunction checkForOutput(outputs, outputIndex) {\n  const output = outputs[outputIndex];\n  if (output === undefined) throw new Error(`No output #${outputIndex}`);\n  return output;\n}\nexports.checkForOutput = checkForOutput;\nfunction checkHasKey(checkKeyVal, keyVals, enumLength) {\n  if (checkKeyVal.key[0] < enumLength) {\n    throw new Error(\n      `Use the method for your specific key instead of addUnknownKeyVal*`,\n    );\n  }\n  if (\n    keyVals &&\n    keyVals.filter(kv => kv.key.equals(checkKeyVal.key)).length !== 0\n  ) {\n    throw new Error(`Duplicate Key: ${checkKeyVal.key.toString('hex')}`);\n  }\n}\nexports.checkHasKey = checkHasKey;\nfunction getEnumLength(myenum) {\n  let count = 0;\n  Object.keys(myenum).forEach(val => {\n    if (Number(isNaN(Number(val)))) {\n      count++;\n    }\n  });\n  return count;\n}\nexports.getEnumLength = getEnumLength;\nfunction inputCheckUncleanFinalized(inputIndex, input) {\n  let result = false;\n  if (input.nonWitnessUtxo || input.witnessUtxo) {\n    const needScriptSig = !!input.redeemScript;\n    const needWitnessScript = !!input.witnessScript;\n    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;\n    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;\n    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;\n    result = scriptSigOK && witnessScriptOK && hasOneFinal;\n  }\n  if (result === false) {\n    throw new Error(\n      `Input #${inputIndex} has too much or too little data to clean`,\n    );\n  }\n}\nexports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;\nfunction throwForUpdateMaker(typeName, name, expected, data) {\n  throw new Error(\n    `Data for ${typeName} key ${name} is incorrect: Expected ` +\n      `${expected} and got ${JSON.stringify(data)}`,\n  );\n}\nfunction updateMaker(typeName) {\n  return (updateData, mainData) => {\n    for (const name of Object.keys(updateData)) {\n      // @ts-ignore\n      const data = updateData[name];\n      // @ts-ignore\n      const { canAdd, canAddToArray, check, expected } =\n        // @ts-ignore\n        converter[typeName + 's'][name] || {};\n      const isArray = !!canAddToArray;\n      // If unknown data. ignore and do not add\n      if (check) {\n        if (isArray) {\n          if (\n            !Array.isArray(data) ||\n            // @ts-ignore\n            (mainData[name] && !Array.isArray(mainData[name]))\n          ) {\n            throw new Error(`Key type ${name} must be an array`);\n          }\n          if (!data.every(check)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n          // @ts-ignore\n          const arr = mainData[name] || [];\n          const dupeCheckSet = new Set();\n          if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {\n            throw new Error('Can not add duplicate data to array');\n          }\n          // @ts-ignore\n          mainData[name] = arr.concat(data);\n        } else {\n          if (!check(data)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n          if (!canAdd(mainData, data)) {\n            throw new Error(`Can not add duplicate data to ${typeName}`);\n          }\n          // @ts-ignore\n          mainData[name] = data;\n        }\n      }\n    }\n  };\n}\nexports.updateGlobal = updateMaker('global');\nexports.updateInput = updateMaker('input');\nexports.updateOutput = updateMaker('output');\nfunction addInputAttributes(inputs, data) {\n  const index = inputs.length - 1;\n  const input = checkForInput(inputs, index);\n  exports.updateInput(data, input);\n}\nexports.addInputAttributes = addInputAttributes;\nfunction addOutputAttributes(outputs, data) {\n  const index = outputs.length - 1;\n  const output = checkForOutput(outputs, index);\n  exports.updateOutput(data, output);\n}\nexports.addOutputAttributes = addOutputAttributes;\nfunction defaultVersionSetter(version, txBuf) {\n  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {\n    throw new Error('Set Version: Invalid Transaction');\n  }\n  txBuf.writeUInt32LE(version, 0);\n  return txBuf;\n}\nexports.defaultVersionSetter = defaultVersionSetter;\nfunction defaultLocktimeSetter(locktime, txBuf) {\n  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {\n    throw new Error('Set Locktime: Invalid Transaction');\n  }\n  txBuf.writeUInt32LE(locktime, txBuf.length - 4);\n  return txBuf;\n}\nexports.defaultLocktimeSetter = defaultLocktimeSetter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst combiner_1 = require('./combiner');\nconst parser_1 = require('./parser');\nconst typeFields_1 = require('./typeFields');\nconst utils_1 = require('./utils');\nclass Psbt {\n  constructor(tx) {\n    this.inputs = [];\n    this.outputs = [];\n    this.globalMap = {\n      unsignedTx: tx,\n    };\n  }\n  static fromBase64(data, txFromBuffer) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n  static fromHex(data, txFromBuffer) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n  static fromBuffer(buffer, txFromBuffer) {\n    const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);\n    const psbt = new this(results.globalMap.unsignedTx);\n    Object.assign(psbt, results);\n    return psbt;\n  }\n  toBase64() {\n    const buffer = this.toBuffer();\n    return buffer.toString('base64');\n  }\n  toHex() {\n    const buffer = this.toBuffer();\n    return buffer.toString('hex');\n  }\n  toBuffer() {\n    return parser_1.psbtToBuffer(this);\n  }\n  updateGlobal(updateData) {\n    utils_1.updateGlobal(updateData, this.globalMap);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.updateInput(updateData, input);\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const output = utils_1.checkForOutput(this.outputs, outputIndex);\n    utils_1.updateOutput(updateData, output);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    utils_1.checkHasKey(\n      keyVal,\n      this.globalMap.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.GlobalTypes),\n    );\n    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];\n    this.globalMap.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.checkHasKey(\n      keyVal,\n      input.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.InputTypes),\n    );\n    if (!input.unknownKeyVals) input.unknownKeyVals = [];\n    input.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    const output = utils_1.checkForOutput(this.outputs, outputIndex);\n    utils_1.checkHasKey(\n      keyVal,\n      output.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.OutputTypes),\n    );\n    if (!output.unknownKeyVals) output.unknownKeyVals = [];\n    output.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addInput(inputData) {\n    this.globalMap.unsignedTx.addInput(inputData);\n    this.inputs.push({\n      unknownKeyVals: [],\n    });\n    const addKeyVals = inputData.unknownKeyVals || [];\n    const inputIndex = this.inputs.length - 1;\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n    addKeyVals.forEach(keyVal =>\n      this.addUnknownKeyValToInput(inputIndex, keyVal),\n    );\n    utils_1.addInputAttributes(this.inputs, inputData);\n    return this;\n  }\n  addOutput(outputData) {\n    this.globalMap.unsignedTx.addOutput(outputData);\n    this.outputs.push({\n      unknownKeyVals: [],\n    });\n    const addKeyVals = outputData.unknownKeyVals || [];\n    const outputIndex = this.outputs.length - 1;\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n    addKeyVals.forEach(keyVal =>\n      this.addUnknownKeyValToOutput(outputIndex, keyVal),\n    );\n    utils_1.addOutputAttributes(this.outputs, outputData);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.inputCheckUncleanFinalized(inputIndex, input);\n    for (const key of Object.keys(input)) {\n      if (\n        ![\n          'witnessUtxo',\n          'nonWitnessUtxo',\n          'finalScriptSig',\n          'finalScriptWitness',\n          'unknownKeyVals',\n        ].includes(key)\n      ) {\n        // @ts-ignore\n        delete input[key];\n      }\n    }\n    return this;\n  }\n  combine(...those) {\n    // Combine this with those.\n    // Return self for chaining.\n    const result = combiner_1.combine([this].concat(those));\n    Object.assign(this, result);\n    return this;\n  }\n  getTransaction() {\n    return this.globalMap.unsignedTx.toBuffer();\n  }\n}\nexports.Psbt = Psbt;\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nexport function ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nexport function byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexport const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexport const swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nexport class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport const wrapConstructor = createHasher;\nexport const wrapConstructorWithOpts = createOptHasher;\nexport const wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, Hash, toBytes } from \"./utils.js\";\nexport class HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        ahash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        clean(pad);\n    }\n    update(buf) {\n        aexists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        abytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { Hash, abytes, aexists, aoutput, clean, createView, toBytes } from \"./utils.js\";\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nexport function Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map","/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from \"./_md.js\";\nimport { clean, createHasher, rotl } from \"./utils.js\";\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */\nexport class SHA1 extends HashMD {\n    constructor() {\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = Chi(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = Maj(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = rotl(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        clean(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1 = /* @__PURE__ */ createHasher(() => new SHA1());\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nexport class MD5 extends HashMD {\n    constructor() {\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [A, B, C, D];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for (let i = 0; i < 64; i++) {\n            let F, g, s;\n            if (i < 16) {\n                F = Chi(B, C, D);\n                g = i;\n                s = [7, 12, 17, 22];\n            }\n            else if (i < 32) {\n                F = Chi(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [5, 9, 14, 20];\n            }\n            else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [4, 11, 16, 23];\n            }\n            else {\n                F = C ^ (B | ~D);\n                g = (7 * i) % 16;\n                s = [6, 10, 15, 21];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + rotl(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        clean(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5 = /* @__PURE__ */ createHasher(() => new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n    const L = [Id160];\n    const R = [Pi160];\n    const res = [L, R];\n    for (let i = 0; i < 4; i++)\n        for (let j of res)\n            j.push(j[i].map((k) => Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    if (group === 1)\n        return (x & y) | (~x & z);\n    if (group === 2)\n        return (x | ~y) ^ z;\n    if (group === 3)\n        return (x & z) | (y & ~z);\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        clean(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160 = /* @__PURE__ */ createHasher(() => new RIPEMD160());\n//# sourceMappingURL=legacy.js.map","/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n * @deprecated\n */\nimport { RIPEMD160 as RIPEMD160n, ripemd160 as ripemd160n } from \"./legacy.js\";\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexport const RIPEMD160 = RIPEMD160n;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexport const ripemd160 = ripemd160n;\n//# sourceMappingURL=ripemd160.js.map","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from \"./_md.js\";\nimport * as u64 from \"./_u64.js\";\nimport { clean, createHasher, rotr } from \"./utils.js\";\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        clean(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        clean(this.buffer);\n    }\n}\nexport class SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = SHA224_IV[0] | 0;\n        this.B = SHA224_IV[1] | 0;\n        this.C = SHA224_IV[2] | 0;\n        this.D = SHA224_IV[3] | 0;\n        this.E = SHA224_IV[4] | 0;\n        this.F = SHA224_IV[5] | 0;\n        this.G = SHA224_IV[6] | 0;\n        this.H = SHA224_IV[7] | 0;\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = SHA512_IV[0] | 0;\n        this.Al = SHA512_IV[1] | 0;\n        this.Bh = SHA512_IV[2] | 0;\n        this.Bl = SHA512_IV[3] | 0;\n        this.Ch = SHA512_IV[4] | 0;\n        this.Cl = SHA512_IV[5] | 0;\n        this.Dh = SHA512_IV[6] | 0;\n        this.Dl = SHA512_IV[7] | 0;\n        this.Eh = SHA512_IV[8] | 0;\n        this.El = SHA512_IV[9] | 0;\n        this.Fh = SHA512_IV[10] | 0;\n        this.Fl = SHA512_IV[11] | 0;\n        this.Gh = SHA512_IV[12] | 0;\n        this.Gl = SHA512_IV[13] | 0;\n        this.Hh = SHA512_IV[14] | 0;\n        this.Hl = SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        clean(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexport class SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = SHA384_IV[0] | 0;\n        this.Al = SHA384_IV[1] | 0;\n        this.Bh = SHA384_IV[2] | 0;\n        this.Bl = SHA384_IV[3] | 0;\n        this.Ch = SHA384_IV[4] | 0;\n        this.Cl = SHA384_IV[5] | 0;\n        this.Dh = SHA384_IV[6] | 0;\n        this.Dl = SHA384_IV[7] | 0;\n        this.Eh = SHA384_IV[8] | 0;\n        this.El = SHA384_IV[9] | 0;\n        this.Fh = SHA384_IV[10] | 0;\n        this.Fl = SHA384_IV[11] | 0;\n        this.Gh = SHA384_IV[12] | 0;\n        this.Gl = SHA384_IV[13] | 0;\n        this.Hh = SHA384_IV[14] | 0;\n        this.Hl = SHA384_IV[15] | 0;\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nexport class SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexport class SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256 = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224 = /* @__PURE__ */ createHasher(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512 = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384 = /* @__PURE__ */ createHasher(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256 = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224 = /* @__PURE__ */ createHasher(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map","/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nimport { SHA224 as SHA224n, sha224 as sha224n, SHA256 as SHA256n, sha256 as sha256n, } from \"./sha2.js\";\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA256 = SHA256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha256 = sha256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA224 = SHA224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha224 = sha224n;\n//# sourceMappingURL=sha256.js.map","/**\n * SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.\n *\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).\n * @module\n * @deprecated\n */\nimport { SHA384 as SHA384n, sha384 as sha384n, sha512_224 as sha512_224n, SHA512_224 as SHA512_224n, sha512_256 as sha512_256n, SHA512_256 as SHA512_256n, SHA512 as SHA512n, sha512 as sha512n, } from \"./sha2.js\";\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA512 = SHA512n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha512 = sha512n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA384 = SHA384n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha384 = sha384n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA512_224 = SHA512_224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha512_224 = sha512_224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA512_256 = SHA512_256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha512_256 = sha512_256n;\n//# sourceMappingURL=sha512.js.map","import { hmac } from '@noble/hashes/hmac';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512 } from '@noble/hashes/sha512';\nexport function hash160(buffer) {\n    return ripemd160(sha256(buffer));\n}\nexport function hmacSHA512(key, data) {\n    return hmac(sha512, key, data);\n}\n","const HEX_STRINGS = \"0123456789abcdefABCDEF\";\nconst HEX_CODES = HEX_STRINGS.split(\"\").map((c) => c.codePointAt(0));\nconst HEX_CODEPOINTS = Array(256)\n    .fill(true)\n    .map((_, i) => {\n    const s = String.fromCodePoint(i);\n    const index = HEX_STRINGS.indexOf(s);\n    // ABCDEF will use 10 - 15\n    return index < 0 ? undefined : index < 16 ? index : index - 6;\n});\nconst ENCODER = new TextEncoder();\nconst DECODER = new TextDecoder();\nexport function toUtf8(bytes) {\n    return DECODER.decode(bytes);\n}\nexport function fromUtf8(s) {\n    return ENCODER.encode(s);\n}\nexport function concat(arrays) {\n    const totalLength = arrays.reduce((a, b) => a + b.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const array of arrays) {\n        result.set(array, offset);\n        offset += array.length;\n    }\n    return result;\n}\n// There are two implementations.\n// One optimizes for length of the bytes, and uses TextDecoder.\n// One optimizes for iteration count, and appends strings.\n// This removes the overhead of TextDecoder.\nexport function toHex(bytes) {\n    const b = bytes || new Uint8Array();\n    return b.length > 512 ? _toHexLengthPerf(b) : _toHexIterPerf(b);\n}\nfunction _toHexIterPerf(bytes) {\n    let s = \"\";\n    for (let i = 0; i < bytes.length; ++i) {\n        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] >> 4]]];\n        s += HEX_STRINGS[HEX_CODEPOINTS[HEX_CODES[bytes[i] & 15]]];\n    }\n    return s;\n}\nfunction _toHexLengthPerf(bytes) {\n    const hexBytes = new Uint8Array(bytes.length * 2);\n    for (let i = 0; i < bytes.length; ++i) {\n        hexBytes[i * 2] = HEX_CODES[bytes[i] >> 4];\n        hexBytes[i * 2 + 1] = HEX_CODES[bytes[i] & 15];\n    }\n    return DECODER.decode(hexBytes);\n}\n// Mimics Buffer.from(x, 'hex') logic\n// Stops on first non-hex string and returns\n// https://github.com/nodejs/node/blob/v14.18.1/src/string_bytes.cc#L246-L261\nexport function fromHex(hexString) {\n    const hexBytes = ENCODER.encode(hexString || \"\");\n    const resultBytes = new Uint8Array(Math.floor(hexBytes.length / 2));\n    let i;\n    for (i = 0; i < resultBytes.length; i++) {\n        const a = HEX_CODEPOINTS[hexBytes[i * 2]];\n        const b = HEX_CODEPOINTS[hexBytes[i * 2 + 1]];\n        if (a === undefined || b === undefined) {\n            break;\n        }\n        resultBytes[i] = (a << 4) | b;\n    }\n    return i === resultBytes.length ? resultBytes : resultBytes.slice(0, i);\n}\nexport function toBase64(bytes) {\n    return btoa(String.fromCharCode(...bytes));\n}\nexport function fromBase64(base64) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n}\n// Same behavior as Buffer.compare()\nexport function compare(v1, v2) {\n    const minLength = Math.min(v1.length, v2.length);\n    for (let i = 0; i < minLength; ++i) {\n        if (v1[i] !== v2[i]) {\n            return v1[i] < v2[i] ? -1 : 1;\n        }\n    }\n    return v1.length === v2.length ? 0 : v1.length > v2.length ? 1 : -1;\n}\nexport function writeUInt8(buffer, offset, value) {\n    if (offset + 1 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    if (value > 0xff) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= 0 and <= ${0xff}. Received ${value}`);\n    }\n    buffer[offset] = value;\n}\nexport function writeUInt16(buffer, offset, value, littleEndian) {\n    if (offset + 2 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (value > 0xffff) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= 0 and <= ${0xffff}. Received ${value}`);\n    }\n    if (littleEndian === \"LE\") {\n        buffer[offset] = value & 0xff;\n        buffer[offset + 1] = (value >> 8) & 0xff;\n    }\n    else {\n        buffer[offset] = (value >> 8) & 0xff;\n        buffer[offset + 1] = value & 0xff;\n    }\n}\nexport function writeUInt32(buffer, offset, value, littleEndian) {\n    if (offset + 4 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (value > 0xffffffff) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= 0 and <= ${0xffffffff}. Received ${value}`);\n    }\n    if (littleEndian === \"LE\") {\n        buffer[offset] = value & 0xff;\n        buffer[offset + 1] = (value >> 8) & 0xff;\n        buffer[offset + 2] = (value >> 16) & 0xff;\n        buffer[offset + 3] = (value >> 24) & 0xff;\n    }\n    else {\n        buffer[offset] = (value >> 24) & 0xff;\n        buffer[offset + 1] = (value >> 16) & 0xff;\n        buffer[offset + 2] = (value >> 8) & 0xff;\n        buffer[offset + 3] = value & 0xff;\n    }\n}\nexport function writeUInt64(buffer, offset, value, littleEndian) {\n    if (offset + 8 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (value > 0xffffffffffffffffn) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${value}`);\n    }\n    if (littleEndian === \"LE\") {\n        buffer[offset] = Number(value & 0xffn);\n        buffer[offset + 1] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 7] = Number((value >> 56n) & 0xffn);\n    }\n    else {\n        buffer[offset] = Number((value >> 56n) & 0xffn);\n        buffer[offset + 1] = Number((value >> 48n) & 0xffn);\n        buffer[offset + 2] = Number((value >> 40n) & 0xffn);\n        buffer[offset + 3] = Number((value >> 32n) & 0xffn);\n        buffer[offset + 4] = Number((value >> 24n) & 0xffn);\n        buffer[offset + 5] = Number((value >> 16n) & 0xffn);\n        buffer[offset + 6] = Number((value >> 8n) & 0xffn);\n        buffer[offset + 7] = Number(value & 0xffn);\n    }\n}\nexport function readUInt8(buffer, offset) {\n    if (offset + 1 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    return buffer[offset];\n}\nexport function readUInt16(buffer, offset, littleEndian) {\n    if (offset + 2 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        let num = 0;\n        num = (num << 8) + buffer[offset + 1];\n        num = (num << 8) + buffer[offset];\n        return num;\n    }\n    else {\n        let num = 0;\n        num = (num << 8) + buffer[offset];\n        num = (num << 8) + buffer[offset + 1];\n        return num;\n    }\n}\nexport function readUInt32(buffer, offset, littleEndian) {\n    if (offset + 4 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        let num = 0;\n        num = ((num << 8) + buffer[offset + 3]) >>> 0;\n        num = ((num << 8) + buffer[offset + 2]) >>> 0;\n        num = ((num << 8) + buffer[offset + 1]) >>> 0;\n        num = ((num << 8) + buffer[offset]) >>> 0;\n        return num;\n    }\n    else {\n        let num = 0;\n        num = ((num << 8) + buffer[offset]) >>> 0;\n        num = ((num << 8) + buffer[offset + 1]) >>> 0;\n        num = ((num << 8) + buffer[offset + 2]) >>> 0;\n        num = ((num << 8) + buffer[offset + 3]) >>> 0;\n        return num;\n    }\n}\nexport function readUInt64(buffer, offset, littleEndian) {\n    if (offset + 8 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        let num = 0n;\n        num = (num << 8n) + BigInt(buffer[offset + 7]);\n        num = (num << 8n) + BigInt(buffer[offset + 6]);\n        num = (num << 8n) + BigInt(buffer[offset + 5]);\n        num = (num << 8n) + BigInt(buffer[offset + 4]);\n        num = (num << 8n) + BigInt(buffer[offset + 3]);\n        num = (num << 8n) + BigInt(buffer[offset + 2]);\n        num = (num << 8n) + BigInt(buffer[offset + 1]);\n        num = (num << 8n) + BigInt(buffer[offset]);\n        return num;\n    }\n    else {\n        let num = 0n;\n        num = (num << 8n) + BigInt(buffer[offset]);\n        num = (num << 8n) + BigInt(buffer[offset + 1]);\n        num = (num << 8n) + BigInt(buffer[offset + 2]);\n        num = (num << 8n) + BigInt(buffer[offset + 3]);\n        num = (num << 8n) + BigInt(buffer[offset + 4]);\n        num = (num << 8n) + BigInt(buffer[offset + 5]);\n        num = (num << 8n) + BigInt(buffer[offset + 6]);\n        num = (num << 8n) + BigInt(buffer[offset + 7]);\n        return num;\n    }\n}\n","import * as tools from 'uint8array-tools';\nconst h = (hex) => tools.fromHex(hex);\nexport function testEcc(ecc) {\n    assert(ecc.isPoint(h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));\n    assert(!ecc.isPoint(h('030000000000000000000000000000000000000000000000000000000000000005')));\n    assert(ecc.isPrivate(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));\n    // order - 1\n    assert(ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')));\n    // 0\n    assert(!ecc.isPrivate(h('0000000000000000000000000000000000000000000000000000000000000000')));\n    // order\n    assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141')));\n    // order + 1\n    assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142')));\n    assert(tools.compare(ecc.pointFromScalar(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af')), h('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99')) === 0);\n    if (ecc.xOnlyPointAddTweak) {\n        assert(ecc.xOnlyPointAddTweak(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === null);\n        let xOnlyRes = ecc.xOnlyPointAddTweak(h('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'), h('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac'));\n        assert(tools.compare(xOnlyRes.xOnlyPubkey, h('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf')) === 0 && xOnlyRes.parity === 1);\n        xOnlyRes = ecc.xOnlyPointAddTweak(h('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'), h('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47'));\n    }\n    assert(tools.compare(ecc.pointAddScalar(h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('0000000000000000000000000000000000000000000000000000000000000003')), h('02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5')) === 0);\n    assert(tools.compare(ecc.privateAdd(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'), h('0000000000000000000000000000000000000000000000000000000000000002')), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === 0);\n    if (ecc.privateNegate) {\n        assert(tools.compare(ecc.privateNegate(h('0000000000000000000000000000000000000000000000000000000000000001')), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === 0);\n        assert(tools.compare(ecc.privateNegate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e')), h('0000000000000000000000000000000000000000000000000000000000000003')) === 0);\n        assert(tools.compare(ecc.privateNegate(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af')), h('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792')) === 0);\n    }\n    assert(tools.compare(ecc.sign(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')), h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')) === 0);\n    assert(ecc.verify(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')));\n    if (ecc.signSchnorr) {\n        assert(tools.compare(ecc.signSchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'), h('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906')), h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')) === 0);\n    }\n    if (ecc.verifySchnorr) {\n        assert(ecc.verifySchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'), h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')));\n    }\n}\nfunction assert(bool) {\n    if (!bool)\n        throw new Error('ecc library invalid');\n}\n","/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction isArrayOf(isString, arr) {\n    if (!Array.isArray(arr))\n        return false;\n    if (arr.length === 0)\n        return true;\n    if (isString) {\n        return arr.every((item) => typeof item === 'string');\n    }\n    else {\n        return arr.every((item) => Number.isSafeInteger(item));\n    }\n}\n// no abytes: seems to have 10% slowdown. Why?!\nfunction afn(input) {\n    if (typeof input !== 'function')\n        throw new Error('function expected');\n    return true;\n}\nfunction astr(label, input) {\n    if (typeof input !== 'string')\n        throw new Error(`${label}: string expected`);\n    return true;\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`invalid integer: ${n}`);\n}\nfunction aArr(input) {\n    if (!Array.isArray(input))\n        throw new Error('array expected');\n}\nfunction astrArr(label, input) {\n    if (!isArrayOf(true, input))\n        throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label, input) {\n    if (!isArrayOf(false, input))\n        throw new Error(`${label}: array of numbers expected`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters) {\n    // mapping 1 to \"b\"\n    const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n    const len = lettersA.length;\n    astrArr('alphabet', lettersA);\n    // mapping \"b\" to 1\n    const indexes = new Map(lettersA.map((l, i) => [l, i]));\n    return {\n        encode: (digits) => {\n            aArr(digits);\n            return digits.map((i) => {\n                if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n                    throw new Error(`alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`);\n                return lettersA[i];\n            });\n        },\n        decode: (input) => {\n            aArr(input);\n            return input.map((letter) => {\n                astr('alphabet.decode', letter);\n                const i = indexes.get(letter);\n                if (i === undefined)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n                return i;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    astr('join', separator);\n    return {\n        encode: (from) => {\n            astrArr('join.decode', from);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            astr('join.decode', to);\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    anumber(bits);\n    astr('padding', chr);\n    return {\n        encode(data) {\n            astrArr('padding.encode', data);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            astrArr('padding.decode', input);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('padding: invalid, string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                const last = end - 1;\n                const byte = last * bits;\n                if (byte % 8 === 0)\n                    throw new Error('padding: invalid, string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    afn(fn);\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n    aArr(data);\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data, (d) => {\n        anumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`invalid integer: ${d}`);\n        return d;\n    });\n    const dlen = digits.length;\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < dlen; i++) {\n            const digit = digits[i];\n            const fromCarry = from * carry;\n            const digitBase = fromCarry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                fromCarry / from !== carry ||\n                digitBase - digit !== fromCarry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            const div = digitBase / to;\n            carry = digitBase % to;\n            const rounded = Math.floor(div);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\nconst powers = /* @__PURE__ */ (() => {\n    let res = [];\n    for (let i = 0; i < 40; i++)\n        res.push(2 ** i);\n    return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data, from, to, padding) {\n    aArr(data);\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const max = powers[from];\n    const mask = powers[to] - 1;\n    const res = [];\n    for (const n of data) {\n        anumber(n);\n        if (n >= max)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        const pow = powers[pos];\n        if (pow === undefined)\n            throw new Error('invalid carry');\n        carry &= pow - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry > 0)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    anumber(num);\n    const _256 = 2 ** 8;\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), _256, num);\n        },\n        decode: (digits) => {\n            anumArr('radix.decode', digits);\n            return Uint8Array.from(convertRadix(digits, num, _256));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    anumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            anumArr('radix2.decode', digits);\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    afn(fn);\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    anumber(len);\n    afn(fn);\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const sum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(sum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const oldChecksum = data.slice(-len);\n            const newChecksum = fn(payload).slice(0, len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nexport const utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toBase64 === 'function' &&\n    typeof Uint8Array.fromBase64 === 'function')();\nconst decodeBase64Builtin = (s, isUrl) => {\n    astr('base64', s);\n    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n    const alphabet = isUrl ? 'base64url' : 'base64';\n    if (s.length > 0 && !re.test(s))\n        throw new Error('invalid base64');\n    return Uint8Array.fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\n};\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64 = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64(); },\n    decode(s) { return decodeBase64Builtin(s, false); },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url = hasBase64Builtin ? {\n    encode(b) { abytes(b); return b.toBase64({ alphabet: 'base64url' }); },\n    decode(s) { return decodeBase64Builtin(s, true); },\n} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(''));\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check = createBase58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        astr('bech32.encode prefix', prefix);\n        if (isBytes(words))\n            words = Array.from(words);\n        anumArr('bech32.encode', words);\n        const plen = prefix.length;\n        if (plen === 0)\n            throw new TypeError(`Invalid prefix length ${plen}`);\n        const actualLength = plen + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        astr('bech32.decode input', str);\n        const slen = str.length;\n        if (slen < 8 || (limit !== false && slen > limit))\n            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords,\n    };\n}\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32 = genBech32('bech32');\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m = genBech32('bech32m');\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin = /* @__PURE__ */ (() => typeof Uint8Array.from([]).toHex === 'function' &&\n    typeof Uint8Array.fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin = {\n    encode(data) { abytes(data); return data.toHex(); },\n    decode(s) { astr('hex', s); return Uint8Array.fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex = hasHexBuiltin\n    ? hexBuiltin\n    : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n            throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n        return s.toLowerCase();\n    }));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n/** @deprecated */\nexport const bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\n/** @deprecated */\nexport const str = bytesToString; // as in python, but for bytes only\n/** @deprecated */\nexport const stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes = stringToBytes;\n//# sourceMappingURL=index.js.map","// src/actions/await/awaitAsync.ts\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async _run(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    // @ts-expect-error\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? // @ts-expect-error\n  context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message) {\n    issue.message = typeof message === \"function\" ? message(issue) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * The error issues.\n   */\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/base64/base64.ts\nfunction base64(message) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/email/email.ts\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value > this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: requirement.map((option) => `\"${option}\"`).join(\" | \") || \"never\",\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value < this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    _run(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\nfunction _isPartiallyTyped(dataset, pathList) {\n  if (dataset.issues) {\n    for (const path of pathList) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (path[index] !== issue.path[index].key) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\nfunction partialCheck(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\nfunction partialCheckAsync(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    _run(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async _run(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    _run(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async _run(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    _run(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async _run(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/config/config.ts\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    _run(dataset, config_) {\n      return schema._run(dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _run(dataset, config2) {\n      const outputDataset = schema._run(dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    async _run(dataset, config2) {\n      const outputDataset = await schema._run(dataset, config2);\n      return outputDataset.issues ? (\n        // @ts-expect-error\n        { typed: true, value: await getFallback(this, outputDataset, config2) }\n      ) : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      await action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input) {\n  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item._run({ typed: false, value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    _run(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    async _run(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n  const options = Object.entries(enum__).filter(([key]) => isNaN(+key)).map(([, value2]) => value2);\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/file/file.ts\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema._run(\n            { typed: false, value: input },\n            config2\n          );\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map(\n            (schema) => schema._run({ typed: false, value: input }, config2)\n          )\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    _run(dataset, config2) {\n      return this.getter(dataset.value)._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    async _run(dataset, config2) {\n      return (await this.getter(dataset.value))._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key._run(\n            { typed: false, value: inputKey },\n            config2\n          );\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key._run({ typed: false, value: inputKey }, config2),\n              this.value._run({ typed: false, value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"!null & !undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"!null & !undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `${wrapped.expects} | null`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `${wrapped.expects} | null`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `${wrapped.expects} | null | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/number/number.ts\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const value2 = input[key];\n              const valueDataset = this.rest._run(\n                { typed: false, value: value2 },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal entry\n          // Hint: We do not distinguish between missing and `undefined` entries.\n          // The reason for this decision is that it reduces the bundle size, and\n          // we also expect that most users will expect this behavior.\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, schema]) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await schema._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other entries with rest schema\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueDataset] of normalDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `${wrapped.expects} | undefined`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `${wrapped.expects} | undefined`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: options.map(_stringify).join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key._run(\n              { typed: false, value: entryKey },\n              config2\n            );\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value._run(\n              { typed: false, value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key._run({ typed: false, value: entryKey }, config2),\n              this.value._run({ typed: false, value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value._run(\n                { typed: false, value: inputValue },\n                config2\n              )\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest._run({ typed: false, value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \") || \"never\",\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/utils/_discriminators/_discriminators.ts\nfunction _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {\n  for (const schema of options) {\n    if (schema.type === \"variant\") {\n      _discriminators(key, schema.options, set2);\n    } else {\n      set2.add(schema.entries[key].expects);\n    }\n  }\n  return set2;\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            ).issues) {\n              const optionDataset = schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, message) {\n  let expectedDiscriminators;\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        const discriminator = input[this.key];\n        if (this.key in input) {\n          let outputDataset;\n          for (const schema of this.options) {\n            if (schema.type === \"variant\" || !(await schema.entries[this.key]._run(\n              { typed: false, value: discriminator },\n              config2\n            )).issues) {\n              const optionDataset = await schema._run(\n                { typed: false, value: input },\n                config2\n              );\n              if (!optionDataset.issues) {\n                return optionDataset;\n              }\n              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                outputDataset = optionDataset;\n              }\n            }\n          }\n          if (outputDataset) {\n            return outputDataset;\n          }\n        }\n        if (!expectedDiscriminators) {\n          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(\" | \") || \"never\";\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          input: discriminator,\n          expected: expectedDiscriminators,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: discriminator\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pipe/pipe.ts\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    _run(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item._run(dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    async _run(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item._run(dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BASE64_REGEX,\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  OCTAL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _stringify,\n  any,\n  array,\n  arrayAsync,\n  awaitAsync,\n  base64,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  description,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxLength,\n  maxSize,\n  maxValue,\n  mimeType,\n  minBytes,\n  minLength,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_\n};\n","import * as v from 'valibot';\nexport const Uint32Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0xffffffff));\nexport const Uint31Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0x7fffffff));\nconst Uint8Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0xff));\nexport const Buffer256Bit = v.pipe(v.instance(Uint8Array), v.length(32));\nexport const Buffer33Bytes = v.pipe(v.instance(Uint8Array), v.length(33));\nexport const NetworkSchema = v.object({\n    wif: Uint8Schema,\n    bip32: v.object({\n        public: Uint32Schema,\n        private: Uint32Schema,\n    }),\n});\nexport const Bip32PathSchema = v.pipe(v.string(), v.regex(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/));\n","// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  const BASE_MAP = new Uint8Array(256)\n  for (let j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i)\n    const xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  const BASE = ALPHABET.length\n  const LEADER = ALPHABET.charAt(0)\n  const FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  const iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    // eslint-disable-next-line no-empty\n    if (source instanceof Uint8Array) { } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n    // Skip & count leading zeroes.\n    let zeroes = 0\n    let length = 0\n    let pbegin = 0\n    const pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    const b58 = new Uint8Array(size)\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = source[pbegin]\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0\n      for (let it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    let psz = 0\n    // Skip and count leading '1's.\n    let zeroes = 0\n    let length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n    // Allocate enough space in big-endian base256 representation.\n    const size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    const b256 = new Uint8Array(size)\n    // Process the characters.\n    while (psz < source.length) {\n      // Find code of next character\n      const charCode = source.charCodeAt(psz)\n      // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n      // Decode character\n      let carry = BASE_MAP[charCode]\n      // Invalid character\n      if (carry === 255) { return }\n      let i = 0\n      for (let it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n    // Skip leading zeroes in b256.\n    let it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    const vch = new Uint8Array(zeroes + (size - it4))\n    let j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    const buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode,\n    decodeUnsafe,\n    decode\n  }\n}\nexport default base\n","import basex from 'base-x';\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nexport default basex(ALPHABET);\n","'use strict';\nimport base58 from 'bs58';\nexport default function (checksumFn) {\n    // Encode a buffer as a base58-check encoded string\n    function encode(payload) {\n        var payloadU8 = Uint8Array.from(payload);\n        var checksum = checksumFn(payloadU8);\n        var length = payloadU8.length + 4;\n        var both = new Uint8Array(length);\n        both.set(payloadU8, 0);\n        both.set(checksum.subarray(0, 4), payloadU8.length);\n        return base58.encode(both);\n    }\n    function decodeRaw(buffer) {\n        var payload = buffer.slice(0, -4);\n        var checksum = buffer.slice(-4);\n        var newChecksum = checksumFn(payload);\n        // eslint-disable-next-line\n        if (checksum[0] ^ newChecksum[0] |\n            checksum[1] ^ newChecksum[1] |\n            checksum[2] ^ newChecksum[2] |\n            checksum[3] ^ newChecksum[3])\n            return;\n        return payload;\n    }\n    // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n    function decodeUnsafe(str) {\n        var buffer = base58.decodeUnsafe(str);\n        if (buffer == null)\n            return;\n        return decodeRaw(buffer);\n    }\n    function decode(str) {\n        var buffer = base58.decode(str);\n        var payload = decodeRaw(buffer);\n        if (payload == null)\n            throw new Error('Invalid checksum');\n        return payload;\n    }\n    return {\n        encode: encode,\n        decode: decode,\n        decodeUnsafe: decodeUnsafe\n    };\n}\n","'use strict';\nimport { sha256 } from '@noble/hashes/sha256';\nimport bs58checkBase from './base.js';\n// SHA256(SHA256(buffer))\nfunction sha256x2(buffer) {\n    return sha256(sha256(buffer));\n}\nexport default bs58checkBase(sha256x2);\n","import bs58Check from 'bs58check';\nexport function decodeRaw(buffer, version) {\n    // check version only if defined\n    if (version !== undefined && buffer[0] !== version)\n        throw new Error('Invalid network version');\n    // uncompressed\n    if (buffer.length === 33) {\n        return {\n            version: buffer[0],\n            privateKey: buffer.slice(1, 33),\n            compressed: false\n        };\n    }\n    // invalid length\n    if (buffer.length !== 34)\n        throw new Error('Invalid WIF length');\n    // invalid compression flag\n    if (buffer[33] !== 0x01)\n        throw new Error('Invalid compression flag');\n    return {\n        version: buffer[0],\n        privateKey: buffer.slice(1, 33),\n        compressed: true\n    };\n}\nexport function encodeRaw(version, privateKey, compressed) {\n    if (privateKey.length !== 32)\n        throw new TypeError('Invalid privateKey length');\n    var result = new Uint8Array(compressed ? 34 : 33);\n    var view = new DataView(result.buffer);\n    view.setUint8(0, version);\n    result.set(privateKey, 1);\n    if (compressed) {\n        result[33] = 0x01;\n    }\n    return result;\n}\nexport function decode(str, version) {\n    return decodeRaw(bs58Check.decode(str), version);\n}\nexport function encode(wif) {\n    return bs58Check.encode(encodeRaw(wif.version, wif.privateKey, wif.compressed));\n}\n","import * as crypto from './crypto.js';\nimport { testEcc } from './testecc.js';\nimport { base58check } from '@scure/base';\nimport { sha256 } from '@noble/hashes/sha256';\nimport * as v from 'valibot';\nimport { Bip32PathSchema, Buffer256Bit, Buffer33Bytes, NetworkSchema, Uint31Schema, Uint32Schema, } from './types.js';\nimport * as wif from 'wif';\nimport * as tools from 'uint8array-tools';\nconst _bs58check = base58check(sha256);\nconst bs58check = {\n    encode: (data) => _bs58check.encode(data),\n    decode: (str) => _bs58check.decode(str),\n};\nexport function BIP32Factory(ecc) {\n    testEcc(ecc);\n    const BITCOIN = {\n        messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n        bech32: 'bc',\n        bip32: {\n            public: 0x0488b21e,\n            private: 0x0488ade4,\n        },\n        pubKeyHash: 0x00,\n        scriptHash: 0x05,\n        wif: 0x80,\n    };\n    const HIGHEST_BIT = 0x80000000;\n    function toXOnly(pubKey) {\n        return pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);\n    }\n    class Bip32Signer {\n        __D;\n        __Q;\n        lowR = false;\n        constructor(__D, __Q) {\n            this.__D = __D;\n            this.__Q = __Q;\n        }\n        get publicKey() {\n            if (this.__Q === undefined)\n                this.__Q = ecc.pointFromScalar(this.__D, true);\n            return this.__Q;\n        }\n        get privateKey() {\n            return this.__D;\n        }\n        sign(hash, lowR) {\n            if (!this.privateKey)\n                throw new Error('Missing private key');\n            if (lowR === undefined)\n                lowR = this.lowR;\n            if (lowR === false) {\n                return ecc.sign(hash, this.privateKey);\n            }\n            else {\n                let sig = ecc.sign(hash, this.privateKey);\n                const extraData = new Uint8Array(32);\n                let counter = 0;\n                // if first try is lowR, skip the loop\n                // for second try and on, add extra entropy counting up\n                while (sig[0] > 0x7f) {\n                    counter++;\n                    tools.writeUInt32(extraData, 0, counter, 'LE');\n                    sig = ecc.sign(hash, this.privateKey, extraData);\n                }\n                return sig;\n            }\n        }\n        signSchnorr(hash) {\n            if (!this.privateKey)\n                throw new Error('Missing private key');\n            if (!ecc.signSchnorr)\n                throw new Error('signSchnorr not supported by ecc library');\n            return ecc.signSchnorr(hash, this.privateKey);\n        }\n        verify(hash, signature) {\n            return ecc.verify(hash, this.publicKey, signature);\n        }\n        verifySchnorr(hash, signature) {\n            if (!ecc.verifySchnorr)\n                throw new Error('verifySchnorr not supported by ecc library');\n            return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);\n        }\n    }\n    class BIP32 extends Bip32Signer {\n        chainCode;\n        network;\n        __DEPTH;\n        __INDEX;\n        __PARENT_FINGERPRINT;\n        constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {\n            super(__D, __Q);\n            this.chainCode = chainCode;\n            this.network = network;\n            this.__DEPTH = __DEPTH;\n            this.__INDEX = __INDEX;\n            this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;\n            v.parse(NetworkSchema, network);\n        }\n        get depth() {\n            return this.__DEPTH;\n        }\n        get index() {\n            return this.__INDEX;\n        }\n        get parentFingerprint() {\n            return this.__PARENT_FINGERPRINT;\n        }\n        get identifier() {\n            return crypto.hash160(this.publicKey);\n        }\n        get fingerprint() {\n            return this.identifier.slice(0, 4);\n        }\n        get compressed() {\n            return true;\n        }\n        // Private === not neutered\n        // Public === neutered\n        isNeutered() {\n            return this.__D === undefined;\n        }\n        neutered() {\n            return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);\n        }\n        toBase58() {\n            const network = this.network;\n            const version = !this.isNeutered()\n                ? network.bip32.private\n                : network.bip32.public;\n            const buffer = new Uint8Array(78);\n            // 4 bytes: version bytes\n            tools.writeUInt32(buffer, 0, version, 'BE');\n            // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n            tools.writeUInt8(buffer, 4, this.depth);\n            // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n            tools.writeUInt32(buffer, 5, this.parentFingerprint, 'BE');\n            // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n            // This is encoded in big endian. (0x00000000 if master key)\n            tools.writeUInt32(buffer, 9, this.index, 'BE');\n            // 32 bytes: the chain code\n            buffer.set(this.chainCode, 13);\n            // 33 bytes: the public key or private key data\n            if (!this.isNeutered()) {\n                // 0x00 + k for private keys\n                tools.writeUInt8(buffer, 45, 0);\n                buffer.set(this.privateKey, 46);\n                // 33 bytes: the public key\n            }\n            else {\n                // X9.62 encoding for public keys\n                buffer.set(this.publicKey, 45);\n            }\n            return bs58check.encode(buffer);\n        }\n        toWIF() {\n            if (!this.privateKey)\n                throw new TypeError('Missing private key');\n            return wif.encode({\n                version: this.network.wif,\n                privateKey: this.privateKey,\n                compressed: true,\n            });\n        }\n        // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n        derive(index) {\n            v.parse(Uint32Schema, index);\n            const isHardened = index >= HIGHEST_BIT;\n            const data = new Uint8Array(37);\n            // Hardened child\n            if (isHardened) {\n                if (this.isNeutered())\n                    throw new TypeError('Missing private key for hardened child key');\n                // data = 0x00 || ser256(kpar) || ser32(index)\n                data[0] = 0x00;\n                data.set(this.privateKey, 1);\n                tools.writeUInt32(data, 33, index, 'BE');\n                // Normal child\n            }\n            else {\n                // data = serP(point(kpar)) || ser32(index)\n                //      = serP(Kpar) || ser32(index)\n                data.set(this.publicKey, 0);\n                tools.writeUInt32(data, 33, index, 'BE');\n            }\n            const I = crypto.hmacSHA512(this.chainCode, data);\n            const IL = I.slice(0, 32);\n            const IR = I.slice(32);\n            // if parse256(IL) >= n, proceed with the next value for i\n            if (!ecc.isPrivate(IL))\n                return this.derive(index + 1);\n            // Private parent key -> private child key\n            let hd;\n            if (!this.isNeutered()) {\n                // ki = parse256(IL) + kpar (mod n)\n                const ki = ecc.privateAdd(this.privateKey, IL);\n                // In case ki == 0, proceed with the next value for i\n                if (ki == null)\n                    return this.derive(index + 1);\n                hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, tools.readUInt32(this.fingerprint, 0, 'BE'));\n                // Public parent key -> public child key\n            }\n            else {\n                // Ki = point(parse256(IL)) + Kpar\n                //    = G*IL + Kpar\n                const Ki = ecc.pointAddScalar(this.publicKey, IL, true);\n                // In case Ki is the point at infinity, proceed with the next value for i\n                if (Ki === null)\n                    return this.derive(index + 1);\n                hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, tools.readUInt32(this.fingerprint, 0, 'BE'));\n            }\n            return hd;\n        }\n        deriveHardened(index) {\n            if (typeof v.parse(Uint31Schema, index) === 'number')\n                // Only derives hardened private keys by default\n                return this.derive(index + HIGHEST_BIT);\n            throw new TypeError('Expected UInt31, got ' + index);\n        }\n        derivePath(path) {\n            v.parse(Bip32PathSchema, path);\n            let splitPath = path.split('/');\n            if (splitPath[0] === 'm') {\n                if (this.parentFingerprint)\n                    throw new TypeError('Expected master, got child');\n                splitPath = splitPath.slice(1);\n            }\n            return splitPath.reduce((prevHd, indexStr) => {\n                let index;\n                if (indexStr.slice(-1) === `'`) {\n                    index = parseInt(indexStr.slice(0, -1), 10);\n                    return prevHd.deriveHardened(index);\n                }\n                else {\n                    index = parseInt(indexStr, 10);\n                    return prevHd.derive(index);\n                }\n            }, this);\n        }\n        tweak(t) {\n            if (this.privateKey)\n                return this.tweakFromPrivateKey(t);\n            return this.tweakFromPublicKey(t);\n        }\n        tweakFromPublicKey(t) {\n            const xOnlyPubKey = toXOnly(this.publicKey);\n            if (!ecc.xOnlyPointAddTweak)\n                throw new Error('xOnlyPointAddTweak not supported by ecc library');\n            const tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t);\n            if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)\n                throw new Error('Cannot tweak public key!');\n            const parityByte = Uint8Array.from([\n                tweakedPublicKey.parity === 0 ? 0x02 : 0x03,\n            ]);\n            const tweakedPublicKeyCompresed = tools.concat([\n                parityByte,\n                tweakedPublicKey.xOnlyPubkey,\n            ]);\n            return new Bip32Signer(undefined, tweakedPublicKeyCompresed);\n        }\n        tweakFromPrivateKey(t) {\n            const hasOddY = this.publicKey[0] === 3 ||\n                (this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1);\n            const privateKey = (() => {\n                if (!hasOddY)\n                    return this.privateKey;\n                else if (!ecc.privateNegate)\n                    throw new Error('privateNegate not supported by ecc library');\n                else\n                    return ecc.privateNegate(this.privateKey);\n            })();\n            const tweakedPrivateKey = ecc.privateAdd(privateKey, t);\n            if (!tweakedPrivateKey)\n                throw new Error('Invalid tweaked private key!');\n            return new Bip32Signer(tweakedPrivateKey, undefined);\n        }\n    }\n    function fromBase58(inString, network) {\n        const buffer = bs58check.decode(inString);\n        if (buffer.length !== 78)\n            throw new TypeError('Invalid buffer length');\n        network = network || BITCOIN;\n        // 4 bytes: version bytes\n        const version = tools.readUInt32(buffer, 0, 'BE');\n        if (version !== network.bip32.private && version !== network.bip32.public)\n            throw new TypeError('Invalid network version');\n        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n        const depth = buffer[4];\n        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n        const parentFingerprint = tools.readUInt32(buffer, 5, 'BE');\n        if (depth === 0) {\n            if (parentFingerprint !== 0x00000000)\n                throw new TypeError('Invalid parent fingerprint');\n        }\n        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n        // This is encoded in MSB order. (0x00000000 if master key)\n        const index = tools.readUInt32(buffer, 9, 'BE');\n        if (depth === 0 && index !== 0)\n            throw new TypeError('Invalid index');\n        // 32 bytes: the chain code\n        const chainCode = buffer.slice(13, 45);\n        let hd;\n        // 33 bytes: private key data (0x00 + k)\n        if (version === network.bip32.private) {\n            if (buffer[45] !== 0x00)\n                throw new TypeError('Invalid private key');\n            const k = buffer.slice(46, 78);\n            hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);\n            // 33 bytes: public key data (0x02 + X or 0x03 + X)\n        }\n        else {\n            const X = buffer.slice(45, 78);\n            hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);\n        }\n        return hd;\n    }\n    function fromPrivateKey(privateKey, chainCode, network) {\n        return fromPrivateKeyLocal(privateKey, chainCode, network);\n    }\n    function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {\n        v.parse(Buffer256Bit, privateKey);\n        v.parse(Buffer256Bit, chainCode);\n        network = network || BITCOIN;\n        if (!ecc.isPrivate(privateKey))\n            throw new TypeError('Private key not in range [1, n)');\n        return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);\n    }\n    function fromPublicKey(publicKey, chainCode, network) {\n        return fromPublicKeyLocal(publicKey, chainCode, network);\n    }\n    function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {\n        v.parse(Buffer33Bytes, publicKey);\n        v.parse(Buffer256Bit, chainCode);\n        network = network || BITCOIN;\n        // verify the X coordinate is a point on the curve\n        if (!ecc.isPoint(publicKey))\n            throw new TypeError('Point is not on the curve');\n        return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);\n    }\n    function fromSeed(seed, network) {\n        v.parse(v.instance(Uint8Array), seed);\n        if (seed.length < 16)\n            throw new TypeError('Seed should be at least 128 bits');\n        if (seed.length > 64)\n            throw new TypeError('Seed should be at most 512 bits');\n        network = network || BITCOIN;\n        const I = crypto.hmacSHA512(tools.fromUtf8('Bitcoin seed'), seed);\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n        return fromPrivateKey(IL, IR, network);\n    }\n    return {\n        fromSeed,\n        fromBase58,\n        fromPublicKey,\n        fromPrivateKey,\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sha512_256 = exports.SHA512_256 = exports.sha512_224 = exports.SHA512_224 = exports.sha384 = exports.SHA384 = exports.sha512 = exports.SHA512 = void 0;\n/**\n * SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.\n *\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).\n * @module\n * @deprecated\n */\nconst sha2_ts_1 = require(\"./sha2.js\");\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA512 = sha2_ts_1.SHA512;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha512 = sha2_ts_1.sha512;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA384 = sha2_ts_1.SHA384;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha384 = sha2_ts_1.sha384;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA512_224 = sha2_ts_1.SHA512_224;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha512_224 = sha2_ts_1.sha512_224;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA512_256 = sha2_ts_1.SHA512_256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha512_256 = sha2_ts_1.sha512_256;\n//# sourceMappingURL=sha512.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hmac = exports.HMAC = void 0;\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nconst utils_ts_1 = require(\"./utils.js\");\nclass HMAC extends utils_ts_1.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, utils_ts_1.ahash)(hash);\n        const key = (0, utils_ts_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        (0, utils_ts_1.clean)(pad);\n    }\n    update(buf) {\n        (0, utils_ts_1.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pbkdf2 = pbkdf2;\nexports.pbkdf2Async = pbkdf2Async;\n/**\n * PBKDF (RFC 2898). Can be used to create a key from password and salt.\n * @module\n */\nconst hmac_ts_1 = require(\"./hmac.js\");\n// prettier-ignore\nconst utils_ts_1 = require(\"./utils.js\");\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0, utils_ts_1.ahash)(hash);\n    const opts = (0, utils_ts_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0, utils_ts_1.anumber)(c);\n    (0, utils_ts_1.anumber)(dkLen);\n    (0, utils_ts_1.anumber)(asyncTick);\n    if (c < 1)\n        throw new Error('iterations (c) should be >= 1');\n    const password = (0, utils_ts_1.kdfInputToBytes)(_password);\n    const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = hmac_ts_1.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    (0, utils_ts_1.clean)(u);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n * @example\n * const key = pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });\n */\nfunction pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0, utils_ts_1.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + â‹¯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ â‹¯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Ucâˆ’1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function. Async version.\n * @example\n * await pbkdf2Async(sha256, 'password', 'salt', { dkLen: 32, c: 500_000 });\n */\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0, utils_ts_1.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + â‹¯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ â‹¯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0, utils_ts_1.asyncLoop)(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Ucâˆ’1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// browserify by default only pulls in files that are hard coded in requires\n// In order of last to first in this file, the default wordlist will be chosen\n// based on what is present. (Bundles may remove wordlists they don't need)\nconst wordlists = {};\nexports.wordlists = wordlists;\nlet _default;\nexports._default = _default;\ntry {\n    exports._default = _default = require('./wordlists/czech.json');\n    wordlists.czech = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = require('./wordlists/chinese_simplified.json');\n    wordlists.chinese_simplified = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = require('./wordlists/chinese_traditional.json');\n    wordlists.chinese_traditional = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = require('./wordlists/korean.json');\n    wordlists.korean = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = require('./wordlists/french.json');\n    wordlists.french = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = require('./wordlists/italian.json');\n    wordlists.italian = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = require('./wordlists/spanish.json');\n    wordlists.spanish = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = require('./wordlists/japanese.json');\n    wordlists.japanese = _default;\n    wordlists.JA = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = require('./wordlists/portuguese.json');\n    wordlists.portuguese = _default;\n}\ncatch (err) { }\ntry {\n    exports._default = _default = require('./wordlists/english.json');\n    wordlists.english = _default;\n    wordlists.EN = _default;\n}\ncatch (err) { }\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sha256_1 = require(\"@noble/hashes/sha256\");\nconst sha512_1 = require(\"@noble/hashes/sha512\");\nconst pbkdf2_1 = require(\"@noble/hashes/pbkdf2\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst _wordlists_1 = require(\"./_wordlists\");\nlet DEFAULT_WORDLIST = _wordlists_1._default;\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nconst WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' +\n    'Please pass a 2048 word array explicitly.';\nfunction normalize(str) {\n    return (str || '').normalize('NFKD');\n}\nfunction lpad(str, padString, length) {\n    while (str.length < length) {\n        str = padString + str;\n    }\n    return str;\n}\nfunction binaryToByte(bin) {\n    return parseInt(bin, 2);\n}\nfunction bytesToBinary(bytes) {\n    return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');\n}\nfunction deriveChecksumBits(entropyBuffer) {\n    const ENT = entropyBuffer.length * 8;\n    const CS = ENT / 32;\n    const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));\n    return bytesToBinary(Array.from(hash)).slice(0, CS);\n}\nfunction salt(password) {\n    return 'mnemonic' + (password || '');\n}\nfunction mnemonicToSeedSync(mnemonic, password) {\n    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));\n    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));\n    const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {\n        c: 2048,\n        dkLen: 64,\n    });\n    return Buffer.from(res);\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\nfunction mnemonicToSeed(mnemonic, password) {\n    const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));\n    const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), 'utf8'));\n    return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {\n        c: 2048,\n        dkLen: 64,\n    }).then((res) => Buffer.from(res));\n}\nexports.mnemonicToSeed = mnemonicToSeed;\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    wordlist = wordlist || DEFAULT_WORDLIST;\n    if (!wordlist) {\n        throw new Error(WORDLIST_REQUIRED);\n    }\n    const words = normalize(mnemonic).split(' ');\n    if (words.length % 3 !== 0) {\n        throw new Error(INVALID_MNEMONIC);\n    }\n    // convert word indices to 11 bit binary strings\n    const bits = words\n        .map((word) => {\n        const index = wordlist.indexOf(word);\n        if (index === -1) {\n            throw new Error(INVALID_MNEMONIC);\n        }\n        return lpad(index.toString(2), '0', 11);\n    })\n        .join('');\n    // split the binary string into ENT/CS\n    const dividerIndex = Math.floor(bits.length / 33) * 32;\n    const entropyBits = bits.slice(0, dividerIndex);\n    const checksumBits = bits.slice(dividerIndex);\n    // calculate the checksum and compare\n    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n    if (entropyBytes.length < 16) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    if (entropyBytes.length > 32) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    if (entropyBytes.length % 4 !== 0) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    const entropy = Buffer.from(entropyBytes);\n    const newChecksum = deriveChecksumBits(entropy);\n    if (newChecksum !== checksumBits) {\n        throw new Error(INVALID_CHECKSUM);\n    }\n    return entropy.toString('hex');\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nfunction entropyToMnemonic(entropy, wordlist) {\n    if (!Buffer.isBuffer(entropy)) {\n        entropy = Buffer.from(entropy, 'hex');\n    }\n    wordlist = wordlist || DEFAULT_WORDLIST;\n    if (!wordlist) {\n        throw new Error(WORDLIST_REQUIRED);\n    }\n    // 128 <= ENT <= 256\n    if (entropy.length < 16) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    if (entropy.length > 32) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    if (entropy.length % 4 !== 0) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    const entropyBits = bytesToBinary(Array.from(entropy));\n    const checksumBits = deriveChecksumBits(entropy);\n    const bits = entropyBits + checksumBits;\n    const chunks = bits.match(/(.{1,11})/g);\n    const words = chunks.map((binary) => {\n        const index = binaryToByte(binary);\n        return wordlist[index];\n    });\n    return wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093' // Japanese wordlist\n        ? words.join('\\u3000')\n        : words.join(' ');\n}\nexports.entropyToMnemonic = entropyToMnemonic;\nfunction generateMnemonic(strength, rng, wordlist) {\n    strength = strength || 128;\n    if (strength % 32 !== 0) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    rng = rng || ((size) => Buffer.from(utils_1.randomBytes(size)));\n    return entropyToMnemonic(rng(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nfunction validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.validateMnemonic = validateMnemonic;\nfunction setDefaultWordlist(language) {\n    const result = _wordlists_1.wordlists[language];\n    if (result) {\n        DEFAULT_WORDLIST = result;\n    }\n    else {\n        throw new Error('Could not find wordlist for language \"' + language + '\"');\n    }\n}\nexports.setDefaultWordlist = setDefaultWordlist;\nfunction getDefaultWordlist() {\n    if (!DEFAULT_WORDLIST) {\n        throw new Error('No Default Wordlist set');\n    }\n    return Object.keys(_wordlists_1.wordlists).filter((lang) => {\n        if (lang === 'JA' || lang === 'EN') {\n            return false;\n        }\n        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);\n    })[0];\n}\nexports.getDefaultWordlist = getDefaultWordlist;\nvar _wordlists_2 = require(\"./_wordlists\");\nexports.wordlists = _wordlists_2.wordlists;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;\nexports.abool = abool;\nexports._abool2 = _abool2;\nexports._abytes2 = _abytes2;\nexports.numberToHexUnpadded = numberToHexUnpadded;\nexports.hexToNumber = hexToNumber;\nexports.bytesToNumberBE = bytesToNumberBE;\nexports.bytesToNumberLE = bytesToNumberLE;\nexports.numberToBytesBE = numberToBytesBE;\nexports.numberToBytesLE = numberToBytesLE;\nexports.numberToVarBytesBE = numberToVarBytesBE;\nexports.ensureBytes = ensureBytes;\nexports.equalBytes = equalBytes;\nexports.copyBytes = copyBytes;\nexports.asciiToBytes = asciiToBytes;\nexports.inRange = inRange;\nexports.aInRange = aInRange;\nexports.bitLen = bitLen;\nexports.bitGet = bitGet;\nexports.bitSet = bitSet;\nexports.createHmacDrbg = createHmacDrbg;\nexports.validateObject = validateObject;\nexports.isHash = isHash;\nexports._validateObject = _validateObject;\nexports.memoized = memoized;\n/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_js_1 = require(\"@noble/hashes/utils.js\");\nvar utils_js_2 = require(\"@noble/hashes/utils.js\");\nObject.defineProperty(exports, \"abytes\", { enumerable: true, get: function () { return utils_js_2.abytes; } });\nObject.defineProperty(exports, \"anumber\", { enumerable: true, get: function () { return utils_js_2.anumber; } });\nObject.defineProperty(exports, \"bytesToHex\", { enumerable: true, get: function () { return utils_js_2.bytesToHex; } });\nObject.defineProperty(exports, \"bytesToUtf8\", { enumerable: true, get: function () { return utils_js_2.bytesToUtf8; } });\nObject.defineProperty(exports, \"concatBytes\", { enumerable: true, get: function () { return utils_js_2.concatBytes; } });\nObject.defineProperty(exports, \"hexToBytes\", { enumerable: true, get: function () { return utils_js_2.hexToBytes; } });\nObject.defineProperty(exports, \"isBytes\", { enumerable: true, get: function () { return utils_js_2.isBytes; } });\nObject.defineProperty(exports, \"randomBytes\", { enumerable: true, get: function () { return utils_js_2.randomBytes; } });\nObject.defineProperty(exports, \"utf8ToBytes\", { enumerable: true, get: function () { return utils_js_2.utf8ToBytes; } });\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// tmp name until v2\nfunction _abool2(value, title = '') {\n    if (typeof value !== 'boolean') {\n        const prefix = title && `\"${title}\"`;\n        throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n    }\n    return value;\n}\n// tmp name until v2\n/** Asserts something is Uint8Array. */\nfunction _abytes2(value, length, title = '') {\n    const bytes = (0, utils_js_1.isBytes)(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || (needsLen && len !== length)) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : '';\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n    }\n    return value;\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber((0, utils_js_1.bytesToHex)(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    (0, utils_js_1.abytes)(bytes);\n    return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'secret key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = (0, utils_js_1.hexToBytes)(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if ((0, utils_js_1.isBytes)(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nfunction copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as utf8ToBytes for ASCII or throws.\n */\nfunction asciiToBytes(ascii) {\n    return Uint8Array.from(ascii, (c, i) => {\n        const charCode = c.charCodeAt(0);\n        if (c.length !== 1 || charCode > 127) {\n            throw new Error(`string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`);\n        }\n        return charCode;\n    });\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_1n << BigInt(n)) - _1n;\nexports.bitMask = bitMask;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    const u8n = (len) => new Uint8Array(len); // creates Uint8Array\n    const u8of = (byte) => Uint8Array.of(byte); // another shortcut\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0)) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return (0, utils_js_1.concatBytes)(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || (0, utils_js_1.isBytes)(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\nfunction isHash(val) {\n    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nfunction _validateObject(object, fields, optFields = {}) {\n    if (!object || typeof object !== 'object')\n        throw new Error('expected valid options object');\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined)\n            return;\n        const current = typeof val;\n        if (current !== expectedType || val === null)\n            throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n/**\n * throws not implemented error\n */\nconst notImplemented = () => {\n    throw new Error('not implemented');\n};\nexports.notImplemented = notImplemented;\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isNegativeLE = void 0;\nexports.mod = mod;\nexports.pow = pow;\nexports.pow2 = pow2;\nexports.invert = invert;\nexports.tonelliShanks = tonelliShanks;\nexports.FpSqrt = FpSqrt;\nexports.validateField = validateField;\nexports.FpPow = FpPow;\nexports.FpInvertBatch = FpInvertBatch;\nexports.FpDiv = FpDiv;\nexports.FpLegendre = FpLegendre;\nexports.FpIsSquare = FpIsSquare;\nexports.nLength = nLength;\nexports.Field = Field;\nexports.FpSqrtOdd = FpSqrtOdd;\nexports.FpSqrtEven = FpSqrtEven;\nexports.hashToPrivateScalar = hashToPrivateScalar;\nexports.getFieldBytesLength = getFieldBytesLength;\nexports.getMinHashLength = getMinHashLength;\nexports.mapHashToField = mapHashToField;\n/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_ts_1 = require(\"../utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);\n// prettier-ignore\nconst _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nfunction pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nfunction invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n    if (!Fp.eql(Fp.sqr(root), n))\n        throw new Error('Cannot find square root');\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    assertIsSquare(Fp, root, n);\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    assertIsSquare(Fp, root, n);\n    return root;\n}\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P) {\n    const Fp_ = Field(P);\n    const tn = tonelliShanks(P);\n    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    return (Fp, n) => {\n        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4\n        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1\n        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1\n        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1\n        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n        assertIsSquare(Fp, root, n);\n        return root;\n    };\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Initialization (precomputation).\n    // Caching initialization could boost perf by 7%.\n    if (P < _3n)\n        throw new Error('sqrt is not defined for small field');\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1)\n        return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n))\n            return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1)\n            throw new Error('Cannot find square root');\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while (!Fp.eql(t, Fp.ONE)) {\n            if (Fp.is0(t))\n                return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i) â‰¡ 1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while (!Fp.eql(t_tmp, Fp.ONE)) {\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M)\n                    throw new Error('Cannot find square root');\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P â‰¡ 3 (mod 4)\n * 2. P â‰¡ 5 (mod 8)\n * 3. P â‰¡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nfunction FpSqrt(P) {\n    // P â‰¡ 3 (mod 4) => âˆšn = n^((P+1)/4)\n    if (P % _4n === _3n)\n        return sqrt3mod4;\n    // P â‰¡ 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n)\n        return sqrt5mod8;\n    // P â‰¡ 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n    if (P % _16n === _9n)\n        return sqrt9mod16(P);\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'number',\n        BITS: 'number',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    (0, utils_ts_1._validateObject)(field, opts);\n    // const max = 16384;\n    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n    return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nfunction FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nfunction FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) â‰¡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) â‰¡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) â‰¡ 0    if a â‰¡ 0 (mod p)\n */\nfunction FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('invalid Legendre symbol result');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        (0, utils_ts_1.anumber)(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLenOrOpts, // TODO: use opts only in v2?\nisLE = false, opts = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    let _nbitLength = undefined;\n    let _sqrt = undefined;\n    let modFromBytes = false;\n    let allowedLengths = undefined;\n    if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {\n        if (opts.sqrt || isLE)\n            throw new Error('cannot specify opts in two arguments');\n        const _opts = bitLenOrOpts;\n        if (_opts.BITS)\n            _nbitLength = _opts.BITS;\n        if (_opts.sqrt)\n            _sqrt = _opts.sqrt;\n        if (typeof _opts.isLE === 'boolean')\n            isLE = _opts.isLE;\n        if (typeof _opts.modFromBytes === 'boolean')\n            modFromBytes = _opts.modFromBytes;\n        allowedLengths = _opts.allowedLengths;\n    }\n    else {\n        if (typeof bitLenOrOpts === 'number')\n            _nbitLength = bitLenOrOpts;\n        if (opts.sqrt)\n            _sqrt = opts.sqrt;\n    }\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0, utils_ts_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        allowedLengths: allowedLengths,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        // is valid and invertible\n        isValidNot0: (num) => !f.is0(num) && f.isValid(num),\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: _sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        toBytes: (num) => (isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes, skipValidation = true) => {\n            if (allowedLengths) {\n                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n                    throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);\n                }\n                const padded = new Uint8Array(BYTES);\n                // isLE add 0 to right, !isLE to the left.\n                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n                bytes = padded;\n            }\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            let scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);\n            if (modFromBytes)\n                scalar = mod(scalar, ORDER);\n            if (!skipValidation)\n                if (!f.isValid(scalar))\n                    throw new Error('invalid field element: outside of range 0..ORDER');\n            // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n            // protocol may allow non-reduced scalar that reduced later or changed some other way.\n            return scalar;\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c) => (c ? b : a),\n    });\n    return Object.freeze(f);\n}\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_ts_1.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.wNAF = void 0;\nexports.negateCt = negateCt;\nexports.normalizeZ = normalizeZ;\nexports.mulEndoUnsafe = mulEndoUnsafe;\nexports.pippenger = pippenger;\nexports.precomputeMSMUnsafe = precomputeMSMUnsafe;\nexports.validateBasic = validateBasic;\nexports._createCurveFields = _createCurveFields;\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_ts_1 = require(\"../utils.js\");\nconst modular_ts_1 = require(\"./modular.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nfunction normalizeZ(c, points) {\n    const invertedZs = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map((p) => p.Z));\n    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = (0, utils_ts_1.bitMask)(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    // To disable precomputes:\n    // return 1;\n    return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n    if (n !== _0n)\n        throw new Error('invalid wNAF');\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ð‘Š) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nclass wNAF {\n    // Parametrized with a given Point class (not individual point)\n    constructor(Point, bits) {\n        this.BASE = Point.BASE;\n        this.ZERO = Point.ZERO;\n        this.Fn = Point.Fn;\n        this.bits = bits;\n    }\n    // non-const time multiplication ladder\n    _unsafeLadder(elm, n, p = this.ZERO) {\n        let d = elm;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(ð‘Šâˆ’1) * (Math.ceil(ð‘› / ð‘Š) + 1), where:\n     * - ð‘Š is the window size\n     * - ð‘› is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param point Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(point, W) {\n        const { windows, windowSize } = calcWOpts(W, this.bits);\n        const points = [];\n        let p = point;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            // i=1, bc we skip 0\n            for (let i = 1; i < windowSize; i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * More compact implementation:\n     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W, precomputes, n) {\n        // Scalar should be smaller than field order\n        if (!this.Fn.isValid(n))\n            throw new Error('invalid scalar');\n        // Accumulators\n        let p = this.ZERO;\n        let f = this.BASE;\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // bits are 0: add garbage to fake point\n                // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                f = f.add(negateCt(isNegF, precomputes[offsetF]));\n            }\n            else {\n                // bits are 1: add to result point\n                p = p.add(negateCt(isNeg, precomputes[offset]));\n            }\n        }\n        assert0(n);\n        // Return both real and fake points: JIT won't eliminate f.\n        // At this point there is a way to F be infinity-point even if p is not,\n        // which makes it less const-time: around 1 bigint multiply.\n        return { p, f };\n    }\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n        const wo = calcWOpts(W, this.bits);\n        for (let window = 0; window < wo.windows; window++) {\n            if (n === _0n)\n                break; // Early-exit, skip 0 value\n            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // Window bits are 0: skip processing.\n                // Move to next window.\n                continue;\n            }\n            else {\n                const item = precomputes[offset];\n                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n            }\n        }\n        assert0(n);\n        return acc;\n    }\n    getPrecomputes(W, point, transform) {\n        // Calculate precomputes on a first run, reuse them after\n        let comp = pointPrecomputes.get(point);\n        if (!comp) {\n            comp = this.precomputeWindow(point, W);\n            if (W !== 1) {\n                // Doing transform outside of if brings 15% perf hit\n                if (typeof transform === 'function')\n                    comp = transform(comp);\n                pointPrecomputes.set(point, comp);\n            }\n        }\n        return comp;\n    }\n    cached(point, scalar, transform) {\n        const W = getW(point);\n        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n    }\n    unsafe(point, scalar, transform, prev) {\n        const W = getW(point);\n        if (W === 1)\n            return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n    }\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    createCache(P, W) {\n        validateW(W, this.bits);\n        pointWindowSizes.set(P, W);\n        pointPrecomputes.delete(P);\n    }\n    hasCache(elm) {\n        return getW(elm) !== 1;\n    }\n}\nexports.wNAF = wNAF;\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nfunction mulEndoUnsafe(Point, point, k1, k2) {\n    let acc = point;\n    let p1 = Point.ZERO;\n    let p2 = Point.ZERO;\n    while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n)\n            p1 = p1.add(acc);\n        if (k2 & _1n)\n            p2 = p2.add(acc);\n        acc = acc.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n    }\n    return { p1, p2 };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nfunction pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n        throw new Error('arrays of points and scalars must have equal length');\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12)\n        windowSize = wbits - 3;\n    else if (wbits > 4)\n        windowSize = wbits - 2;\n    else if (wbits > 0)\n        windowSize = 2;\n    const MASK = (0, utils_ts_1.bitMask)(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < slength; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nfunction precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar Ã— 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 Ã— 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 Ã— 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = (0, utils_ts_1.bitMask)(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\n// TODO: remove\n/** @deprecated */\nfunction validateBasic(curve) {\n    (0, modular_ts_1.validateField)(curve.Fp);\n    (0, utils_ts_1.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\nfunction createField(order, field, isLE) {\n    if (field) {\n        if (field.ORDER !== order)\n            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n        (0, modular_ts_1.validateField)(field);\n        return field;\n    }\n    else {\n        return (0, modular_ts_1.Field)(order, { isLE });\n    }\n}\n/** Validates CURVE opts and creates fields */\nfunction _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {\n    if (FpFnLE === undefined)\n        FpFnLE = type === 'edwards';\n    if (!CURVE || typeof CURVE !== 'object')\n        throw new Error(`expected valid ${type} CURVE object`);\n    for (const p of ['p', 'n', 'h']) {\n        const val = CURVE[p];\n        if (!(typeof val === 'bigint' && val > _0n))\n            throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n    const _b = type === 'weierstrass' ? 'b' : 'd';\n    const params = ['Gx', 'Gy', 'a', _b];\n    for (const p of params) {\n        // @ts-ignore\n        if (!Fp.isValid(CURVE[p]))\n            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    CURVE = Object.freeze(Object.assign({}, CURVE));\n    return { CURVE, Fp, Fn };\n}\n//# sourceMappingURL=curve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DER = exports.DERErr = void 0;\nexports._splitEndoScalar = _splitEndoScalar;\nexports._normFnElement = _normFnElement;\nexports.weierstrassN = weierstrassN;\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;\nexports.ecdh = ecdh;\nexports.ecdsa = ecdsa;\nexports.weierstrassPoints = weierstrassPoints;\nexports._legacyHelperEquat = _legacyHelperEquat;\nexports.weierstrass = weierstrass;\n/**\n * Short Weierstrass curve methods. The formula is: yÂ² = xÂ³ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst hmac_js_1 = require(\"@noble/hashes/hmac.js\");\nconst utils_1 = require(\"@noble/hashes/utils\");\nconst utils_ts_1 = require(\"../utils.js\");\nconst curve_ts_1 = require(\"./curve.js\");\nconst modular_ts_1 = require(\"./modular.js\");\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;\n/**\n * Splits scalar for GLV endomorphism.\n */\nfunction _splitEndoScalar(k, basis, n) {\n    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n    // Since part can be negative, we need to do this on point.\n    // TODO: verifyScalar function which consumes lambda\n    const [[a1, b1], [a2, b2]] = basis;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    // |k1|/|k2| is < sqrt(N), but can be negative.\n    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n    let k1 = k - c1 * a1 - c2 * a2;\n    let k2 = -c1 * b1 - c2 * b2;\n    const k1neg = k1 < _0n;\n    const k2neg = k2 < _0n;\n    if (k1neg)\n        k1 = -k1;\n    if (k2neg)\n        k2 = -k2;\n    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n    const MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n; // Half bits of N\n    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n        throw new Error('splitScalar (endomorphism): failed, k=' + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n}\nfunction validateSigFormat(format) {\n    if (!['compact', 'recovered', 'der'].includes(format))\n        throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n    return format;\n}\nfunction validateSigOpts(opts, def) {\n    const optsn = {};\n    for (let optName of Object.keys(def)) {\n        // @ts-ignore\n        optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n    }\n    (0, utils_ts_1._abool2)(optsn.lowS, 'lowS');\n    (0, utils_ts_1._abool2)(optsn.prehash, 'prehash');\n    if (optsn.format !== undefined)\n        validateSigFormat(optsn.format);\n    return optsn;\n}\nclass DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\nexports.DERErr = DERErr;\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexports.DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = exports.DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)((len.length / 2) | 128) : '';\n            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = exports.DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = exports.DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = (0, utils_ts_1.numberToHexUnpadded)(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = exports.DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return (0, utils_ts_1.bytesToNumberBE)(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = exports.DER;\n        const data = (0, utils_ts_1.ensureBytes)('signature', hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = exports.DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction _normFnElement(Fn, key) {\n    const { BYTES: expected } = Fn;\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else {\n        let bytes = (0, utils_ts_1.ensureBytes)('private key', key);\n        try {\n            num = Fn.fromBytes(bytes);\n        }\n        catch (error) {\n            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n        }\n    }\n    if (!Fn.isValidNot0(num))\n        throw new Error('invalid private key: out of range [1..N-1]');\n    return num;\n}\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * @example\n```js\nconst opts = {\n  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  h: BigInt(1),\n  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\nconst p256_Point = weierstrass(opts);\n```\n */\nfunction weierstrassN(params, extraOpts = {}) {\n    const validated = (0, curve_ts_1._createCurveFields)('weierstrass', params, extraOpts);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor, n: CURVE_ORDER } = CURVE;\n    (0, utils_ts_1._validateObject)(extraOpts, {}, {\n        allowInfinityPoint: 'boolean',\n        clearCofactor: 'function',\n        isTorsionFree: 'function',\n        fromBytes: 'function',\n        toBytes: 'function',\n        endo: 'object',\n        wrapPrivateKey: 'boolean',\n    });\n    const { endo } = extraOpts;\n    if (endo) {\n        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n        if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n        }\n    }\n    const lengths = getWLengths(Fp, Fn);\n    function assertCompressionIsSupported() {\n        if (!Fp.isOdd)\n            throw new Error('compression is not supported: Field does not have .isOdd()');\n    }\n    // Implements IEEE P1363 point encoding\n    function pointToBytes(_c, point, isCompressed) {\n        const { x, y } = point.toAffine();\n        const bx = Fp.toBytes(x);\n        (0, utils_ts_1._abool2)(isCompressed, 'isCompressed');\n        if (isCompressed) {\n            assertCompressionIsSupported();\n            const hasEvenY = !Fp.isOdd(y);\n            return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);\n        }\n        else {\n            return (0, utils_ts_1.concatBytes)(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n        }\n    }\n    function pointFromBytes(bytes) {\n        (0, utils_ts_1._abytes2)(bytes, undefined, 'Point');\n        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n        const length = bytes.length;\n        const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // No actual validation is done here: use .assertValidity()\n        if (length === comp && (head === 0x02 || head === 0x03)) {\n            const x = Fp.fromBytes(tail);\n            if (!Fp.isValid(x))\n                throw new Error('bad point: is not on curve, wrong x');\n            const y2 = weierstrassEquation(x); // yÂ² = xÂ³ + ax + b\n            let y;\n            try {\n                y = Fp.sqrt(y2); // y = yÂ² ^ (p+1)/4\n            }\n            catch (sqrtError) {\n                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                throw new Error('bad point: is not on curve, sqrt error' + err);\n            }\n            assertCompressionIsSupported();\n            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;\n            const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n            if (isHeadOdd !== isYOdd)\n                y = Fp.neg(y);\n            return { x, y };\n        }\n        else if (length === uncomp && head === 0x04) {\n            // TODO: more checks\n            const L = Fp.BYTES;\n            const x = Fp.fromBytes(tail.subarray(0, L));\n            const y = Fp.fromBytes(tail.subarray(L, L * 2));\n            if (!isValidXY(x, y))\n                throw new Error('bad point: is not on curve');\n            return { x, y };\n        }\n        else {\n            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);\n        }\n    }\n    const encodePoint = extraOpts.toBytes || pointToBytes;\n    const decodePoint = extraOpts.fromBytes || pointFromBytes;\n    function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // xÂ² * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // xÂ³ + a * x + b\n    }\n    // TODO: move top-level\n    /** Checks whether equation holds for given x, y: yÂ² == xÂ³ + ax + b */\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // yÂ²\n        const right = weierstrassEquation(x); // xÂ³ + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation yÂ² = xÂ³ + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy))\n        throw new Error('bad curve params: generator point');\n    // Test 2: discriminant Î” part should be non-zero: 4aÂ³ + 27bÂ² != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2)))\n        throw new Error('bad curve params: a or b');\n    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n    function acoord(title, n, banZero = false) {\n        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))\n            throw new Error(`bad point coordinate ${title}`);\n        return n;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    function splitEndoScalarN(k) {\n        if (!endo || !endo.basises)\n            throw new Error('no endo');\n        return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z) âˆ‹ (x=X/Z, y=Y/Z)\n    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {\n        const { X, Y, Z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(Z, Fp.ONE))\n            return { x: X, y: Y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(Z);\n        const x = Fp.mul(X, iz);\n        const y = Fp.mul(Y, iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x, y };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not field elements');\n        if (!isValidXY(x, y))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {\n        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);\n        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);\n        return k1p.add(k2p);\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) âˆ‹ (x=X/Z, y=Y/Z).\n     * Default Point works in 2d / affine coordinates: (x, y).\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        constructor(X, Y, Z) {\n            this.X = acoord('x', X);\n            this.Y = acoord('y', Y, true);\n            this.Z = acoord('z', Z);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n            if (Fp.is0(x) && Fp.is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        static fromBytes(bytes) {\n            const P = Point.fromAffine(decodePoint((0, utils_ts_1._abytes2)(bytes, undefined, 'point')));\n            P.assertValidity();\n            return P;\n        }\n        static fromHex(hex) {\n            return Point.fromBytes((0, utils_ts_1.ensureBytes)('pointHex', hex));\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         *\n         * @param windowSize\n         * @param isLazy true will defer table computation until the first multiplication\n         * @returns\n         */\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy)\n                this.multiply(_3n); // random number\n            return this;\n        }\n        // TODO: return `this`\n        /** A point on curve is valid if it conforms to equation. */\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (!Fp.isOdd)\n                throw new Error(\"Field doesn't support isOdd\");\n            return !Fp.isOdd(y);\n        }\n        /** Compare one point to another. */\n        equals(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n        negate() {\n            return new Point(this.X, Fp.neg(this.Y), this.Z);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo } = extraOpts;\n            if (!Fn.isValidNot0(scalar))\n                throw new Error('invalid scalar: out of range'); // 0 is invalid\n            let point, fake; // Fake point is used to const-time mult\n            const mul = (n) => wnaf.cached(this, n, (p) => (0, curve_ts_1.normalizeZ)(Point, p));\n            /** See docs for {@link EndomorphismOpts} */\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n                const { p: k1p, f: k1f } = mul(k1);\n                const { p: k2p, f: k2f } = mul(k2);\n                fake = k1f.add(k2f);\n                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n            }\n            else {\n                const { p, f } = mul(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return (0, curve_ts_1.normalizeZ)(Point, [point, fake])[0];\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed secret key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo } = extraOpts;\n            const p = this;\n            if (!Fn.isValid(sc))\n                throw new Error('invalid scalar: out of range'); // 0 is valid\n            if (sc === _0n || p.is0())\n                return Point.ZERO;\n            if (sc === _1n)\n                return p; // fast-path\n            if (wnaf.hasCache(this))\n                return this.multiply(sc);\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n                const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n            }\n            else {\n                return wnaf.unsafe(p, sc);\n            }\n        }\n        multiplyAndAddUnsafe(Q, a, b) {\n            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n            return sum.is0() ? undefined : sum;\n        }\n        /**\n         * Converts Projective point to affine (x, y) coordinates.\n         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n         */\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        /**\n         * Checks whether Point is free of torsion elements (is in prime subgroup).\n         * Always torsion-free for cofactor=1 curves.\n         */\n        isTorsionFree() {\n            const { isTorsionFree } = extraOpts;\n            if (cofactor === _1n)\n                return true;\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            return wnaf.unsafe(this, CURVE_ORDER).is0();\n        }\n        clearCofactor() {\n            const { clearCofactor } = extraOpts;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(cofactor);\n        }\n        isSmallOrder() {\n            // can we use this.clearCofactor()?\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        toBytes(isCompressed = true) {\n            (0, utils_ts_1._abool2)(isCompressed, 'isCompressed');\n            this.assertValidity();\n            return encodePoint(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));\n        }\n        toString() {\n            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n        }\n        // TODO: remove\n        get px() {\n            return this.X;\n        }\n        get py() {\n            return this.X;\n        }\n        get pz() {\n            return this.Z;\n        }\n        toRawBytes(isCompressed = true) {\n            return this.toBytes(isCompressed);\n        }\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        static normalizeZ(points) {\n            return (0, curve_ts_1.normalizeZ)(Point, points);\n        }\n        static msm(points, scalars) {\n            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);\n        }\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(_normFnElement(Fn, privateKey));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // math field\n    Point.Fp = Fp;\n    // scalar field\n    Point.Fn = Fn;\n    const bits = Fn.BITS;\n    const wnaf = new curve_ts_1.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY) {\n    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    (0, modular_ts_1.validateField)(Fp);\n    const { A, B, Z } = opts;\n    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n    if (!Fp.isOdd)\n        throw new Error('Field does not have .isOdd()');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\nfunction getWLengths(Fp, Fn) {\n    return {\n        secretKey: Fn.BYTES,\n        publicKey: 1 + Fp.BYTES,\n        publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n        publicKeyHasPrefix: true,\n        signature: 2 * Fn.BYTES,\n    };\n}\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */\nfunction ecdh(Point, ecdhOpts = {}) {\n    const { Fn } = Point;\n    const randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;\n    const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: (0, modular_ts_1.getMinHashLength)(Fn.ORDER) });\n    function isValidSecretKey(secretKey) {\n        try {\n            return !!_normFnElement(Fn, secretKey);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    function isValidPublicKey(publicKey, isCompressed) {\n        const { publicKey: comp, publicKeyUncompressed } = lengths;\n        try {\n            const l = publicKey.length;\n            if (isCompressed === true && l !== comp)\n                return false;\n            if (isCompressed === false && l !== publicKeyUncompressed)\n                return false;\n            return !!Point.fromBytes(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n    }\n    /**\n     * Produces cryptographically secure secret key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    function randomSecretKey(seed = randomBytes_(lengths.seed)) {\n        return (0, modular_ts_1.mapHashToField)((0, utils_ts_1._abytes2)(seed, lengths.seed, 'seed'), Fn.ORDER);\n    }\n    /**\n     * Computes public key for a secret key. Checks for validity of the secret key.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(secretKey, isCompressed = true) {\n        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);\n    }\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return { secretKey, publicKey: getPublicKey(secretKey) };\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        if (typeof item === 'bigint')\n            return false;\n        if (item instanceof Point)\n            return true;\n        const { secretKey, publicKey, publicKeyUncompressed } = lengths;\n        if (Fn.allowedLengths || secretKey === publicKey)\n            return undefined;\n        const l = (0, utils_ts_1.ensureBytes)('key', item).length;\n        return l === publicKey || l === publicKeyUncompressed;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from secret key A and public key B.\n     * Checks: 1) secret key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {\n        if (isProbPub(secretKeyA) === true)\n            throw new Error('first arg must be private key');\n        if (isProbPub(publicKeyB) === false)\n            throw new Error('second arg must be public key');\n        const s = _normFnElement(Fn, secretKeyA);\n        const b = Point.fromHex(publicKeyB); // checks for being on-curve\n        return b.multiply(s).toBytes(isCompressed);\n    }\n    const utils = {\n        isValidSecretKey,\n        isValidPublicKey,\n        randomSecretKey,\n        // TODO: remove\n        isValidPrivateKey: isValidSecretKey,\n        randomPrivateKey: randomSecretKey,\n        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),\n        precompute(windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        },\n    };\n    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });\n}\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n * We need `hash` for 2 features:\n * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`\n * 2. k generation in `sign`, using HMAC-drbg(hash)\n *\n * ECDSAOpts are only rarely needed.\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */\nfunction ecdsa(Point, hash, ecdsaOpts = {}) {\n    (0, utils_1.ahash)(hash);\n    (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {\n        hmac: 'function',\n        lowS: 'boolean',\n        randomBytes: 'function',\n        bits2int: 'function',\n        bits2int_modN: 'function',\n    });\n    const randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;\n    const hmac = ecdsaOpts.hmac ||\n        ((key, ...msgs) => (0, hmac_js_1.hmac)(hash, key, (0, utils_ts_1.concatBytes)(...msgs)));\n    const { Fp, Fn } = Point;\n    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n    const defaultSigOpts = {\n        prehash: false,\n        lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,\n        format: undefined, //'compact' as ECDSASigFormat,\n        extraEntropy: false,\n    };\n    const defaultSigOpts_format = 'compact';\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function validateRS(title, num) {\n        if (!Fn.isValidNot0(num))\n            throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n        return num;\n    }\n    function validateSigLength(bytes, format) {\n        validateSigFormat(format);\n        const size = lengths.signature;\n        const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;\n        return (0, utils_ts_1._abytes2)(bytes, sizer, `${format} signature`);\n    }\n    /**\n     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = validateRS('r', r); // r in [1..N-1];\n            this.s = validateRS('s', s); // s in [1..N-1];\n            if (recovery != null)\n                this.recovery = recovery;\n            Object.freeze(this);\n        }\n        static fromBytes(bytes, format = defaultSigOpts_format) {\n            validateSigLength(bytes, format);\n            let recid;\n            if (format === 'der') {\n                const { r, s } = exports.DER.toSig((0, utils_ts_1._abytes2)(bytes));\n                return new Signature(r, s);\n            }\n            if (format === 'recovered') {\n                recid = bytes[0];\n                format = 'compact';\n                bytes = bytes.subarray(1);\n            }\n            const L = Fn.BYTES;\n            const r = bytes.subarray(0, L);\n            const s = bytes.subarray(L, L * 2);\n            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n        }\n        static fromHex(hex, format) {\n            return this.fromBytes((0, utils_ts_1.hexToBytes)(hex), format);\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(messageHash) {\n            const FIELD_ORDER = Fp.ORDER;\n            const { r, s, recovery: rec } = this;\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            // ECDSA recovery is hard for cofactor > 1 curves.\n            // In sign, `r = q.x mod n`, and here we recover q.x from r.\n            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n            // However, for cofactor>1, r+n may not get q.x:\n            // r+n*i would need to be done instead where i is unknown.\n            // To easily get i, we either need to:\n            // a. increase amount of valid recid values (4, 5...); OR\n            // b. prohibit non-prime-order signatures (recid > 1).\n            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n            if (hasCofactor && rec > 1)\n                throw new Error('recovery id is ambiguous for h>1 curve');\n            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n            if (!Fp.isValid(radj))\n                throw new Error('recovery id 2 or 3 invalid');\n            const x = Fp.toBytes(radj);\n            const R = Point.fromBytes((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));\n            const ir = Fn.inv(radj); // r^-1\n            const h = bits2int_modN((0, utils_ts_1.ensureBytes)('msgHash', messageHash)); // Truncate hash\n            const u1 = Fn.create(-h * ir); // -hr^-1\n            const u2 = Fn.create(s * ir); // sr^-1\n            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n            if (Q.is0())\n                throw new Error('point at infinify');\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        toBytes(format = defaultSigOpts_format) {\n            validateSigFormat(format);\n            if (format === 'der')\n                return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));\n            const r = Fn.toBytes(this.r);\n            const s = Fn.toBytes(this.s);\n            if (format === 'recovered') {\n                if (this.recovery == null)\n                    throw new Error('recovery bit must be present');\n                return (0, utils_ts_1.concatBytes)(Uint8Array.of(this.recovery), r, s);\n            }\n            return (0, utils_ts_1.concatBytes)(r, s);\n        }\n        toHex(format) {\n            return (0, utils_ts_1.bytesToHex)(this.toBytes(format));\n        }\n        // TODO: remove\n        assertValidity() { }\n        static fromCompact(hex) {\n            return Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', hex), 'compact');\n        }\n        static fromDER(hex) {\n            return Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', hex), 'der');\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n        }\n        toDERRawBytes() {\n            return this.toBytes('der');\n        }\n        toDERHex() {\n            return (0, utils_ts_1.bytesToHex)(this.toBytes('der'));\n        }\n        toCompactRawBytes() {\n            return this.toBytes('compact');\n        }\n        toCompactHex() {\n            return (0, utils_ts_1.bytesToHex)(this.toBytes('compact'));\n        }\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = ecdsaOpts.bits2int ||\n        function bits2int_def(bytes) {\n            // Our custom check \"just in case\", for protection against DoS\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = (0, utils_ts_1.bytesToNumberBE)(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = ecdsaOpts.bits2int_modN ||\n        function bits2int_modN_def(bytes) {\n            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // Pads output with zero as per spec\n    const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);\n    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */\n    function int2octets(num) {\n        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n        (0, utils_ts_1.aInRange)('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n        return Fn.toBytes(num);\n    }\n    function validateMsgAndHash(message, prehash) {\n        (0, utils_ts_1._abytes2)(message, undefined, 'message');\n        return prehash ? (0, utils_ts_1._abytes2)(hash(message), undefined, 'prehashed message') : message;\n    }\n    /**\n     * Steps A, D of RFC6979 3.2.\n     * Creates RFC6979 seed; converts msg/privKey to numbers.\n     * Used only in sign, not in verify.\n     *\n     * Warning: we cannot assume here that message has same amount of bytes as curve order,\n     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n     */\n    function prepSig(message, privateKey, opts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(message);\n        const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (extraEntropy != null && extraEntropy !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            // gen random bytes OR pass as-is\n            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;\n            seedArgs.push((0, utils_ts_1.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = (0, utils_ts_1.concatBytes)(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        // To transform k => Signature:\n        // q = kâ‹…G\n        // r = q.x mod n\n        // s = k^-1(m + rd) mod n\n        // Can use scalar blinding b^-1(bm + bdr) where b âˆˆ [1,qâˆ’1] according to\n        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            // Important: all mod() calls here must be done over N\n            const k = bits2int(kBytes); // mod n, not mod p\n            if (!Fn.isValidNot0(k))\n                return; // Valid scalars (including k) must be in 1..N-1\n            const ik = Fn.inv(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = kâ‹…G\n            const r = Fn.create(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = Fn.neg(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    /**\n     * Signs message hash with a secret key.\n     *\n     * ```\n     * sign(m, d) where\n     *   k = rfc6979_hmac_drbg(m, d)\n     *   (x, y) = G Ã— k\n     *   r = x mod n\n     *   s = (m + dr) / k mod n\n     * ```\n     */\n    function sign(message, secretKey, opts = {}) {\n        message = (0, utils_ts_1.ensureBytes)('message', message);\n        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n        const drbg = (0, utils_ts_1.createHmacDrbg)(hash.outputLen, Fn.BYTES, hmac);\n        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n        return sig;\n    }\n    function tryParsingSig(sg) {\n        // Try to deduce format\n        let sig = undefined;\n        const isHex = typeof sg === 'string' || (0, utils_ts_1.isBytes)(sg);\n        const isObj = !isHex &&\n            sg !== null &&\n            typeof sg === 'object' &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        if (isObj) {\n            sig = new Signature(sg.r, sg.s);\n        }\n        else if (isHex) {\n            try {\n                sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', sg), 'der');\n            }\n            catch (derError) {\n                if (!(derError instanceof exports.DER.Err))\n                    throw derError;\n            }\n            if (!sig) {\n                try {\n                    sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', sg), 'compact');\n                }\n                catch (error) {\n                    return false;\n                }\n            }\n        }\n        if (!sig)\n            return false;\n        return sig;\n    }\n    /**\n     * Verifies a signature against message and public key.\n     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   u1 = hs^-1 mod n\n     *   u2 = rs^-1 mod n\n     *   R = u1â‹…G + u2â‹…P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, message, publicKey, opts = {}) {\n        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey);\n        message = validateMsgAndHash((0, utils_ts_1.ensureBytes)('message', message), prehash);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const sig = format === undefined\n            ? tryParsingSig(signature)\n            : Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', signature), format);\n        if (sig === false)\n            return false;\n        try {\n            const P = Point.fromBytes(publicKey);\n            if (lowS && sig.hasHighS())\n                return false;\n            const { r, s } = sig;\n            const h = bits2int_modN(message); // mod n, not mod p\n            const is = Fn.inv(s); // s^-1 mod n\n            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1â‹…G + u2â‹…P\n            if (R.is0())\n                return false;\n            const v = Fn.create(R.x); // v = r.x mod n\n            return v === r;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    function recoverPublicKey(signature, message, opts = {}) {\n        const { prehash } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash);\n        return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();\n    }\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        getSharedSecret,\n        utils,\n        lengths,\n        Point,\n        sign,\n        verify,\n        recoverPublicKey,\n        Signature,\n        hash,\n    });\n}\n/** @deprecated use `weierstrass` in newer releases */\nfunction weierstrassPoints(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    return _weierstrass_new_output_to_legacy(c, Point);\n}\nfunction _weierstrass_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        b: c.b,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy,\n    };\n    const Fp = c.Fp;\n    let allowedLengths = c.allowedPrivateKeyLengths\n        ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2))))\n        : undefined;\n    const Fn = (0, modular_ts_1.Field)(CURVE.n, {\n        BITS: c.nBitLength,\n        allowedLengths: allowedLengths,\n        modFromBytes: c.wrapPrivateKey,\n    });\n    const curveOpts = {\n        Fp,\n        Fn,\n        allowInfinityPoint: c.allowInfinityPoint,\n        endo: c.endo,\n        isTorsionFree: c.isTorsionFree,\n        clearCofactor: c.clearCofactor,\n        fromBytes: c.fromBytes,\n        toBytes: c.toBytes,\n    };\n    return { CURVE, curveOpts };\n}\nfunction _ecdsa_legacy_opts_to_new(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const ecdsaOpts = {\n        hmac: c.hmac,\n        randomBytes: c.randomBytes,\n        lowS: c.lowS,\n        bits2int: c.bits2int,\n        bits2int_modN: c.bits2int_modN,\n    };\n    return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };\n}\nfunction _legacyHelperEquat(Fp, a, b) {\n    /**\n     * yÂ² = xÂ³ + ax + b: Short weierstrass curve formula. Takes x, returns yÂ².\n     * @returns yÂ²\n     */\n    function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // xÂ² * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // xÂ³ + a * x + b\n    }\n    return weierstrassEquation;\n}\nfunction _weierstrass_new_output_to_legacy(c, Point) {\n    const { Fp, Fn } = Point;\n    function isWithinCurveOrder(num) {\n        return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);\n    }\n    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\n    return Object.assign({}, {\n        CURVE: c,\n        Point: Point,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),\n        weierstrassEquation,\n        isWithinCurveOrder,\n    });\n}\nfunction _ecdsa_new_output_to_legacy(c, _ecdsa) {\n    const Point = _ecdsa.Point;\n    return Object.assign({}, _ecdsa, {\n        ProjectivePoint: Point,\n        CURVE: Object.assign({}, c, (0, modular_ts_1.nLength)(Point.Fn.ORDER, Point.Fn.BITS)),\n    });\n}\n// _ecdsa_legacy\nfunction weierstrass(c) {\n    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    const signs = ecdsa(Point, hash, ecdsaOpts);\n    return _ecdsa_new_output_to_legacy(c, signs);\n}\n//# sourceMappingURL=weierstrass.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getHash = getHash;\nexports.createCurve = createCurve;\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst weierstrass_ts_1 = require(\"./abstract/weierstrass.js\");\n/** connects noble-curves to noble-hashes */\nfunction getHash(hash) {\n    return { hash };\n}\n/** @deprecated use new `weierstrass()` and `ecdsa()` methods */\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash });\n    return { ...create(defHash), create };\n}\n//# sourceMappingURL=_shortw_utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports._DST_scalar = void 0;\nexports.expand_message_xmd = expand_message_xmd;\nexports.expand_message_xof = expand_message_xof;\nexports.hash_to_field = hash_to_field;\nexports.isogenyMap = isogenyMap;\nexports.createHasher = createHasher;\nconst utils_ts_1 = require(\"../utils.js\");\nconst modular_ts_1 = require(\"./modular.js\");\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_ts_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << (8 * length))\n        throw new Error('invalid I2OSP input: ' + value);\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\nfunction normDST(DST) {\n    if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== 'string')\n        throw new Error('DST must be Uint8Array or string');\n    return typeof DST === 'string' ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0, utils_ts_1.abytes)(msg);\n    anum(lenInBytes);\n    DST = normDST(DST);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255)\n        throw new Error('expand_message_xmd: invalid lenInBytes');\n    const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0, utils_ts_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0, utils_ts_1.abytes)(msg);\n    anum(lenInBytes);\n    DST = normDST(DST);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0, utils_ts_1._validateObject)(options, {\n        p: 'bigint',\n        m: 'number',\n        k: 'number',\n        hash: 'function',\n    });\n    const { p, k, m, hash, expand, DST } = options;\n    if (!(0, utils_ts_1.isHash)(options.hash))\n        throw new Error('expected valid hash');\n    (0, utils_ts_1.abytes)(msg);\n    anum(count);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const coeff = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        // 6.6.3\n        // Exceptional cases of iso_map are inputs that cause the denominator of\n        // either rational function to evaluate to zero; such cases MUST return\n        // the identity point on E.\n        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);\n        x = field.mul(xn, xd_inv); // xNum / xDen\n        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nexports._DST_scalar = (0, utils_ts_1.utf8ToBytes)('HashToScalar-');\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */\nfunction createHasher(Point, mapToCurve, defaults) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    function map(num) {\n        return Point.fromAffine(mapToCurve(num));\n    }\n    function clear(initial) {\n        const P = initial.clearCofactor();\n        if (P.equals(Point.ZERO))\n            return Point.ZERO; // zero will throw in assert\n        P.assertValidity();\n        return P;\n    }\n    return {\n        defaults,\n        hashToCurve(msg, options) {\n            const opts = Object.assign({}, defaults, options);\n            const u = hash_to_field(msg, 2, opts);\n            const u0 = map(u[0]);\n            const u1 = map(u[1]);\n            return clear(u0.add(u1));\n        },\n        encodeToCurve(msg, options) {\n            const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};\n            const opts = Object.assign({}, defaults, optsDst, options);\n            const u = hash_to_field(msg, 1, opts);\n            const u0 = map(u[0]);\n            return clear(u0);\n        },\n        /** See {@link H2CHasher} */\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error('expected array of bigints');\n            return clear(map(scalars));\n        },\n        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393\n        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08\n        hashToScalar(msg, options) {\n            // @ts-ignore\n            const N = Point.Fn.ORDER;\n            const opts = Object.assign({}, defaults, { p: N, m: 1, DST: exports._DST_scalar }, options);\n            return hash_to_field(msg, 1, opts)[0][0];\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;\n/**\n * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism Ïˆ,\n * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst sha2_js_1 = require(\"@noble/hashes/sha2.js\");\nconst utils_js_1 = require(\"@noble/hashes/utils.js\");\nconst _shortw_utils_ts_1 = require(\"./_shortw_utils.js\");\nconst hash_to_curve_ts_1 = require(\"./abstract/hash-to-curve.js\");\nconst modular_ts_1 = require(\"./abstract/modular.js\");\nconst weierstrass_ts_1 = require(\"./abstract/weierstrass.js\");\nconst utils_ts_1 = require(\"./utils.js\");\n// Seems like generator was produced from some seed:\n// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`\n// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n\nconst secp256k1_CURVE = {\n    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: BigInt(1),\n    a: BigInt(0),\n    b: BigInt(7),\n    Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),\n};\nconst secp256k1_ENDO = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    basises: [\n        [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],\n        [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],\n    ],\n};\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\n/**\n * âˆšn = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1_CURVE.p;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0, modular_ts_1.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0, modular_ts_1.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0, modular_ts_1.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0, modular_ts_1.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0, modular_ts_1.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0, modular_ts_1.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0, modular_ts_1.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0, modular_ts_1.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0, modular_ts_1.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0, modular_ts_1.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0, modular_ts_1.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0, modular_ts_1.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, { sqrt: sqrtMod });\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = secp256k1.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = secp256k1.sign(msg, secretKey);\n * const isValid = secp256k1.verify(sig, msg, publicKey) === true;\n * ```\n */\nexports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2_js_1.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, sha2_js_1.sha256)((0, utils_ts_1.utf8ToBytes)(tag));\n        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toBytes(true).slice(1);\nconst Pointk1 = /* @__PURE__ */ (() => exports.secp256k1.Point)();\nconst hasEven = (y) => y % _2n === _0n;\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    const { Fn, BASE } = Pointk1;\n    const d_ = (0, weierstrass_ts_1._normFnElement)(Fn, priv);\n    const p = BASE.multiply(d_); // P = d'â‹…G; 0 < d' < n check is done inside\n    const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);\n    return { scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    const Fp = Fpk1;\n    if (!Fp.isValidNot0(x))\n        throw new Error('invalid x: Fail if x â‰¥ p');\n    const xx = Fp.create(x * x);\n    const c = Fp.create(xx * x + BigInt(7)); // Let c = xÂ³ + 7 mod p.\n    let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().\n    // Return the unique point P such that x(P) = x and\n    // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    if (!hasEven(y))\n        y = Fp.neg(y);\n    const p = Pointk1.fromAffine({ x, y });\n    p.assertValidity();\n    return p;\n}\nconst num = utils_ts_1.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return Pointk1.Fn.create(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(secretKey) {\n    return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'â‰¥n. Ret bytes(d'â‹…G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, secretKey, auxRand = (0, utils_js_1.randomBytes)(32)) {\n    const { Fn } = Pointk1;\n    const m = (0, utils_ts_1.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder\n    const a = (0, utils_ts_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = Fn.toBytes(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'â‹…G\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const { Fn, BASE } = Pointk1;\n    const sig = (0, utils_ts_1.ensureBytes)('signature', signature, 64);\n    const m = (0, utils_ts_1.ensureBytes)('message', message);\n    const pub = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r â‰¥ p.\n        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1_CURVE.p))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s â‰¥ n.\n        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1_CURVE.n))\n            return false;\n        // int(challenge(bytes(r)||bytes(P)||m))%n\n        const e = challenge(Fn.toBytes(r), pointToBytes(P), m);\n        // R = sâ‹…G - eâ‹…P, where -eP == (n-e)P\n        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));\n        const { x, y } = R.toAffine();\n        // Fail if is_infinite(R) / not has_even_y(R) / x(R) â‰  r.\n        if (R.is0() || !hasEven(y) || x !== r)\n            return false;\n        return true;\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = schnorr.keygen();\n * // const publicKey = schnorr.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, secretKey);\n * const isValid = schnorr.verify(sig, msg, publicKey);\n * ```\n */\nexports.schnorr = (() => {\n    const size = 32;\n    const seedLength = 48;\n    const randomSecretKey = (seed = (0, utils_js_1.randomBytes)(seedLength)) => {\n        return (0, modular_ts_1.mapHashToField)(seed, secp256k1_CURVE.n);\n    };\n    // TODO: remove\n    exports.secp256k1.utils.randomSecretKey;\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };\n    }\n    return {\n        keygen,\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        Point: Pointk1,\n        utils: {\n            randomSecretKey: randomSecretKey,\n            randomPrivateKey: randomSecretKey,\n            taggedHash,\n            // TODO: remove\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: utils_ts_1.numberToBytesBE,\n            bytesToNumberBE: utils_ts_1.bytesToNumberBE,\n            mod: modular_ts_1.mod,\n        },\n        lengths: {\n            secretKey: size,\n            publicKey: size,\n            publicKeyHasPrefix: false,\n            signature: size * 2,\n            seed: seedLength,\n        },\n    };\n})();\nconst isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nexports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.Point, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha2_js_1.sha256,\n}))();\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */\nexports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */\nexports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isHash = exports.validateObject = exports.memoized = exports.notImplemented = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.aInRange = exports.inRange = exports.asciiToBytes = exports.copyBytes = exports.equalBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToNumber = exports.numberToHexUnpadded = exports.abool = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;\n/**\n * Deprecated module: moved from curves/abstract/utils.js to curves/utils.js\n * @module\n */\nconst u = require(\"../utils.js\");\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.abytes = u.abytes;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.anumber = u.anumber;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.bytesToHex = u.bytesToHex;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.bytesToUtf8 = u.bytesToUtf8;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.concatBytes = u.concatBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.hexToBytes = u.hexToBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.isBytes = u.isBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.randomBytes = u.randomBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.utf8ToBytes = u.utf8ToBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.abool = u.abool;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.numberToHexUnpadded = u.numberToHexUnpadded;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.hexToNumber = u.hexToNumber;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.bytesToNumberBE = u.bytesToNumberBE;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.bytesToNumberLE = u.bytesToNumberLE;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.numberToBytesBE = u.numberToBytesBE;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.numberToBytesLE = u.numberToBytesLE;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.numberToVarBytesBE = u.numberToVarBytesBE;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.ensureBytes = u.ensureBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.equalBytes = u.equalBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.copyBytes = u.copyBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.asciiToBytes = u.asciiToBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.inRange = u.inRange;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.aInRange = u.aInRange;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.bitLen = u.bitLen;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.bitGet = u.bitGet;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.bitSet = u.bitSet;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.bitMask = u.bitMask;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.createHmacDrbg = u.createHmacDrbg;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.notImplemented = u.notImplemented;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.memoized = u.memoized;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.validateObject = u.validateObject;\n/** @deprecated moved to `@noble/curves/utils.js` */\nexports.isHash = u.isHash;\n//# sourceMappingURL=utils.js.map","// can-promise has a crash in some versions of react native that dont have\n// standard global objects\n// https://github.com/soldair/node-qrcode/issues/157\n\nmodule.exports = function () {\n  return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then\n}\n","let toSJISFunction\nconst CODEWORDS_COUNT = [\n  0, // Not used\n  26, 44, 70, 100, 134, 172, 196, 242, 292, 346,\n  404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,\n  1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185,\n  2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706\n]\n\n/**\n * Returns the QR Code size for the specified version\n *\n * @param  {Number} version QR Code version\n * @return {Number}         size of QR code\n */\nexports.getSymbolSize = function getSymbolSize (version) {\n  if (!version) throw new Error('\"version\" cannot be null or undefined')\n  if (version < 1 || version > 40) throw new Error('\"version\" should be in range from 1 to 40')\n  return version * 4 + 17\n}\n\n/**\n * Returns the total number of codewords used to store data and EC information.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Data length in bits\n */\nexports.getSymbolTotalCodewords = function getSymbolTotalCodewords (version) {\n  return CODEWORDS_COUNT[version]\n}\n\n/**\n * Encode data with Bose-Chaudhuri-Hocquenghem\n *\n * @param  {Number} data Value to encode\n * @return {Number}      Encoded value\n */\nexports.getBCHDigit = function (data) {\n  let digit = 0\n\n  while (data !== 0) {\n    digit++\n    data >>>= 1\n  }\n\n  return digit\n}\n\nexports.setToSJISFunction = function setToSJISFunction (f) {\n  if (typeof f !== 'function') {\n    throw new Error('\"toSJISFunc\" is not a valid function.')\n  }\n\n  toSJISFunction = f\n}\n\nexports.isKanjiModeEnabled = function () {\n  return typeof toSJISFunction !== 'undefined'\n}\n\nexports.toSJIS = function toSJIS (kanji) {\n  return toSJISFunction(kanji)\n}\n","exports.L = { bit: 1 }\nexports.M = { bit: 0 }\nexports.Q = { bit: 3 }\nexports.H = { bit: 2 }\n\nfunction fromString (string) {\n  if (typeof string !== 'string') {\n    throw new Error('Param is not a string')\n  }\n\n  const lcStr = string.toLowerCase()\n\n  switch (lcStr) {\n    case 'l':\n    case 'low':\n      return exports.L\n\n    case 'm':\n    case 'medium':\n      return exports.M\n\n    case 'q':\n    case 'quartile':\n      return exports.Q\n\n    case 'h':\n    case 'high':\n      return exports.H\n\n    default:\n      throw new Error('Unknown EC Level: ' + string)\n  }\n}\n\nexports.isValid = function isValid (level) {\n  return level && typeof level.bit !== 'undefined' &&\n    level.bit >= 0 && level.bit < 4\n}\n\nexports.from = function from (value, defaultValue) {\n  if (exports.isValid(value)) {\n    return value\n  }\n\n  try {\n    return fromString(value)\n  } catch (e) {\n    return defaultValue\n  }\n}\n","function BitBuffer () {\n  this.buffer = []\n  this.length = 0\n}\n\nBitBuffer.prototype = {\n\n  get: function (index) {\n    const bufIndex = Math.floor(index / 8)\n    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) === 1\n  },\n\n  put: function (num, length) {\n    for (let i = 0; i < length; i++) {\n      this.putBit(((num >>> (length - i - 1)) & 1) === 1)\n    }\n  },\n\n  getLengthInBits: function () {\n    return this.length\n  },\n\n  putBit: function (bit) {\n    const bufIndex = Math.floor(this.length / 8)\n    if (this.buffer.length <= bufIndex) {\n      this.buffer.push(0)\n    }\n\n    if (bit) {\n      this.buffer[bufIndex] |= (0x80 >>> (this.length % 8))\n    }\n\n    this.length++\n  }\n}\n\nmodule.exports = BitBuffer\n","/**\n * Helper class to handle QR Code symbol modules\n *\n * @param {Number} size Symbol size\n */\nfunction BitMatrix (size) {\n  if (!size || size < 1) {\n    throw new Error('BitMatrix size must be defined and greater than 0')\n  }\n\n  this.size = size\n  this.data = new Uint8Array(size * size)\n  this.reservedBit = new Uint8Array(size * size)\n}\n\n/**\n * Set bit value at specified location\n * If reserved flag is set, this bit will be ignored during masking process\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n * @param {Boolean} reserved\n */\nBitMatrix.prototype.set = function (row, col, value, reserved) {\n  const index = row * this.size + col\n  this.data[index] = value\n  if (reserved) this.reservedBit[index] = true\n}\n\n/**\n * Returns bit value at specified location\n *\n * @param  {Number}  row\n * @param  {Number}  col\n * @return {Boolean}\n */\nBitMatrix.prototype.get = function (row, col) {\n  return this.data[row * this.size + col]\n}\n\n/**\n * Applies xor operator at specified location\n * (used during masking process)\n *\n * @param {Number}  row\n * @param {Number}  col\n * @param {Boolean} value\n */\nBitMatrix.prototype.xor = function (row, col, value) {\n  this.data[row * this.size + col] ^= value\n}\n\n/**\n * Check if bit at specified location is reserved\n *\n * @param {Number}   row\n * @param {Number}   col\n * @return {Boolean}\n */\nBitMatrix.prototype.isReserved = function (row, col) {\n  return this.reservedBit[row * this.size + col]\n}\n\nmodule.exports = BitMatrix\n","/**\n * Alignment pattern are fixed reference pattern in defined positions\n * in a matrix symbology, which enables the decode software to re-synchronise\n * the coordinate mapping of the image modules in the event of moderate amounts\n * of distortion of the image.\n *\n * Alignment patterns are present only in QR Code symbols of version 2 or larger\n * and their number depends on the symbol version.\n */\n\nconst getSymbolSize = require('./utils').getSymbolSize\n\n/**\n * Calculate the row/column coordinates of the center module of each alignment pattern\n * for the specified QR Code version.\n *\n * The alignment patterns are positioned symmetrically on either side of the diagonal\n * running from the top left corner of the symbol to the bottom right corner.\n *\n * Since positions are simmetrical only half of the coordinates are returned.\n * Each item of the array will represent in turn the x and y coordinate.\n * @see {@link getPositions}\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinate\n */\nexports.getRowColCoords = function getRowColCoords (version) {\n  if (version === 1) return []\n\n  const posCount = Math.floor(version / 7) + 2\n  const size = getSymbolSize(version)\n  const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2\n  const positions = [size - 7] // Last coord is always (size - 7)\n\n  for (let i = 1; i < posCount - 1; i++) {\n    positions[i] = positions[i - 1] - intervals\n  }\n\n  positions.push(6) // First coord is always 6\n\n  return positions.reverse()\n}\n\n/**\n * Returns an array containing the positions of each alignment pattern.\n * Each array's element represent the center point of the pattern as (x, y) coordinates\n *\n * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}\n * and filtering out the items that overlaps with finder pattern\n *\n * @example\n * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.\n * The alignment patterns, therefore, are to be centered on (row, column)\n * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).\n * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns\n * and are not therefore used for alignment patterns.\n *\n * let pos = getPositions(7)\n * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\nexports.getPositions = function getPositions (version) {\n  const coords = []\n  const pos = exports.getRowColCoords(version)\n  const posLength = pos.length\n\n  for (let i = 0; i < posLength; i++) {\n    for (let j = 0; j < posLength; j++) {\n      // Skip if position is occupied by finder patterns\n      if ((i === 0 && j === 0) || // top-left\n          (i === 0 && j === posLength - 1) || // bottom-left\n          (i === posLength - 1 && j === 0)) { // top-right\n        continue\n      }\n\n      coords.push([pos[i], pos[j]])\n    }\n  }\n\n  return coords\n}\n","const getSymbolSize = require('./utils').getSymbolSize\nconst FINDER_PATTERN_SIZE = 7\n\n/**\n * Returns an array containing the positions of each finder pattern.\n * Each array's element represent the top-left point of the pattern as (x, y) coordinates\n *\n * @param  {Number} version QR Code version\n * @return {Array}          Array of coordinates\n */\nexports.getPositions = function getPositions (version) {\n  const size = getSymbolSize(version)\n\n  return [\n    // top-left\n    [0, 0],\n    // top-right\n    [size - FINDER_PATTERN_SIZE, 0],\n    // bottom-left\n    [0, size - FINDER_PATTERN_SIZE]\n  ]\n}\n","/**\n * Data mask pattern reference\n * @type {Object}\n */\nexports.Patterns = {\n  PATTERN000: 0,\n  PATTERN001: 1,\n  PATTERN010: 2,\n  PATTERN011: 3,\n  PATTERN100: 4,\n  PATTERN101: 5,\n  PATTERN110: 6,\n  PATTERN111: 7\n}\n\n/**\n * Weighted penalty scores for the undesirable features\n * @type {Object}\n */\nconst PenaltyScores = {\n  N1: 3,\n  N2: 3,\n  N3: 40,\n  N4: 10\n}\n\n/**\n * Check if mask pattern value is valid\n *\n * @param  {Number}  mask    Mask pattern\n * @return {Boolean}         true if valid, false otherwise\n */\nexports.isValid = function isValid (mask) {\n  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7\n}\n\n/**\n * Returns mask pattern from a value.\n * If value is not valid, returns undefined\n *\n * @param  {Number|String} value        Mask pattern value\n * @return {Number}                     Valid mask pattern or undefined\n */\nexports.from = function from (value) {\n  return exports.isValid(value) ? parseInt(value, 10) : undefined\n}\n\n/**\n* Find adjacent modules in row/column with the same color\n* and assign a penalty value.\n*\n* Points: N1 + i\n* i is the amount by which the number of adjacent modules of the same color exceeds 5\n*/\nexports.getPenaltyN1 = function getPenaltyN1 (data) {\n  const size = data.size\n  let points = 0\n  let sameCountCol = 0\n  let sameCountRow = 0\n  let lastCol = null\n  let lastRow = null\n\n  for (let row = 0; row < size; row++) {\n    sameCountCol = sameCountRow = 0\n    lastCol = lastRow = null\n\n    for (let col = 0; col < size; col++) {\n      let module = data.get(row, col)\n      if (module === lastCol) {\n        sameCountCol++\n      } else {\n        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)\n        lastCol = module\n        sameCountCol = 1\n      }\n\n      module = data.get(col, row)\n      if (module === lastRow) {\n        sameCountRow++\n      } else {\n        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)\n        lastRow = module\n        sameCountRow = 1\n      }\n    }\n\n    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)\n    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)\n  }\n\n  return points\n}\n\n/**\n * Find 2x2 blocks with the same color and assign a penalty value\n *\n * Points: N2 * (m - 1) * (n - 1)\n */\nexports.getPenaltyN2 = function getPenaltyN2 (data) {\n  const size = data.size\n  let points = 0\n\n  for (let row = 0; row < size - 1; row++) {\n    for (let col = 0; col < size - 1; col++) {\n      const last = data.get(row, col) +\n        data.get(row, col + 1) +\n        data.get(row + 1, col) +\n        data.get(row + 1, col + 1)\n\n      if (last === 4 || last === 0) points++\n    }\n  }\n\n  return points * PenaltyScores.N2\n}\n\n/**\n * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,\n * preceded or followed by light area 4 modules wide\n *\n * Points: N3 * number of pattern found\n */\nexports.getPenaltyN3 = function getPenaltyN3 (data) {\n  const size = data.size\n  let points = 0\n  let bitsCol = 0\n  let bitsRow = 0\n\n  for (let row = 0; row < size; row++) {\n    bitsCol = bitsRow = 0\n    for (let col = 0; col < size; col++) {\n      bitsCol = ((bitsCol << 1) & 0x7FF) | data.get(row, col)\n      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++\n\n      bitsRow = ((bitsRow << 1) & 0x7FF) | data.get(col, row)\n      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++\n    }\n  }\n\n  return points * PenaltyScores.N3\n}\n\n/**\n * Calculate proportion of dark modules in entire symbol\n *\n * Points: N4 * k\n *\n * k is the rating of the deviation of the proportion of dark modules\n * in the symbol from 50% in steps of 5%\n */\nexports.getPenaltyN4 = function getPenaltyN4 (data) {\n  let darkCount = 0\n  const modulesCount = data.data.length\n\n  for (let i = 0; i < modulesCount; i++) darkCount += data.data[i]\n\n  const k = Math.abs(Math.ceil((darkCount * 100 / modulesCount) / 5) - 10)\n\n  return k * PenaltyScores.N4\n}\n\n/**\n * Return mask value at given position\n *\n * @param  {Number} maskPattern Pattern reference value\n * @param  {Number} i           Row\n * @param  {Number} j           Column\n * @return {Boolean}            Mask value\n */\nfunction getMaskAt (maskPattern, i, j) {\n  switch (maskPattern) {\n    case exports.Patterns.PATTERN000: return (i + j) % 2 === 0\n    case exports.Patterns.PATTERN001: return i % 2 === 0\n    case exports.Patterns.PATTERN010: return j % 3 === 0\n    case exports.Patterns.PATTERN011: return (i + j) % 3 === 0\n    case exports.Patterns.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0\n    case exports.Patterns.PATTERN101: return (i * j) % 2 + (i * j) % 3 === 0\n    case exports.Patterns.PATTERN110: return ((i * j) % 2 + (i * j) % 3) % 2 === 0\n    case exports.Patterns.PATTERN111: return ((i * j) % 3 + (i + j) % 2) % 2 === 0\n\n    default: throw new Error('bad maskPattern:' + maskPattern)\n  }\n}\n\n/**\n * Apply a mask pattern to a BitMatrix\n *\n * @param  {Number}    pattern Pattern reference number\n * @param  {BitMatrix} data    BitMatrix data\n */\nexports.applyMask = function applyMask (pattern, data) {\n  const size = data.size\n\n  for (let col = 0; col < size; col++) {\n    for (let row = 0; row < size; row++) {\n      if (data.isReserved(row, col)) continue\n      data.xor(row, col, getMaskAt(pattern, row, col))\n    }\n  }\n}\n\n/**\n * Returns the best mask pattern for data\n *\n * @param  {BitMatrix} data\n * @return {Number} Mask pattern reference number\n */\nexports.getBestMask = function getBestMask (data, setupFormatFunc) {\n  const numPatterns = Object.keys(exports.Patterns).length\n  let bestPattern = 0\n  let lowerPenalty = Infinity\n\n  for (let p = 0; p < numPatterns; p++) {\n    setupFormatFunc(p)\n    exports.applyMask(p, data)\n\n    // Calculate penalty\n    const penalty =\n      exports.getPenaltyN1(data) +\n      exports.getPenaltyN2(data) +\n      exports.getPenaltyN3(data) +\n      exports.getPenaltyN4(data)\n\n    // Undo previously applied mask\n    exports.applyMask(p, data)\n\n    if (penalty < lowerPenalty) {\n      lowerPenalty = penalty\n      bestPattern = p\n    }\n  }\n\n  return bestPattern\n}\n","const ECLevel = require('./error-correction-level')\r\n\r\nconst EC_BLOCKS_TABLE = [\r\n// L  M  Q  H\r\n  1, 1, 1, 1,\r\n  1, 1, 1, 1,\r\n  1, 1, 2, 2,\r\n  1, 2, 2, 4,\r\n  1, 2, 4, 4,\r\n  2, 4, 4, 4,\r\n  2, 4, 6, 5,\r\n  2, 4, 6, 6,\r\n  2, 5, 8, 8,\r\n  4, 5, 8, 8,\r\n  4, 5, 8, 11,\r\n  4, 8, 10, 11,\r\n  4, 9, 12, 16,\r\n  4, 9, 16, 16,\r\n  6, 10, 12, 18,\r\n  6, 10, 17, 16,\r\n  6, 11, 16, 19,\r\n  6, 13, 18, 21,\r\n  7, 14, 21, 25,\r\n  8, 16, 20, 25,\r\n  8, 17, 23, 25,\r\n  9, 17, 23, 34,\r\n  9, 18, 25, 30,\r\n  10, 20, 27, 32,\r\n  12, 21, 29, 35,\r\n  12, 23, 34, 37,\r\n  12, 25, 34, 40,\r\n  13, 26, 35, 42,\r\n  14, 28, 38, 45,\r\n  15, 29, 40, 48,\r\n  16, 31, 43, 51,\r\n  17, 33, 45, 54,\r\n  18, 35, 48, 57,\r\n  19, 37, 51, 60,\r\n  19, 38, 53, 63,\r\n  20, 40, 56, 66,\r\n  21, 43, 59, 70,\r\n  22, 45, 62, 74,\r\n  24, 47, 65, 77,\r\n  25, 49, 68, 81\r\n]\r\n\r\nconst EC_CODEWORDS_TABLE = [\r\n// L  M  Q  H\r\n  7, 10, 13, 17,\r\n  10, 16, 22, 28,\r\n  15, 26, 36, 44,\r\n  20, 36, 52, 64,\r\n  26, 48, 72, 88,\r\n  36, 64, 96, 112,\r\n  40, 72, 108, 130,\r\n  48, 88, 132, 156,\r\n  60, 110, 160, 192,\r\n  72, 130, 192, 224,\r\n  80, 150, 224, 264,\r\n  96, 176, 260, 308,\r\n  104, 198, 288, 352,\r\n  120, 216, 320, 384,\r\n  132, 240, 360, 432,\r\n  144, 280, 408, 480,\r\n  168, 308, 448, 532,\r\n  180, 338, 504, 588,\r\n  196, 364, 546, 650,\r\n  224, 416, 600, 700,\r\n  224, 442, 644, 750,\r\n  252, 476, 690, 816,\r\n  270, 504, 750, 900,\r\n  300, 560, 810, 960,\r\n  312, 588, 870, 1050,\r\n  336, 644, 952, 1110,\r\n  360, 700, 1020, 1200,\r\n  390, 728, 1050, 1260,\r\n  420, 784, 1140, 1350,\r\n  450, 812, 1200, 1440,\r\n  480, 868, 1290, 1530,\r\n  510, 924, 1350, 1620,\r\n  540, 980, 1440, 1710,\r\n  570, 1036, 1530, 1800,\r\n  570, 1064, 1590, 1890,\r\n  600, 1120, 1680, 1980,\r\n  630, 1204, 1770, 2100,\r\n  660, 1260, 1860, 2220,\r\n  720, 1316, 1950, 2310,\r\n  750, 1372, 2040, 2430\r\n]\r\n\r\n/**\r\n * Returns the number of error correction block that the QR Code should contain\r\n * for the specified version and error correction level.\r\n *\r\n * @param  {Number} version              QR Code version\r\n * @param  {Number} errorCorrectionLevel Error correction level\r\n * @return {Number}                      Number of error correction blocks\r\n */\r\nexports.getBlocksCount = function getBlocksCount (version, errorCorrectionLevel) {\r\n  switch (errorCorrectionLevel) {\r\n    case ECLevel.L:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 0]\r\n    case ECLevel.M:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 1]\r\n    case ECLevel.Q:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 2]\r\n    case ECLevel.H:\r\n      return EC_BLOCKS_TABLE[(version - 1) * 4 + 3]\r\n    default:\r\n      return undefined\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the number of error correction codewords to use for the specified\r\n * version and error correction level.\r\n *\r\n * @param  {Number} version              QR Code version\r\n * @param  {Number} errorCorrectionLevel Error correction level\r\n * @return {Number}                      Number of error correction codewords\r\n */\r\nexports.getTotalCodewordsCount = function getTotalCodewordsCount (version, errorCorrectionLevel) {\r\n  switch (errorCorrectionLevel) {\r\n    case ECLevel.L:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0]\r\n    case ECLevel.M:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1]\r\n    case ECLevel.Q:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2]\r\n    case ECLevel.H:\r\n      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3]\r\n    default:\r\n      return undefined\r\n  }\r\n}\r\n","const EXP_TABLE = new Uint8Array(512)\nconst LOG_TABLE = new Uint8Array(256)\n/**\n * Precompute the log and anti-log tables for faster computation later\n *\n * For each possible value in the galois field 2^8, we will pre-compute\n * the logarithm and anti-logarithm (exponential) of this value\n *\n * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}\n */\n;(function initTables () {\n  let x = 1\n  for (let i = 0; i < 255; i++) {\n    EXP_TABLE[i] = x\n    LOG_TABLE[x] = i\n\n    x <<= 1 // multiply by 2\n\n    // The QR code specification says to use byte-wise modulo 100011101 arithmetic.\n    // This means that when a number is 256 or larger, it should be XORed with 0x11D.\n    if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)\n      x ^= 0x11D\n    }\n  }\n\n  // Optimization: double the size of the anti-log table so that we don't need to mod 255 to\n  // stay inside the bounds (because we will mainly use this table for the multiplication of\n  // two GF numbers, no more).\n  // @see {@link mul}\n  for (let i = 255; i < 512; i++) {\n    EXP_TABLE[i] = EXP_TABLE[i - 255]\n  }\n}())\n\n/**\n * Returns log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nexports.log = function log (n) {\n  if (n < 1) throw new Error('log(' + n + ')')\n  return LOG_TABLE[n]\n}\n\n/**\n * Returns anti-log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nexports.exp = function exp (n) {\n  return EXP_TABLE[n]\n}\n\n/**\n * Multiplies two number inside Galois Field\n *\n * @param  {Number} x\n * @param  {Number} y\n * @return {Number}\n */\nexports.mul = function mul (x, y) {\n  if (x === 0 || y === 0) return 0\n\n  // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized\n  // @see {@link initTables}\n  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]\n}\n","const GF = require('./galois-field')\n\n/**\n * Multiplies two polynomials inside Galois Field\n *\n * @param  {Uint8Array} p1 Polynomial\n * @param  {Uint8Array} p2 Polynomial\n * @return {Uint8Array}    Product of p1 and p2\n */\nexports.mul = function mul (p1, p2) {\n  const coeff = new Uint8Array(p1.length + p2.length - 1)\n\n  for (let i = 0; i < p1.length; i++) {\n    for (let j = 0; j < p2.length; j++) {\n      coeff[i + j] ^= GF.mul(p1[i], p2[j])\n    }\n  }\n\n  return coeff\n}\n\n/**\n * Calculate the remainder of polynomials division\n *\n * @param  {Uint8Array} divident Polynomial\n * @param  {Uint8Array} divisor  Polynomial\n * @return {Uint8Array}          Remainder\n */\nexports.mod = function mod (divident, divisor) {\n  let result = new Uint8Array(divident)\n\n  while ((result.length - divisor.length) >= 0) {\n    const coeff = result[0]\n\n    for (let i = 0; i < divisor.length; i++) {\n      result[i] ^= GF.mul(divisor[i], coeff)\n    }\n\n    // remove all zeros from buffer head\n    let offset = 0\n    while (offset < result.length && result[offset] === 0) offset++\n    result = result.slice(offset)\n  }\n\n  return result\n}\n\n/**\n * Generate an irreducible generator polynomial of specified degree\n * (used by Reed-Solomon encoder)\n *\n * @param  {Number} degree Degree of the generator polynomial\n * @return {Uint8Array}    Buffer containing polynomial coefficients\n */\nexports.generateECPolynomial = function generateECPolynomial (degree) {\n  let poly = new Uint8Array([1])\n  for (let i = 0; i < degree; i++) {\n    poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]))\n  }\n\n  return poly\n}\n","const Polynomial = require('./polynomial')\n\nfunction ReedSolomonEncoder (degree) {\n  this.genPoly = undefined\n  this.degree = degree\n\n  if (this.degree) this.initialize(this.degree)\n}\n\n/**\n * Initialize the encoder.\n * The input param should correspond to the number of error correction codewords.\n *\n * @param  {Number} degree\n */\nReedSolomonEncoder.prototype.initialize = function initialize (degree) {\n  // create an irreducible generator polynomial\n  this.degree = degree\n  this.genPoly = Polynomial.generateECPolynomial(this.degree)\n}\n\n/**\n * Encodes a chunk of data\n *\n * @param  {Uint8Array} data Buffer containing input data\n * @return {Uint8Array}      Buffer containing encoded data\n */\nReedSolomonEncoder.prototype.encode = function encode (data) {\n  if (!this.genPoly) {\n    throw new Error('Encoder not initialized')\n  }\n\n  // Calculate EC for this data block\n  // extends data size to data+genPoly size\n  const paddedData = new Uint8Array(data.length + this.degree)\n  paddedData.set(data)\n\n  // The error correction codewords are the remainder after dividing the data codewords\n  // by a generator polynomial\n  const remainder = Polynomial.mod(paddedData, this.genPoly)\n\n  // return EC data blocks (last n byte, where n is the degree of genPoly)\n  // If coefficients number in remainder are less than genPoly degree,\n  // pad with 0s to the left to reach the needed number of coefficients\n  const start = this.degree - remainder.length\n  if (start > 0) {\n    const buff = new Uint8Array(this.degree)\n    buff.set(remainder, start)\n\n    return buff\n  }\n\n  return remainder\n}\n\nmodule.exports = ReedSolomonEncoder\n","/**\n * Check if QR Code version is valid\n *\n * @param  {Number}  version QR Code version\n * @return {Boolean}         true if valid version, false otherwise\n */\nexports.isValid = function isValid (version) {\n  return !isNaN(version) && version >= 1 && version <= 40\n}\n","const numeric = '[0-9]+'\nconst alphanumeric = '[A-Z $%*+\\\\-./:]+'\nlet kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' +\n  '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' +\n  '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' +\n  '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+'\nkanji = kanji.replace(/u/g, '\\\\u')\n\nconst byte = '(?:(?![A-Z0-9 $%*+\\\\-./:]|' + kanji + ')(?:.|[\\r\\n]))+'\n\nexports.KANJI = new RegExp(kanji, 'g')\nexports.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\\\-./:]+', 'g')\nexports.BYTE = new RegExp(byte, 'g')\nexports.NUMERIC = new RegExp(numeric, 'g')\nexports.ALPHANUMERIC = new RegExp(alphanumeric, 'g')\n\nconst TEST_KANJI = new RegExp('^' + kanji + '$')\nconst TEST_NUMERIC = new RegExp('^' + numeric + '$')\nconst TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\\\-./:]+$')\n\nexports.testKanji = function testKanji (str) {\n  return TEST_KANJI.test(str)\n}\n\nexports.testNumeric = function testNumeric (str) {\n  return TEST_NUMERIC.test(str)\n}\n\nexports.testAlphanumeric = function testAlphanumeric (str) {\n  return TEST_ALPHANUMERIC.test(str)\n}\n","const VersionCheck = require('./version-check')\nconst Regex = require('./regex')\n\n/**\n * Numeric mode encodes data from the decimal digit set (0 - 9)\n * (byte values 30HEX to 39HEX).\n * Normally, 3 data characters are represented by 10 bits.\n *\n * @type {Object}\n */\nexports.NUMERIC = {\n  id: 'Numeric',\n  bit: 1 << 0,\n  ccBits: [10, 12, 14]\n}\n\n/**\n * Alphanumeric mode encodes data from a set of 45 characters,\n * i.e. 10 numeric digits (0 - 9),\n *      26 alphabetic characters (A - Z),\n *   and 9 symbols (SP, $, %, *, +, -, ., /, :).\n * Normally, two input characters are represented by 11 bits.\n *\n * @type {Object}\n */\nexports.ALPHANUMERIC = {\n  id: 'Alphanumeric',\n  bit: 1 << 1,\n  ccBits: [9, 11, 13]\n}\n\n/**\n * In byte mode, data is encoded at 8 bits per character.\n *\n * @type {Object}\n */\nexports.BYTE = {\n  id: 'Byte',\n  bit: 1 << 2,\n  ccBits: [8, 16, 16]\n}\n\n/**\n * The Kanji mode efficiently encodes Kanji characters in accordance with\n * the Shift JIS system based on JIS X 0208.\n * The Shift JIS values are shifted from the JIS X 0208 values.\n * JIS X 0208 gives details of the shift coded representation.\n * Each two-byte character value is compacted to a 13-bit binary codeword.\n *\n * @type {Object}\n */\nexports.KANJI = {\n  id: 'Kanji',\n  bit: 1 << 3,\n  ccBits: [8, 10, 12]\n}\n\n/**\n * Mixed mode will contain a sequences of data in a combination of any of\n * the modes described above\n *\n * @type {Object}\n */\nexports.MIXED = {\n  bit: -1\n}\n\n/**\n * Returns the number of bits needed to store the data length\n * according to QR Code specifications.\n *\n * @param  {Mode}   mode    Data mode\n * @param  {Number} version QR Code version\n * @return {Number}         Number of bits\n */\nexports.getCharCountIndicator = function getCharCountIndicator (mode, version) {\n  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode)\n\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid version: ' + version)\n  }\n\n  if (version >= 1 && version < 10) return mode.ccBits[0]\n  else if (version < 27) return mode.ccBits[1]\n  return mode.ccBits[2]\n}\n\n/**\n * Returns the most efficient mode to store the specified data\n *\n * @param  {String} dataStr Input data string\n * @return {Mode}           Best mode\n */\nexports.getBestModeForData = function getBestModeForData (dataStr) {\n  if (Regex.testNumeric(dataStr)) return exports.NUMERIC\n  else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC\n  else if (Regex.testKanji(dataStr)) return exports.KANJI\n  else return exports.BYTE\n}\n\n/**\n * Return mode name as string\n *\n * @param {Mode} mode Mode object\n * @returns {String}  Mode name\n */\nexports.toString = function toString (mode) {\n  if (mode && mode.id) return mode.id\n  throw new Error('Invalid mode')\n}\n\n/**\n * Check if input param is a valid mode object\n *\n * @param   {Mode}    mode Mode object\n * @returns {Boolean} True if valid mode, false otherwise\n */\nexports.isValid = function isValid (mode) {\n  return mode && mode.bit && mode.ccBits\n}\n\n/**\n * Get mode object from its name\n *\n * @param   {String} string Mode name\n * @returns {Mode}          Mode object\n */\nfunction fromString (string) {\n  if (typeof string !== 'string') {\n    throw new Error('Param is not a string')\n  }\n\n  const lcStr = string.toLowerCase()\n\n  switch (lcStr) {\n    case 'numeric':\n      return exports.NUMERIC\n    case 'alphanumeric':\n      return exports.ALPHANUMERIC\n    case 'kanji':\n      return exports.KANJI\n    case 'byte':\n      return exports.BYTE\n    default:\n      throw new Error('Unknown mode: ' + string)\n  }\n}\n\n/**\n * Returns mode from a value.\n * If value is not a valid mode, returns defaultValue\n *\n * @param  {Mode|String} value        Encoding mode\n * @param  {Mode}        defaultValue Fallback value\n * @return {Mode}                     Encoding mode\n */\nexports.from = function from (value, defaultValue) {\n  if (exports.isValid(value)) {\n    return value\n  }\n\n  try {\n    return fromString(value)\n  } catch (e) {\n    return defaultValue\n  }\n}\n","const Utils = require('./utils')\nconst ECCode = require('./error-correction-code')\nconst ECLevel = require('./error-correction-level')\nconst Mode = require('./mode')\nconst VersionCheck = require('./version-check')\n\n// Generator polynomial used to encode version information\nconst G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0)\nconst G18_BCH = Utils.getBCHDigit(G18)\n\nfunction getBestVersionForDataLength (mode, length, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\nfunction getReservedBitsCount (mode, version) {\n  // Character count indicator + mode indicator bits\n  return Mode.getCharCountIndicator(mode, version) + 4\n}\n\nfunction getTotalBitsFromDataArray (segments, version) {\n  let totalBits = 0\n\n  segments.forEach(function (data) {\n    const reservedBits = getReservedBitsCount(data.mode, version)\n    totalBits += reservedBits + data.getBitsLength()\n  })\n\n  return totalBits\n}\n\nfunction getBestVersionForMixedData (segments, errorCorrectionLevel) {\n  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {\n    const length = getTotalBitsFromDataArray(segments, currentVersion)\n    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {\n      return currentVersion\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns version number from a value.\n * If value is not a valid version, returns defaultValue\n *\n * @param  {Number|String} value        QR Code version\n * @param  {Number}        defaultValue Fallback value\n * @return {Number}                     QR Code version number\n */\nexports.from = function from (value, defaultValue) {\n  if (VersionCheck.isValid(value)) {\n    return parseInt(value, 10)\n  }\n\n  return defaultValue\n}\n\n/**\n * Returns how much data can be stored with the specified QR code version\n * and error correction level\n *\n * @param  {Number} version              QR Code version (1-40)\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Mode}   mode                 Data mode\n * @return {Number}                      Quantity of storable data\n */\nexports.getCapacity = function getCapacity (version, errorCorrectionLevel, mode) {\n  if (!VersionCheck.isValid(version)) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  // Use Byte mode as default\n  if (typeof mode === 'undefined') mode = Mode.BYTE\n\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  if (mode === Mode.MIXED) return dataTotalCodewordsBits\n\n  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version)\n\n  // Return max number of storable codewords\n  switch (mode) {\n    case Mode.NUMERIC:\n      return Math.floor((usableBits / 10) * 3)\n\n    case Mode.ALPHANUMERIC:\n      return Math.floor((usableBits / 11) * 2)\n\n    case Mode.KANJI:\n      return Math.floor(usableBits / 13)\n\n    case Mode.BYTE:\n    default:\n      return Math.floor(usableBits / 8)\n  }\n}\n\n/**\n * Returns the minimum version needed to contain the amount of data\n *\n * @param  {Segment} data                    Segment of data\n * @param  {Number} [errorCorrectionLevel=H] Error correction level\n * @param  {Mode} mode                       Data mode\n * @return {Number}                          QR Code version\n */\nexports.getBestVersionForData = function getBestVersionForData (data, errorCorrectionLevel) {\n  let seg\n\n  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M)\n\n  if (Array.isArray(data)) {\n    if (data.length > 1) {\n      return getBestVersionForMixedData(data, ecl)\n    }\n\n    if (data.length === 0) {\n      return 1\n    }\n\n    seg = data[0]\n  } else {\n    seg = data\n  }\n\n  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)\n}\n\n/**\n * Returns version information with relative error correction bits\n *\n * The version information is included in QR Code symbols of version 7 or larger.\n * It consists of an 18-bit sequence containing 6 data bits,\n * with 12 error correction bits calculated using the (18, 6) Golay code.\n *\n * @param  {Number} version QR Code version\n * @return {Number}         Encoded version info bits\n */\nexports.getEncodedBits = function getEncodedBits (version) {\n  if (!VersionCheck.isValid(version) || version < 7) {\n    throw new Error('Invalid QR Code version')\n  }\n\n  let d = version << 12\n\n  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {\n    d ^= (G18 << (Utils.getBCHDigit(d) - G18_BCH))\n  }\n\n  return (version << 12) | d\n}\n","const Utils = require('./utils')\n\nconst G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0)\nconst G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1)\nconst G15_BCH = Utils.getBCHDigit(G15)\n\n/**\n * Returns format information with relative error correction bits\n *\n * The format information is a 15-bit sequence containing 5 data bits,\n * with 10 error correction bits calculated using the (15, 5) BCH code.\n *\n * @param  {Number} errorCorrectionLevel Error correction level\n * @param  {Number} mask                 Mask pattern\n * @return {Number}                      Encoded format information bits\n */\nexports.getEncodedBits = function getEncodedBits (errorCorrectionLevel, mask) {\n  const data = ((errorCorrectionLevel.bit << 3) | mask)\n  let d = data << 10\n\n  while (Utils.getBCHDigit(d) - G15_BCH >= 0) {\n    d ^= (G15 << (Utils.getBCHDigit(d) - G15_BCH))\n  }\n\n  // xor final data with mask pattern in order to ensure that\n  // no combination of Error Correction Level and data mask pattern\n  // will result in an all-zero data string\n  return ((data << 10) | d) ^ G15_MASK\n}\n","const Mode = require('./mode')\n\nfunction NumericData (data) {\n  this.mode = Mode.NUMERIC\n  this.data = data.toString()\n}\n\nNumericData.getBitsLength = function getBitsLength (length) {\n  return 10 * Math.floor(length / 3) + ((length % 3) ? ((length % 3) * 3 + 1) : 0)\n}\n\nNumericData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nNumericData.prototype.getBitsLength = function getBitsLength () {\n  return NumericData.getBitsLength(this.data.length)\n}\n\nNumericData.prototype.write = function write (bitBuffer) {\n  let i, group, value\n\n  // The input data string is divided into groups of three digits,\n  // and each group is converted to its 10-bit binary equivalent.\n  for (i = 0; i + 3 <= this.data.length; i += 3) {\n    group = this.data.substr(i, 3)\n    value = parseInt(group, 10)\n\n    bitBuffer.put(value, 10)\n  }\n\n  // If the number of input digits is not an exact multiple of three,\n  // the final one or two digits are converted to 4 or 7 bits respectively.\n  const remainingNum = this.data.length - i\n  if (remainingNum > 0) {\n    group = this.data.substr(i)\n    value = parseInt(group, 10)\n\n    bitBuffer.put(value, remainingNum * 3 + 1)\n  }\n}\n\nmodule.exports = NumericData\n","const Mode = require('./mode')\n\n/**\n * Array of characters available in alphanumeric mode\n *\n * As per QR Code specification, to each character\n * is assigned a value from 0 to 44 which in this case coincides\n * with the array index\n *\n * @type {Array}\n */\nconst ALPHA_NUM_CHARS = [\n  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n  ' ', '$', '%', '*', '+', '-', '.', '/', ':'\n]\n\nfunction AlphanumericData (data) {\n  this.mode = Mode.ALPHANUMERIC\n  this.data = data\n}\n\nAlphanumericData.getBitsLength = function getBitsLength (length) {\n  return 11 * Math.floor(length / 2) + 6 * (length % 2)\n}\n\nAlphanumericData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nAlphanumericData.prototype.getBitsLength = function getBitsLength () {\n  return AlphanumericData.getBitsLength(this.data.length)\n}\n\nAlphanumericData.prototype.write = function write (bitBuffer) {\n  let i\n\n  // Input data characters are divided into groups of two characters\n  // and encoded as 11-bit binary codes.\n  for (i = 0; i + 2 <= this.data.length; i += 2) {\n    // The character value of the first character is multiplied by 45\n    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45\n\n    // The character value of the second digit is added to the product\n    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1])\n\n    // The sum is then stored as 11-bit binary number\n    bitBuffer.put(value, 11)\n  }\n\n  // If the number of input data characters is not a multiple of two,\n  // the character value of the final character is encoded as a 6-bit binary number.\n  if (this.data.length % 2) {\n    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6)\n  }\n}\n\nmodule.exports = AlphanumericData\n","const Mode = require('./mode')\n\nfunction ByteData (data) {\n  this.mode = Mode.BYTE\n  if (typeof (data) === 'string') {\n    this.data = new TextEncoder().encode(data)\n  } else {\n    this.data = new Uint8Array(data)\n  }\n}\n\nByteData.getBitsLength = function getBitsLength (length) {\n  return length * 8\n}\n\nByteData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nByteData.prototype.getBitsLength = function getBitsLength () {\n  return ByteData.getBitsLength(this.data.length)\n}\n\nByteData.prototype.write = function (bitBuffer) {\n  for (let i = 0, l = this.data.length; i < l; i++) {\n    bitBuffer.put(this.data[i], 8)\n  }\n}\n\nmodule.exports = ByteData\n","const Mode = require('./mode')\nconst Utils = require('./utils')\n\nfunction KanjiData (data) {\n  this.mode = Mode.KANJI\n  this.data = data\n}\n\nKanjiData.getBitsLength = function getBitsLength (length) {\n  return length * 13\n}\n\nKanjiData.prototype.getLength = function getLength () {\n  return this.data.length\n}\n\nKanjiData.prototype.getBitsLength = function getBitsLength () {\n  return KanjiData.getBitsLength(this.data.length)\n}\n\nKanjiData.prototype.write = function (bitBuffer) {\n  let i\n\n  // In the Shift JIS system, Kanji characters are represented by a two byte combination.\n  // These byte values are shifted from the JIS X 0208 values.\n  // JIS X 0208 gives details of the shift coded representation.\n  for (i = 0; i < this.data.length; i++) {\n    let value = Utils.toSJIS(this.data[i])\n\n    // For characters with Shift JIS values from 0x8140 to 0x9FFC:\n    if (value >= 0x8140 && value <= 0x9FFC) {\n      // Subtract 0x8140 from Shift JIS value\n      value -= 0x8140\n\n    // For characters with Shift JIS values from 0xE040 to 0xEBBF\n    } else if (value >= 0xE040 && value <= 0xEBBF) {\n      // Subtract 0xC140 from Shift JIS value\n      value -= 0xC140\n    } else {\n      throw new Error(\n        'Invalid SJIS character: ' + this.data[i] + '\\n' +\n        'Make sure your charset is UTF-8')\n    }\n\n    // Multiply most significant byte of result by 0xC0\n    // and add least significant byte to product\n    value = (((value >>> 8) & 0xff) * 0xC0) + (value & 0xff)\n\n    // Convert result to a 13-bit binary string\n    bitBuffer.put(value, 13)\n  }\n}\n\nmodule.exports = KanjiData\n","'use strict';\n\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\nvar dijkstra = {\n  single_source_shortest_paths: function(graph, s, d) {\n    // Predecessor map for each node that has been encountered.\n    // node ID => predecessor node ID\n    var predecessors = {};\n\n    // Costs of shortest paths from s to all nodes encountered.\n    // node ID => cost\n    var costs = {};\n    costs[s] = 0;\n\n    // Costs of shortest paths from s to all nodes encountered; differs from\n    // `costs` in that it provides easy access to the node that currently has\n    // the known shortest path from s.\n    // XXX: Do we actually need both `costs` and `open`?\n    var open = dijkstra.PriorityQueue.make();\n    open.push(s, 0);\n\n    var closest,\n        u, v,\n        cost_of_s_to_u,\n        adjacent_nodes,\n        cost_of_e,\n        cost_of_s_to_u_plus_cost_of_e,\n        cost_of_s_to_v,\n        first_visit;\n    while (!open.empty()) {\n      // In the nodes remaining in graph that have a known cost from s,\n      // find the node, u, that currently has the shortest path from s.\n      closest = open.pop();\n      u = closest.value;\n      cost_of_s_to_u = closest.cost;\n\n      // Get nodes adjacent to u...\n      adjacent_nodes = graph[u] || {};\n\n      // ...and explore the edges that connect u to those nodes, updating\n      // the cost of the shortest paths to any or all of those nodes as\n      // necessary. v is the node across the current edge from u.\n      for (v in adjacent_nodes) {\n        if (adjacent_nodes.hasOwnProperty(v)) {\n          // Get the cost of the edge running from u to v.\n          cost_of_e = adjacent_nodes[v];\n\n          // Cost of s to u plus the cost of u to v across e--this is *a*\n          // cost from s to v that may or may not be less than the current\n          // known cost to v.\n          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;\n\n          // If we haven't visited v yet OR if the current known cost from s to\n          // v is greater than the new cost we just found (cost of s to u plus\n          // cost of u to v across e), update v's cost in the cost list and\n          // update v's predecessor in the predecessor list (it's now u).\n          cost_of_s_to_v = costs[v];\n          first_visit = (typeof costs[v] === 'undefined');\n          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n            costs[v] = cost_of_s_to_u_plus_cost_of_e;\n            open.push(v, cost_of_s_to_u_plus_cost_of_e);\n            predecessors[v] = u;\n          }\n        }\n      }\n    }\n\n    if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {\n      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n      throw new Error(msg);\n    }\n\n    return predecessors;\n  },\n\n  extract_shortest_path_from_predecessor_list: function(predecessors, d) {\n    var nodes = [];\n    var u = d;\n    var predecessor;\n    while (u) {\n      nodes.push(u);\n      predecessor = predecessors[u];\n      u = predecessors[u];\n    }\n    nodes.reverse();\n    return nodes;\n  },\n\n  find_path: function(graph, s, d) {\n    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n    return dijkstra.extract_shortest_path_from_predecessor_list(\n      predecessors, d);\n  },\n\n  /**\n   * A very naive priority queue implementation.\n   */\n  PriorityQueue: {\n    make: function (opts) {\n      var T = dijkstra.PriorityQueue,\n          t = {},\n          key;\n      opts = opts || {};\n      for (key in T) {\n        if (T.hasOwnProperty(key)) {\n          t[key] = T[key];\n        }\n      }\n      t.queue = [];\n      t.sorter = opts.sorter || T.default_sorter;\n      return t;\n    },\n\n    default_sorter: function (a, b) {\n      return a.cost - b.cost;\n    },\n\n    /**\n     * Add a new item to the queue and ensure the highest priority element\n     * is at the front of the queue.\n     */\n    push: function (value, cost) {\n      var item = {value: value, cost: cost};\n      this.queue.push(item);\n      this.queue.sort(this.sorter);\n    },\n\n    /**\n     * Return the highest priority element in the queue.\n     */\n    pop: function () {\n      return this.queue.shift();\n    },\n\n    empty: function () {\n      return this.queue.length === 0;\n    }\n  }\n};\n\n\n// node.js module exports\nif (typeof module !== 'undefined') {\n  module.exports = dijkstra;\n}\n","const Mode = require('./mode')\nconst NumericData = require('./numeric-data')\nconst AlphanumericData = require('./alphanumeric-data')\nconst ByteData = require('./byte-data')\nconst KanjiData = require('./kanji-data')\nconst Regex = require('./regex')\nconst Utils = require('./utils')\nconst dijkstra = require('dijkstrajs')\n\n/**\n * Returns UTF8 byte length\n *\n * @param  {String} str Input string\n * @return {Number}     Number of byte\n */\nfunction getStringByteLength (str) {\n  return unescape(encodeURIComponent(str)).length\n}\n\n/**\n * Get a list of segments of the specified mode\n * from a string\n *\n * @param  {Mode}   mode Segment mode\n * @param  {String} str  String to process\n * @return {Array}       Array of object with segments data\n */\nfunction getSegments (regex, mode, str) {\n  const segments = []\n  let result\n\n  while ((result = regex.exec(str)) !== null) {\n    segments.push({\n      data: result[0],\n      index: result.index,\n      mode: mode,\n      length: result[0].length\n    })\n  }\n\n  return segments\n}\n\n/**\n * Extracts a series of segments with the appropriate\n * modes from a string\n *\n * @param  {String} dataStr Input string\n * @return {Array}          Array of object with segments data\n */\nfunction getSegmentsFromString (dataStr) {\n  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)\n  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)\n  let byteSegs\n  let kanjiSegs\n\n  if (Utils.isKanjiModeEnabled()) {\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)\n  } else {\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)\n    kanjiSegs = []\n  }\n\n  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)\n\n  return segs\n    .sort(function (s1, s2) {\n      return s1.index - s2.index\n    })\n    .map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      }\n    })\n}\n\n/**\n * Returns how many bits are needed to encode a string of\n * specified length with the specified mode\n *\n * @param  {Number} length String length\n * @param  {Mode} mode     Segment mode\n * @return {Number}        Bit length\n */\nfunction getSegmentBitsLength (length, mode) {\n  switch (mode) {\n    case Mode.NUMERIC:\n      return NumericData.getBitsLength(length)\n    case Mode.ALPHANUMERIC:\n      return AlphanumericData.getBitsLength(length)\n    case Mode.KANJI:\n      return KanjiData.getBitsLength(length)\n    case Mode.BYTE:\n      return ByteData.getBitsLength(length)\n  }\n}\n\n/**\n * Merges adjacent segments which have the same mode\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction mergeSegments (segs) {\n  return segs.reduce(function (acc, curr) {\n    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null\n    if (prevSeg && prevSeg.mode === curr.mode) {\n      acc[acc.length - 1].data += curr.data\n      return acc\n    }\n\n    acc.push(curr)\n    return acc\n  }, [])\n}\n\n/**\n * Generates a list of all possible nodes combination which\n * will be used to build a segments graph.\n *\n * Nodes are divided by groups. Each group will contain a list of all the modes\n * in which is possible to encode the given text.\n *\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n * The group for '12345' will contain then 3 objects, one for each\n * possible encoding mode.\n *\n * Each node represents a possible segment.\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction buildNodes (segs) {\n  const nodes = []\n  for (let i = 0; i < segs.length; i++) {\n    const seg = segs[i]\n\n    switch (seg.mode) {\n      case Mode.NUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.ALPHANUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.KANJI:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n        break\n      case Mode.BYTE:\n        nodes.push([\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n    }\n  }\n\n  return nodes\n}\n\n/**\n * Builds a graph from a list of nodes.\n * All segments in each node group will be connected with all the segments of\n * the next group and so on.\n *\n * At each connection will be assigned a weight depending on the\n * segment's byte length.\n *\n * @param  {Array} nodes    Array of object with segments data\n * @param  {Number} version QR Code version\n * @return {Object}         Graph of all possible segments\n */\nfunction buildGraph (nodes, version) {\n  const table = {}\n  const graph = { start: {} }\n  let prevNodeIds = ['start']\n\n  for (let i = 0; i < nodes.length; i++) {\n    const nodeGroup = nodes[i]\n    const currentNodeIds = []\n\n    for (let j = 0; j < nodeGroup.length; j++) {\n      const node = nodeGroup[j]\n      const key = '' + i + j\n\n      currentNodeIds.push(key)\n      table[key] = { node: node, lastCount: 0 }\n      graph[key] = {}\n\n      for (let n = 0; n < prevNodeIds.length; n++) {\n        const prevNodeId = prevNodeIds[n]\n\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n          graph[prevNodeId][key] =\n            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)\n\n          table[prevNodeId].lastCount += node.length\n        } else {\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length\n\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost\n        }\n      }\n    }\n\n    prevNodeIds = currentNodeIds\n  }\n\n  for (let n = 0; n < prevNodeIds.length; n++) {\n    graph[prevNodeIds[n]].end = 0\n  }\n\n  return { map: graph, table: table }\n}\n\n/**\n * Builds a segment from a specified data and mode.\n * If a mode is not specified, the more suitable will be used.\n *\n * @param  {String} data             Input data\n * @param  {Mode | String} modesHint Data mode\n * @return {Segment}                 Segment\n */\nfunction buildSingleSegment (data, modesHint) {\n  let mode\n  const bestMode = Mode.getBestModeForData(data)\n\n  mode = Mode.from(modesHint, bestMode)\n\n  // Make sure data can be encoded\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n    throw new Error('\"' + data + '\"' +\n      ' cannot be encoded with mode ' + Mode.toString(mode) +\n      '.\\n Suggested mode is: ' + Mode.toString(bestMode))\n  }\n\n  // Use Mode.BYTE if Kanji support is disabled\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n    mode = Mode.BYTE\n  }\n\n  switch (mode) {\n    case Mode.NUMERIC:\n      return new NumericData(data)\n\n    case Mode.ALPHANUMERIC:\n      return new AlphanumericData(data)\n\n    case Mode.KANJI:\n      return new KanjiData(data)\n\n    case Mode.BYTE:\n      return new ByteData(data)\n  }\n}\n\n/**\n * Builds a list of segments from an array.\n * Array can contain Strings or Objects with segment's info.\n *\n * For each item which is a string, will be generated a segment with the given\n * string and the more appropriate encoding mode.\n *\n * For each item which is an object, will be generated a segment with the given\n * data and mode.\n * Objects must contain at least the property \"data\".\n * If property \"mode\" is not present, the more suitable mode will be used.\n *\n * @param  {Array} array Array of objects with segments data\n * @return {Array}       Array of Segments\n */\nexports.fromArray = function fromArray (array) {\n  return array.reduce(function (acc, seg) {\n    if (typeof seg === 'string') {\n      acc.push(buildSingleSegment(seg, null))\n    } else if (seg.data) {\n      acc.push(buildSingleSegment(seg.data, seg.mode))\n    }\n\n    return acc\n  }, [])\n}\n\n/**\n * Builds an optimized sequence of segments from a string,\n * which will produce the shortest possible bitstream.\n *\n * @param  {String} data    Input string\n * @param  {Number} version QR Code version\n * @return {Array}          Array of segments\n */\nexports.fromString = function fromString (data, version) {\n  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n\n  const nodes = buildNodes(segs)\n  const graph = buildGraph(nodes, version)\n  const path = dijkstra.find_path(graph.map, 'start', 'end')\n\n  const optimizedSegs = []\n  for (let i = 1; i < path.length - 1; i++) {\n    optimizedSegs.push(graph.table[path[i]].node)\n  }\n\n  return exports.fromArray(mergeSegments(optimizedSegs))\n}\n\n/**\n * Splits a string in various segments with the modes which\n * best represent their content.\n * The produced segments are far from being optimized.\n * The output of this function is only used to estimate a QR Code version\n * which may contain the data.\n *\n * @param  {string} data Input string\n * @return {Array}       Array of segments\n */\nexports.rawSplit = function rawSplit (data) {\n  return exports.fromArray(\n    getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n  )\n}\n","const Utils = require('./utils')\nconst ECLevel = require('./error-correction-level')\nconst BitBuffer = require('./bit-buffer')\nconst BitMatrix = require('./bit-matrix')\nconst AlignmentPattern = require('./alignment-pattern')\nconst FinderPattern = require('./finder-pattern')\nconst MaskPattern = require('./mask-pattern')\nconst ECCode = require('./error-correction-code')\nconst ReedSolomonEncoder = require('./reed-solomon-encoder')\nconst Version = require('./version')\nconst FormatInfo = require('./format-info')\nconst Mode = require('./mode')\nconst Segments = require('./segments')\n\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupFinderPattern (matrix, version) {\n  const size = matrix.size\n  const pos = FinderPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -1; r <= 7; r++) {\n      if (row + r <= -1 || size <= row + r) continue\n\n      for (let c = -1; c <= 7; c++) {\n        if (col + c <= -1 || size <= col + c) continue\n\n        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||\n          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||\n          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\nfunction setupTimingPattern (matrix) {\n  const size = matrix.size\n\n  for (let r = 8; r < size - 8; r++) {\n    const value = r % 2 === 0\n    matrix.set(r, 6, value, true)\n    matrix.set(6, r, value, true)\n  }\n}\n\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupAlignmentPattern (matrix, version) {\n  const pos = AlignmentPattern.getPositions(version)\n\n  for (let i = 0; i < pos.length; i++) {\n    const row = pos[i][0]\n    const col = pos[i][1]\n\n    for (let r = -2; r <= 2; r++) {\n      for (let c = -2; c <= 2; c++) {\n        if (r === -2 || r === 2 || c === -2 || c === 2 ||\n          (r === 0 && c === 0)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupVersionInfo (matrix, version) {\n  const size = matrix.size\n  const bits = Version.getEncodedBits(version)\n  let row, col, mod\n\n  for (let i = 0; i < 18; i++) {\n    row = Math.floor(i / 3)\n    col = i % 3 + size - 8 - 3\n    mod = ((bits >> i) & 1) === 1\n\n    matrix.set(row, col, mod, true)\n    matrix.set(col, row, mod, true)\n  }\n}\n\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\nfunction setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {\n  const size = matrix.size\n  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern)\n  let i, mod\n\n  for (i = 0; i < 15; i++) {\n    mod = ((bits >> i) & 1) === 1\n\n    // vertical\n    if (i < 6) {\n      matrix.set(i, 8, mod, true)\n    } else if (i < 8) {\n      matrix.set(i + 1, 8, mod, true)\n    } else {\n      matrix.set(size - 15 + i, 8, mod, true)\n    }\n\n    // horizontal\n    if (i < 8) {\n      matrix.set(8, size - i - 1, mod, true)\n    } else if (i < 9) {\n      matrix.set(8, 15 - i - 1 + 1, mod, true)\n    } else {\n      matrix.set(8, 15 - i - 1, mod, true)\n    }\n  }\n\n  // fixed module\n  matrix.set(size - 8, 8, 1, true)\n}\n\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix}  matrix Modules matrix\n * @param  {Uint8Array} data   Data codewords\n */\nfunction setupData (matrix, data) {\n  const size = matrix.size\n  let inc = -1\n  let row = size - 1\n  let bitIndex = 7\n  let byteIndex = 0\n\n  for (let col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col--\n\n    while (true) {\n      for (let c = 0; c < 2; c++) {\n        if (!matrix.isReserved(row, col - c)) {\n          let dark = false\n\n          if (byteIndex < data.length) {\n            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1)\n          }\n\n          matrix.set(row, col - c, dark)\n          bitIndex--\n\n          if (bitIndex === -1) {\n            byteIndex++\n            bitIndex = 7\n          }\n        }\n      }\n\n      row += inc\n\n      if (row < 0 || size <= row) {\n        row -= inc\n        inc = -inc\n        break\n      }\n    }\n  }\n}\n\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Uint8Array}                    Buffer containing encoded codewords\n */\nfunction createData (version, errorCorrectionLevel, segments) {\n  // Prepare data buffer\n  const buffer = new BitBuffer()\n\n  segments.forEach(function (data) {\n    // prefix data with mode indicator (4 bits)\n    buffer.put(data.mode.bit, 4)\n\n    // Prefix data with character count indicator.\n    // The character count indicator is a string of bits that represents the\n    // number of characters that are being encoded.\n    // The character count indicator must be placed after the mode indicator\n    // and must be a certain number of bits long, depending on the QR version\n    // and data mode\n    // @see {@link Mode.getCharCountIndicator}.\n    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version))\n\n    // add binary data sequence to buffer\n    data.write(buffer)\n  })\n\n  // Calculate required number of bits\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  // Add a terminator.\n  // If the bit string is shorter than the total number of required bits,\n  // a terminator of up to four 0s must be added to the right side of the string.\n  // If the bit string is more than four bits shorter than the required number of bits,\n  // add four 0s to the end.\n  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n    buffer.put(0, 4)\n  }\n\n  // If the bit string is fewer than four bits shorter, add only the number of 0s that\n  // are needed to reach the required number of bits.\n\n  // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n  // pad the string on the right with 0s to make the string's length a multiple of 8.\n  while (buffer.getLengthInBits() % 8 !== 0) {\n    buffer.putBit(0)\n  }\n\n  // Add pad bytes if the string is still shorter than the total number of required bits.\n  // Extend the buffer to fill the data capacity of the symbol corresponding to\n  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n  // and 00010001 (0x11) alternately.\n  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8\n  for (let i = 0; i < remainingByte; i++) {\n    buffer.put(i % 2 ? 0x11 : 0xEC, 8)\n  }\n\n  return createCodewords(buffer, version, errorCorrectionLevel)\n}\n\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Uint8Array}                     Buffer containing encoded codewords\n */\nfunction createCodewords (bitBuffer, version, errorCorrectionLevel) {\n  // Total codewords for this QR code version (Data + Error correction)\n  const totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  const dataTotalCodewords = totalCodewords - ecTotalCodewords\n\n  // Total number of blocks\n  const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel)\n\n  // Calculate how many blocks each group should contain\n  const blocksInGroup2 = totalCodewords % ecTotalBlocks\n  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2\n\n  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks)\n\n  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks)\n  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1\n\n  // Number of EC codewords is the same for both groups\n  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1\n\n  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n  const rs = new ReedSolomonEncoder(ecCount)\n\n  let offset = 0\n  const dcData = new Array(ecTotalBlocks)\n  const ecData = new Array(ecTotalBlocks)\n  let maxDataSize = 0\n  const buffer = new Uint8Array(bitBuffer.buffer)\n\n  // Divide the buffer into the required number of blocks\n  for (let b = 0; b < ecTotalBlocks; b++) {\n    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2\n\n    // extract a block of data from buffer\n    dcData[b] = buffer.slice(offset, offset + dataSize)\n\n    // Calculate EC codewords for this data block\n    ecData[b] = rs.encode(dcData[b])\n\n    offset += dataSize\n    maxDataSize = Math.max(maxDataSize, dataSize)\n  }\n\n  // Create final data\n  // Interleave the data and error correction codewords from each block\n  const data = new Uint8Array(totalCodewords)\n  let index = 0\n  let i, r\n\n  // Add data codewords\n  for (i = 0; i < maxDataSize; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      if (i < dcData[r].length) {\n        data[index++] = dcData[r][i]\n      }\n    }\n  }\n\n  // Apped EC codewords\n  for (i = 0; i < ecCount; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      data[index++] = ecData[r][i]\n    }\n  }\n\n  return data\n}\n\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\nfunction createSymbol (data, version, errorCorrectionLevel, maskPattern) {\n  let segments\n\n  if (Array.isArray(data)) {\n    segments = Segments.fromArray(data)\n  } else if (typeof data === 'string') {\n    let estimatedVersion = version\n\n    if (!estimatedVersion) {\n      const rawSegments = Segments.rawSplit(data)\n\n      // Estimate best version that can contain raw splitted segments\n      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel)\n    }\n\n    // Build optimized segments\n    // If estimated version is undefined, try with the highest version\n    segments = Segments.fromString(data, estimatedVersion || 40)\n  } else {\n    throw new Error('Invalid data')\n  }\n\n  // Get the min version that can contain data\n  const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel)\n\n  // If no version is found, data cannot be stored\n  if (!bestVersion) {\n    throw new Error('The amount of data is too big to be stored in a QR Code')\n  }\n\n  // If not specified, use min version as default\n  if (!version) {\n    version = bestVersion\n\n  // Check if the specified version can contain the data\n  } else if (version < bestVersion) {\n    throw new Error('\\n' +\n      'The chosen QR Code version cannot contain this amount of data.\\n' +\n      'Minimum version required to store current data is: ' + bestVersion + '.\\n'\n    )\n  }\n\n  const dataBits = createData(version, errorCorrectionLevel, segments)\n\n  // Allocate matrix buffer\n  const moduleCount = Utils.getSymbolSize(version)\n  const modules = new BitMatrix(moduleCount)\n\n  // Add function modules\n  setupFinderPattern(modules, version)\n  setupTimingPattern(modules)\n  setupAlignmentPattern(modules, version)\n\n  // Add temporary dummy bits for format info just to set them as reserved.\n  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n  // since the masking operation must be performed only on the encoding region.\n  // These blocks will be replaced with correct values later in code.\n  setupFormatInfo(modules, errorCorrectionLevel, 0)\n\n  if (version >= 7) {\n    setupVersionInfo(modules, version)\n  }\n\n  // Add data codewords\n  setupData(modules, dataBits)\n\n  if (isNaN(maskPattern)) {\n    // Find best mask pattern\n    maskPattern = MaskPattern.getBestMask(modules,\n      setupFormatInfo.bind(null, modules, errorCorrectionLevel))\n  }\n\n  // Apply mask pattern\n  MaskPattern.applyMask(maskPattern, modules)\n\n  // Replace format info bits with correct values\n  setupFormatInfo(modules, errorCorrectionLevel, maskPattern)\n\n  return {\n    modules: modules,\n    version: version,\n    errorCorrectionLevel: errorCorrectionLevel,\n    maskPattern: maskPattern,\n    segments: segments\n  }\n}\n\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\nexports.create = function create (data, options) {\n  if (typeof data === 'undefined' || data === '') {\n    throw new Error('No input text')\n  }\n\n  let errorCorrectionLevel = ECLevel.M\n  let version\n  let mask\n\n  if (typeof options !== 'undefined') {\n    // Use higher error correction level as default\n    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M)\n    version = Version.from(options.version)\n    mask = MaskPattern.from(options.maskPattern)\n\n    if (options.toSJISFunc) {\n      Utils.setToSJISFunction(options.toSJISFunc)\n    }\n  }\n\n  return createSymbol(data, version, errorCorrectionLevel, mask)\n}\n","function hex2rgba (hex) {\n  if (typeof hex === 'number') {\n    hex = hex.toString()\n  }\n\n  if (typeof hex !== 'string') {\n    throw new Error('Color should be defined as hex string')\n  }\n\n  let hexCode = hex.slice().replace('#', '').split('')\n  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {\n    throw new Error('Invalid hex color: ' + hex)\n  }\n\n  // Convert from short to long form (fff -> ffffff)\n  if (hexCode.length === 3 || hexCode.length === 4) {\n    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {\n      return [c, c]\n    }))\n  }\n\n  // Add default alpha value\n  if (hexCode.length === 6) hexCode.push('F', 'F')\n\n  const hexValue = parseInt(hexCode.join(''), 16)\n\n  return {\n    r: (hexValue >> 24) & 255,\n    g: (hexValue >> 16) & 255,\n    b: (hexValue >> 8) & 255,\n    a: hexValue & 255,\n    hex: '#' + hexCode.slice(0, 6).join('')\n  }\n}\n\nexports.getOptions = function getOptions (options) {\n  if (!options) options = {}\n  if (!options.color) options.color = {}\n\n  const margin = typeof options.margin === 'undefined' ||\n    options.margin === null ||\n    options.margin < 0\n    ? 4\n    : options.margin\n\n  const width = options.width && options.width >= 21 ? options.width : undefined\n  const scale = options.scale || 4\n\n  return {\n    width: width,\n    scale: width ? 4 : scale,\n    margin: margin,\n    color: {\n      dark: hex2rgba(options.color.dark || '#000000ff'),\n      light: hex2rgba(options.color.light || '#ffffffff')\n    },\n    type: options.type,\n    rendererOpts: options.rendererOpts || {}\n  }\n}\n\nexports.getScale = function getScale (qrSize, opts) {\n  return opts.width && opts.width >= qrSize + opts.margin * 2\n    ? opts.width / (qrSize + opts.margin * 2)\n    : opts.scale\n}\n\nexports.getImageWidth = function getImageWidth (qrSize, opts) {\n  const scale = exports.getScale(qrSize, opts)\n  return Math.floor((qrSize + opts.margin * 2) * scale)\n}\n\nexports.qrToImageData = function qrToImageData (imgData, qr, opts) {\n  const size = qr.modules.size\n  const data = qr.modules.data\n  const scale = exports.getScale(size, opts)\n  const symbolSize = Math.floor((size + opts.margin * 2) * scale)\n  const scaledMargin = opts.margin * scale\n  const palette = [opts.color.light, opts.color.dark]\n\n  for (let i = 0; i < symbolSize; i++) {\n    for (let j = 0; j < symbolSize; j++) {\n      let posDst = (i * symbolSize + j) * 4\n      let pxColor = opts.color.light\n\n      if (i >= scaledMargin && j >= scaledMargin &&\n        i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {\n        const iSrc = Math.floor((i - scaledMargin) / scale)\n        const jSrc = Math.floor((j - scaledMargin) / scale)\n        pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0]\n      }\n\n      imgData[posDst++] = pxColor.r\n      imgData[posDst++] = pxColor.g\n      imgData[posDst++] = pxColor.b\n      imgData[posDst] = pxColor.a\n    }\n  }\n}\n","const Utils = require('./utils')\n\nfunction clearCanvas (ctx, canvas, size) {\n  ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n  if (!canvas.style) canvas.style = {}\n  canvas.height = size\n  canvas.width = size\n  canvas.style.height = size + 'px'\n  canvas.style.width = size + 'px'\n}\n\nfunction getCanvasElement () {\n  try {\n    return document.createElement('canvas')\n  } catch (e) {\n    throw new Error('You need to specify a canvas element')\n  }\n}\n\nexports.render = function render (qrData, canvas, options) {\n  let opts = options\n  let canvasEl = canvas\n\n  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n    opts = canvas\n    canvas = undefined\n  }\n\n  if (!canvas) {\n    canvasEl = getCanvasElement()\n  }\n\n  opts = Utils.getOptions(opts)\n  const size = Utils.getImageWidth(qrData.modules.size, opts)\n\n  const ctx = canvasEl.getContext('2d')\n  const image = ctx.createImageData(size, size)\n  Utils.qrToImageData(image.data, qrData, opts)\n\n  clearCanvas(ctx, canvasEl, size)\n  ctx.putImageData(image, 0, 0)\n\n  return canvasEl\n}\n\nexports.renderToDataURL = function renderToDataURL (qrData, canvas, options) {\n  let opts = options\n\n  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {\n    opts = canvas\n    canvas = undefined\n  }\n\n  if (!opts) opts = {}\n\n  const canvasEl = exports.render(qrData, canvas, opts)\n\n  const type = opts.type || 'image/png'\n  const rendererOpts = opts.rendererOpts || {}\n\n  return canvasEl.toDataURL(type, rendererOpts.quality)\n}\n","const Utils = require('./utils')\n\nfunction getColorAttrib (color, attrib) {\n  const alpha = color.a / 255\n  const str = attrib + '=\"' + color.hex + '\"'\n\n  return alpha < 1\n    ? str + ' ' + attrib + '-opacity=\"' + alpha.toFixed(2).slice(1) + '\"'\n    : str\n}\n\nfunction svgCmd (cmd, x, y) {\n  let str = cmd + x\n  if (typeof y !== 'undefined') str += ' ' + y\n\n  return str\n}\n\nfunction qrToPath (data, size, margin) {\n  let path = ''\n  let moveBy = 0\n  let newRow = false\n  let lineLength = 0\n\n  for (let i = 0; i < data.length; i++) {\n    const col = Math.floor(i % size)\n    const row = Math.floor(i / size)\n\n    if (!col && !newRow) newRow = true\n\n    if (data[i]) {\n      lineLength++\n\n      if (!(i > 0 && col > 0 && data[i - 1])) {\n        path += newRow\n          ? svgCmd('M', col + margin, 0.5 + row + margin)\n          : svgCmd('m', moveBy, 0)\n\n        moveBy = 0\n        newRow = false\n      }\n\n      if (!(col + 1 < size && data[i + 1])) {\n        path += svgCmd('h', lineLength)\n        lineLength = 0\n      }\n    } else {\n      moveBy++\n    }\n  }\n\n  return path\n}\n\nexports.render = function render (qrData, options, cb) {\n  const opts = Utils.getOptions(options)\n  const size = qrData.modules.size\n  const data = qrData.modules.data\n  const qrcodesize = size + opts.margin * 2\n\n  const bg = !opts.color.light.a\n    ? ''\n    : '<path ' + getColorAttrib(opts.color.light, 'fill') +\n      ' d=\"M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z\"/>'\n\n  const path =\n    '<path ' + getColorAttrib(opts.color.dark, 'stroke') +\n    ' d=\"' + qrToPath(data, size, opts.margin) + '\"/>'\n\n  const viewBox = 'viewBox=\"' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '\"'\n\n  const width = !opts.width ? '' : 'width=\"' + opts.width + '\" height=\"' + opts.width + '\" '\n\n  const svgTag = '<svg xmlns=\"http://www.w3.org/2000/svg\" ' + width + viewBox + ' shape-rendering=\"crispEdges\">' + bg + path + '</svg>\\n'\n\n  if (typeof cb === 'function') {\n    cb(null, svgTag)\n  }\n\n  return svgTag\n}\n","\nconst canPromise = require('./can-promise')\n\nconst QRCode = require('./core/qrcode')\nconst CanvasRenderer = require('./renderer/canvas')\nconst SvgRenderer = require('./renderer/svg-tag.js')\n\nfunction renderCanvas (renderFunc, canvas, text, opts, cb) {\n  const args = [].slice.call(arguments, 1)\n  const argsNum = args.length\n  const isLastArgCb = typeof args[argsNum - 1] === 'function'\n\n  if (!isLastArgCb && !canPromise()) {\n    throw new Error('Callback required as last argument')\n  }\n\n  if (isLastArgCb) {\n    if (argsNum < 2) {\n      throw new Error('Too few arguments provided')\n    }\n\n    if (argsNum === 2) {\n      cb = text\n      text = canvas\n      canvas = opts = undefined\n    } else if (argsNum === 3) {\n      if (canvas.getContext && typeof cb === 'undefined') {\n        cb = opts\n        opts = undefined\n      } else {\n        cb = opts\n        opts = text\n        text = canvas\n        canvas = undefined\n      }\n    }\n  } else {\n    if (argsNum < 1) {\n      throw new Error('Too few arguments provided')\n    }\n\n    if (argsNum === 1) {\n      text = canvas\n      canvas = opts = undefined\n    } else if (argsNum === 2 && !canvas.getContext) {\n      opts = text\n      text = canvas\n      canvas = undefined\n    }\n\n    return new Promise(function (resolve, reject) {\n      try {\n        const data = QRCode.create(text, opts)\n        resolve(renderFunc(data, canvas, opts))\n      } catch (e) {\n        reject(e)\n      }\n    })\n  }\n\n  try {\n    const data = QRCode.create(text, opts)\n    cb(null, renderFunc(data, canvas, opts))\n  } catch (e) {\n    cb(e)\n  }\n}\n\nexports.create = QRCode.create\nexports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render)\nexports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL)\n\n// only svg for now.\nexports.toString = renderCanvas.bind(null, function (data, _, opts) {\n  return SvgRenderer.render(data, opts)\n})\n"],"names":["f","a","b","c","d","e","g","h","k","w","m","C","n","x","l","exports","p","q","r","t","u","y","z","A","B","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","schedulerModule","require$$0","isNothing","subject","isObject","toArray","sequence","extend","target","source","index","length","key","sourceKeys","repeat","string","count","result","cycle","isNegativeZero","number","isNothing_1","isObject_1","toArray_1","repeat_1","isNegativeZero_1","extend_1","common","formatError","exception","compact","where","message","YAMLException$1","reason","mark","getLine","buffer","lineStart","lineEnd","position","maxLineLength","head","tail","maxHalfLength","padStart","max","makeSnippet","options","re","lineStarts","lineEnds","match","foundLineNo","i","line","lineNoLength","snippet","TYPE_CONSTRUCTOR_OPTIONS","YAML_NODE_KINDS","compileStyleAliases","map","style","alias","Type$1","tag","name","data","type","compileList","schema","currentType","newIndex","previousType","previousIndex","compileMap","collectType","Schema$1","definition","implicit","explicit","type$1","str","seq","failsafe","resolveYamlNull","constructYamlNull","isNull","object","_null","resolveYamlBoolean","constructYamlBoolean","isBoolean","bool","isHexCode","isOctCode","isDecCode","resolveYamlInteger","hasDigits","ch","constructYamlInteger","value","sign","isInteger","int","obj","YAML_FLOAT_PATTERN","resolveYamlFloat","constructYamlFloat","SCIENTIFIC_WITHOUT_DOT","representYamlFloat","res","isFloat","float","json","core","YAML_DATE_REGEXP","YAML_TIMESTAMP_REGEXP","resolveYamlTimestamp","constructYamlTimestamp","year","month","day","hour","minute","second","fraction","delta","tz_hour","tz_minute","date","representYamlTimestamp","timestamp","resolveYamlMerge","merge","BASE64_MAP","resolveYamlBinary","code","idx","bitlen","constructYamlBinary","tailbits","input","bits","representYamlBinary","isBinary","binary","_hasOwnProperty$3","_toString$2","resolveYamlOmap","objectKeys","pair","pairKey","pairHasKey","constructYamlOmap","omap","_toString$1","resolveYamlPairs","keys","constructYamlPairs","pairs","_hasOwnProperty$2","resolveYamlSet","constructYamlSet","set","_default","_hasOwnProperty$1","CONTEXT_FLOW_IN","CONTEXT_FLOW_OUT","CONTEXT_BLOCK_IN","CONTEXT_BLOCK_OUT","CHOMPING_CLIP","CHOMPING_STRIP","CHOMPING_KEEP","PATTERN_NON_PRINTABLE","PATTERN_NON_ASCII_LINE_BREAKS","PATTERN_FLOW_INDICATORS","PATTERN_TAG_HANDLE","PATTERN_TAG_URI","_class","is_EOL","is_WHITE_SPACE","is_WS_OR_EOL","is_FLOW_INDICATOR","fromHexCode","lc","escapedHexLen","fromDecimalCode","simpleEscapeSequence","charFromCodepoint","setProperty","simpleEscapeCheck","simpleEscapeMap","State$1","generateError","state","throwError","throwWarning","directiveHandlers","args","major","minor","handle","prefix","captureSegment","start","end","checkJson","_position","_length","_character","_result","mergeMappings","destination","overridableKeys","quantity","storeMappingPair","keyTag","keyNode","valueNode","startLine","startLineStart","startPos","readLineBreak","skipSeparationSpace","allowComments","checkIndent","lineBreaks","testDocumentSeparator","writeFoldedLines","readPlainScalar","nodeIndent","withinFlowCollection","preceding","following","captureStart","captureEnd","hasPendingContent","_line","_lineStart","_lineIndent","_kind","readSingleQuotedScalar","readDoubleQuotedScalar","hexLength","hexResult","tmp","readFlowCollection","readNext","_pos","_tag","_anchor","terminator","isPair","isExplicitPair","isMapping","composeNode","readBlockScalar","folding","chomping","didReadContent","detectedIndent","textIndent","emptyLines","atMoreIndented","readBlockSequence","detected","readBlockMapping","flowIndent","allowCompact","_keyLine","_keyLineStart","_keyPos","atExplicitKey","readTagProperty","isVerbatim","isNamed","tagHandle","tagName","readAnchorProperty","readAlias","parentIndent","nodeContext","allowToSeek","allowBlockStyles","allowBlockScalars","allowBlockCollections","indentStatus","atNewLine","hasContent","typeIndex","typeQuantity","typeList","blockIndent","readDocument","documentStart","directiveName","directiveArgs","hasDirectives","loadDocuments","nullpos","load$1","documents","load_1","loader","load","base64Js","byteLength","toByteArray","fromByteArray","lookup","revLookup","Arr","len","getLens","b64","validLen","placeHoldersLen","lens","_byteLength","arr","curByte","tripletToBase64","num","encodeChunk","uint8","output","extraBytes","parts","maxChunkLength","len2","ieee754","offset","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","s","rt","base64","ieee754$1","customInspectSymbol","Buffer","SlowBuffer","K_MAX_LENGTH","GlobalUint8Array","GlobalArrayBuffer","GlobalSharedArrayBuffer","typedArraySupport","proto","createBuffer","buf","arg","encodingOrOffset","allocUnsafe","from","fromString","fromArrayView","isInstance","fromArrayBuffer","valueOf","fromObject","assertSize","size","alloc","fill","encoding","checked","actual","fromArrayLike","array","arrayView","copy","byteOffset","numberIsNaN","list","pos","mustMatch","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","thisStart","thisEnd","thisCopy","targetCopy","bidirectionalIndexOf","val","dir","arrayIndexOf","indexSize","arrLength","valLength","read","foundIndex","found","j","hexWrite","remaining","strLen","parsed","utf8Write","blitBuffer","asciiWrite","asciiToBytes","base64Write","ucs2Write","utf16leToBytes","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","MAX_ARGUMENTS_LENGTH","codePoints","ret","out","hexSliceLookupTable","bytes","newBuf","checkOffset","ext","noAssert","mul","defineBigIntMethod","validateNumber","first","last","boundsError","lo","hi","checkInt","min","maxBytes","wrtBigUInt64LE","checkIntBI","wrtBigUInt64BE","limit","sub","checkIEEE754","writeFloat","littleEndian","writeDouble","targetStart","errors","sym","getMessage","Base","range","msg","received","addNumericalSeparator","checkBounds","INVALID_BASE64_RE","base64clean","units","leadSurrogate","byteArray","src","dst","alphabet","table","i16","fn","BufferBigIntNotDefined","types","typeName","native","getTypeName","getValueTypeName","getValue","captureStackTrace","tfJSON","tfErrorString","valueTypeName","valueJson","TfTypeError","tfPropertyErrorString","label","description","TfPropertyTypeError","property","tfCustomError","expected","tfSubError","NATIVE","ERRORS","require$$1","_Buffer","Hex","_LengthN","Length","_ArrayN","_BufferN","_HexN","_StringN","Range","_range","strict","INT53_MAX","Finite","Int8","Int16","Int32","Int53","UInt8","UInt16","UInt32","UInt53","extra","TYPES","compile","_arrayOf","typeforce","maybe","_maybe","propertyType","propertyKeyType","_map","propertyName","propertyValue","uncompiled","typePropertyName","_object","_anyOf","_allOf","_quacksLike","_tuple","values","_value","surrogate","EXTRA","require$$2","typeforce_1","crypto","isBytes","anumber","abytes","ahash","aexists","aoutput","u8","u32","clean","createView","rotr","rotl","byteSwap","byteSwap32","bytesToHex","hexToBytes","asyncLoop","bytesToUtf8","toBytes","kdfInputToBytes","concatBytes","checkOpts","createHasher","createOptHasher","createXOFer","randomBytes","crypto_1","lengths","instance","checkFinished","arrays","word","shift","hasHexBuiltin","hexes","_","hex","asciis","asciiToBase16","hl","al","ai","n1","n2","char","nextTick","iters","tick","cb","ts","diff","sum","pad","defaults","opts","Hash","hashCons","hashC","bytesLength","_md","setBigUint64","Chi","Maj","utils_ts_1","view","_32n","_u32_max","wh","wl","HashMD","blockLen","outputLen","padOffset","take","dataView","oview","outLen","to","finished","destroyed","legacy","_md_ts_1","SHA1_IV","SHA1_W","SHA1","p32","MD5_IV","MD5_W","MD5","Rho160","Id160","Pi160","idxLR","idxL","idxR","shifts160","shiftsL160","shiftsR160","Kl160","Kr160","ripemd_f","group","BUF_160","RIPEMD160","h0","h1","h2","h3","h4","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sl","sr","tl","tr","ripemd160","legacy_ts_1","sha1","_u64","add","fromBig","split","U32_MASK64","le","lst","Ah","Al","toBig","shrSH","_l","shrSL","rotrSH","rotrSL","rotrBH","rotrBL","rotr32H","_h","rotr32L","rotlSH","rotlSL","rotlBH","rotlBL","Bh","Bl","add3L","Cl","add3H","low","Ch","add4L","Dl","add4H","Dh","add5L","El","add5H","Eh","u64","sha2","SHA256_K","SHA256_W","SHA256","W15","W2","s0","s1","sigma1","T1","T2","SHA224","K512","SHA512_Kh","SHA512_Kl","SHA512_W_H","SHA512_W_L","SHA512","Fh","Fl","Gh","Gl","Hh","Hl","W15h","W15l","s0h","s0l","W2h","W2l","s1h","s1l","SUMl","SUMh","sigma1h","sigma1l","CHIh","CHIl","T1ll","T1h","T1l","sigma0h","sigma0l","MAJh","MAJl","All","SHA384","T224_IV","T256_IV","SHA512_224","SHA512_256","sha256","sha2_ts_1","base","ALPHABET","BASE_MAP","xc","BASE","LEADER","FACTOR","iFACTOR","encode","zeroes","pbegin","pend","b58","carry","it1","it2","decodeUnsafe","psz","b256","charCode","it3","it4","vch","decode","bs58","base58","checksumFn","payload","payloadU8","checksum","both","decodeRaw","newChecksum","bs58checkBase","sha256x2","bs58check","dist","ALPHABET_MAP","polymodStep","pre","prefixChk","chk","v","convert","inBits","outBits","maxV","toWords","fromWordsUnsafe","words","fromWords","getLibraryFromEncoding","ENCODING_CONST","LIMIT","__decode","lowered","uppered","wordChars","copyProps","module","SafeBuffer","MAX_SAFE_INTEGER","checkUInt53","encodingLength","varuintBitcoin","GlobalTypes","InputTypes","OutputTypes","globalXpub","typeFields_1","keyVal","extendedPubkey","isHard","splitPath","level","check","epk","mfp","canAddToArray","item","dupeSet","dupeString","unsignedTx","finalScriptSig","canAdd","currentData","newData","finalScriptWitness","nonWitnessUtxo","partialSig","pSig","isDerSigWithSighash","rLen","sLen","porCommitment","sighashType","tapKeySig","tapLeafScript","leafVersion","script","tScript","verBuf","tapMerkleRoot","tapScriptSig","pubkey","leafHash","tSig","varint","_number","tools","varuint","reverseBuffer","keyValsToBuffer","keyVals","buffers","keyValToBuffer","keyLen","valLen","keyVarIntLen","valVarIntLen","verifuint","readUInt64LE","writeUInt64LE","witnessUtxo","tools_1","_offset","scriptLen","varintLen","tapTree","depth","tree","bufs","tapLeaf","bip32Derivation","isValidDERKey","makeConverter","TYPE_BYTE","isValidPubkey","checkPubkey","makeChecker","pubkeyTypes","redeemScript","tapBip32Derivation","isValidBIP340Key","parent","nHashes","nHashesLen","leafHashes","nHashesBuf","tapInternalKey","witnessScript","converter","require$$3","require$$4","require$$5","require$$6","require$$7","require$$8","require$$9","require$$10","require$$11","require$$12","require$$13","require$$14","require$$15","require$$16","require$$17","require$$18","require$$19","require$$20","globals","inputs","outputs","fromBuffer","psbtFromBuffer","txGetter","varSlice","readUInt32BE","readUInt8","getKeyValue","checkEndOfKeyValPairs","isEnd","globalMapKeyVals","globalKeyIndex","hexKey","unsignedTxMaps","inputCount","outputCount","inputKeyVals","outputKeyVals","inputKeyIndex","outputKeyIndex","psbtFromKeyVals","checkKeyBuffer","keyBuf","keyNum","globalMap","txCount","toBuffer","psbtToBuffer","globalKeyVals","psbtToKeyVals","globalBuffer","keyValsOrEmptyToBuffer","inputBuffers","outputBuffers","header","sortKeyVals","keyValsFromMap","keyValMap","converterFactory","keyHexSet","encodedKeyVals","kv","otherKeyVals","o","__export","combiner","parser_1","combine","psbts","self","selfKeyVals","others","selfTx","getTx","selfGlobalSet","getKeySet","selfInputSets","selfOutputSets","other","otherTx","keyPusher","inputSet","outputSet","selfSet","newKv","psbt","checkForInput","inputIndex","checkForOutput","outputIndex","checkHasKey","checkKeyVal","enumLength","getEnumLength","myenum","inputCheckUncleanFinalized","needScriptSig","needWitnessScript","scriptSigOK","witnessScriptOK","hasOneFinal","throwForUpdateMaker","updateMaker","updateData","mainData","isArray","dupeCheckSet","addInputAttributes","addOutputAttributes","defaultVersionSetter","version","txBuf","defaultLocktimeSetter","locktime","combiner_1","utils_1","Psbt","tx","txFromBuffer","results","inputData","addKeyVals","outputData","those","HMAC","hash","_key","oHash","iHash","hmac","SHA256_IV","SHA512_IV","ripemd160n","u64.split","u64.rotrSH","u64.shrSH","u64.rotrSL","u64.shrSL","u64.rotrBH","u64.rotrBL","u64.add4L","u64.add4H","u64.add5L","u64.add5H","u64.add","u64.add3L","u64.add3H","sha512","sha256n","sha512n","hash160","hmacSHA512","HEX_STRINGS","HEX_CODEPOINTS","ENCODER","fromUtf8","concat","totalLength","fromHex","hexString","hexBytes","resultBytes","compare","v1","v2","minLength","writeUInt8","writeUInt32","readUInt32","tools.fromHex","testEcc","ecc","assert","tools.compare","xOnlyRes","isArrayOf","isString","afn","astr","aArr","astrArr","anumArr","chain","id","wrap","letters","lettersA","indexes","digits","letter","join","separator","convertRadix","dlen","done","digit","fromCarry","digitBase","div","rounded","radix","_256","oldChecksum","genBase58","abc","createBase58check","base58check","store","getGlobalConfig","config2","store2","getGlobalMessage","lang","store3","getSchemaMessage","store4","getSpecificMessage","reference","_stringify","_addIssue","context","dataset","issue","isSchema","ValiError","issues","integer","requirement","maxValue","minValue","regex","class_","entries","value2","valueDataset","pathItem","parse","pipe","pipe2","Uint32Schema","v.pipe","v.number","v.integer","v.minValue","v.maxValue","Uint31Schema","Uint8Schema","Buffer256Bit","v.instance","v.length","Buffer33Bytes","NetworkSchema","v.object","Bip32PathSchema","v.string","v.regex","basex","bs58Check","encodeRaw","privateKey","compressed","wif","_bs58check","BIP32Factory","BITCOIN","HIGHEST_BIT","toXOnly","pubKey","Bip32Signer","__D","__Q","lowR","sig","extraData","counter","tools.writeUInt32","signature","BIP32","chainCode","network","__DEPTH","__INDEX","__PARENT_FINGERPRINT","v.parse","crypto.hash160","fromPublicKeyLocal","tools.writeUInt8","wif.encode","isHardened","crypto.hmacSHA512","IL","IR","hd","Ki","tools.readUInt32","ki","fromPrivateKeyLocal","path","prevHd","indexStr","xOnlyPubKey","tweakedPublicKey","parityByte","tweakedPublicKeyCompresed","tools.concat","hasOddY","tweakedPrivateKey","fromBase58","inString","parentFingerprint","X","fromPrivateKey","fromPublicKey","publicKey","fromSeed","seed","tools.fromUtf8","pbkdf2_1","pbkdf2","pbkdf2Async","hmac_ts_1","pbkdf2Init","_password","_salt","_opts","dkLen","asyncTick","password","salt","DK","PRF","PRFSalt","pbkdf2Output","prfW","ti","Ti","ui","_wordlists","wordlists","sha256_1","sha512_1","_wordlists_1","DEFAULT_WORDLIST","INVALID_MNEMONIC","INVALID_ENTROPY","INVALID_CHECKSUM","WORDLIST_REQUIRED","normalize","lpad","padString","binaryToByte","bin","bytesToBinary","deriveChecksumBits","entropyBuffer","CS","mnemonicToSeedSync","mnemonic","mnemonicBuffer","saltBuffer","mnemonicToSeed","mnemonicToEntropy","wordlist","dividerIndex","entropyBits","checksumBits","entropyBytes","entropy","entropyToMnemonic","generateMnemonic","strength","rng","validateMnemonic","setDefaultWordlist","language","getDefaultWordlist","_wordlists_2","abool","_abool2","_abytes2","numberToHexUnpadded","hexToNumber","bytesToNumberBE","bytesToNumberLE","numberToBytesBE","numberToBytesLE","numberToVarBytesBE","ensureBytes","equalBytes","copyBytes","inRange","aInRange","bitLen","bitGet","bitSet","createHmacDrbg","validateObject","isHash","_validateObject","memoized","utils_js_1","utils_js_2","_0n","_1n","title","needsLen","ofLen","got","expectedLength","ascii","isPosBig","bitMask","hashLen","qByteLen","hmacFn","u8n","u8of","byte","reset","reseed","gen","pred","validatorFns","validators","optValidators","checkField","fieldName","isOptional","checkVal","fields","optFields","expectedType","isOpt","current","notImplemented","computed","modular","mod","pow","pow2","invert","tonelliShanks","FpSqrt","validateField","FpPow","FpInvertBatch","FpDiv","FpLegendre","FpIsSquare","nLength","Field","FpSqrtOdd","FpSqrtEven","hashToPrivateScalar","getFieldBytesLength","getMinHashLength","mapHashToField","_2n","_3n","_4n","_5n","_7n","_8n","_9n","_16n","power","modulo","assertIsSquare","Fp","root","sqrt3mod4","p1div4","sqrt5mod8","p5div8","nv","sqrt9mod16","Fp_","tn","c1","c2","c3","c4","tv1","tv2","tv3","tv4","e1","e2","e3","_Fp","cc","Q1div2","t_tmp","exponent","isNegativeLE","FIELD_FIELDS","field","initial","nums","passZero","inverted","multipliedAcc","acc","invertedAcc","lhs","rhs","p1mod2","powered","yes","zero","no","nBitLength","_nBitLength","nByteLength","ORDER","bitLenOrOpts","_nbitLength","_sqrt","modFromBytes","allowedLengths","BITS","BYTES","sqrtP","skipValidation","padded","scalar","elm","groupOrder","minLen","fieldOrder","bitLength","fieldLen","reduced","curve","negateCt","normalizeZ","mulEndoUnsafe","pippenger","precomputeMSMUnsafe","validateBasic","_createCurveFields","modular_ts_1","condition","neg","points","invertedZs","validateW","W","calcWOpts","scalarBits","windows","windowSize","maxNumber","mask","shiftBy","calcOffsets","window","wOpts","wbits","nextN","offsetStart","isZero","isNeg","isNegF","validateMSMPoints","validateMSMScalars","scalars","pointPrecomputes","pointWindowSizes","getW","assert0","wNAF","Point","point","precomputes","wo","offsetF","transform","comp","prev","k1","k2","p1","p2","fieldN","plength","slength","MASK","buckets","lastBits","resI","sumI","tableSize","chunks","tables","curr","createField","order","CURVE","curveOpts","FpFnLE","Fn","params","_splitEndoScalar","_normFnElement","weierstrassN","SWUFpSqrtRatio","mapToCurveSimpleSWU","ecdh","ecdsa","weierstrassPoints","_legacyHelperEquat","weierstrass","hmac_js_1","curve_ts_1","divNearest","den","basis","a1","b1","a2","b2","k1neg","k2neg","MAX_NUM","validateSigFormat","format","validateSigOpts","def","optsn","optName","DERErr","dataLen","lenLen","isLong","lengthBytes","tlv","seqBytes","seqLeftBytes","rBytes","rLeftBytes","sBytes","sLeftBytes","rs","ss","extraOpts","validated","cofactor","CURVE_ORDER","endo","getWLengths","assertCompressionIsSupported","pointToBytes","_c","isCompressed","bx","hasEvenY","pprefix","pointFromBytes","uncomp","y2","weierstrassEquation","sqrtError","err","isYOdd","isValidXY","encodePoint","decodePoint","x2","x3","left","right","_4a3","_27b2","acoord","banZero","aprjpoint","splitEndoScalarN","toAffineMemo","iz","Y","Z","is0","zz","assertValidMemo","finishEndo","endoBeta","k1p","k2p","isLazy","wnaf","X1","Y1","Z1","X2","Y2","Z2","U1","U2","b3","X3","Y3","Z3","t0","t1","t2","t3","t4","t5","fake","k1f","k2f","sc","invertedZ","isTorsionFree","clearCofactor","_2n_pow_c1_1","_2n_pow_c1","c5","c6","c7","sqrtRatio","tv5","isQR","tvv5","y1","tv6","isValid","tv4_inv","ecdhOpts","randomBytes_","isValidSecretKey","secretKey","isValidPublicKey","publicKeyUncompressed","randomSecretKey","getPublicKey","keygen","isProbPub","getSharedSecret","secretKeyA","publicKeyB","ecdsaOpts","msgs","fnBits","utils","defaultSigOpts","defaultSigOpts_format","isBiggerThanHalfOrder","HALF","validateRS","validateSigLength","sizer","Signature","recovery","recid","messageHash","FIELD_ORDER","rec","radj","ir","bits2int_modN","u1","u2","bits2int","ORDER_MASK","int2octets","validateMsgAndHash","prehash","prepSig","lowS","extraEntropy","h1int","seedArgs","k2sig","kBytes","ik","normS","tryParsingSig","sg","isHex","isObj","derError","verify","is","recoverPublicKey","_weierstrass_legacy_opts_to_new","_weierstrass_new_output_to_legacy","_ecdsa_legacy_opts_to_new","isWithinCurveOrder","_ecdsa_new_output_to_legacy","_ecdsa","signs","_shortw_utils","getHash","createCurve","weierstrass_ts_1","curveDef","defHash","create","expand_message_xmd","expand_message_xof","hash_to_field","isogenyMap","os2ip","i2osp","anum","strxor","normDST","DST","lenInBytes","b_in_bytes","r_in_bytes","ell","DST_prime","Z_pad","l_i_b_str","b_0","expand","log2p","len_in_bytes","prb","elm_offset","tv","coeff","xn","xd","yn","yd","xd_inv","yd_inv","mapToCurve","clear","u0","optsDst","sha2_js_1","_shortw_utils_ts_1","hash_to_curve_ts_1","secp256k1_CURVE","secp256k1_ENDO","sqrtMod","_6n","_11n","_22n","_23n","_44n","_88n","b6","b9","b11","b22","b44","b88","b176","b220","b223","Fpk1","TAGGED_HASH_PREFIXES","taggedHash","messages","tagP","tagH","Pointk1","hasEven","schnorrGetExtPubKey","priv","d_","lift_x","xx","challenge","schnorrGetPublicKey","schnorrSign","auxRand","px","rand","rx","schnorrVerify","pub","isoMap","mapSWU","canPromise","toSJISFunction","CODEWORDS_COUNT","kanji","defaultValue","BitBuffer","bufIndex","bit","bitBuffer","BitMatrix","row","col","reserved","bitMatrix","getSymbolSize","posCount","intervals","positions","coords","posLength","FINDER_PATTERN_SIZE","finderPattern","PenaltyScores","sameCountCol","sameCountRow","lastCol","lastRow","bitsCol","bitsRow","darkCount","modulesCount","getMaskAt","maskPattern","pattern","setupFormatFunc","numPatterns","bestPattern","lowerPenalty","penalty","ECLevel","EC_BLOCKS_TABLE","EC_CODEWORDS_TABLE","errorCorrectionCode","errorCorrectionLevel","EXP_TABLE","LOG_TABLE","galoisField","GF","divident","divisor","degree","poly","Polynomial","ReedSolomonEncoder","paddedData","remainder","buff","reedSolomonEncoder","versionCheck","numeric","alphanumeric","TEST_KANJI","TEST_NUMERIC","TEST_ALPHANUMERIC","VersionCheck","Regex","mode","dataStr","Utils","ECCode","Mode","G18","G18_BCH","getBestVersionForDataLength","currentVersion","getReservedBitsCount","getTotalBitsFromDataArray","segments","totalBits","reservedBits","getBestVersionForMixedData","totalCodewords","ecTotalCodewords","dataTotalCodewordsBits","usableBits","seg","ecl","G15","G15_MASK","G15_BCH","formatInfo","NumericData","remainingNum","numericData","ALPHA_NUM_CHARS","AlphanumericData","alphanumericData","ByteData","byteData","KanjiData","kanjiData","dijkstra","graph","predecessors","costs","open","closest","cost_of_s_to_u","adjacent_nodes","cost_of_e","cost_of_s_to_u_plus_cost_of_e","cost_of_s_to_v","first_visit","nodes","cost","getStringByteLength","getSegments","getSegmentsFromString","numSegs","alphaNumSegs","byteSegs","kanjiSegs","s2","getSegmentBitsLength","mergeSegments","segs","prevSeg","buildNodes","buildGraph","prevNodeIds","nodeGroup","currentNodeIds","node","prevNodeId","buildSingleSegment","modesHint","bestMode","optimizedSegs","AlignmentPattern","FinderPattern","MaskPattern","Version","FormatInfo","Segments","setupFinderPattern","matrix","setupTimingPattern","setupAlignmentPattern","setupVersionInfo","setupFormatInfo","setupData","inc","bitIndex","byteIndex","dark","createData","remainingByte","createCodewords","dataTotalCodewords","ecTotalBlocks","blocksInGroup2","blocksInGroup1","totalCodewordsInGroup1","dataCodewordsInGroup1","dataCodewordsInGroup2","ecCount","dcData","ecData","maxDataSize","dataSize","createSymbol","estimatedVersion","rawSegments","bestVersion","dataBits","moduleCount","modules","qrcode","hex2rgba","hexCode","hexValue","margin","width","scale","qrSize","imgData","qr","symbolSize","scaledMargin","palette","posDst","pxColor","iSrc","jSrc","clearCanvas","ctx","canvas","getCanvasElement","qrData","canvasEl","image","rendererOpts","getColorAttrib","color","attrib","alpha","svgCmd","cmd","qrToPath","moveBy","newRow","lineLength","svgTag","qrcodesize","bg","viewBox","QRCode","CanvasRenderer","SvgRenderer","renderCanvas","renderFunc","text","argsNum","isLastArgCb","resolve","reject","browser"],"mappings":";;;;;;;;sDASa,SAASA,EAAEC,EAAEC,EAAE,CAAC,IAAIC,EAAEF,EAAE,OAAOA,EAAE,KAAKC,CAAC,EAAED,EAAE,KAAK,EAAEE,GAAG,CAAC,IAAIC,EAAED,EAAE,IAAI,EAAEE,EAAEJ,EAAEG,CAAC,EAAE,GAAG,EAAEE,EAAED,EAAEH,CAAC,EAAED,EAAEG,CAAC,EAAEF,EAAED,EAAEE,CAAC,EAAEE,EAAEF,EAAEC,MAAO,OAAMH,CAAC,CAAC,CAAC,SAASM,EAAEN,EAAE,CAAC,OAAWA,EAAE,SAAN,EAAa,KAAKA,EAAE,CAAC,CAAC,CAAC,SAASO,EAAEP,EAAE,CAAC,GAAOA,EAAE,SAAN,EAAa,OAAO,KAAK,IAAIC,EAAED,EAAE,CAAC,EAAEE,EAAEF,EAAE,MAAM,GAAGE,IAAID,EAAE,CAACD,EAAE,CAAC,EAAEE,EAAEF,EAAE,QAAQG,EAAE,EAAEC,EAAEJ,EAAE,OAAOQ,EAAEJ,IAAI,EAAED,EAAEK,GAAG,CAAC,IAAIC,EAAE,GAAGN,EAAE,GAAG,EAAEO,GAAEV,EAAES,CAAC,EAAEE,GAAEF,EAAE,EAAEG,GAAEZ,EAAEW,EAAC,EAAE,GAAG,EAAEN,EAAEK,GAAER,CAAC,EAAES,GAAEP,GAAG,EAAEC,EAAEO,GAAEF,EAAC,GAAGV,EAAEG,CAAC,EAAES,GAAEZ,EAAEW,EAAC,EAAET,EAAEC,EAAEQ,KAAIX,EAAEG,CAAC,EAAEO,GAAEV,EAAES,CAAC,EAAEP,EAAEC,EAAEM,WAAWE,GAAEP,GAAG,EAAEC,EAAEO,GAAEV,CAAC,EAAEF,EAAEG,CAAC,EAAES,GAAEZ,EAAEW,EAAC,EAAET,EAAEC,EAAEQ,OAAO,OAAMX,CAAC,CAAC,CAAC,OAAOC,CAAC,CAC3c,SAASI,EAAEL,EAAEC,EAAE,CAAC,IAAIC,EAAEF,EAAE,UAAUC,EAAE,UAAU,OAAWC,IAAJ,EAAMA,EAAEF,EAAE,GAAGC,EAAE,EAAE,CAAC,GAAc,OAAO,aAAlB,UAA4C,OAAO,YAAY,KAAhC,WAAoC,CAAC,IAAIY,EAAE,YAAYC,EAAA,aAAqB,UAAU,CAAC,OAAOD,EAAE,IAAG,CAAE,CAAC,KAAK,CAAC,IAAIE,EAAE,KAAKC,EAAED,EAAE,IAAG,EAAGD,EAAA,aAAqB,UAAU,CAAC,OAAOC,EAAE,IAAG,EAAGC,CAAC,CAAC,CAAC,IAAIC,EAAE,CAAA,EAAGC,EAAE,CAAA,EAAGC,EAAE,EAAE,EAAE,KAAKC,EAAE,EAAEC,EAAE,GAAGC,EAAE,GAAGC,EAAE,GAAGC,EAAe,OAAO,YAApB,WAA+B,WAAW,KAAKC,EAAe,OAAO,cAApB,WAAiC,aAAa,KAAKC,EAAgB,OAAO,aAArB,IAAkC,aAAa,KACjd,OAAO,UAArB,KAAyC,UAAU,aAAnB,QAAwC,UAAU,WAAW,iBAA9B,QAA8C,UAAU,WAAW,eAAe,KAAK,UAAU,UAAU,EAAE,SAASC,EAAE3B,EAAE,CAAC,QAAQC,EAAEK,EAAEY,CAAC,EAASjB,IAAP,MAAU,CAAC,GAAUA,EAAE,WAAT,KAAkBM,EAAEW,CAAC,UAAUjB,EAAE,WAAWD,EAAEO,EAAEW,CAAC,EAAEjB,EAAE,UAAUA,EAAE,eAAeF,EAAEkB,EAAEhB,CAAC,MAAO,OAAMA,EAAEK,EAAEY,CAAC,CAAC,CAAC,CAAC,SAASU,EAAE5B,EAAE,CAAW,GAAVuB,EAAE,GAAGI,EAAE3B,CAAC,EAAK,CAACsB,EAAE,GAAUhB,EAAEW,CAAC,IAAV,KAAYK,EAAE,GAAGO,EAAEC,CAAC,MAAM,CAAC,IAAI7B,EAAEK,EAAEY,CAAC,EAASjB,IAAP,MAAU8B,EAAEH,EAAE3B,EAAE,UAAUD,CAAC,CAAC,CAAC,CACra,SAAS8B,EAAE9B,EAAEC,EAAE,CAACqB,EAAE,GAAGC,IAAIA,EAAE,GAAGE,EAAEO,CAAC,EAAEA,EAAE,IAAIX,EAAE,GAAG,IAAInB,EAAEkB,EAAE,GAAG,CAAM,IAALO,EAAE1B,CAAC,EAAM,EAAEK,EAAEW,CAAC,EAAS,IAAP,OAAW,EAAE,EAAE,eAAehB,IAAID,GAAG,CAACiC,EAAC,IAAK,CAAC,IAAI9B,EAAE,EAAE,SAAS,GAAgB,OAAOA,GAApB,WAAsB,CAAC,EAAE,SAAS,KAAKiB,EAAE,EAAE,cAAc,IAAIhB,EAAED,EAAE,EAAE,gBAAgBF,CAAC,EAAEA,EAAEa,EAAQ,aAAY,EAAgB,OAAOV,GAApB,WAAsB,EAAE,SAASA,EAAE,IAAIE,EAAEW,CAAC,GAAGV,EAAEU,CAAC,EAAEU,EAAE1B,CAAC,CAAC,MAAMM,EAAEU,CAAC,EAAE,EAAEX,EAAEW,CAAC,CAAC,CAAC,GAAU,IAAP,KAAS,IAAIT,EAAE,OAAO,CAAC,IAAIC,EAAEH,EAAEY,CAAC,EAAST,IAAP,MAAUsB,EAAEH,EAAEnB,EAAE,UAAUR,CAAC,EAAEO,EAAE,EAAE,CAAC,OAAOA,CAAC,QAAC,CAAQ,EAAE,KAAKY,EAAElB,EAAEmB,EAAE,EAAE,CAAC,CAAC,IAAIa,EAAE,GAAGC,EAAE,KAAKH,EAAE,GAAGI,EAAE,EAAEC,EAAE,GACtc,SAASJ,GAAG,CAAC,MAAOnB,EAAAA,EAAQ,aAAY,EAAGuB,EAAED,EAAO,CAAC,SAASE,GAAG,CAAC,GAAUH,IAAP,KAAS,CAAC,IAAInC,EAAEc,EAAQ,eAAeuB,EAAErC,EAAE,IAAIC,EAAE,GAAG,GAAG,CAACA,EAAEkC,EAAE,GAAGnC,CAAC,CAAC,QAAC,CAAQC,EAAEsC,KAAKL,EAAE,GAAGC,EAAE,KAAK,CAAC,MAAMD,EAAE,EAAE,CAAC,IAAIK,EAAE,GAAgB,OAAOb,GAApB,WAAsBa,EAAE,UAAU,CAACb,EAAEY,CAAC,CAAC,UAAwB,OAAO,eAArB,IAAoC,CAAC,IAAIE,EAAE,IAAI,eAAeC,EAAED,EAAE,MAAMA,EAAE,MAAM,UAAUF,EAAEC,EAAE,UAAU,CAACE,EAAE,YAAY,IAAI,CAAC,CAAC,MAAMF,EAAE,UAAU,CAACf,EAAEc,EAAE,CAAC,CAAC,EAAE,SAAST,EAAE7B,EAAE,CAACmC,EAAEnC,EAAEkC,IAAIA,EAAE,GAAGK,EAAC,EAAG,CAAC,SAASR,EAAE/B,EAAEC,EAAE,CAAC+B,EAAER,EAAE,UAAU,CAACxB,EAAEc,EAAQ,cAAc,CAAC,EAAEb,CAAC,CAAC,CAC5da,EAAA,sBAA8B,EAAEA,EAAA,2BAAmC,EAAEA,EAAA,qBAA6B,EAAEA,EAAA,wBAAgC,EAAEA,EAAA,mBAA2B,KAAKA,EAAA,8BAAsC,EAAEA,EAAA,wBAAgC,SAASd,EAAE,CAACA,EAAE,SAAS,IAAI,EAAEc,6BAAmC,UAAU,CAACQ,GAAGD,IAAIC,EAAE,GAAGO,EAAEC,CAAC,EAAE,EAC1UhB,EAAA,wBAAgC,SAASd,EAAE,CAAC,EAAEA,GAAG,IAAIA,EAAE,QAAQ,MAAM,iHAAiH,EAAEoC,EAAE,EAAEpC,EAAE,KAAK,MAAM,IAAIA,CAAC,EAAE,CAAC,EAAEc,EAAA,iCAAyC,UAAU,CAAC,OAAOM,CAAC,EAAEN,EAAA,8BAAsC,UAAU,CAAC,OAAOR,EAAEW,CAAC,CAAC,EAAEH,EAAA,cAAsB,SAASd,EAAE,CAAC,OAAOoB,EAAC,CAAE,IAAK,GAAE,IAAK,GAAE,IAAK,GAAE,IAAInB,EAAE,EAAE,MAAM,QAAQA,EAAEmB,CAAC,CAAC,IAAIlB,EAAEkB,EAAEA,EAAEnB,EAAE,GAAG,CAAC,OAAOD,EAAC,CAAE,QAAC,CAAQoB,EAAElB,CAAC,CAAC,EAAEY,EAAA,wBAAgC,UAAU,CAAA,EAC7fA,EAAA,sBAA8B,UAAU,CAAA,EAAGA,EAAA,yBAAiC,SAASd,EAAEC,EAAE,CAAC,OAAOD,EAAC,CAAE,IAAK,GAAE,IAAK,GAAE,IAAK,GAAE,IAAK,GAAE,IAAK,GAAE,MAAM,QAAQA,EAAE,CAAC,CAAC,IAAIE,EAAEkB,EAAEA,EAAEpB,EAAE,GAAG,CAAC,OAAOC,EAAC,CAAE,QAAC,CAAQmB,EAAElB,CAAC,CAAC,EAChMY,EAAA,0BAAkC,SAASd,EAAEC,EAAEC,EAAE,CAAC,IAAIC,EAAEW,EAAQ,eAA8F,OAApE,OAAOZ,GAAlB,UAA4BA,IAAP,MAAUA,EAAEA,EAAE,MAAMA,EAAa,OAAOA,GAAlB,UAAqB,EAAEA,EAAEC,EAAED,EAAEC,GAAGD,EAAEC,EAASH,EAAC,CAAE,IAAK,GAAE,IAAII,EAAE,GAAG,MAAM,IAAK,GAAEA,EAAE,IAAI,MAAM,IAAK,GAAEA,EAAE,WAAW,MAAM,IAAK,GAAEA,EAAE,IAAI,MAAM,QAAQA,EAAE,GAAG,CAAC,OAAAA,EAAEF,EAAEE,EAAEJ,EAAE,CAAC,GAAGmB,IAAI,SAASlB,EAAE,cAAcD,EAAE,UAAUE,EAAE,eAAeE,EAAE,UAAU,EAAE,EAAEF,EAAEC,GAAGH,EAAE,UAAUE,EAAEH,EAAEmB,EAAElB,CAAC,EAASM,EAAEW,CAAC,IAAV,MAAajB,IAAIM,EAAEY,CAAC,IAAIK,GAAGE,EAAEO,CAAC,EAAEA,EAAE,IAAIT,EAAE,GAAGQ,EAAEH,EAAE1B,EAAEC,CAAC,KAAKH,EAAE,UAAUI,EAAEL,EAAEkB,EAAEjB,CAAC,EAAEsB,GAAGD,IAAIC,EAAE,GAAGO,EAAEC,CAAC,IAAW9B,CAAC,EACnec,EAAA,qBAA6BmB,EAAEnB,EAAA,sBAA8B,SAASd,EAAE,CAAC,IAAIC,EAAEmB,EAAE,OAAO,UAAU,CAAC,IAAIlB,EAAEkB,EAAEA,EAAEnB,EAAE,GAAG,CAAC,OAAOD,EAAE,MAAM,KAAK,SAAS,CAAC,QAAC,CAAQoB,EAAElB,CAAC,CAAC,CAAC,kDCf7JwC,GAAA,QAAiBC,GAAA,cCFnB,mEACA,SAASC,GAAUC,EAAS,CAC1B,OAAQ,OAAOA,EAAY,KAAiBA,IAAY,IAC1D,CAGA,SAASC,GAASD,EAAS,CACzB,OAAQ,OAAOA,GAAY,UAAcA,IAAY,IACvD,CAGA,SAASE,GAAQC,EAAU,CACzB,OAAI,MAAM,QAAQA,CAAQ,EAAUA,EAC3BJ,GAAUI,CAAQ,EAAU,CAAA,EAE9B,CAAEA,CAAQ,CACnB,CAGA,SAASC,GAAOC,EAAQC,EAAQ,CAC9B,IAAIC,EAAOC,EAAQC,EAAKC,EAExB,GAAIJ,EAGF,IAFAI,EAAa,OAAO,KAAKJ,CAAM,EAE1BC,EAAQ,EAAGC,EAASE,EAAW,OAAQH,EAAQC,EAAQD,GAAS,EACnEE,EAAMC,EAAWH,CAAK,EACtBF,EAAOI,CAAG,EAAIH,EAAOG,CAAG,EAI5B,OAAOJ,CACT,CAGA,SAASM,GAAOC,EAAQC,EAAO,CAC7B,IAAIC,EAAS,GAAIC,EAEjB,IAAKA,EAAQ,EAAGA,EAAQF,EAAOE,GAAS,EACtCD,GAAUF,EAGZ,OAAOE,CACT,CAGA,SAASE,GAAeC,EAAQ,CAC9B,OAAQA,IAAW,GAAO,OAAO,oBAAsB,EAAIA,CAC7D,CAGA,IAAIC,GAAmBnB,GACnBoB,GAAmBlB,GACnBmB,GAAmBlB,GACnBmB,GAAmBV,GACnBW,GAAmBN,GACnBO,GAAmBnB,GAEnBoB,GAAS,CACZ,UAAWN,GACX,SAAUC,GACV,QAASC,GACT,OAAQC,GACR,eAAgBC,GAChB,OAAQC,EACT,EAKA,SAASE,GAAYC,EAAWC,EAAS,CACvC,IAAIC,EAAQ,GAAIC,EAAUH,EAAU,QAAU,mBAE9C,OAAKA,EAAU,MAEXA,EAAU,KAAK,OACjBE,GAAS,OAASF,EAAU,KAAK,KAAO,MAG1CE,GAAS,KAAOF,EAAU,KAAK,KAAO,GAAK,KAAOA,EAAU,KAAK,OAAS,GAAK,IAE3E,CAACC,GAAWD,EAAU,KAAK,UAC7BE,GAAS;AAAA;AAAA,EAASF,EAAU,KAAK,SAG5BG,EAAU,IAAMD,GAZKC,CAa9B,CAGA,SAASC,GAAgBC,EAAQC,EAAM,CAErC,MAAM,KAAK,IAAI,EAEf,KAAK,KAAO,gBACZ,KAAK,OAASD,EACd,KAAK,KAAOC,EACZ,KAAK,QAAUP,GAAY,KAAM,EAAK,EAGlC,MAAM,kBAER,MAAM,kBAAkB,KAAM,KAAK,WAAW,EAG9C,KAAK,MAAS,IAAI,MAAK,EAAI,OAAS,EAExC,CAIAK,GAAgB,UAAY,OAAO,OAAO,MAAM,SAAS,EACzDA,GAAgB,UAAU,YAAcA,GAGxCA,GAAgB,UAAU,SAAW,SAAkBH,EAAS,CAC9D,OAAO,KAAK,KAAO,KAAOF,GAAY,KAAME,CAAO,CACrD,EAGA,IAAID,GAAYI,GAGhB,SAASG,GAAQC,EAAQC,EAAWC,EAASC,EAAUC,EAAe,CACpE,IAAIC,EAAO,GACPC,EAAO,GACPC,EAAgB,KAAK,MAAMH,EAAgB,CAAC,EAAI,EAEpD,OAAID,EAAWF,EAAYM,IACzBF,EAAO,QACPJ,EAAYE,EAAWI,EAAgBF,EAAK,QAG1CH,EAAUC,EAAWI,IACvBD,EAAO,OACPJ,EAAUC,EAAWI,EAAgBD,EAAK,QAGrC,CACL,IAAKD,EAAOL,EAAO,MAAMC,EAAWC,CAAO,EAAE,QAAQ,MAAO,GAAG,EAAII,EACnE,IAAKH,EAAWF,EAAYI,EAAK,MACrC,CACA,CAGA,SAASG,GAAS9B,EAAQ+B,EAAK,CAC7B,OAAOnB,GAAO,OAAO,IAAKmB,EAAM/B,EAAO,MAAM,EAAIA,CACnD,CAGA,SAASgC,GAAYZ,EAAMa,EAAS,CAGlC,GAFAA,EAAU,OAAO,OAAOA,GAAW,IAAI,EAEnC,CAACb,EAAK,OAAQ,OAAO,KAEpBa,EAAQ,YAAWA,EAAQ,UAAY,IACxC,OAAOA,EAAQ,QAAgB,WAAUA,EAAQ,OAAc,GAC/D,OAAOA,EAAQ,aAAgB,WAAUA,EAAQ,YAAc,GAC/D,OAAOA,EAAQ,YAAgB,WAAUA,EAAQ,WAAc,GAQnE,QANIC,EAAK,eACLC,EAAa,CAAE,CAAC,EAChBC,EAAW,CAAA,EACXC,EACAC,EAAc,GAEVD,EAAQH,EAAG,KAAKd,EAAK,MAAM,GACjCgB,EAAS,KAAKC,EAAM,KAAK,EACzBF,EAAW,KAAKE,EAAM,MAAQA,EAAM,CAAC,EAAE,MAAM,EAEzCjB,EAAK,UAAYiB,EAAM,OAASC,EAAc,IAChDA,EAAcH,EAAW,OAAS,GAIlCG,EAAc,IAAGA,EAAcH,EAAW,OAAS,GAEvD,IAAIjC,EAAS,GAAIqC,EAAGC,EAChBC,EAAe,KAAK,IAAIrB,EAAK,KAAOa,EAAQ,WAAYG,EAAS,MAAM,EAAE,SAAQ,EAAG,OACpFV,EAAgBO,EAAQ,WAAaA,EAAQ,OAASQ,EAAe,GAEzE,IAAKF,EAAI,EAAGA,GAAKN,EAAQ,aACnB,EAAAK,EAAcC,EAAI,GADcA,IAEpCC,EAAOnB,GACLD,EAAK,OACLe,EAAWG,EAAcC,CAAC,EAC1BH,EAASE,EAAcC,CAAC,EACxBnB,EAAK,UAAYe,EAAWG,CAAW,EAAIH,EAAWG,EAAcC,CAAC,GACrEb,CACN,EACIxB,EAASU,GAAO,OAAO,IAAKqB,EAAQ,MAAM,EAAIH,IAAUV,EAAK,KAAOmB,EAAI,GAAG,SAAQ,EAAIE,CAAY,EACjG,MAAQD,EAAK,IAAM;AAAA,EAAOtC,EAQ9B,IALAsC,EAAOnB,GAAQD,EAAK,OAAQe,EAAWG,CAAW,EAAGF,EAASE,CAAW,EAAGlB,EAAK,SAAUM,CAAa,EACxGxB,GAAUU,GAAO,OAAO,IAAKqB,EAAQ,MAAM,EAAIH,IAAUV,EAAK,KAAO,GAAG,SAAQ,EAAIqB,CAAY,EAC9F,MAAQD,EAAK,IAAM;AAAA,EACrBtC,GAAUU,GAAO,OAAO,IAAKqB,EAAQ,OAASQ,EAAe,EAAID,EAAK,GAAG,EAAI;AAAA,EAExED,EAAI,EAAGA,GAAKN,EAAQ,YACnB,EAAAK,EAAcC,GAAKH,EAAS,QADGG,IAEnCC,EAAOnB,GACLD,EAAK,OACLe,EAAWG,EAAcC,CAAC,EAC1BH,EAASE,EAAcC,CAAC,EACxBnB,EAAK,UAAYe,EAAWG,CAAW,EAAIH,EAAWG,EAAcC,CAAC,GACrEb,CACN,EACIxB,GAAUU,GAAO,OAAO,IAAKqB,EAAQ,MAAM,EAAIH,IAAUV,EAAK,KAAOmB,EAAI,GAAG,SAAQ,EAAIE,CAAY,EAClG,MAAQD,EAAK,IAAM;AAAA,EAGvB,OAAOtC,EAAO,QAAQ,MAAO,EAAE,CACjC,CAGA,IAAIwC,GAAUV,GAEVW,GAA2B,CAC7B,OACA,QACA,UACA,YACA,aACA,YACA,YACA,gBACA,eACA,cACF,EAEIC,GAAkB,CACpB,SACA,WACA,SACF,EAEA,SAASC,GAAoBC,EAAK,CAChC,IAAI5C,EAAS,CAAA,EAEb,OAAI4C,IAAQ,MACV,OAAO,KAAKA,CAAG,EAAE,QAAQ,SAAUC,EAAO,CACxCD,EAAIC,CAAK,EAAE,QAAQ,SAAUC,EAAO,CAClC9C,EAAO,OAAO8C,CAAK,CAAC,EAAID,CAC1B,CAAC,CACH,CAAC,EAGI7C,CACT,CAEA,SAAS+C,GAAOC,EAAKjB,EAAS,CAuB5B,GAtBAA,EAAUA,GAAW,CAAA,EAErB,OAAO,KAAKA,CAAO,EAAE,QAAQ,SAAUkB,EAAM,CAC3C,GAAIR,GAAyB,QAAQQ,CAAI,IAAM,GAC7C,MAAM,IAAIrC,GAAU,mBAAqBqC,EAAO,8BAAgCD,EAAM,cAAc,CAExG,CAAC,EAGD,KAAK,QAAgBjB,EACrB,KAAK,IAAgBiB,EACrB,KAAK,KAAgBjB,EAAQ,MAAoB,KACjD,KAAK,QAAgBA,EAAQ,SAAoB,UAAY,CAAE,MAAO,EAAM,EAC5E,KAAK,UAAgBA,EAAQ,WAAoB,SAAUmB,EAAM,CAAE,OAAOA,CAAM,EAChF,KAAK,WAAgBnB,EAAQ,YAAoB,KACjD,KAAK,UAAgBA,EAAQ,WAAoB,KACjD,KAAK,UAAgBA,EAAQ,WAAoB,KACjD,KAAK,cAAgBA,EAAQ,eAAoB,KACjD,KAAK,aAAgBA,EAAQ,cAAoB,KACjD,KAAK,MAAgBA,EAAQ,OAAoB,GACjD,KAAK,aAAgBY,GAAoBZ,EAAQ,cAAmB,IAAI,EAEpEW,GAAgB,QAAQ,KAAK,IAAI,IAAM,GACzC,MAAM,IAAI9B,GAAU,iBAAmB,KAAK,KAAO,uBAAyBoC,EAAM,cAAc,CAEpG,CAEA,IAAIG,GAAOJ,GAQX,SAASK,GAAYC,EAAQJ,EAAM,CACjC,IAAIjD,EAAS,CAAA,EAEb,OAAAqD,EAAOJ,CAAI,EAAE,QAAQ,SAAUK,EAAa,CAC1C,IAAIC,EAAWvD,EAAO,OAEtBA,EAAO,QAAQ,SAAUwD,EAAcC,EAAe,CAChDD,EAAa,MAAQF,EAAY,KACjCE,EAAa,OAASF,EAAY,MAClCE,EAAa,QAAUF,EAAY,QAErCC,EAAWE,EAEf,CAAC,EAEDzD,EAAOuD,CAAQ,EAAID,CACrB,CAAC,EAEMtD,CACT,CAGA,SAAS0D,IAA2B,CAClC,IAAI1D,EAAS,CACP,OAAQ,CAAA,EACR,SAAU,CAAA,EACV,QAAS,CAAA,EACT,SAAU,CAAA,EACV,MAAO,CACL,OAAQ,CAAA,EACR,SAAU,CAAA,EACV,QAAS,CAAA,EACT,SAAU,CAAA,CACpB,CACA,EAASP,EAAOC,EAEd,SAASiE,EAAYR,EAAM,CACrBA,EAAK,OACPnD,EAAO,MAAMmD,EAAK,IAAI,EAAE,KAAKA,CAAI,EACjCnD,EAAO,MAAM,SAAY,KAAKmD,CAAI,GAElCnD,EAAOmD,EAAK,IAAI,EAAEA,EAAK,GAAG,EAAInD,EAAO,SAAYmD,EAAK,GAAG,EAAIA,CAEjE,CAEA,IAAK1D,EAAQ,EAAGC,EAAS,UAAU,OAAQD,EAAQC,EAAQD,GAAS,EAClE,UAAUA,CAAK,EAAE,QAAQkE,CAAW,EAEtC,OAAO3D,CACT,CAGA,SAAS4D,GAASC,EAAY,CAC5B,OAAO,KAAK,OAAOA,CAAU,CAC/B,CAGAD,GAAS,UAAU,OAAS,SAAgBC,EAAY,CACtD,IAAIC,EAAW,CAAA,EACXC,EAAW,CAAA,EAEf,GAAIF,aAAsBV,GAExBY,EAAS,KAAKF,CAAU,UAEf,MAAM,QAAQA,CAAU,EAEjCE,EAAWA,EAAS,OAAOF,CAAU,UAE5BA,IAAe,MAAM,QAAQA,EAAW,QAAQ,GAAK,MAAM,QAAQA,EAAW,QAAQ,GAE3FA,EAAW,WAAUC,EAAWA,EAAS,OAAOD,EAAW,QAAQ,GACnEA,EAAW,WAAUE,EAAWA,EAAS,OAAOF,EAAW,QAAQ,OAGvE,OAAM,IAAIjD,GAAU,kHAC6C,EAGnEkD,EAAS,QAAQ,SAAUE,EAAQ,CACjC,GAAI,EAAEA,aAAkBb,IACtB,MAAM,IAAIvC,GAAU,oFAAoF,EAG1G,GAAIoD,EAAO,UAAYA,EAAO,WAAa,SACzC,MAAM,IAAIpD,GAAU,iHAAiH,EAGvI,GAAIoD,EAAO,MACT,MAAM,IAAIpD,GAAU,oGAAoG,CAE5H,CAAC,EAEDmD,EAAS,QAAQ,SAAUC,EAAQ,CACjC,GAAI,EAAEA,aAAkBb,IACtB,MAAM,IAAIvC,GAAU,oFAAoF,CAE5G,CAAC,EAED,IAAIZ,EAAS,OAAO,OAAO4D,GAAS,SAAS,EAE7C,OAAA5D,EAAO,UAAY,KAAK,UAAY,CAAA,GAAI,OAAO8D,CAAQ,EACvD9D,EAAO,UAAY,KAAK,UAAY,CAAA,GAAI,OAAO+D,CAAQ,EAEvD/D,EAAO,iBAAmBoD,GAAYpD,EAAQ,UAAU,EACxDA,EAAO,iBAAmBoD,GAAYpD,EAAQ,UAAU,EACxDA,EAAO,gBAAmB0D,GAAW1D,EAAO,iBAAkBA,EAAO,gBAAgB,EAE9EA,CACT,EAGA,IAAIqD,GAASO,GAETK,GAAM,IAAId,GAAK,wBAAyB,CAC1C,KAAM,SACN,UAAW,SAAUD,EAAM,CAAE,OAAOA,IAAS,KAAOA,EAAO,EAAI,CACjE,CAAC,EAEGgB,GAAM,IAAIf,GAAK,wBAAyB,CAC1C,KAAM,WACN,UAAW,SAAUD,EAAM,CAAE,OAAOA,IAAS,KAAOA,EAAO,CAAA,CAAI,CACjE,CAAC,EAEGN,GAAM,IAAIO,GAAK,wBAAyB,CAC1C,KAAM,UACN,UAAW,SAAUD,EAAM,CAAE,OAAOA,IAAS,KAAOA,EAAO,CAAA,CAAI,CACjE,CAAC,EAEGiB,GAAW,IAAId,GAAO,CACxB,SAAU,CACRY,GACAC,GACAtB,EACJ,CACA,CAAC,EAED,SAASwB,GAAgBlB,EAAM,CAC7B,GAAIA,IAAS,KAAM,MAAO,GAE1B,IAAIrB,EAAMqB,EAAK,OAEf,OAAQrB,IAAQ,GAAKqB,IAAS,KACtBrB,IAAQ,IAAMqB,IAAS,QAAUA,IAAS,QAAUA,IAAS,OACvE,CAEA,SAASmB,IAAoB,CAC3B,OAAO,IACT,CAEA,SAASC,GAAOC,EAAQ,CACtB,OAAOA,IAAW,IACpB,CAEA,IAAIC,GAAQ,IAAIrB,GAAK,yBAA0B,CAC7C,KAAM,SACN,QAASiB,GACT,UAAWC,GACX,UAAWC,GACX,UAAW,CACT,UAAW,UAAY,CAAE,MAAO,GAAQ,EACxC,UAAW,UAAY,CAAE,MAAO,MAAQ,EACxC,UAAW,UAAY,CAAE,MAAO,MAAQ,EACxC,UAAW,UAAY,CAAE,MAAO,MAAQ,EACxC,MAAW,UAAY,CAAE,MAAO,EAAQ,CAC5C,EACE,aAAc,WAChB,CAAC,EAED,SAASG,GAAmBvB,EAAM,CAChC,GAAIA,IAAS,KAAM,MAAO,GAE1B,IAAIrB,EAAMqB,EAAK,OAEf,OAAQrB,IAAQ,IAAMqB,IAAS,QAAUA,IAAS,QAAUA,IAAS,SAC7DrB,IAAQ,IAAMqB,IAAS,SAAWA,IAAS,SAAWA,IAAS,QACzE,CAEA,SAASwB,GAAqBxB,EAAM,CAClC,OAAOA,IAAS,QACTA,IAAS,QACTA,IAAS,MAClB,CAEA,SAASyB,GAAUJ,EAAQ,CACzB,OAAO,OAAO,UAAU,SAAS,KAAKA,CAAM,IAAM,kBACpD,CAEA,IAAIK,GAAO,IAAIzB,GAAK,yBAA0B,CAC5C,KAAM,SACN,QAASsB,GACT,UAAWC,GACX,UAAWC,GACX,UAAW,CACT,UAAW,SAAUJ,EAAQ,CAAE,OAAOA,EAAS,OAAS,OAAS,EACjE,UAAW,SAAUA,EAAQ,CAAE,OAAOA,EAAS,OAAS,OAAS,EACjE,UAAW,SAAUA,EAAQ,CAAE,OAAOA,EAAS,OAAS,OAAS,CACrE,EACE,aAAc,WAChB,CAAC,EAED,SAASM,GAAUtI,EAAG,CACpB,MAAS,KAAeA,GAAOA,GAAK,IAC3B,IAAeA,GAAOA,GAAK,IAC3B,IAAeA,GAAOA,GAAK,GACtC,CAEA,SAASuI,GAAUvI,EAAG,CACpB,MAAS,KAAeA,GAAOA,GAAK,EACtC,CAEA,SAASwI,GAAUxI,EAAG,CACpB,MAAS,KAAeA,GAAOA,GAAK,EACtC,CAEA,SAASyI,GAAmB9B,EAAM,CAChC,GAAIA,IAAS,KAAM,MAAO,GAE1B,IAAIrB,EAAMqB,EAAK,OACXzD,EAAQ,EACRwF,EAAY,GACZC,EAEJ,GAAI,CAACrD,EAAK,MAAO,GASjB,GAPAqD,EAAKhC,EAAKzD,CAAK,GAGXyF,IAAO,KAAOA,IAAO,OACvBA,EAAKhC,EAAK,EAAEzD,CAAK,GAGfyF,IAAO,IAAK,CAEd,GAAIzF,EAAQ,IAAMoC,EAAK,MAAO,GAK9B,GAJAqD,EAAKhC,EAAK,EAAEzD,CAAK,EAIbyF,IAAO,IAAK,CAId,IAFAzF,IAEOA,EAAQoC,EAAKpC,IAElB,GADAyF,EAAKhC,EAAKzD,CAAK,EACXyF,IAAO,IACX,IAAIA,IAAO,KAAOA,IAAO,IAAK,MAAO,GACrCD,EAAY,GAEd,OAAOA,GAAaC,IAAO,GAC7B,CAGA,GAAIA,IAAO,IAAK,CAId,IAFAzF,IAEOA,EAAQoC,EAAKpC,IAElB,GADAyF,EAAKhC,EAAKzD,CAAK,EACXyF,IAAO,IACX,IAAI,CAACL,GAAU3B,EAAK,WAAWzD,CAAK,CAAC,EAAG,MAAO,GAC/CwF,EAAY,GAEd,OAAOA,GAAaC,IAAO,GAC7B,CAGA,GAAIA,IAAO,IAAK,CAId,IAFAzF,IAEOA,EAAQoC,EAAKpC,IAElB,GADAyF,EAAKhC,EAAKzD,CAAK,EACXyF,IAAO,IACX,IAAI,CAACJ,GAAU5B,EAAK,WAAWzD,CAAK,CAAC,EAAG,MAAO,GAC/CwF,EAAY,GAEd,OAAOA,GAAaC,IAAO,GAC7B,CACF,CAKA,GAAIA,IAAO,IAAK,MAAO,GAEvB,KAAOzF,EAAQoC,EAAKpC,IAElB,GADAyF,EAAKhC,EAAKzD,CAAK,EACXyF,IAAO,IACX,IAAI,CAACH,GAAU7B,EAAK,WAAWzD,CAAK,CAAC,EACnC,MAAO,GAETwF,EAAY,GAId,MAAI,GAACA,GAAaC,IAAO,IAG3B,CAEA,SAASC,GAAqBjC,EAAM,CAClC,IAAIkC,EAAQlC,EAAMmC,EAAO,EAAGH,EAc5B,GAZIE,EAAM,QAAQ,GAAG,IAAM,KACzBA,EAAQA,EAAM,QAAQ,KAAM,EAAE,GAGhCF,EAAKE,EAAM,CAAC,GAERF,IAAO,KAAOA,IAAO,OACnBA,IAAO,MAAKG,EAAO,IACvBD,EAAQA,EAAM,MAAM,CAAC,EACrBF,EAAKE,EAAM,CAAC,GAGVA,IAAU,IAAK,MAAO,GAE1B,GAAIF,IAAO,IAAK,CACd,GAAIE,EAAM,CAAC,IAAM,IAAK,OAAOC,EAAO,SAASD,EAAM,MAAM,CAAC,EAAG,CAAC,EAC9D,GAAIA,EAAM,CAAC,IAAM,IAAK,OAAOC,EAAO,SAASD,EAAM,MAAM,CAAC,EAAG,EAAE,EAC/D,GAAIA,EAAM,CAAC,IAAM,IAAK,OAAOC,EAAO,SAASD,EAAM,MAAM,CAAC,EAAG,CAAC,CAChE,CAEA,OAAOC,EAAO,SAASD,EAAO,EAAE,CAClC,CAEA,SAASE,GAAUf,EAAQ,CACzB,OAAQ,OAAO,UAAU,SAAS,KAAKA,CAAM,IAAO,mBAC5CA,EAAS,IAAM,GAAK,CAAC7D,GAAO,eAAe6D,CAAM,CAC3D,CAEA,IAAIgB,GAAM,IAAIpC,GAAK,wBAAyB,CAC1C,KAAM,SACN,QAAS6B,GACT,UAAWG,GACX,UAAWG,GACX,UAAW,CACT,OAAa,SAAUE,EAAK,CAAE,OAAOA,GAAO,EAAI,KAAOA,EAAI,SAAS,CAAC,EAAI,MAAQA,EAAI,SAAS,CAAC,EAAE,MAAM,CAAC,CAAG,EAC3G,MAAa,SAAUA,EAAK,CAAE,OAAOA,GAAO,EAAI,KAAQA,EAAI,SAAS,CAAC,EAAI,MAASA,EAAI,SAAS,CAAC,EAAE,MAAM,CAAC,CAAG,EAC7G,QAAa,SAAUA,EAAK,CAAE,OAAOA,EAAI,SAAS,EAAE,CAAG,EAEvD,YAAa,SAAUA,EAAK,CAAE,OAAOA,GAAO,EAAI,KAAOA,EAAI,SAAS,EAAE,EAAE,YAAW,EAAM,MAAQA,EAAI,SAAS,EAAE,EAAE,cAAc,MAAM,CAAC,CAAG,CAC9I,EACE,aAAc,UACd,aAAc,CACZ,OAAa,CAAE,EAAI,KAAK,EACxB,MAAa,CAAE,EAAI,KAAK,EACxB,QAAa,CAAE,GAAI,KAAK,EACxB,YAAa,CAAE,GAAI,KAAK,CAC5B,CACA,CAAC,EAEGC,GAAqB,IAAI,OAE3B,0IAOuB,EAEzB,SAASC,GAAiBxC,EAAM,CAG9B,MAFI,EAAAA,IAAS,MAET,CAACuC,GAAmB,KAAKvC,CAAI,GAG7BA,EAAKA,EAAK,OAAS,CAAC,IAAM,IAKhC,CAEA,SAASyC,GAAmBzC,EAAM,CAChC,IAAIkC,EAAOC,EASX,OAPAD,EAASlC,EAAK,QAAQ,KAAM,EAAE,EAAE,YAAW,EAC3CmC,EAASD,EAAM,CAAC,IAAM,IAAM,GAAK,EAE7B,KAAK,QAAQA,EAAM,CAAC,CAAC,GAAK,IAC5BA,EAAQA,EAAM,MAAM,CAAC,GAGnBA,IAAU,OACJC,IAAS,EAAK,OAAO,kBAAoB,OAAO,kBAE/CD,IAAU,OACZ,IAEFC,EAAO,WAAWD,EAAO,EAAE,CACpC,CAGA,IAAIQ,GAAyB,gBAE7B,SAASC,GAAmBtB,EAAQ1B,EAAO,CACzC,IAAIiD,EAEJ,GAAI,MAAMvB,CAAM,EACd,OAAQ1B,EAAK,CACX,IAAK,YAAa,MAAO,OACzB,IAAK,YAAa,MAAO,OACzB,IAAK,YAAa,MAAO,MAC/B,SACa,OAAO,oBAAsB0B,EACtC,OAAQ1B,EAAK,CACX,IAAK,YAAa,MAAO,OACzB,IAAK,YAAa,MAAO,OACzB,IAAK,YAAa,MAAO,MAC/B,SACa,OAAO,oBAAsB0B,EACtC,OAAQ1B,EAAK,CACX,IAAK,YAAa,MAAO,QACzB,IAAK,YAAa,MAAO,QACzB,IAAK,YAAa,MAAO,OAC/B,SACanC,GAAO,eAAe6D,CAAM,EACrC,MAAO,OAGT,OAAAuB,EAAMvB,EAAO,SAAS,EAAE,EAKjBqB,GAAuB,KAAKE,CAAG,EAAIA,EAAI,QAAQ,IAAK,IAAI,EAAIA,CACrE,CAEA,SAASC,GAAQxB,EAAQ,CACvB,OAAQ,OAAO,UAAU,SAAS,KAAKA,CAAM,IAAM,oBAC3CA,EAAS,IAAM,GAAK7D,GAAO,eAAe6D,CAAM,EAC1D,CAEA,IAAIyB,GAAQ,IAAI7C,GAAK,0BAA2B,CAC9C,KAAM,SACN,QAASuC,GACT,UAAWC,GACX,UAAWI,GACX,UAAWF,GACX,aAAc,WAChB,CAAC,EAEGI,GAAO9B,GAAS,OAAO,CACzB,SAAU,CACRK,GACAI,GACAW,GACAS,EACJ,CACA,CAAC,EAEGE,GAAOD,GAEPE,GAAmB,IAAI,OACzB,oDAEgB,EAEdC,GAAwB,IAAI,OAC9B,kLASwB,EAE1B,SAASC,GAAqBnD,EAAM,CAClC,OAAIA,IAAS,KAAa,GACtBiD,GAAiB,KAAKjD,CAAI,IAAM,MAChCkD,GAAsB,KAAKlD,CAAI,IAAM,IAE3C,CAEA,SAASoD,GAAuBpD,EAAM,CACpC,IAAIf,EAAOoE,EAAMC,EAAOC,EAAKC,EAAMC,EAAQC,EAAQC,EAAW,EAC1DC,EAAQ,KAAMC,EAASC,EAAWC,EAKtC,GAHA9E,EAAQgE,GAAiB,KAAKjD,CAAI,EAC9Bf,IAAU,OAAMA,EAAQiE,GAAsB,KAAKlD,CAAI,GAEvDf,IAAU,KAAM,MAAM,IAAI,MAAM,oBAAoB,EAQxD,GAJAoE,EAAO,CAAEpE,EAAM,CAAC,EAChBqE,EAAQ,CAAErE,EAAM,CAAC,EAAK,EACtBsE,EAAM,CAAEtE,EAAM,CAAC,EAEX,CAACA,EAAM,CAAC,EACV,OAAO,IAAI,KAAK,KAAK,IAAIoE,EAAMC,EAAOC,CAAG,CAAC,EAS5C,GAJAC,EAAO,CAAEvE,EAAM,CAAC,EAChBwE,EAAS,CAAExE,EAAM,CAAC,EAClByE,EAAS,CAAEzE,EAAM,CAAC,EAEdA,EAAM,CAAC,EAAG,CAEZ,IADA0E,EAAW1E,EAAM,CAAC,EAAE,MAAM,EAAG,CAAC,EACvB0E,EAAS,OAAS,GACvBA,GAAY,IAEdA,EAAW,CAACA,CACd,CAIA,OAAI1E,EAAM,CAAC,IACT4E,EAAU,CAAE5E,EAAM,EAAE,EACpB6E,EAAY,EAAE7E,EAAM,EAAE,GAAK,GAC3B2E,GAASC,EAAU,GAAKC,GAAa,IACjC7E,EAAM,CAAC,IAAM,MAAK2E,EAAQ,CAACA,IAGjCG,EAAO,IAAI,KAAK,KAAK,IAAIV,EAAMC,EAAOC,EAAKC,EAAMC,EAAQC,EAAQC,CAAQ,CAAC,EAEtEC,GAAOG,EAAK,QAAQA,EAAK,QAAO,EAAKH,CAAK,EAEvCG,CACT,CAEA,SAASC,GAAuB3C,EAAoB,CAClD,OAAOA,EAAO,YAAW,CAC3B,CAEA,IAAI4C,GAAY,IAAIhE,GAAK,8BAA+B,CACtD,KAAM,SACN,QAASkD,GACT,UAAWC,GACX,WAAY,KACZ,UAAWY,EACb,CAAC,EAED,SAASE,GAAiBlE,EAAM,CAC9B,OAAOA,IAAS,MAAQA,IAAS,IACnC,CAEA,IAAImE,GAAQ,IAAIlE,GAAK,0BAA2B,CAC9C,KAAM,SACN,QAASiE,EACX,CAAC,EASGE,GAAa;AAAA,IAGjB,SAASC,GAAkBrE,EAAM,CAC/B,GAAIA,IAAS,KAAM,MAAO,GAE1B,IAAIsE,EAAMC,EAAKC,EAAS,EAAG7F,EAAMqB,EAAK,OAAQN,EAAM0E,GAGpD,IAAKG,EAAM,EAAGA,EAAM5F,EAAK4F,IAIvB,GAHAD,EAAO5E,EAAI,QAAQM,EAAK,OAAOuE,CAAG,CAAC,EAG/B,EAAAD,EAAO,IAGX,IAAIA,EAAO,EAAG,MAAO,GAErBE,GAAU,EAIZ,OAAQA,EAAS,IAAO,CAC1B,CAEA,SAASC,GAAoBzE,EAAM,CACjC,IAAIuE,EAAKG,EACLC,EAAQ3E,EAAK,QAAQ,WAAY,EAAE,EACnCrB,EAAMgG,EAAM,OACZjF,EAAM0E,GACNQ,EAAO,EACP9H,EAAS,CAAA,EAIb,IAAKyH,EAAM,EAAGA,EAAM5F,EAAK4F,IAClBA,EAAM,IAAM,GAAMA,IACrBzH,EAAO,KAAM8H,GAAQ,GAAM,GAAI,EAC/B9H,EAAO,KAAM8H,GAAQ,EAAK,GAAI,EAC9B9H,EAAO,KAAK8H,EAAO,GAAI,GAGzBA,EAAQA,GAAQ,EAAKlF,EAAI,QAAQiF,EAAM,OAAOJ,CAAG,CAAC,EAKpD,OAAAG,EAAY/F,EAAM,EAAK,EAEnB+F,IAAa,GACf5H,EAAO,KAAM8H,GAAQ,GAAM,GAAI,EAC/B9H,EAAO,KAAM8H,GAAQ,EAAK,GAAI,EAC9B9H,EAAO,KAAK8H,EAAO,GAAI,GACdF,IAAa,IACtB5H,EAAO,KAAM8H,GAAQ,GAAM,GAAI,EAC/B9H,EAAO,KAAM8H,GAAQ,EAAK,GAAI,GACrBF,IAAa,IACtB5H,EAAO,KAAM8H,GAAQ,EAAK,GAAI,EAGzB,IAAI,WAAW9H,CAAM,CAC9B,CAEA,SAAS+H,GAAoBxD,EAAoB,CAC/C,IAAIvE,EAAS,GAAI8H,EAAO,EAAGL,EAAK/F,EAC5BG,EAAM0C,EAAO,OACb3B,EAAM0E,GAIV,IAAKG,EAAM,EAAGA,EAAM5F,EAAK4F,IAClBA,EAAM,IAAM,GAAMA,IACrBzH,GAAU4C,EAAKkF,GAAQ,GAAM,EAAI,EACjC9H,GAAU4C,EAAKkF,GAAQ,GAAM,EAAI,EACjC9H,GAAU4C,EAAKkF,GAAQ,EAAK,EAAI,EAChC9H,GAAU4C,EAAIkF,EAAO,EAAI,GAG3BA,GAAQA,GAAQ,GAAKvD,EAAOkD,CAAG,EAKjC,OAAA/F,EAAOG,EAAM,EAETH,IAAS,GACX1B,GAAU4C,EAAKkF,GAAQ,GAAM,EAAI,EACjC9H,GAAU4C,EAAKkF,GAAQ,GAAM,EAAI,EACjC9H,GAAU4C,EAAKkF,GAAQ,EAAK,EAAI,EAChC9H,GAAU4C,EAAIkF,EAAO,EAAI,GAChBpG,IAAS,GAClB1B,GAAU4C,EAAKkF,GAAQ,GAAM,EAAI,EACjC9H,GAAU4C,EAAKkF,GAAQ,EAAK,EAAI,EAChC9H,GAAU4C,EAAKkF,GAAQ,EAAK,EAAI,EAChC9H,GAAU4C,EAAI,EAAE,GACPlB,IAAS,IAClB1B,GAAU4C,EAAKkF,GAAQ,EAAK,EAAI,EAChC9H,GAAU4C,EAAKkF,GAAQ,EAAK,EAAI,EAChC9H,GAAU4C,EAAI,EAAE,EAChB5C,GAAU4C,EAAI,EAAE,GAGX5C,CACT,CAEA,SAASgI,GAASxC,EAAK,CACrB,OAAO,OAAO,UAAU,SAAS,KAAKA,CAAG,IAAO,qBAClD,CAEA,IAAIyC,GAAS,IAAI9E,GAAK,2BAA4B,CAChD,KAAM,SACN,QAASoE,GACT,UAAWI,GACX,UAAWK,GACX,UAAWD,EACb,CAAC,EAEGG,GAAoB,OAAO,UAAU,eACrCC,GAAoB,OAAO,UAAU,SAEzC,SAASC,GAAgBlF,EAAM,CAC7B,GAAIA,IAAS,KAAM,MAAO,GAE1B,IAAImF,EAAa,CAAA,EAAI5I,EAAOC,EAAQ4I,EAAMC,EAASC,EAC/CjE,EAASrB,EAEb,IAAKzD,EAAQ,EAAGC,EAAS6E,EAAO,OAAQ9E,EAAQC,EAAQD,GAAS,EAAG,CAIlE,GAHA6I,EAAO/D,EAAO9E,CAAK,EACnB+I,EAAa,GAETL,GAAY,KAAKG,CAAI,IAAM,kBAAmB,MAAO,GAEzD,IAAKC,KAAWD,EACd,GAAIJ,GAAkB,KAAKI,EAAMC,CAAO,EACtC,GAAI,CAACC,EAAYA,EAAa,OACzB,OAAO,GAIhB,GAAI,CAACA,EAAY,MAAO,GAExB,GAAIH,EAAW,QAAQE,CAAO,IAAM,GAAIF,EAAW,KAAKE,CAAO,MAC1D,OAAO,EACd,CAEA,MAAO,EACT,CAEA,SAASE,GAAkBvF,EAAM,CAC/B,OAAOA,IAAS,KAAOA,EAAO,CAAA,CAChC,CAEA,IAAIwF,GAAO,IAAIvF,GAAK,yBAA0B,CAC5C,KAAM,WACN,QAASiF,GACT,UAAWK,EACb,CAAC,EAEGE,GAAc,OAAO,UAAU,SAEnC,SAASC,GAAiB1F,EAAM,CAC9B,GAAIA,IAAS,KAAM,MAAO,GAE1B,IAAIzD,EAAOC,EAAQ4I,EAAMO,EAAM7I,EAC3BuE,EAASrB,EAIb,IAFAlD,EAAS,IAAI,MAAMuE,EAAO,MAAM,EAE3B9E,EAAQ,EAAGC,EAAS6E,EAAO,OAAQ9E,EAAQC,EAAQD,GAAS,EAAG,CAOlE,GANA6I,EAAO/D,EAAO9E,CAAK,EAEfkJ,GAAY,KAAKL,CAAI,IAAM,oBAE/BO,EAAO,OAAO,KAAKP,CAAI,EAEnBO,EAAK,SAAW,GAAG,MAAO,GAE9B7I,EAAOP,CAAK,EAAI,CAAEoJ,EAAK,CAAC,EAAGP,EAAKO,EAAK,CAAC,CAAC,CAAC,CAC1C,CAEA,MAAO,EACT,CAEA,SAASC,GAAmB5F,EAAM,CAChC,GAAIA,IAAS,KAAM,MAAO,CAAA,EAE1B,IAAIzD,EAAOC,EAAQ4I,EAAMO,EAAM7I,EAC3BuE,EAASrB,EAIb,IAFAlD,EAAS,IAAI,MAAMuE,EAAO,MAAM,EAE3B9E,EAAQ,EAAGC,EAAS6E,EAAO,OAAQ9E,EAAQC,EAAQD,GAAS,EAC/D6I,EAAO/D,EAAO9E,CAAK,EAEnBoJ,EAAO,OAAO,KAAKP,CAAI,EAEvBtI,EAAOP,CAAK,EAAI,CAAEoJ,EAAK,CAAC,EAAGP,EAAKO,EAAK,CAAC,CAAC,CAAC,EAG1C,OAAO7I,CACT,CAEA,IAAI+I,GAAQ,IAAI5F,GAAK,0BAA2B,CAC9C,KAAM,WACN,QAASyF,GACT,UAAWE,EACb,CAAC,EAEGE,GAAoB,OAAO,UAAU,eAEzC,SAASC,GAAe/F,EAAM,CAC5B,GAAIA,IAAS,KAAM,MAAO,GAE1B,IAAIvD,EAAK4E,EAASrB,EAElB,IAAKvD,KAAO4E,EACV,GAAIyE,GAAkB,KAAKzE,EAAQ5E,CAAG,GAChC4E,EAAO5E,CAAG,IAAM,KAAM,MAAO,GAIrC,MAAO,EACT,CAEA,SAASuJ,GAAiBhG,EAAM,CAC9B,OAAOA,IAAS,KAAOA,EAAO,CAAA,CAChC,CAEA,IAAIiG,GAAM,IAAIhG,GAAK,wBAAyB,CAC1C,KAAM,UACN,QAAS8F,GACT,UAAWC,EACb,CAAC,EAEGE,GAAWlD,GAAK,OAAO,CACzB,SAAU,CACRiB,GACAE,EACJ,EACE,SAAU,CACRY,GACAS,GACAK,GACAI,EACJ,CACA,CAAC,EAUGE,GAAoB,OAAO,UAAU,eAGrCC,GAAoB,EACpBC,GAAoB,EACpBC,GAAoB,EACpBC,GAAoB,EAGpBC,GAAiB,EACjBC,GAAiB,EACjBC,GAAiB,EAGjBC,GAAgC,sIAChCC,GAAgC,qBAChCC,GAAgC,cAChCC,GAAgC,yBAChCC,GAAgC,mFAGpC,SAASC,GAAO1E,EAAK,CAAE,OAAO,OAAO,UAAU,SAAS,KAAKA,CAAG,CAAG,CAEnE,SAAS2E,GAAO5N,EAAG,CACjB,OAAQA,IAAM,IAAkBA,IAAM,EACxC,CAEA,SAAS6N,GAAe7N,EAAG,CACzB,OAAQA,IAAM,GAAmBA,IAAM,EACzC,CAEA,SAAS8N,GAAa9N,EAAG,CACvB,OAAQA,IAAM,GACNA,IAAM,IACNA,IAAM,IACNA,IAAM,EAChB,CAEA,SAAS+N,GAAkB/N,EAAG,CAC5B,OAAOA,IAAM,IACNA,IAAM,IACNA,IAAM,IACNA,IAAM,KACNA,IAAM,GACf,CAEA,SAASgO,GAAYhO,EAAG,CACtB,IAAIiO,EAEJ,MAAK,KAAejO,GAAOA,GAAK,GACvBA,EAAI,IAIbiO,EAAKjO,EAAI,GAEJ,IAAeiO,GAAQA,GAAM,IACzBA,EAAK,GAAO,GAGd,GACT,CAEA,SAASC,GAAclO,EAAG,CACxB,OAAIA,IAAM,IAAsB,EAC5BA,IAAM,IAAsB,EAC5BA,IAAM,GAAsB,EACzB,CACT,CAEA,SAASmO,GAAgBnO,EAAG,CAC1B,MAAK,KAAeA,GAAOA,GAAK,GACvBA,EAAI,GAGN,EACT,CAEA,SAASoO,GAAqBpO,EAAG,CAE/B,OAAQA,IAAM,GAAe,KACtBA,IAAM,GAAe,OACrBA,IAAM,GAAe,KACrBA,IAAM,KACNA,IAAM,EADe,IAErBA,IAAM,IAAe;AAAA,EACrBA,IAAM,IAAe,KACrBA,IAAM,IAAe,KACrBA,IAAM,IAAe,KACrBA,IAAM,IAAe,OACrBA,IAAM,GAAmB,IACzBA,IAAM,GAAe,IACrBA,IAAM,GAAe,IACrBA,IAAM,GAAe,KACrBA,IAAM,GAAe,IACrBA,IAAM,GAAe,IACrBA,IAAM,GAAe,SACrBA,IAAM,GAAe,SAAW,EACzC,CAEA,SAASqO,GAAkBrO,EAAG,CAC5B,OAAIA,GAAK,MACA,OAAO,aAAaA,CAAC,EAIvB,OAAO,cACVA,EAAI,OAAa,IAAM,OACvBA,EAAI,MAAY,MAAU,KAChC,CACA,CAIA,SAASsO,GAAYtG,EAAQ5E,EAAKyF,EAAO,CAEnCzF,IAAQ,YACV,OAAO,eAAe4E,EAAQ5E,EAAK,CACjC,aAAc,GACd,WAAY,GACZ,SAAU,GACV,MAAOyF,CACb,CAAK,EAEDb,EAAO5E,CAAG,EAAIyF,CAElB,CAEA,IAAI0F,GAAoB,IAAI,MAAM,GAAG,EACjCC,GAAkB,IAAI,MAAM,GAAG,EACnC,QAAS1I,GAAI,EAAGA,GAAI,IAAKA,KACvByI,GAAkBzI,EAAC,EAAIsI,GAAqBtI,EAAC,EAAI,EAAI,EACrD0I,GAAgB1I,EAAC,EAAIsI,GAAqBtI,EAAC,EAI7C,SAAS2I,GAAQnD,EAAO9F,EAAS,CAC/B,KAAK,MAAQ8F,EAEb,KAAK,SAAY9F,EAAQ,UAAgB,KACzC,KAAK,OAAYA,EAAQ,QAAgBqH,GACzC,KAAK,UAAYrH,EAAQ,WAAgB,KAGzC,KAAK,OAAYA,EAAQ,QAAgB,GAEzC,KAAK,KAAYA,EAAQ,MAAgB,GACzC,KAAK,SAAYA,EAAQ,UAAgB,KAEzC,KAAK,cAAgB,KAAK,OAAO,iBACjC,KAAK,QAAgB,KAAK,OAAO,gBAEjC,KAAK,OAAa8F,EAAM,OACxB,KAAK,SAAa,EAClB,KAAK,KAAa,EAClB,KAAK,UAAa,EAClB,KAAK,WAAa,EAIlB,KAAK,eAAiB,GAEtB,KAAK,UAAY,CAAA,CAYnB,CAGA,SAASoD,GAAcC,EAAOnK,EAAS,CACrC,IAAIG,EAAO,CACT,KAAUgK,EAAM,SAChB,OAAUA,EAAM,MAAM,MAAM,EAAG,EAAE,EACjC,SAAUA,EAAM,SAChB,KAAUA,EAAM,KAChB,OAAUA,EAAM,SAAWA,EAAM,SACrC,EAEE,OAAAhK,EAAK,QAAUsB,GAAQtB,CAAI,EAEpB,IAAIN,GAAUG,EAASG,CAAI,CACpC,CAEA,SAASiK,GAAWD,EAAOnK,EAAS,CAClC,MAAMkK,GAAcC,EAAOnK,CAAO,CACpC,CAEA,SAASqK,GAAaF,EAAOnK,EAAS,CAChCmK,EAAM,WACRA,EAAM,UAAU,KAAK,KAAMD,GAAcC,EAAOnK,CAAO,CAAC,CAE5D,CAGA,IAAIsK,GAAoB,CAEtB,KAAM,SAA6BH,EAAOjI,EAAMqI,EAAM,CAEpD,IAAInJ,EAAOoJ,EAAOC,EAEdN,EAAM,UAAY,MACpBC,GAAWD,EAAO,gCAAgC,EAGhDI,EAAK,SAAW,GAClBH,GAAWD,EAAO,6CAA6C,EAGjE/I,EAAQ,uBAAuB,KAAKmJ,EAAK,CAAC,CAAC,EAEvCnJ,IAAU,MACZgJ,GAAWD,EAAO,2CAA2C,EAG/DK,EAAQ,SAASpJ,EAAM,CAAC,EAAG,EAAE,EAC7BqJ,EAAQ,SAASrJ,EAAM,CAAC,EAAG,EAAE,EAEzBoJ,IAAU,GACZJ,GAAWD,EAAO,2CAA2C,EAG/DA,EAAM,QAAUI,EAAK,CAAC,EACtBJ,EAAM,gBAAmBM,EAAQ,EAE7BA,IAAU,GAAKA,IAAU,GAC3BJ,GAAaF,EAAO,0CAA0C,CAElE,EAEA,IAAK,SAA4BA,EAAOjI,EAAMqI,EAAM,CAElD,IAAIG,EAAQC,EAERJ,EAAK,SAAW,GAClBH,GAAWD,EAAO,6CAA6C,EAGjEO,EAASH,EAAK,CAAC,EACfI,EAASJ,EAAK,CAAC,EAEVtB,GAAmB,KAAKyB,CAAM,GACjCN,GAAWD,EAAO,6DAA6D,EAG7E7B,GAAkB,KAAK6B,EAAM,OAAQO,CAAM,GAC7CN,GAAWD,EAAO,8CAAgDO,EAAS,cAAc,EAGtFxB,GAAgB,KAAKyB,CAAM,GAC9BP,GAAWD,EAAO,8DAA8D,EAGlF,GAAI,CACFQ,EAAS,mBAAmBA,CAAM,CACpC,MAAc,CACZP,GAAWD,EAAO,4BAA8BQ,CAAM,CACxD,CAEAR,EAAM,OAAOO,CAAM,EAAIC,CACzB,CACF,EAGA,SAASC,GAAeT,EAAOU,EAAOC,EAAKC,EAAW,CACpD,IAAIC,EAAWC,EAASC,EAAYC,EAEpC,GAAIN,EAAQC,EAAK,CAGf,GAFAK,EAAUhB,EAAM,MAAM,MAAMU,EAAOC,CAAG,EAElCC,EACF,IAAKC,EAAY,EAAGC,EAAUE,EAAQ,OAAQH,EAAYC,EAASD,GAAa,EAC9EE,EAAaC,EAAQ,WAAWH,CAAS,EACnCE,IAAe,GACd,IAAQA,GAAcA,GAAc,SACzCd,GAAWD,EAAO,+BAA+B,OAG5CrB,GAAsB,KAAKqC,CAAO,GAC3Cf,GAAWD,EAAO,8CAA8C,EAGlEA,EAAM,QAAUgB,CAClB,CACF,CAEA,SAASC,GAAcjB,EAAOkB,EAAa5M,EAAQ6M,EAAiB,CAClE,IAAIzM,EAAYD,EAAKF,EAAO6M,EAQ5B,IANK5L,GAAO,SAASlB,CAAM,GACzB2L,GAAWD,EAAO,mEAAmE,EAGvFtL,EAAa,OAAO,KAAKJ,CAAM,EAE1BC,EAAQ,EAAG6M,EAAW1M,EAAW,OAAQH,EAAQ6M,EAAU7M,GAAS,EACvEE,EAAMC,EAAWH,CAAK,EAEjB4J,GAAkB,KAAK+C,EAAazM,CAAG,IAC1CkL,GAAYuB,EAAazM,EAAKH,EAAOG,CAAG,CAAC,EACzC0M,EAAgB1M,CAAG,EAAI,GAG7B,CAEA,SAAS4M,GAAiBrB,EAAOgB,EAASG,EAAiBG,EAAQC,EAASC,EAC1EC,EAAWC,EAAgBC,EAAU,CAErC,IAAIpN,EAAO6M,EAKX,GAAI,MAAM,QAAQG,CAAO,EAGvB,IAFAA,EAAU,MAAM,UAAU,MAAM,KAAKA,CAAO,EAEvChN,EAAQ,EAAG6M,EAAWG,EAAQ,OAAQhN,EAAQ6M,EAAU7M,GAAS,EAChE,MAAM,QAAQgN,EAAQhN,CAAK,CAAC,GAC9B0L,GAAWD,EAAO,6CAA6C,EAG7D,OAAOuB,GAAY,UAAYvC,GAAOuC,EAAQhN,CAAK,CAAC,IAAM,oBAC5DgN,EAAQhN,CAAK,EAAI,mBAmBvB,GAXI,OAAOgN,GAAY,UAAYvC,GAAOuC,CAAO,IAAM,oBACrDA,EAAU,mBAIZA,EAAU,OAAOA,CAAO,EAEpBP,IAAY,OACdA,EAAU,CAAA,GAGRM,IAAW,0BACb,GAAI,MAAM,QAAQE,CAAS,EACzB,IAAKjN,EAAQ,EAAG6M,EAAWI,EAAU,OAAQjN,EAAQ6M,EAAU7M,GAAS,EACtE0M,GAAcjB,EAAOgB,EAASQ,EAAUjN,CAAK,EAAG4M,CAAe,OAGjEF,GAAcjB,EAAOgB,EAASQ,EAAWL,CAAe,MAGtD,CAACnB,EAAM,MACP,CAAC7B,GAAkB,KAAKgD,EAAiBI,CAAO,GAChDpD,GAAkB,KAAK6C,EAASO,CAAO,IACzCvB,EAAM,KAAOyB,GAAazB,EAAM,KAChCA,EAAM,UAAY0B,GAAkB1B,EAAM,UAC1CA,EAAM,SAAW2B,GAAY3B,EAAM,SACnCC,GAAWD,EAAO,wBAAwB,GAG5CL,GAAYqB,EAASO,EAASC,CAAS,EACvC,OAAOL,EAAgBI,CAAO,EAGhC,OAAOP,CACT,CAEA,SAASY,GAAc5B,EAAO,CAC5B,IAAIhG,EAEJA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,GACTgG,EAAM,WACGhG,IAAO,IAChBgG,EAAM,WACFA,EAAM,MAAM,WAAWA,EAAM,QAAQ,IAAM,IAC7CA,EAAM,YAGRC,GAAWD,EAAO,0BAA0B,EAG9CA,EAAM,MAAQ,EACdA,EAAM,UAAYA,EAAM,SACxBA,EAAM,eAAiB,EACzB,CAEA,SAAS6B,GAAoB7B,EAAO8B,EAAeC,EAAa,CAI9D,QAHIC,EAAa,EACbhI,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEvChG,IAAO,GAAG,CACf,KAAOkF,GAAelF,CAAE,GAClBA,IAAO,GAAiBgG,EAAM,iBAAmB,KACnDA,EAAM,eAAiBA,EAAM,UAE/BhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9C,GAAI8B,GAAiB9H,IAAO,GAC1B,GACEA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,QACrChG,IAAO,IAAgBA,IAAO,IAAgBA,IAAO,GAGhE,GAAIiF,GAAOjF,CAAE,EAOX,IANA4H,GAAc5B,CAAK,EAEnBhG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAC1CgC,IACAhC,EAAM,WAAa,EAEZhG,IAAO,IACZgG,EAAM,aACNhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,MAG9C,MAEJ,CAEA,OAAI+B,IAAgB,IAAMC,IAAe,GAAKhC,EAAM,WAAa+B,GAC/D7B,GAAaF,EAAO,uBAAuB,EAGtCgC,CACT,CAEA,SAASC,GAAsBjC,EAAO,CACpC,IAAIa,EAAYb,EAAM,SAClBhG,EAMJ,OAJAA,EAAKgG,EAAM,MAAM,WAAWa,CAAS,EAIhC,IAAA7G,IAAO,IAAeA,IAAO,KAC9BA,IAAOgG,EAAM,MAAM,WAAWa,EAAY,CAAC,GAC3C7G,IAAOgG,EAAM,MAAM,WAAWa,EAAY,CAAC,IAE7CA,GAAa,EAEb7G,EAAKgG,EAAM,MAAM,WAAWa,CAAS,EAEjC7G,IAAO,GAAKmF,GAAanF,CAAE,GAMnC,CAEA,SAASkI,GAAiBlC,EAAOnL,EAAO,CAClCA,IAAU,EACZmL,EAAM,QAAU,IACPnL,EAAQ,IACjBmL,EAAM,QAAUxK,GAAO,OAAO;AAAA,EAAMX,EAAQ,CAAC,EAEjD,CAGA,SAASsN,GAAgBnC,EAAOoC,EAAYC,EAAsB,CAChE,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAAQ9C,EAAM,KACdgB,EAAUhB,EAAM,OAChBhG,EAoBJ,GAlBAA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtCb,GAAanF,CAAE,GACfoF,GAAkBpF,CAAE,GACpBA,IAAO,IACPA,IAAO,IACPA,IAAO,IACPA,IAAO,IACPA,IAAO,KACPA,IAAO,IACPA,IAAO,IACPA,IAAO,IACPA,IAAO,IACPA,IAAO,IACPA,IAAO,KAIPA,IAAO,IAAeA,IAAO,MAC/BuI,EAAYvC,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,EAEjDb,GAAaoD,CAAS,GACtBF,GAAwBjD,GAAkBmD,CAAS,GACrD,MAAO,GASX,IALAvC,EAAM,KAAO,SACbA,EAAM,OAAS,GACfwC,EAAeC,EAAazC,EAAM,SAClC0C,EAAoB,GAEb1I,IAAO,GAAG,CACf,GAAIA,IAAO,IAGT,GAFAuI,EAAYvC,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,EAEjDb,GAAaoD,CAAS,GACtBF,GAAwBjD,GAAkBmD,CAAS,EACrD,cAGOvI,IAAO,IAGhB,GAFAsI,EAAYtC,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,EAEjDb,GAAamD,CAAS,EACxB,UAGG,IAAKtC,EAAM,WAAaA,EAAM,WAAaiC,GAAsBjC,CAAK,GAClEqC,GAAwBjD,GAAkBpF,CAAE,EACrD,MAEK,GAAIiF,GAAOjF,CAAE,EAMlB,GALA2I,EAAQ3C,EAAM,KACd4C,EAAa5C,EAAM,UACnB6C,EAAc7C,EAAM,WACpB6B,GAAoB7B,EAAO,GAAO,EAAE,EAEhCA,EAAM,YAAcoC,EAAY,CAClCM,EAAoB,GACpB1I,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAC1C,QACF,KAAO,CACLA,EAAM,SAAWyC,EACjBzC,EAAM,KAAO2C,EACb3C,EAAM,UAAY4C,EAClB5C,EAAM,WAAa6C,EACnB,KACF,EAGEH,IACFjC,GAAeT,EAAOwC,EAAcC,EAAY,EAAK,EACrDP,GAAiBlC,EAAOA,EAAM,KAAO2C,CAAK,EAC1CH,EAAeC,EAAazC,EAAM,SAClC0C,EAAoB,IAGjBxD,GAAelF,CAAE,IACpByI,EAAazC,EAAM,SAAW,GAGhChG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,CAC9C,CAIA,OAFAS,GAAeT,EAAOwC,EAAcC,EAAY,EAAK,EAEjDzC,EAAM,OACD,IAGTA,EAAM,KAAO8C,EACb9C,EAAM,OAASgB,EACR,GACT,CAEA,SAAS+B,GAAuB/C,EAAOoC,EAAY,CACjD,IAAIpI,EACAwI,EAAcC,EAIlB,GAFAzI,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,GACT,MAAO,GAQT,IALAgG,EAAM,KAAO,SACbA,EAAM,OAAS,GACfA,EAAM,WACNwC,EAAeC,EAAazC,EAAM,UAE1BhG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,KAAO,GACvD,GAAIhG,IAAO,GAIT,GAHAyG,GAAeT,EAAOwC,EAAcxC,EAAM,SAAU,EAAI,EACxDhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAExChG,IAAO,GACTwI,EAAexC,EAAM,SACrBA,EAAM,WACNyC,EAAazC,EAAM,aAEnB,OAAO,QAGAf,GAAOjF,CAAE,GAClByG,GAAeT,EAAOwC,EAAcC,EAAY,EAAI,EACpDP,GAAiBlC,EAAO6B,GAAoB7B,EAAO,GAAOoC,CAAU,CAAC,EACrEI,EAAeC,EAAazC,EAAM,UAEzBA,EAAM,WAAaA,EAAM,WAAaiC,GAAsBjC,CAAK,EAC1EC,GAAWD,EAAO,8DAA8D,GAGhFA,EAAM,WACNyC,EAAazC,EAAM,UAIvBC,GAAWD,EAAO,4DAA4D,CAChF,CAEA,SAASgD,GAAuBhD,EAAOoC,EAAY,CACjD,IAAII,EACAC,EACAQ,EACAC,EACAC,EACAnJ,EAIJ,GAFAA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,GACT,MAAO,GAQT,IALAgG,EAAM,KAAO,SACbA,EAAM,OAAS,GACfA,EAAM,WACNwC,EAAeC,EAAazC,EAAM,UAE1BhG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,KAAO,GAAG,CAC1D,GAAIhG,IAAO,GACT,OAAAyG,GAAeT,EAAOwC,EAAcxC,EAAM,SAAU,EAAI,EACxDA,EAAM,WACC,GAEF,GAAIhG,IAAO,GAAa,CAI7B,GAHAyG,GAAeT,EAAOwC,EAAcxC,EAAM,SAAU,EAAI,EACxDhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAExCf,GAAOjF,CAAE,EACX6H,GAAoB7B,EAAO,GAAOoC,CAAU,UAGnCpI,EAAK,KAAO4F,GAAkB5F,CAAE,EACzCgG,EAAM,QAAUH,GAAgB7F,CAAE,EAClCgG,EAAM,oBAEImD,EAAM5D,GAAcvF,CAAE,GAAK,EAAG,CAIxC,IAHAiJ,EAAYE,EACZD,EAAY,EAELD,EAAY,EAAGA,IACpBjJ,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,GAEvCmD,EAAM9D,GAAYrF,CAAE,IAAM,EAC7BkJ,GAAaA,GAAa,GAAKC,EAG/BlD,GAAWD,EAAO,gCAAgC,EAItDA,EAAM,QAAUN,GAAkBwD,CAAS,EAE3ClD,EAAM,UAER,MACEC,GAAWD,EAAO,yBAAyB,EAG7CwC,EAAeC,EAAazC,EAAM,QAEpC,MAAWf,GAAOjF,CAAE,GAClByG,GAAeT,EAAOwC,EAAcC,EAAY,EAAI,EACpDP,GAAiBlC,EAAO6B,GAAoB7B,EAAO,GAAOoC,CAAU,CAAC,EACrEI,EAAeC,EAAazC,EAAM,UAEzBA,EAAM,WAAaA,EAAM,WAAaiC,GAAsBjC,CAAK,EAC1EC,GAAWD,EAAO,8DAA8D,GAGhFA,EAAM,WACNyC,EAAazC,EAAM,SAEvB,CAEAC,GAAWD,EAAO,4DAA4D,CAChF,CAEA,SAASoD,GAAmBpD,EAAOoC,EAAY,CAC7C,IAAIiB,EAAW,GACXV,EACAC,EACAU,EACAC,EAAWvD,EAAM,IACjBgB,EACAwC,EAAWxD,EAAM,OACjBuC,EACAkB,EACAC,EACAC,EACAC,EACAzC,EAAkB,OAAO,OAAO,IAAI,EACpCI,EACAD,EACAE,EACAxH,EAIJ,GAFAA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,GACTyJ,EAAa,GACbG,EAAY,GACZ5C,EAAU,CAAA,UACDhH,IAAO,IAChByJ,EAAa,IACbG,EAAY,GACZ5C,EAAU,CAAA,MAEV,OAAO,GAST,IANIhB,EAAM,SAAW,OACnBA,EAAM,UAAUA,EAAM,MAAM,EAAIgB,GAGlChH,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAErChG,IAAO,GAAG,CAKf,GAJA6H,GAAoB7B,EAAO,GAAMoC,CAAU,EAE3CpI,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAOyJ,EACT,OAAAzD,EAAM,WACNA,EAAM,IAAMuD,EACZvD,EAAM,OAASwD,EACfxD,EAAM,KAAO4D,EAAY,UAAY,WACrC5D,EAAM,OAASgB,EACR,GACGqC,EAEDrJ,IAAO,IAEhBiG,GAAWD,EAAO,0CAA0C,EAH5DC,GAAWD,EAAO,8CAA8C,EAMlEsB,EAASC,EAAUC,EAAY,KAC/BkC,EAASC,EAAiB,GAEtB3J,IAAO,KACTuI,EAAYvC,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,EAEjDb,GAAaoD,CAAS,IACxBmB,EAASC,EAAiB,GAC1B3D,EAAM,WACN6B,GAAoB7B,EAAO,GAAMoC,CAAU,IAI/CO,EAAQ3C,EAAM,KACd4C,EAAa5C,EAAM,UACnBsD,EAAOtD,EAAM,SACb6D,GAAY7D,EAAOoC,EAAYhE,GAAiB,GAAO,EAAI,EAC3DkD,EAAStB,EAAM,IACfuB,EAAUvB,EAAM,OAChB6B,GAAoB7B,EAAO,GAAMoC,CAAU,EAE3CpI,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,GAErC2D,GAAkB3D,EAAM,OAAS2C,IAAU3I,IAAO,KACrD0J,EAAS,GACT1J,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAC5C6B,GAAoB7B,EAAO,GAAMoC,CAAU,EAC3CyB,GAAY7D,EAAOoC,EAAYhE,GAAiB,GAAO,EAAI,EAC3DoD,EAAYxB,EAAM,QAGhB4D,EACFvC,GAAiBrB,EAAOgB,EAASG,EAAiBG,EAAQC,EAASC,EAAWmB,EAAOC,EAAYU,CAAI,EAC5FI,EACT1C,EAAQ,KAAKK,GAAiBrB,EAAO,KAAMmB,EAAiBG,EAAQC,EAASC,EAAWmB,EAAOC,EAAYU,CAAI,CAAC,EAEhHtC,EAAQ,KAAKO,CAAO,EAGtBM,GAAoB7B,EAAO,GAAMoC,CAAU,EAE3CpI,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,IACTqJ,EAAW,GACXrJ,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,GAE5CqD,EAAW,EAEf,CAEApD,GAAWD,EAAO,uDAAuD,CAC3E,CAEA,SAAS8D,GAAgB9D,EAAOoC,EAAY,CAC1C,IAAII,EACAuB,EACAC,EAAiBxF,GACjByF,EAAiB,GACjBC,EAAiB,GACjBC,EAAiB/B,EACjBgC,EAAiB,EACjBC,EAAiB,GACjBlB,EACAnJ,EAIJ,GAFAA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,IACT+J,EAAU,WACD/J,IAAO,GAChB+J,EAAU,OAEV,OAAO,GAMT,IAHA/D,EAAM,KAAO,SACbA,EAAM,OAAS,GAERhG,IAAO,GAGZ,GAFAA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAExChG,IAAO,IAAeA,IAAO,GAC3BwE,KAAkBwF,EACpBA,EAAYhK,IAAO,GAAe0E,GAAgBD,GAElDwB,GAAWD,EAAO,sCAAsC,WAGhDmD,EAAM3D,GAAgBxF,CAAE,IAAM,EACpCmJ,IAAQ,EACVlD,GAAWD,EAAO,8EAA8E,EACtFkE,EAIVjE,GAAWD,EAAO,2CAA2C,GAH7DmE,EAAa/B,EAAae,EAAM,EAChCe,EAAiB,QAMnB,OAIJ,GAAIhF,GAAelF,CAAE,EAAG,CACtB,GAAKA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,QAC1Cd,GAAelF,CAAE,GAExB,GAAIA,IAAO,GACT,GAAKA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,QAC1C,CAACf,GAAOjF,CAAE,GAAMA,IAAO,EAElC,CAEA,KAAOA,IAAO,GAAG,CAMf,IALA4H,GAAc5B,CAAK,EACnBA,EAAM,WAAa,EAEnBhG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,GAElC,CAACkE,GAAkBlE,EAAM,WAAamE,IACtCnK,IAAO,IACbgG,EAAM,aACNhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAO9C,GAJI,CAACkE,GAAkBlE,EAAM,WAAamE,IACxCA,EAAanE,EAAM,YAGjBf,GAAOjF,CAAE,EAAG,CACdoK,IACA,QACF,CAGA,GAAIpE,EAAM,WAAamE,EAAY,CAG7BH,IAAatF,GACfsB,EAAM,QAAUxK,GAAO,OAAO;AAAA,EAAMyO,EAAiB,EAAIG,EAAaA,CAAU,EACvEJ,IAAaxF,IAClByF,IACFjE,EAAM,QAAU;AAAA,GAKpB,KACF,CAsCA,IAnCI+D,EAGE7E,GAAelF,CAAE,GACnBqK,EAAiB,GAEjBrE,EAAM,QAAUxK,GAAO,OAAO;AAAA,EAAMyO,EAAiB,EAAIG,EAAaA,CAAU,GAGvEC,GACTA,EAAiB,GACjBrE,EAAM,QAAUxK,GAAO,OAAO;AAAA,EAAM4O,EAAa,CAAC,GAGzCA,IAAe,EACpBH,IACFjE,EAAM,QAAU,KAKlBA,EAAM,QAAUxK,GAAO,OAAO;AAAA,EAAM4O,CAAU,EAMhDpE,EAAM,QAAUxK,GAAO,OAAO;AAAA,EAAMyO,EAAiB,EAAIG,EAAaA,CAAU,EAGlFH,EAAiB,GACjBC,EAAiB,GACjBE,EAAa,EACb5B,EAAexC,EAAM,SAEd,CAACf,GAAOjF,CAAE,GAAMA,IAAO,GAC5BA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9CS,GAAeT,EAAOwC,EAAcxC,EAAM,SAAU,EAAK,CAC3D,CAEA,MAAO,EACT,CAEA,SAASsE,GAAkBtE,EAAOoC,EAAY,CAC5C,IAAIO,EACAY,EAAYvD,EAAM,IAClBwD,EAAYxD,EAAM,OAClBgB,EAAY,CAAA,EACZuB,EACAgC,EAAY,GACZvK,EAIJ,GAAIgG,EAAM,iBAAmB,GAAI,MAAO,GAQxC,IANIA,EAAM,SAAW,OACnBA,EAAM,UAAUA,EAAM,MAAM,EAAIgB,GAGlChH,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEnChG,IAAO,IACRgG,EAAM,iBAAmB,KAC3BA,EAAM,SAAWA,EAAM,eACvBC,GAAWD,EAAO,gDAAgD,GAGhE,EAAAhG,IAAO,KAIXuI,EAAYvC,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,EAEjD,CAACb,GAAaoD,CAAS,MAZZ,CAmBf,GAHAgC,EAAW,GACXvE,EAAM,WAEF6B,GAAoB7B,EAAO,GAAM,EAAE,GACjCA,EAAM,YAAcoC,EAAY,CAClCpB,EAAQ,KAAK,IAAI,EACjBhH,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAC1C,QACF,CAUF,GAPA2C,EAAQ3C,EAAM,KACd6D,GAAY7D,EAAOoC,EAAY9D,GAAkB,GAAO,EAAI,EAC5D0C,EAAQ,KAAKhB,EAAM,MAAM,EACzB6B,GAAoB7B,EAAO,GAAM,EAAE,EAEnChG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,GAErCA,EAAM,OAAS2C,GAAS3C,EAAM,WAAaoC,IAAgBpI,IAAO,EACrEiG,GAAWD,EAAO,qCAAqC,UAC9CA,EAAM,WAAaoC,EAC5B,KAEJ,CAEA,OAAImC,GACFvE,EAAM,IAAMuD,EACZvD,EAAM,OAASwD,EACfxD,EAAM,KAAO,WACbA,EAAM,OAASgB,EACR,IAEF,EACT,CAEA,SAASwD,GAAiBxE,EAAOoC,EAAYqC,EAAY,CACvD,IAAIlC,EACAmC,EACA/B,EACAgC,EACAC,EACAC,EACAtB,EAAgBvD,EAAM,IACtBwD,EAAgBxD,EAAM,OACtBgB,EAAgB,CAAA,EAChBG,EAAkB,OAAO,OAAO,IAAI,EACpCG,EAAgB,KAChBC,EAAgB,KAChBC,EAAgB,KAChBsD,EAAgB,GAChBP,EAAgB,GAChBvK,EAIJ,GAAIgG,EAAM,iBAAmB,GAAI,MAAO,GAQxC,IANIA,EAAM,SAAW,OACnBA,EAAM,UAAUA,EAAM,MAAM,EAAIgB,GAGlChH,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEnChG,IAAO,GAAG,CAaf,GAZI,CAAC8K,GAAiB9E,EAAM,iBAAmB,KAC7CA,EAAM,SAAWA,EAAM,eACvBC,GAAWD,EAAO,gDAAgD,GAGpEuC,EAAYvC,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,EACrD2C,EAAQ3C,EAAM,MAMThG,IAAO,IAAeA,IAAO,KAAgBmF,GAAaoD,CAAS,EAElEvI,IAAO,IACL8K,IACFzD,GAAiBrB,EAAOgB,EAASG,EAAiBG,EAAQC,EAAS,KAAMoD,EAAUC,EAAeC,CAAO,EACzGvD,EAASC,EAAUC,EAAY,MAGjC+C,EAAW,GACXO,EAAgB,GAChBJ,EAAe,IAENI,GAETA,EAAgB,GAChBJ,EAAe,IAGfzE,GAAWD,EAAO,mGAAmG,EAGvHA,EAAM,UAAY,EAClBhG,EAAKuI,MAKA,CAKL,GAJAoC,EAAW3E,EAAM,KACjB4E,EAAgB5E,EAAM,UACtB6E,EAAU7E,EAAM,SAEZ,CAAC6D,GAAY7D,EAAOyE,EAAYpG,GAAkB,GAAO,EAAI,EAG/D,MAGF,GAAI2B,EAAM,OAAS2C,EAAO,CAGxB,IAFA3I,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEnCd,GAAelF,CAAE,GACtBA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9C,GAAIhG,IAAO,GACTA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAEvCb,GAAanF,CAAE,GAClBiG,GAAWD,EAAO,yFAAyF,EAGzG8E,IACFzD,GAAiBrB,EAAOgB,EAASG,EAAiBG,EAAQC,EAAS,KAAMoD,EAAUC,EAAeC,CAAO,EACzGvD,EAASC,EAAUC,EAAY,MAGjC+C,EAAW,GACXO,EAAgB,GAChBJ,EAAe,GACfpD,EAAStB,EAAM,IACfuB,EAAUvB,EAAM,eAEPuE,EACTtE,GAAWD,EAAO,0DAA0D,MAG5E,QAAAA,EAAM,IAAMuD,EACZvD,EAAM,OAASwD,EACR,EAGX,SAAWe,EACTtE,GAAWD,EAAO,gFAAgF,MAGlG,QAAAA,EAAM,IAAMuD,EACZvD,EAAM,OAASwD,EACR,EAEX,CA6BA,IAxBIxD,EAAM,OAAS2C,GAAS3C,EAAM,WAAaoC,KACzC0C,IACFH,EAAW3E,EAAM,KACjB4E,EAAgB5E,EAAM,UACtB6E,EAAU7E,EAAM,UAGd6D,GAAY7D,EAAOoC,EAAY7D,GAAmB,GAAMmG,CAAY,IAClEI,EACFvD,EAAUvB,EAAM,OAEhBwB,EAAYxB,EAAM,QAIjB8E,IACHzD,GAAiBrB,EAAOgB,EAASG,EAAiBG,EAAQC,EAASC,EAAWmD,EAAUC,EAAeC,CAAO,EAC9GvD,EAASC,EAAUC,EAAY,MAGjCK,GAAoB7B,EAAO,GAAM,EAAE,EACnChG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,IAGvCA,EAAM,OAAS2C,GAAS3C,EAAM,WAAaoC,IAAgBpI,IAAO,EACrEiG,GAAWD,EAAO,oCAAoC,UAC7CA,EAAM,WAAaoC,EAC5B,KAEJ,CAOA,OAAI0C,GACFzD,GAAiBrB,EAAOgB,EAASG,EAAiBG,EAAQC,EAAS,KAAMoD,EAAUC,EAAeC,CAAO,EAIvGN,IACFvE,EAAM,IAAMuD,EACZvD,EAAM,OAASwD,EACfxD,EAAM,KAAO,UACbA,EAAM,OAASgB,GAGVuD,CACT,CAEA,SAASQ,GAAgB/E,EAAO,CAC9B,IAAIa,EACAmE,EAAa,GACbC,EAAa,GACbC,EACAC,EACAnL,EAIJ,GAFAA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,GAAa,MAAO,GAuB/B,GArBIgG,EAAM,MAAQ,MAChBC,GAAWD,EAAO,+BAA+B,EAGnDhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAExChG,IAAO,IACTgL,EAAa,GACbhL,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,GAEnChG,IAAO,IAChBiL,EAAU,GACVC,EAAY,KACZlL,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,GAG5CkF,EAAY,IAGdrE,EAAYb,EAAM,SAEdgF,EAAY,CACd,GAAKhL,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,QAC1ChG,IAAO,GAAKA,IAAO,IAEtBgG,EAAM,SAAWA,EAAM,QACzBmF,EAAUnF,EAAM,MAAM,MAAMa,EAAWb,EAAM,QAAQ,EACrDhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,GAE5CC,GAAWD,EAAO,oDAAoD,CAE1E,KAAO,CACL,KAAOhG,IAAO,GAAK,CAACmF,GAAanF,CAAE,GAE7BA,IAAO,KACJiL,EAUHhF,GAAWD,EAAO,6CAA6C,GAT/DkF,EAAYlF,EAAM,MAAM,MAAMa,EAAY,EAAGb,EAAM,SAAW,CAAC,EAE1DlB,GAAmB,KAAKoG,CAAS,GACpCjF,GAAWD,EAAO,iDAAiD,EAGrEiF,EAAU,GACVpE,EAAYb,EAAM,SAAW,IAMjChG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9CmF,EAAUnF,EAAM,MAAM,MAAMa,EAAWb,EAAM,QAAQ,EAEjDnB,GAAwB,KAAKsG,CAAO,GACtClF,GAAWD,EAAO,qDAAqD,CAE3E,CAEImF,GAAW,CAACpG,GAAgB,KAAKoG,CAAO,GAC1ClF,GAAWD,EAAO,4CAA8CmF,CAAO,EAGzE,GAAI,CACFA,EAAU,mBAAmBA,CAAO,CACtC,MAAc,CACZlF,GAAWD,EAAO,0BAA4BmF,CAAO,CACvD,CAEA,OAAIH,EACFhF,EAAM,IAAMmF,EAEHhH,GAAkB,KAAK6B,EAAM,OAAQkF,CAAS,EACvDlF,EAAM,IAAMA,EAAM,OAAOkF,CAAS,EAAIC,EAE7BD,IAAc,IACvBlF,EAAM,IAAM,IAAMmF,EAETD,IAAc,KACvBlF,EAAM,IAAM,qBAAuBmF,EAGnClF,GAAWD,EAAO,0BAA4BkF,EAAY,GAAG,EAGxD,EACT,CAEA,SAASE,GAAmBpF,EAAO,CACjC,IAAIa,EACA7G,EAIJ,GAFAA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,GAAa,MAAO,GAS/B,IAPIgG,EAAM,SAAW,MACnBC,GAAWD,EAAO,mCAAmC,EAGvDhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAC5Ca,EAAYb,EAAM,SAEXhG,IAAO,GAAK,CAACmF,GAAanF,CAAE,GAAK,CAACoF,GAAkBpF,CAAE,GAC3DA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9C,OAAIA,EAAM,WAAaa,GACrBZ,GAAWD,EAAO,4DAA4D,EAGhFA,EAAM,OAASA,EAAM,MAAM,MAAMa,EAAWb,EAAM,QAAQ,EACnD,EACT,CAEA,SAASqF,GAAUrF,EAAO,CACxB,IAAIa,EAAWjJ,EACXoC,EAIJ,GAFAA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,GAAa,MAAO,GAK/B,IAHAA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAC5Ca,EAAYb,EAAM,SAEXhG,IAAO,GAAK,CAACmF,GAAanF,CAAE,GAAK,CAACoF,GAAkBpF,CAAE,GAC3DA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9C,OAAIA,EAAM,WAAaa,GACrBZ,GAAWD,EAAO,2DAA2D,EAG/EpI,EAAQoI,EAAM,MAAM,MAAMa,EAAWb,EAAM,QAAQ,EAE9C7B,GAAkB,KAAK6B,EAAM,UAAWpI,CAAK,GAChDqI,GAAWD,EAAO,uBAAyBpI,EAAQ,GAAG,EAGxDoI,EAAM,OAASA,EAAM,UAAUpI,CAAK,EACpCiK,GAAoB7B,EAAO,GAAM,EAAE,EAC5B,EACT,CAEA,SAAS6D,GAAY7D,EAAOsF,EAAcC,EAAaC,EAAad,EAAc,CAChF,IAAIe,EACAC,EACAC,EACAC,EAAe,EACfC,EAAa,GACbC,EAAa,GACbC,EACAC,EACAC,EACAhO,EACAwM,EACAyB,EA6BJ,GA3BIlG,EAAM,WAAa,MACrBA,EAAM,SAAS,OAAQA,CAAK,EAG9BA,EAAM,IAAS,KACfA,EAAM,OAAS,KACfA,EAAM,KAAS,KACfA,EAAM,OAAS,KAEfyF,EAAmBC,EAAoBC,EACrCpH,KAAsBgH,GACtBjH,KAAsBiH,EAEpBC,GACE3D,GAAoB7B,EAAO,GAAM,EAAE,IACrC6F,EAAY,GAER7F,EAAM,WAAasF,EACrBM,EAAe,EACN5F,EAAM,aAAesF,EAC9BM,EAAe,EACN5F,EAAM,WAAasF,IAC5BM,EAAe,KAKjBA,IAAiB,EACnB,KAAOb,GAAgB/E,CAAK,GAAKoF,GAAmBpF,CAAK,GACnD6B,GAAoB7B,EAAO,GAAM,EAAE,GACrC6F,EAAY,GACZF,EAAwBF,EAEpBzF,EAAM,WAAasF,EACrBM,EAAe,EACN5F,EAAM,aAAesF,EAC9BM,EAAe,EACN5F,EAAM,WAAasF,IAC5BM,EAAe,KAGjBD,EAAwB,GAwD9B,GAnDIA,IACFA,EAAwBE,GAAanB,IAGnCkB,IAAiB,GAAKrH,KAAsBgH,KAC1CnH,KAAoBmH,GAAelH,KAAqBkH,EAC1Dd,EAAaa,EAEbb,EAAaa,EAAe,EAG9BY,EAAclG,EAAM,SAAWA,EAAM,UAEjC4F,IAAiB,EACfD,IACCrB,GAAkBtE,EAAOkG,CAAW,GACpC1B,GAAiBxE,EAAOkG,EAAazB,CAAU,IAChDrB,GAAmBpD,EAAOyE,CAAU,EACtCqB,EAAa,IAERJ,GAAqB5B,GAAgB9D,EAAOyE,CAAU,GACvD1B,GAAuB/C,EAAOyE,CAAU,GACxCzB,GAAuBhD,EAAOyE,CAAU,EAC1CqB,EAAa,GAEJT,GAAUrF,CAAK,GACxB8F,EAAa,IAET9F,EAAM,MAAQ,MAAQA,EAAM,SAAW,OACzCC,GAAWD,EAAO,2CAA2C,GAGtDmC,GAAgBnC,EAAOyE,EAAYrG,KAAoBmH,CAAW,IAC3EO,EAAa,GAET9F,EAAM,MAAQ,OAChBA,EAAM,IAAM,MAIZA,EAAM,SAAW,OACnBA,EAAM,UAAUA,EAAM,MAAM,EAAIA,EAAM,SAGjC4F,IAAiB,IAG1BE,EAAaH,GAAyBrB,GAAkBtE,EAAOkG,CAAW,IAI1ElG,EAAM,MAAQ,KACZA,EAAM,SAAW,OACnBA,EAAM,UAAUA,EAAM,MAAM,EAAIA,EAAM,gBAG/BA,EAAM,MAAQ,KAWvB,IAJIA,EAAM,SAAW,MAAQA,EAAM,OAAS,UAC1CC,GAAWD,EAAO,oEAAsEA,EAAM,KAAO,GAAG,EAGrG+F,EAAY,EAAGC,EAAehG,EAAM,cAAc,OAAQ+F,EAAYC,EAAcD,GAAa,EAGpG,GAFA9N,EAAO+H,EAAM,cAAc+F,CAAS,EAEhC9N,EAAK,QAAQ+H,EAAM,MAAM,EAAG,CAC9BA,EAAM,OAAS/H,EAAK,UAAU+H,EAAM,MAAM,EAC1CA,EAAM,IAAM/H,EAAK,IACb+H,EAAM,SAAW,OACnBA,EAAM,UAAUA,EAAM,MAAM,EAAIA,EAAM,QAExC,KACF,UAEOA,EAAM,MAAQ,IAAK,CAC5B,GAAI7B,GAAkB,KAAK6B,EAAM,QAAQA,EAAM,MAAQ,UAAU,EAAGA,EAAM,GAAG,EAC3E/H,EAAO+H,EAAM,QAAQA,EAAM,MAAQ,UAAU,EAAEA,EAAM,GAAG,MAMxD,KAHA/H,EAAO,KACPgO,EAAWjG,EAAM,QAAQ,MAAMA,EAAM,MAAQ,UAAU,EAElD+F,EAAY,EAAGC,EAAeC,EAAS,OAAQF,EAAYC,EAAcD,GAAa,EACzF,GAAI/F,EAAM,IAAI,MAAM,EAAGiG,EAASF,CAAS,EAAE,IAAI,MAAM,IAAME,EAASF,CAAS,EAAE,IAAK,CAClF9N,EAAOgO,EAASF,CAAS,EACzB,KACF,CAIC9N,GACHgI,GAAWD,EAAO,iBAAmBA,EAAM,IAAM,GAAG,EAGlDA,EAAM,SAAW,MAAQ/H,EAAK,OAAS+H,EAAM,MAC/CC,GAAWD,EAAO,gCAAkCA,EAAM,IAAM,wBAA0B/H,EAAK,KAAO,WAAa+H,EAAM,KAAO,GAAG,EAGhI/H,EAAK,QAAQ+H,EAAM,OAAQA,EAAM,GAAG,GAGvCA,EAAM,OAAS/H,EAAK,UAAU+H,EAAM,OAAQA,EAAM,GAAG,EACjDA,EAAM,SAAW,OACnBA,EAAM,UAAUA,EAAM,MAAM,EAAIA,EAAM,SAJxCC,GAAWD,EAAO,gCAAkCA,EAAM,IAAM,gBAAgB,CAOpF,CAEA,OAAIA,EAAM,WAAa,MACrBA,EAAM,SAAS,QAASA,CAAK,EAExBA,EAAM,MAAQ,MAASA,EAAM,SAAW,MAAQ8F,CACzD,CAEA,SAASK,GAAanG,EAAO,CAC3B,IAAIoG,EAAgBpG,EAAM,SACtBa,EACAwF,EACAC,EACAC,EAAgB,GAChBvM,EAOJ,IALAgG,EAAM,QAAU,KAChBA,EAAM,gBAAkBA,EAAM,OAC9BA,EAAM,OAAS,OAAO,OAAO,IAAI,EACjCA,EAAM,UAAY,OAAO,OAAO,IAAI,GAE5BhG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,KAAO,IACvD6B,GAAoB7B,EAAO,GAAM,EAAE,EAEnChG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtC,EAAAA,EAAM,WAAa,GAAKhG,IAAO,MALuB,CAa1D,IAJAuM,EAAgB,GAChBvM,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAC5Ca,EAAYb,EAAM,SAEXhG,IAAO,GAAK,CAACmF,GAAanF,CAAE,GACjCA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAU9C,IAPAqG,EAAgBrG,EAAM,MAAM,MAAMa,EAAWb,EAAM,QAAQ,EAC3DsG,EAAgB,CAAA,EAEZD,EAAc,OAAS,GACzBpG,GAAWD,EAAO,8DAA8D,EAG3EhG,IAAO,GAAG,CACf,KAAOkF,GAAelF,CAAE,GACtBA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9C,GAAIhG,IAAO,GAAa,CACtB,GAAKA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,QAC1ChG,IAAO,GAAK,CAACiF,GAAOjF,CAAE,GAC7B,KACF,CAEA,GAAIiF,GAAOjF,CAAE,EAAG,MAIhB,IAFA6G,EAAYb,EAAM,SAEXhG,IAAO,GAAK,CAACmF,GAAanF,CAAE,GACjCA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9CsG,EAAc,KAAKtG,EAAM,MAAM,MAAMa,EAAWb,EAAM,QAAQ,CAAC,CACjE,CAEIhG,IAAO,GAAG4H,GAAc5B,CAAK,EAE7B7B,GAAkB,KAAKgC,GAAmBkG,CAAa,EACzDlG,GAAkBkG,CAAa,EAAErG,EAAOqG,EAAeC,CAAa,EAEpEpG,GAAaF,EAAO,+BAAiCqG,EAAgB,GAAG,CAE5E,CAyBA,GAvBAxE,GAAoB7B,EAAO,GAAM,EAAE,EAE/BA,EAAM,aAAe,GACrBA,EAAM,MAAM,WAAWA,EAAM,QAAQ,IAAU,IAC/CA,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,IAAM,IAC/CA,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,IAAM,IACjDA,EAAM,UAAY,EAClB6B,GAAoB7B,EAAO,GAAM,EAAE,GAE1BuG,GACTtG,GAAWD,EAAO,iCAAiC,EAGrD6D,GAAY7D,EAAOA,EAAM,WAAa,EAAGzB,GAAmB,GAAO,EAAI,EACvEsD,GAAoB7B,EAAO,GAAM,EAAE,EAE/BA,EAAM,iBACNpB,GAA8B,KAAKoB,EAAM,MAAM,MAAMoG,EAAepG,EAAM,QAAQ,CAAC,GACrFE,GAAaF,EAAO,kDAAkD,EAGxEA,EAAM,UAAU,KAAKA,EAAM,MAAM,EAE7BA,EAAM,WAAaA,EAAM,WAAaiC,GAAsBjC,CAAK,EAAG,CAElEA,EAAM,MAAM,WAAWA,EAAM,QAAQ,IAAM,KAC7CA,EAAM,UAAY,EAClB6B,GAAoB7B,EAAO,GAAM,EAAE,GAErC,MACF,CAEA,GAAIA,EAAM,SAAYA,EAAM,OAAS,EACnCC,GAAWD,EAAO,uDAAuD,MAEzE,OAEJ,CAGA,SAASwG,GAAc7J,EAAO9F,EAAS,CACrC8F,EAAQ,OAAOA,CAAK,EACpB9F,EAAUA,GAAW,CAAA,EAEjB8F,EAAM,SAAW,IAGfA,EAAM,WAAWA,EAAM,OAAS,CAAC,IAAM,IACvCA,EAAM,WAAWA,EAAM,OAAS,CAAC,IAAM,KACzCA,GAAS;AAAA,GAIPA,EAAM,WAAW,CAAC,IAAM,QAC1BA,EAAQA,EAAM,MAAM,CAAC,IAIzB,IAAIqD,EAAQ,IAAIF,GAAQnD,EAAO9F,CAAO,EAElC4P,EAAU9J,EAAM,QAAQ,IAAI,EAUhC,IARI8J,IAAY,KACdzG,EAAM,SAAWyG,EACjBxG,GAAWD,EAAO,mCAAmC,GAIvDA,EAAM,OAAS,KAERA,EAAM,MAAM,WAAWA,EAAM,QAAQ,IAAM,IAChDA,EAAM,YAAc,EACpBA,EAAM,UAAY,EAGpB,KAAOA,EAAM,SAAYA,EAAM,OAAS,GACtCmG,GAAanG,CAAK,EAGpB,OAAOA,EAAM,SACf,CAqBA,SAAS0G,GAAO/J,EAAO9F,EAAS,CAC9B,IAAI8P,EAAYH,GAAc7J,EAAO9F,CAAO,EAE5C,GAAI8P,EAAU,SAAW,EAGlB,IAAIA,EAAU,SAAW,EAC9B,OAAOA,EAAU,CAAC,EAEpB,MAAM,IAAIjR,GAAU,0DAA0D,EAChF,CAIA,IAAIkR,GAAYF,GAEZG,GAAS,CAEZ,KAAMD,EACP,EAw9BIE,GAAsBD,GAAO,KCnuH7B3Q,GAAS,CAAA,EAET6Q,GAAW,CAAA,EAEfA,GAAS,WAAaC,GACtBD,GAAS,YAAcE,GACvBF,GAAS,cAAgBG,GAEzB,IAAIC,GAAS,CAAA,EACTC,GAAY,CAAA,EACZC,GAAM,OAAO,WAAe,IAAc,WAAa,MAEvD/K,GAAO,mEACX,QAASnF,GAAI,EAAGmQ,GAAMhL,GAAK,OAAQnF,GAAImQ,GAAK,EAAEnQ,GAC5CgQ,GAAOhQ,EAAC,EAAImF,GAAKnF,EAAC,EAClBiQ,GAAU9K,GAAK,WAAWnF,EAAC,CAAC,EAAIA,GAKlCiQ,GAAU,EAAiB,EAAI,GAC/BA,GAAU,EAAiB,EAAI,GAE/B,SAASG,GAASC,EAAK,CACrB,IAAIF,EAAME,EAAI,OAEd,GAAIF,EAAM,EAAI,EACZ,MAAM,IAAI,MAAM,gDAAgD,EAKlE,IAAIG,EAAWD,EAAI,QAAQ,GAAG,EAC1BC,IAAa,KAAIA,EAAWH,GAEhC,IAAII,EAAkBD,IAAaH,EAC/B,EACA,EAAKG,EAAW,EAEpB,MAAO,CAACA,EAAUC,CAAe,CACnC,CAGA,SAASV,GAAYQ,EAAK,CACxB,IAAIG,EAAOJ,GAAQC,CAAG,EAClBC,EAAWE,EAAK,CAAC,EACjBD,EAAkBC,EAAK,CAAC,EAC5B,OAASF,EAAWC,GAAmB,EAAI,EAAKA,CAClD,CAEA,SAASE,GAAaJ,EAAKC,EAAUC,EAAiB,CACpD,OAASD,EAAWC,GAAmB,EAAI,EAAKA,CAClD,CAEA,SAAST,GAAaO,EAAK,CACzB,IAAIrE,EACAwE,EAAOJ,GAAQC,CAAG,EAClBC,EAAWE,EAAK,CAAC,EACjBD,EAAkBC,EAAK,CAAC,EAExBE,EAAM,IAAIR,GAAIO,GAAYJ,EAAKC,EAAUC,CAAe,CAAC,EAEzDI,EAAU,EAGVR,EAAMI,EAAkB,EACxBD,EAAW,EACXA,EAEAtQ,EACJ,IAAKA,EAAI,EAAGA,EAAImQ,EAAKnQ,GAAK,EACxBgM,EACGiE,GAAUI,EAAI,WAAWrQ,CAAC,CAAC,GAAK,GAChCiQ,GAAUI,EAAI,WAAWrQ,EAAI,CAAC,CAAC,GAAK,GACpCiQ,GAAUI,EAAI,WAAWrQ,EAAI,CAAC,CAAC,GAAK,EACrCiQ,GAAUI,EAAI,WAAWrQ,EAAI,CAAC,CAAC,EACjC0Q,EAAIC,GAAS,EAAK3E,GAAO,GAAM,IAC/B0E,EAAIC,GAAS,EAAK3E,GAAO,EAAK,IAC9B0E,EAAIC,GAAS,EAAI3E,EAAM,IAGzB,OAAIuE,IAAoB,IACtBvE,EACGiE,GAAUI,EAAI,WAAWrQ,CAAC,CAAC,GAAK,EAChCiQ,GAAUI,EAAI,WAAWrQ,EAAI,CAAC,CAAC,GAAK,EACvC0Q,EAAIC,GAAS,EAAI3E,EAAM,KAGrBuE,IAAoB,IACtBvE,EACGiE,GAAUI,EAAI,WAAWrQ,CAAC,CAAC,GAAK,GAChCiQ,GAAUI,EAAI,WAAWrQ,EAAI,CAAC,CAAC,GAAK,EACpCiQ,GAAUI,EAAI,WAAWrQ,EAAI,CAAC,CAAC,GAAK,EACvC0Q,EAAIC,GAAS,EAAK3E,GAAO,EAAK,IAC9B0E,EAAIC,GAAS,EAAI3E,EAAM,KAGlB0E,CACT,CAEA,SAASE,GAAiBC,EAAK,CAC7B,OAAOb,GAAOa,GAAO,GAAK,EAAI,EAC5Bb,GAAOa,GAAO,GAAK,EAAI,EACvBb,GAAOa,GAAO,EAAI,EAAI,EACtBb,GAAOa,EAAM,EAAI,CACrB,CAEA,SAASC,GAAaC,EAAOxH,EAAOC,EAAK,CAGvC,QAFIwC,EACAgF,EAAS,CAAA,EACJhR,EAAIuJ,EAAOvJ,EAAIwJ,EAAKxJ,GAAK,EAChCgM,GACI+E,EAAM/Q,CAAC,GAAK,GAAM,WAClB+Q,EAAM/Q,EAAI,CAAC,GAAK,EAAK,QACtB+Q,EAAM/Q,EAAI,CAAC,EAAI,KAClBgR,EAAO,KAAKJ,GAAgB5E,CAAG,CAAC,EAElC,OAAOgF,EAAO,KAAK,EAAE,CACvB,CAEA,SAASjB,GAAegB,EAAO,CAQ7B,QAPI/E,EACAmE,EAAMY,EAAM,OACZE,EAAad,EAAM,EACnBe,EAAQ,CAAA,EACRC,EAAiB,MAGZ,EAAI,EAAGC,EAAOjB,EAAMc,EAAY,EAAIG,EAAM,GAAKD,EACtDD,EAAM,KAAKJ,GAAYC,EAAO,EAAI,EAAII,EAAkBC,EAAOA,EAAQ,EAAID,CAAe,CAAC,EAI7F,OAAIF,IAAe,GACjBjF,EAAM+E,EAAMZ,EAAM,CAAC,EACnBe,EAAM,KACJlB,GAAOhE,GAAO,CAAC,EACfgE,GAAQhE,GAAO,EAAK,EAAI,EACxB,IACN,GACaiF,IAAe,IACxBjF,GAAO+E,EAAMZ,EAAM,CAAC,GAAK,GAAKY,EAAMZ,EAAM,CAAC,EAC3Ce,EAAM,KACJlB,GAAOhE,GAAO,EAAE,EAChBgE,GAAQhE,GAAO,EAAK,EAAI,EACxBgE,GAAQhE,GAAO,EAAK,EAAI,EACxB,GACN,GAGSkF,EAAM,KAAK,EAAE,CACtB,CAEA,IAAIG,GAAU,CAAA,EAEd,yFAEAA,GAAQ,KAAO,SAAUtS,EAAQuS,EAAQC,EAAMC,EAAMC,EAAQ,CAC3D,IAAIrX,EAAGK,EACHiX,EAAQD,EAAS,EAAKD,EAAO,EAC7BG,GAAQ,GAAKD,GAAQ,EACrBE,EAAQD,GAAQ,EAChBE,EAAQ,GACR7R,EAAIuR,EAAQE,EAAS,EAAK,EAC1BtX,EAAIoX,EAAO,GAAK,EAChBO,EAAI/S,EAAOuS,EAAStR,CAAC,EAOzB,IALAA,GAAK7F,EAELC,EAAI0X,GAAM,GAAM,CAACD,GAAU,EAC3BC,IAAO,CAACD,EACRA,GAASH,EACFG,EAAQ,EAAGzX,EAAKA,EAAI,IAAO2E,EAAOuS,EAAStR,CAAC,EAAGA,GAAK7F,EAAG0X,GAAS,EAAG,CAK1E,IAHApX,EAAIL,GAAM,GAAM,CAACyX,GAAU,EAC3BzX,IAAO,CAACyX,EACRA,GAASL,EACFK,EAAQ,EAAGpX,EAAKA,EAAI,IAAOsE,EAAOuS,EAAStR,CAAC,EAAGA,GAAK7F,EAAG0X,GAAS,EAAG,CAE1E,GAAIzX,IAAM,EACRA,EAAI,EAAIwX,MACH,IAAIxX,IAAMuX,EACf,OAAOlX,EAAI,KAAQqX,EAAI,GAAK,GAAK,MAEjCrX,EAAIA,EAAI,KAAK,IAAI,EAAG+W,CAAI,EACxBpX,EAAIA,EAAIwX,EAEV,OAAQE,EAAI,GAAK,GAAKrX,EAAI,KAAK,IAAI,EAAGL,EAAIoX,CAAI,CAChD,EAEAH,GAAQ,MAAQ,SAAUtS,EAAQgE,EAAOuO,EAAQC,EAAMC,EAAMC,EAAQ,CACnE,IAAIrX,EAAGK,EAAGP,EACNwX,EAAQD,EAAS,EAAKD,EAAO,EAC7BG,GAAQ,GAAKD,GAAQ,EACrBE,EAAQD,GAAQ,EAChBI,EAAMP,IAAS,GAAK,KAAK,IAAI,EAAG,GAAG,EAAI,KAAK,IAAI,EAAG,GAAG,EAAI,EAC1DxR,EAAIuR,EAAO,EAAKE,EAAS,EACzBtX,EAAIoX,EAAO,EAAI,GACfO,EAAI/O,EAAQ,GAAMA,IAAU,GAAK,EAAIA,EAAQ,EAAK,EAAI,EAmC1D,IAjCAA,EAAQ,KAAK,IAAIA,CAAK,EAElB,MAAMA,CAAK,GAAKA,IAAU,KAC5BtI,EAAI,MAAMsI,CAAK,EAAI,EAAI,EACvB3I,EAAIuX,IAEJvX,EAAI,KAAK,MAAM,KAAK,IAAI2I,CAAK,EAAI,KAAK,GAAG,EACrCA,GAAS7I,EAAI,KAAK,IAAI,EAAG,CAACE,CAAC,GAAK,IAClCA,IACAF,GAAK,GAEHE,EAAIwX,GAAS,EACf7O,GAASgP,EAAK7X,EAEd6I,GAASgP,EAAK,KAAK,IAAI,EAAG,EAAIH,CAAK,EAEjC7O,EAAQ7I,GAAK,IACfE,IACAF,GAAK,GAGHE,EAAIwX,GAASD,GACflX,EAAI,EACJL,EAAIuX,GACKvX,EAAIwX,GAAS,GACtBnX,GAAMsI,EAAQ7I,EAAK,GAAK,KAAK,IAAI,EAAGsX,CAAI,EACxCpX,EAAIA,EAAIwX,IAERnX,EAAIsI,EAAQ,KAAK,IAAI,EAAG6O,EAAQ,CAAC,EAAI,KAAK,IAAI,EAAGJ,CAAI,EACrDpX,EAAI,IAIDoX,GAAQ,EAAGzS,EAAOuS,EAAStR,CAAC,EAAIvF,EAAI,IAAMuF,GAAK7F,EAAGM,GAAK,IAAK+W,GAAQ,EAAG,CAI9E,IAFApX,EAAKA,GAAKoX,EAAQ/W,EAClBiX,GAAQF,EACDE,EAAO,EAAG3S,EAAOuS,EAAStR,CAAC,EAAI5F,EAAI,IAAM4F,GAAK7F,EAAGC,GAAK,IAAKsX,GAAQ,EAAG,CAE7E3S,EAAOuS,EAAStR,EAAI7F,CAAC,GAAK2X,EAAI,GAChC,EAEA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOC,SAAUhX,EAAS,CAEnB,MAAMkX,EAASpC,GACTqC,EAAYZ,GACZa,EACH,OAAO,QAAW,YAAc,OAAO,OAAO,KAAW,WACtD,OAAO,IAAO,4BAA4B,EAC1C,KAENpX,EAAQ,OAASqX,EACjBrX,EAAQ,WAAasX,EACrBtX,EAAQ,kBAAoB,GAE5B,MAAMuX,EAAe,WACrBvX,EAAQ,WAAauX,EACrB,KAAM,CAAE,WAAYC,EAAkB,YAAaC,EAAmB,kBAAmBC,CAAuB,EAAK,WAgBrHL,EAAO,oBAAsBM,EAAiB,EAE1C,CAACN,EAAO,qBAAuB,OAAO,QAAY,KAClD,OAAO,QAAQ,OAAU,YAC3B,QAAQ,MACN,+IAEL,EAGC,SAASM,GAAqB,CAE5B,GAAI,CACF,MAAM/B,EAAM,IAAI4B,EAAiB,CAAC,EAC5BI,EAAQ,CAAE,IAAK,UAAY,CAAE,MAAO,GAAG,CAAC,EAC9C,cAAO,eAAeA,EAAOJ,EAAiB,SAAS,EACvD,OAAO,eAAe5B,EAAKgC,CAAK,EACzBhC,EAAI,QAAU,EACvB,MAAY,CACV,MAAO,EACT,CACF,CAEA,OAAO,eAAeyB,EAAO,UAAW,SAAU,CAChD,WAAY,GACZ,IAAK,UAAY,CACf,GAAKA,EAAO,SAAS,IAAI,EACzB,OAAO,KAAK,MACd,CACH,CAAE,EAED,OAAO,eAAeA,EAAO,UAAW,SAAU,CAChD,WAAY,GACZ,IAAK,UAAY,CACf,GAAKA,EAAO,SAAS,IAAI,EACzB,OAAO,KAAK,UACd,CACH,CAAE,EAED,SAASQ,EAActV,EAAQ,CAC7B,GAAIA,EAASgV,EACX,MAAM,IAAI,WAAW,cAAgBhV,EAAS,gCAAgC,EAGhF,MAAMuV,EAAM,IAAIN,EAAiBjV,CAAM,EACvC,cAAO,eAAeuV,EAAKT,EAAO,SAAS,EACpCS,CACT,CAYA,SAAST,EAAQU,EAAKC,EAAkBzV,EAAQ,CAE9C,GAAI,OAAOwV,GAAQ,SAAU,CAC3B,GAAI,OAAOC,GAAqB,SAC9B,MAAM,IAAI,UACR,oEACT,EAEK,OAAOC,EAAYF,CAAG,CACxB,CACA,OAAOG,EAAKH,EAAKC,EAAkBzV,CAAM,CAC3C,CAEA8U,EAAO,SAAW,KAElB,SAASa,EAAMjQ,EAAO+P,EAAkBzV,EAAQ,CAC9C,GAAI,OAAO0F,GAAU,SACnB,OAAOkQ,EAAWlQ,EAAO+P,CAAgB,EAG3C,GAAIP,EAAkB,OAAOxP,CAAK,EAChC,OAAOmQ,EAAcnQ,CAAK,EAG5B,GAAIA,GAAS,KACX,MAAM,IAAI,UACR,kHAC0C,OAAOA,CACxD,EAQG,GALIoQ,GAAWpQ,EAAOwP,CAAiB,GAClCxP,GAASoQ,GAAWpQ,EAAM,OAAQwP,CAAiB,GAIpD,OAAOC,EAA4B,MAClCW,GAAWpQ,EAAOyP,CAAuB,GACzCzP,GAASoQ,GAAWpQ,EAAM,OAAQyP,CAAuB,GAC5D,OAAOY,EAAgBrQ,EAAO+P,EAAkBzV,CAAM,EAGxD,GAAI,OAAO0F,GAAU,SACnB,MAAM,IAAI,UACR,uEACP,EAGG,MAAMsQ,EAAUtQ,EAAM,SAAWA,EAAM,QAAO,EAC9C,GAAIsQ,GAAW,MAAQA,IAAYtQ,EACjC,OAAOoP,EAAO,KAAKkB,EAASP,EAAkBzV,CAAM,EAGtD,MAAMpD,EAAIqZ,EAAWvQ,CAAK,EAC1B,GAAI9I,EAAG,OAAOA,EAEd,GAAI,OAAO,OAAW,KAAe,OAAO,aAAe,MACvD,OAAO8I,EAAM,OAAO,WAAW,GAAM,WACvC,OAAOoP,EAAO,KAAKpP,EAAM,OAAO,WAAW,EAAE,QAAQ,EAAG+P,EAAkBzV,CAAM,EAGlF,MAAM,IAAI,UACR,kHAC0C,OAAO0F,CACtD,CACC,CAUAoP,EAAO,KAAO,SAAUpP,EAAO+P,EAAkBzV,EAAQ,CACvD,OAAO2V,EAAKjQ,EAAO+P,EAAkBzV,CAAM,CAC7C,EAIA,OAAO,eAAe8U,EAAO,UAAWG,EAAiB,SAAS,EAClE,OAAO,eAAeH,EAAQG,CAAgB,EAE9C,SAASiB,EAAYC,EAAM,CACzB,GAAI,OAAOA,GAAS,SAClB,MAAM,IAAI,UAAU,wCAAwC,EACvD,GAAIA,EAAO,EAChB,MAAM,IAAI,WAAW,cAAgBA,EAAO,gCAAgC,CAEhF,CAEA,SAASC,EAAOD,EAAME,EAAMC,EAAU,CAEpC,OADAJ,EAAWC,CAAI,EACXA,GAAQ,EACHb,EAAaa,CAAI,EAEtBE,IAAS,OAIJ,OAAOC,GAAa,SACvBhB,EAAaa,CAAI,EAAE,KAAKE,EAAMC,CAAQ,EACtChB,EAAaa,CAAI,EAAE,KAAKE,CAAI,EAE3Bf,EAAaa,CAAI,CAC1B,CAMArB,EAAO,MAAQ,SAAUqB,EAAME,EAAMC,EAAU,CAC7C,OAAOF,EAAMD,EAAME,EAAMC,CAAQ,CACnC,EAEA,SAASZ,EAAaS,EAAM,CAC1B,OAAAD,EAAWC,CAAI,EACRb,EAAaa,EAAO,EAAI,EAAII,EAAQJ,CAAI,EAAI,CAAC,CACtD,CAKArB,EAAO,YAAc,SAAUqB,EAAM,CACnC,OAAOT,EAAYS,CAAI,CACzB,EAIArB,EAAO,gBAAkB,SAAUqB,EAAM,CACvC,OAAOT,EAAYS,CAAI,CACzB,EAEA,SAASP,EAAYxV,EAAQkW,EAAU,CAKrC,IAJI,OAAOA,GAAa,UAAYA,IAAa,MAC/CA,EAAW,QAGT,CAACxB,EAAO,WAAWwB,CAAQ,EAC7B,MAAM,IAAI,UAAU,qBAAuBA,CAAQ,EAGrD,MAAMtW,EAASwS,EAAWpS,EAAQkW,CAAQ,EAAI,EAC9C,IAAIf,EAAMD,EAAatV,CAAM,EAE7B,MAAMwW,EAASjB,EAAI,MAAMnV,EAAQkW,CAAQ,EAEzC,OAAIE,IAAWxW,IAIbuV,EAAMA,EAAI,MAAM,EAAGiB,CAAM,GAGpBjB,CACT,CAEA,SAASkB,EAAeC,EAAO,CAC7B,MAAM1W,EAAS0W,EAAM,OAAS,EAAI,EAAIH,EAAQG,EAAM,MAAM,EAAI,EACxDnB,EAAMD,EAAatV,CAAM,EAC/B,QAAS2C,EAAI,EAAGA,EAAI3C,EAAQ2C,GAAK,EAC/B4S,EAAI5S,CAAC,EAAI+T,EAAM/T,CAAC,EAAI,IAEtB,OAAO4S,CACT,CAEA,SAASM,EAAec,EAAW,CACjC,GAAIb,GAAWa,EAAW1B,CAAgB,EAAG,CAC3C,MAAM2B,EAAO,IAAI3B,EAAiB0B,CAAS,EAC3C,OAAOZ,EAAgBa,EAAK,OAAQA,EAAK,WAAYA,EAAK,UAAU,CACtE,CACA,OAAOH,EAAcE,CAAS,CAChC,CAEA,SAASZ,EAAiBW,EAAOG,EAAY7W,EAAQ,CACnD,GAAI6W,EAAa,GAAKH,EAAM,WAAaG,EACvC,MAAM,IAAI,WAAW,sCAAsC,EAG7D,GAAIH,EAAM,WAAaG,GAAc7W,GAAU,GAC7C,MAAM,IAAI,WAAW,sCAAsC,EAG7D,IAAIuV,EACJ,OAAIsB,IAAe,QAAa7W,IAAW,OACzCuV,EAAM,IAAIN,EAAiByB,CAAK,EACvB1W,IAAW,OACpBuV,EAAM,IAAIN,EAAiByB,EAAOG,CAAU,EAE5CtB,EAAM,IAAIN,EAAiByB,EAAOG,EAAY7W,CAAM,EAItD,OAAO,eAAeuV,EAAKT,EAAO,SAAS,EAEpCS,CACT,CAEA,SAASU,EAAYnQ,EAAK,CACxB,GAAIgP,EAAO,SAAShP,CAAG,EAAG,CACxB,MAAMgN,EAAMyD,EAAQzQ,EAAI,MAAM,EAAI,EAC5ByP,EAAMD,EAAaxC,CAAG,EAE5B,OAAIyC,EAAI,SAAW,GAInBzP,EAAI,KAAKyP,EAAK,EAAG,EAAGzC,CAAG,EAChByC,CACT,CAEA,GAAIzP,EAAI,SAAW,OACjB,OAAI,OAAOA,EAAI,QAAW,UAAYgR,GAAYhR,EAAI,MAAM,EACnDwP,EAAa,CAAC,EAEhBmB,EAAc3Q,CAAG,EAG1B,GAAIA,EAAI,OAAS,UAAY,MAAM,QAAQA,EAAI,IAAI,EACjD,OAAO2Q,EAAc3Q,EAAI,IAAI,CAEjC,CAEA,SAASyQ,EAASvW,EAAQ,CAGxB,GAAIA,GAAUgV,EACZ,MAAM,IAAI,WAAW,0DACaA,EAAa,SAAS,EAAE,EAAI,QAAQ,EAExE,OAAOhV,EAAS,CAClB,CAEA,SAAS+U,EAAY/U,EAAQ,CAC3B,MAAI,CAACA,GAAUA,IACbA,EAAS,GAEJ8U,EAAO,MAAM,CAAC9U,CAAM,CAC7B,CAEA8U,EAAO,SAAW,SAAmBlY,EAAG,CACtC,OAAOA,GAAK,MAAQA,EAAE,YAAc,IAClCA,IAAMkY,EAAO,SACjB,EAEAA,EAAO,QAAU,SAAkBnY,EAAGC,EAAG,CAGvC,GAFIkZ,GAAWnZ,EAAGsY,CAAgB,IAAGtY,EAAImY,EAAO,KAAKnY,EAAGA,EAAE,OAAQA,EAAE,UAAU,GAC1EmZ,GAAWlZ,EAAGqY,CAAgB,IAAGrY,EAAIkY,EAAO,KAAKlY,EAAGA,EAAE,OAAQA,EAAE,UAAU,GAC1E,CAACkY,EAAO,SAASnY,CAAC,GAAK,CAACmY,EAAO,SAASlY,CAAC,EAC3C,MAAM,IAAI,UACR,uEACP,EAGG,GAAID,IAAMC,EAAG,MAAO,GAEpB,IAAIW,EAAIZ,EAAE,OACNoB,EAAInB,EAAE,OAEV,QAAS+F,EAAI,EAAGmQ,EAAM,KAAK,IAAIvV,EAAGQ,CAAC,EAAG4E,EAAImQ,EAAK,EAAEnQ,EAC/C,GAAIhG,EAAEgG,CAAC,IAAM/F,EAAE+F,CAAC,EAAG,CACjBpF,EAAIZ,EAAEgG,CAAC,EACP5E,EAAInB,EAAE+F,CAAC,EACP,KACF,CAGF,OAAIpF,EAAIQ,EAAU,GACdA,EAAIR,EAAU,EACX,CACT,EAEAuX,EAAO,WAAa,SAAqBwB,EAAU,CACjD,OAAQ,OAAOA,CAAQ,EAAE,YAAW,EAAE,CACpC,IAAK,MACL,IAAK,OACL,IAAK,QACL,IAAK,QACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,MAAO,GACT,QACE,MAAO,EACd,CACC,EAEAxB,EAAO,OAAS,SAAiBiC,EAAM/W,EAAQ,CAC7C,GAAI,CAAC,MAAM,QAAQ+W,CAAI,EACrB,MAAM,IAAI,UAAU,6CAA6C,EAGnE,GAAIA,EAAK,SAAW,EAClB,OAAOjC,EAAO,MAAM,CAAC,EAGvB,IAAInS,EACJ,GAAI3C,IAAW,OAEb,IADAA,EAAS,EACJ2C,EAAI,EAAGA,EAAIoU,EAAK,OAAQ,EAAEpU,EAC7B3C,GAAU+W,EAAKpU,CAAC,EAAE,OAItB,MAAMjB,EAASoT,EAAO,YAAY9U,CAAM,EACxC,IAAIgX,EAAM,EACV,IAAKrU,EAAI,EAAGA,EAAIoU,EAAK,OAAQ,EAAEpU,EAAG,CAChC,IAAI4S,EAAMwB,EAAKpU,CAAC,EAChB,GAAImT,GAAWP,EAAKN,CAAgB,EAC9B+B,EAAMzB,EAAI,OAAS7T,EAAO,QACvBoT,EAAO,SAASS,CAAG,IAAGA,EAAMT,EAAO,KAAKS,CAAG,GAChDA,EAAI,KAAK7T,EAAQsV,CAAG,GAEpB/B,EAAiB,UAAU,IAAI,KAC7BvT,EACA6T,EACAyB,CACX,UAEiBlC,EAAO,SAASS,CAAG,EAG7BA,EAAI,KAAK7T,EAAQsV,CAAG,MAFpB,OAAM,IAAI,UAAU,6CAA6C,EAInEA,GAAOzB,EAAI,MACb,CACA,OAAO7T,CACT,EAEA,SAAS8Q,EAAYpS,EAAQkW,EAAU,CACrC,GAAIxB,EAAO,SAAS1U,CAAM,EACxB,OAAOA,EAAO,OAEhB,GAAI8U,EAAkB,OAAO9U,CAAM,GAAK0V,GAAW1V,EAAQ8U,CAAiB,EAC1E,OAAO9U,EAAO,WAEhB,GAAI,OAAOA,GAAW,SACpB,MAAM,IAAI,UACR,2FACmB,OAAOA,CACjC,EAGG,MAAM0S,EAAM1S,EAAO,OACb6W,EAAa,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,GAC5D,GAAI,CAACA,GAAanE,IAAQ,EAAG,MAAO,GAGpC,IAAIoE,EAAc,GAClB,OACE,OAAQZ,EAAQ,CACd,IAAK,QACL,IAAK,SACL,IAAK,SACH,OAAOxD,EACT,IAAK,OACL,IAAK,QACH,OAAOqE,GAAY/W,CAAM,EAAE,OAC7B,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAO0S,EAAM,EACf,IAAK,MACH,OAAOA,IAAQ,EACjB,IAAK,SACH,OAAOsE,GAAchX,CAAM,EAAE,OAC/B,QACE,GAAI8W,EACF,OAAOD,EAAY,GAAKE,GAAY/W,CAAM,EAAE,OAE9CkW,GAAY,GAAKA,GAAU,YAAW,EACtCY,EAAc,EACvB,CAEC,CACApC,EAAO,WAAatC,EAEpB,SAAS6E,EAAcf,EAAUpK,EAAOC,EAAK,CAC3C,IAAI+K,EAAc,GA8BlB,IArBIhL,IAAU,QAAaA,EAAQ,KACjCA,EAAQ,GAINA,EAAQ,KAAK,UAIbC,IAAQ,QAAaA,EAAM,KAAK,UAClCA,EAAM,KAAK,QAGTA,GAAO,KAKXA,KAAS,EACTD,KAAW,EAEPC,GAAOD,GACT,MAAO,GAKT,IAFKoK,IAAUA,EAAW,UAGxB,OAAQA,EAAQ,CACd,IAAK,MACH,OAAOgB,EAAS,KAAMpL,EAAOC,CAAG,EAElC,IAAK,OACL,IAAK,QACH,OAAOoL,EAAU,KAAMrL,EAAOC,CAAG,EAEnC,IAAK,QACH,OAAOqL,EAAW,KAAMtL,EAAOC,CAAG,EAEpC,IAAK,SACL,IAAK,SACH,OAAOsL,EAAY,KAAMvL,EAAOC,CAAG,EAErC,IAAK,SACH,OAAOuL,EAAY,KAAMxL,EAAOC,CAAG,EAErC,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAOwL,EAAa,KAAMzL,EAAOC,CAAG,EAEtC,QACE,GAAI+K,EAAa,MAAM,IAAI,UAAU,qBAAuBZ,CAAQ,EACpEA,GAAYA,EAAW,IAAI,YAAW,EACtCY,EAAc,EACvB,CAEC,CAQApC,EAAO,UAAU,UAAY,GAE7B,SAAS8C,EAAM,EAAGta,EAAGF,EAAG,CACtB,MAAMuF,EAAI,EAAErF,CAAC,EACb,EAAEA,CAAC,EAAI,EAAEF,CAAC,EACV,EAAEA,CAAC,EAAIuF,CACT,CAEAmS,EAAO,UAAU,OAAS,UAAmB,CAC3C,MAAMhC,EAAM,KAAK,OACjB,GAAIA,EAAM,IAAM,EACd,MAAM,IAAI,WAAW,2CAA2C,EAElE,QAASnQ,EAAI,EAAGA,EAAImQ,EAAKnQ,GAAK,EAC5BiV,EAAK,KAAMjV,EAAGA,EAAI,CAAC,EAErB,OAAO,IACT,EAEAmS,EAAO,UAAU,OAAS,UAAmB,CAC3C,MAAMhC,EAAM,KAAK,OACjB,GAAIA,EAAM,IAAM,EACd,MAAM,IAAI,WAAW,2CAA2C,EAElE,QAASnQ,EAAI,EAAGA,EAAImQ,EAAKnQ,GAAK,EAC5BiV,EAAK,KAAMjV,EAAGA,EAAI,CAAC,EACnBiV,EAAK,KAAMjV,EAAI,EAAGA,EAAI,CAAC,EAEzB,OAAO,IACT,EAEAmS,EAAO,UAAU,OAAS,UAAmB,CAC3C,MAAMhC,EAAM,KAAK,OACjB,GAAIA,EAAM,IAAM,EACd,MAAM,IAAI,WAAW,2CAA2C,EAElE,QAASnQ,EAAI,EAAGA,EAAImQ,EAAKnQ,GAAK,EAC5BiV,EAAK,KAAMjV,EAAGA,EAAI,CAAC,EACnBiV,EAAK,KAAMjV,EAAI,EAAGA,EAAI,CAAC,EACvBiV,EAAK,KAAMjV,EAAI,EAAGA,EAAI,CAAC,EACvBiV,EAAK,KAAMjV,EAAI,EAAGA,EAAI,CAAC,EAEzB,OAAO,IACT,EAEAmS,EAAO,UAAU,SAAW,UAAqB,CAC/C,MAAM9U,EAAS,KAAK,OACpB,OAAIA,IAAW,EAAU,GACrB,UAAU,SAAW,EAAUuX,EAAU,KAAM,EAAGvX,CAAM,EACrDqX,EAAa,MAAM,KAAM,SAAS,CAC3C,EAEAvC,EAAO,UAAU,eAAiBA,EAAO,UAAU,SAEnDA,EAAO,UAAU,OAAS,SAAiBlY,EAAG,CAC5C,GAAI,CAACkY,EAAO,SAASlY,CAAC,EAAG,MAAM,IAAI,UAAU,2BAA2B,EACxE,OAAI,OAASA,EAAU,GAChBkY,EAAO,QAAQ,KAAMlY,CAAC,IAAM,CACrC,EAEAkY,EAAO,UAAU,QAAU,UAAoB,CAC7C,IAAIvQ,EAAM,GACV,MAAMpC,EAAM1E,EAAQ,kBACpB,OAAA8G,EAAM,KAAK,SAAS,MAAO,EAAGpC,CAAG,EAAE,QAAQ,UAAW,KAAK,EAAE,KAAI,EAC7D,KAAK,OAASA,IAAKoC,GAAO,SACvB,WAAaA,EAAM,GAC5B,EACIsQ,IACFC,EAAO,UAAUD,CAAmB,EAAIC,EAAO,UAAU,SAG3DA,EAAO,UAAU,QAAU,SAAkBjV,EAAQqM,EAAOC,EAAK0L,EAAWC,EAAS,CAInF,GAHIhC,GAAWjW,EAAQoV,CAAgB,IACrCpV,EAASiV,EAAO,KAAKjV,EAAQA,EAAO,OAAQA,EAAO,UAAU,GAE3D,CAACiV,EAAO,SAASjV,CAAM,EACzB,MAAM,IAAI,UACR,iFACoB,OAAOA,CAClC,EAgBG,GAbIqM,IAAU,SACZA,EAAQ,GAENC,IAAQ,SACVA,EAAMtM,EAASA,EAAO,OAAS,GAE7BgY,IAAc,SAChBA,EAAY,GAEVC,IAAY,SACdA,EAAU,KAAK,QAGb5L,EAAQ,GAAKC,EAAMtM,EAAO,QAAUgY,EAAY,GAAKC,EAAU,KAAK,OACtE,MAAM,IAAI,WAAW,oBAAoB,EAG3C,GAAID,GAAaC,GAAW5L,GAASC,EACnC,MAAO,GAET,GAAI0L,GAAaC,EACf,MAAO,GAET,GAAI5L,GAASC,EACX,MAAO,GAQT,GALAD,KAAW,EACXC,KAAS,EACT0L,KAAe,EACfC,KAAa,EAET,OAASjY,EAAQ,MAAO,GAE5B,IAAItC,EAAIua,EAAUD,EACd9Z,GAAIoO,EAAMD,EACd,MAAM4G,GAAM,KAAK,IAAIvV,EAAGQ,EAAC,EAEnBga,GAAW,KAAK,MAAMF,EAAWC,CAAO,EACxCE,GAAanY,EAAO,MAAMqM,EAAOC,CAAG,EAE1C,QAASxJ,GAAI,EAAGA,GAAImQ,GAAK,EAAEnQ,GACzB,GAAIoV,GAASpV,EAAC,IAAMqV,GAAWrV,EAAC,EAAG,CACjCpF,EAAIwa,GAASpV,EAAC,EACd5E,GAAIia,GAAWrV,EAAC,EAChB,KACF,CAGF,OAAIpF,EAAIQ,GAAU,GACdA,GAAIR,EAAU,EACX,CACT,EAWA,SAAS0a,EAAsBvW,EAAQwW,EAAKrB,EAAYP,EAAU6B,EAAK,CAErE,GAAIzW,EAAO,SAAW,EAAG,MAAO,GAmBhC,GAhBI,OAAOmV,GAAe,UACxBP,EAAWO,EACXA,EAAa,GACJA,EAAa,WACtBA,EAAa,WACJA,EAAa,cACtBA,EAAa,aAEfA,EAAa,CAACA,EACVC,GAAYD,CAAU,IAExBA,EAAasB,EAAM,EAAKzW,EAAO,OAAS,GAItCmV,EAAa,IAAGA,EAAanV,EAAO,OAASmV,GAC7CA,GAAcnV,EAAO,OAAQ,CAC/B,GAAIyW,EAAK,MAAO,GACXtB,EAAanV,EAAO,OAAS,CACpC,SAAWmV,EAAa,EACtB,GAAIsB,EAAKtB,EAAa,MACjB,OAAO,GASd,GALI,OAAOqB,GAAQ,WACjBA,EAAMpD,EAAO,KAAKoD,EAAK5B,CAAQ,GAI7BxB,EAAO,SAASoD,CAAG,EAErB,OAAIA,EAAI,SAAW,EACV,GAEFE,EAAa1W,EAAQwW,EAAKrB,EAAYP,EAAU6B,CAAG,EACrD,GAAI,OAAOD,GAAQ,SAExB,OADAA,EAAMA,EAAM,IACR,OAAOjD,EAAiB,UAAU,SAAY,WAC5CkD,EACKlD,EAAiB,UAAU,QAAQ,KAAKvT,EAAQwW,EAAKrB,CAAU,EAE/D5B,EAAiB,UAAU,YAAY,KAAKvT,EAAQwW,EAAKrB,CAAU,EAGvEuB,EAAa1W,EAAQ,CAACwW,CAAG,EAAGrB,EAAYP,EAAU6B,CAAG,EAG9D,MAAM,IAAI,UAAU,sCAAsC,CAC5D,CAEA,SAASC,EAAc/E,EAAK6E,EAAKrB,EAAYP,EAAU6B,EAAK,CAC1D,IAAIE,EAAY,EACZC,EAAYjF,EAAI,OAChBkF,GAAYL,EAAI,OAEpB,GAAI5B,IAAa,SACfA,EAAW,OAAOA,CAAQ,EAAE,YAAW,EACnCA,IAAa,QAAUA,IAAa,SACpCA,IAAa,WAAaA,IAAa,YAAY,CACrD,GAAIjD,EAAI,OAAS,GAAK6E,EAAI,OAAS,EACjC,MAAO,GAETG,EAAY,EACZC,GAAa,EACbC,IAAa,EACb1B,GAAc,CAChB,CAGF,SAAS2B,GAAMjD,GAAK5S,GAAG,CACrB,OAAI0V,IAAc,EACT9C,GAAI5S,EAAC,EAEL4S,GAAI,aAAa5S,GAAI0V,CAAS,CAEzC,CAEA,IAAI1V,GACJ,GAAIwV,EAAK,CACP,IAAIM,GAAa,GACjB,IAAK9V,GAAIkU,EAAYlU,GAAI2V,EAAW3V,KAClC,GAAI6V,GAAKnF,EAAK1Q,EAAC,IAAM6V,GAAKN,EAAKO,KAAe,GAAK,EAAI9V,GAAI8V,EAAU,GAEnE,GADIA,KAAe,KAAIA,GAAa9V,IAChCA,GAAI8V,GAAa,IAAMF,GAAW,OAAOE,GAAaJ,OAEtDI,KAAe,KAAI9V,IAAKA,GAAI8V,IAChCA,GAAa,EAGnB,KAEE,KADI5B,EAAa0B,GAAYD,IAAWzB,EAAayB,EAAYC,IAC5D5V,GAAIkU,EAAYlU,IAAK,EAAGA,KAAK,CAChC,IAAI+V,GAAQ,GACZ,QAASC,GAAI,EAAGA,GAAIJ,GAAWI,KAC7B,GAAIH,GAAKnF,EAAK1Q,GAAIgW,EAAC,IAAMH,GAAKN,EAAKS,EAAC,EAAG,CACrCD,GAAQ,GACR,KACF,CAEF,GAAIA,GAAO,OAAO/V,EACpB,CAGF,MAAO,EACT,CAEAmS,EAAO,UAAU,SAAW,SAAmBoD,EAAKrB,EAAYP,EAAU,CACxE,OAAO,KAAK,QAAQ4B,EAAKrB,EAAYP,CAAQ,IAAM,EACrD,EAEAxB,EAAO,UAAU,QAAU,SAAkBoD,EAAKrB,EAAYP,EAAU,CACtE,OAAO2B,EAAqB,KAAMC,EAAKrB,EAAYP,EAAU,EAAI,CACnE,EAEAxB,EAAO,UAAU,YAAc,SAAsBoD,EAAKrB,EAAYP,EAAU,CAC9E,OAAO2B,EAAqB,KAAMC,EAAKrB,EAAYP,EAAU,EAAK,CACpE,EAEA,SAASsC,EAAUrD,EAAKnV,EAAQ6T,EAAQjU,EAAQ,CAC9CiU,EAAS,OAAOA,CAAM,GAAK,EAC3B,MAAM4E,EAAYtD,EAAI,OAAStB,EAC1BjU,GAGHA,EAAS,OAAOA,CAAM,EAClBA,EAAS6Y,IACX7Y,EAAS6Y,IAJX7Y,EAAS6Y,EAQX,MAAMC,EAAS1Y,EAAO,OAElBJ,EAAS8Y,EAAS,IACpB9Y,EAAS8Y,EAAS,GAEpB,IAAInW,EACJ,IAAKA,EAAI,EAAGA,EAAI3C,EAAQ,EAAE2C,EAAG,CAC3B,MAAMoW,GAAS,SAAS3Y,EAAO,OAAOuC,EAAI,EAAG,CAAC,EAAG,EAAE,EACnD,GAAImU,GAAYiC,EAAM,EAAG,OAAOpW,EAChC4S,EAAItB,EAAStR,CAAC,EAAIoW,EACpB,CACA,OAAOpW,CACT,CAEA,SAASqW,EAAWzD,EAAKnV,EAAQ6T,EAAQjU,EAAQ,CAC/C,OAAOiZ,GAAW9B,GAAY/W,EAAQmV,EAAI,OAAStB,CAAM,EAAGsB,EAAKtB,EAAQjU,CAAM,CACjF,CAEA,SAASkZ,EAAY3D,EAAKnV,EAAQ6T,EAAQjU,EAAQ,CAChD,OAAOiZ,GAAWE,GAAa/Y,CAAM,EAAGmV,EAAKtB,EAAQjU,CAAM,CAC7D,CAEA,SAASoZ,EAAa7D,EAAKnV,EAAQ6T,EAAQjU,EAAQ,CACjD,OAAOiZ,GAAW7B,GAAchX,CAAM,EAAGmV,EAAKtB,EAAQjU,CAAM,CAC9D,CAEA,SAASqZ,EAAW9D,EAAKnV,EAAQ6T,EAAQjU,EAAQ,CAC/C,OAAOiZ,GAAWK,GAAelZ,EAAQmV,EAAI,OAAStB,CAAM,EAAGsB,EAAKtB,EAAQjU,CAAM,CACpF,CAEA8U,EAAO,UAAU,MAAQ,SAAgB1U,EAAQ6T,EAAQjU,EAAQsW,EAAU,CAEzE,GAAIrC,IAAW,OACbqC,EAAW,OACXtW,EAAS,KAAK,OACdiU,EAAS,UAEAjU,IAAW,QAAa,OAAOiU,GAAW,SACnDqC,EAAWrC,EACXjU,EAAS,KAAK,OACdiU,EAAS,UAEA,SAASA,CAAM,EACxBA,EAASA,IAAW,EAChB,SAASjU,CAAM,GACjBA,EAASA,IAAW,EAChBsW,IAAa,SAAWA,EAAW,UAEvCA,EAAWtW,EACXA,EAAS,YAGX,OAAM,IAAI,MACR,yEACP,EAGG,MAAM6Y,EAAY,KAAK,OAAS5E,EAGhC,IAFIjU,IAAW,QAAaA,EAAS6Y,KAAW7Y,EAAS6Y,GAEpDzY,EAAO,OAAS,IAAMJ,EAAS,GAAKiU,EAAS,IAAOA,EAAS,KAAK,OACrE,MAAM,IAAI,WAAW,wCAAwC,EAG1DqC,IAAUA,EAAW,QAE1B,IAAIY,EAAc,GAClB,OACE,OAAQZ,EAAQ,CACd,IAAK,MACH,OAAOsC,EAAS,KAAMxY,EAAQ6T,EAAQjU,CAAM,EAE9C,IAAK,OACL,IAAK,QACH,OAAOgZ,EAAU,KAAM5Y,EAAQ6T,EAAQjU,CAAM,EAE/C,IAAK,QACL,IAAK,SACL,IAAK,SACH,OAAOkZ,EAAW,KAAM9Y,EAAQ6T,EAAQjU,CAAM,EAEhD,IAAK,SAEH,OAAOoZ,EAAY,KAAMhZ,EAAQ6T,EAAQjU,CAAM,EAEjD,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAOqZ,EAAU,KAAMjZ,EAAQ6T,EAAQjU,CAAM,EAE/C,QACE,GAAIkX,EAAa,MAAM,IAAI,UAAU,qBAAuBZ,CAAQ,EACpEA,GAAY,GAAKA,GAAU,YAAW,EACtCY,EAAc,EACvB,CAEC,EAEApC,EAAO,UAAU,OAAS,UAAmB,CAC3C,MAAO,CACL,KAAM,SACN,KAAM,MAAM,UAAU,MAAM,KAAK,KAAK,MAAQ,KAAM,CAAC,CAC1D,CACC,EAEA,SAAS4C,EAAanC,EAAKrJ,EAAOC,EAAK,CACrC,OAAID,IAAU,GAAKC,IAAQoJ,EAAI,OACtBZ,EAAO,cAAcY,CAAG,EAExBZ,EAAO,cAAcY,EAAI,MAAMrJ,EAAOC,CAAG,CAAC,CAErD,CAEA,SAASoL,EAAWhC,EAAKrJ,EAAOC,EAAK,CACnCA,EAAM,KAAK,IAAIoJ,EAAI,OAAQpJ,CAAG,EAC9B,MAAM/F,EAAM,CAAA,EAEZ,IAAIzD,EAAIuJ,EACR,KAAOvJ,EAAIwJ,GAAK,CACd,MAAMoN,EAAYhE,EAAI5S,CAAC,EACvB,IAAI6W,EAAY,KACZC,GAAoBF,EAAY,IAChC,EACCA,EAAY,IACT,EACCA,EAAY,IACT,EACA,EAEZ,GAAI5W,EAAI8W,IAAoBtN,EAAK,CAC/B,IAAIuN,GAAYC,GAAWC,GAAYC,GAEvC,OAAQJ,GAAgB,CACtB,IAAK,GACCF,EAAY,MACdC,EAAYD,GAEd,MACF,IAAK,GACHG,GAAanE,EAAI5S,EAAI,CAAC,GACjB+W,GAAa,OAAU,MAC1BG,IAAiBN,EAAY,KAAS,EAAOG,GAAa,GACtDG,GAAgB,MAClBL,EAAYK,KAGhB,MACF,IAAK,GACHH,GAAanE,EAAI5S,EAAI,CAAC,EACtBgX,GAAYpE,EAAI5S,EAAI,CAAC,GAChB+W,GAAa,OAAU,MAASC,GAAY,OAAU,MACzDE,IAAiBN,EAAY,KAAQ,IAAOG,GAAa,KAAS,EAAOC,GAAY,GACjFE,GAAgB,OAAUA,GAAgB,OAAUA,GAAgB,SACtEL,EAAYK,KAGhB,MACF,IAAK,GACHH,GAAanE,EAAI5S,EAAI,CAAC,EACtBgX,GAAYpE,EAAI5S,EAAI,CAAC,EACrBiX,GAAarE,EAAI5S,EAAI,CAAC,GACjB+W,GAAa,OAAU,MAASC,GAAY,OAAU,MAASC,GAAa,OAAU,MACzFC,IAAiBN,EAAY,KAAQ,IAAQG,GAAa,KAAS,IAAOC,GAAY,KAAS,EAAOC,GAAa,GAC/GC,GAAgB,OAAUA,GAAgB,UAC5CL,EAAYK,IAG3B,CACK,CAEIL,IAAc,MAGhBA,EAAY,MACZC,GAAmB,GACVD,EAAY,QAErBA,GAAa,MACbpT,EAAI,KAAKoT,IAAc,GAAK,KAAQ,KAAM,EAC1CA,EAAY,MAASA,EAAY,MAGnCpT,EAAI,KAAKoT,CAAS,EAClB7W,GAAK8W,EACP,CAEA,OAAOK,EAAsB1T,CAAG,CAClC,CAKA,MAAM2T,EAAuB,KAE7B,SAASD,EAAuBE,EAAY,CAC1C,MAAMlH,EAAMkH,EAAW,OACvB,GAAIlH,GAAOiH,EACT,OAAO,OAAO,aAAa,MAAM,OAAQC,CAAU,EAIrD,IAAI5T,EAAM,GACNzD,EAAI,EACR,KAAOA,EAAImQ,GACT1M,GAAO,OAAO,aAAa,MACzB,OACA4T,EAAW,MAAMrX,EAAGA,GAAKoX,CAAoB,CACpD,EAEG,OAAO3T,CACT,CAEA,SAASoR,EAAYjC,EAAKrJ,EAAOC,EAAK,CACpC,IAAI8N,EAAM,GACV9N,EAAM,KAAK,IAAIoJ,EAAI,OAAQpJ,CAAG,EAE9B,QAASxJ,EAAIuJ,EAAOvJ,EAAIwJ,EAAK,EAAExJ,EAC7BsX,GAAO,OAAO,aAAa1E,EAAI5S,CAAC,EAAI,GAAI,EAE1C,OAAOsX,CACT,CAEA,SAASxC,EAAalC,EAAKrJ,EAAOC,EAAK,CACrC,IAAI8N,EAAM,GACV9N,EAAM,KAAK,IAAIoJ,EAAI,OAAQpJ,CAAG,EAE9B,QAASxJ,EAAIuJ,EAAOvJ,EAAIwJ,EAAK,EAAExJ,EAC7BsX,GAAO,OAAO,aAAa1E,EAAI5S,CAAC,CAAC,EAEnC,OAAOsX,CACT,CAEA,SAAS3C,EAAU/B,EAAKrJ,EAAOC,EAAK,CAClC,MAAM2G,EAAMyC,EAAI,QAEZ,CAACrJ,GAASA,EAAQ,KAAGA,EAAQ,IAC7B,CAACC,GAAOA,EAAM,GAAKA,EAAM2G,KAAK3G,EAAM2G,GAExC,IAAIoH,EAAM,GACV,QAASvX,EAAIuJ,EAAOvJ,EAAIwJ,EAAK,EAAExJ,EAC7BuX,GAAOC,GAAoB5E,EAAI5S,CAAC,CAAC,EAEnC,OAAOuX,CACT,CAEA,SAASvC,EAAcpC,EAAKrJ,EAAOC,EAAK,CACtC,MAAMiO,EAAQ7E,EAAI,MAAMrJ,EAAOC,CAAG,EAClC,IAAI/F,EAAM,GAEV,QAASzD,EAAI,EAAGA,EAAIyX,EAAM,OAAS,EAAGzX,GAAK,EACzCyD,GAAO,OAAO,aAAagU,EAAMzX,CAAC,EAAKyX,EAAMzX,EAAI,CAAC,EAAI,GAAI,EAE5D,OAAOyD,CACT,CAEA0O,EAAO,UAAU,MAAQ,SAAgB5I,EAAOC,EAAK,CACnD,MAAM2G,EAAM,KAAK,OACjB5G,EAAQ,CAAC,CAACA,EACVC,EAAMA,IAAQ,OAAY2G,EAAM,CAAC,CAAC3G,EAE9BD,EAAQ,GACVA,GAAS4G,EACL5G,EAAQ,IAAGA,EAAQ,IACdA,EAAQ4G,IACjB5G,EAAQ4G,GAGN3G,EAAM,GACRA,GAAO2G,EACH3G,EAAM,IAAGA,EAAM,IACVA,EAAM2G,IACf3G,EAAM2G,GAGJ3G,EAAMD,IAAOC,EAAMD,GAEvB,MAAMmO,EAAS,KAAK,SAASnO,EAAOC,CAAG,EAEvC,cAAO,eAAekO,EAAQvF,EAAO,SAAS,EAEvCuF,CACT,EAKA,SAASC,EAAarG,EAAQsG,EAAKva,EAAQ,CACzC,GAAKiU,EAAS,IAAO,GAAKA,EAAS,EAAG,MAAM,IAAI,WAAW,oBAAoB,EAC/E,GAAIA,EAASsG,EAAMva,EAAQ,MAAM,IAAI,WAAW,uCAAuC,CACzF,CAEA8U,EAAO,UAAU,WACjBA,EAAO,UAAU,WAAa,SAAqBb,EAAQzB,EAAYgI,EAAU,CAC/EvG,EAASA,IAAW,EACpBzB,EAAaA,IAAe,EACvBgI,GAAUF,EAAYrG,EAAQzB,EAAY,KAAK,MAAM,EAE1D,IAAI0F,EAAM,KAAKjE,CAAM,EACjBwG,EAAM,EACN9X,EAAI,EACR,KAAO,EAAEA,EAAI6P,IAAeiI,GAAO,MACjCvC,GAAO,KAAKjE,EAAStR,CAAC,EAAI8X,EAG5B,OAAOvC,CACT,EAEApD,EAAO,UAAU,WACjBA,EAAO,UAAU,WAAa,SAAqBb,EAAQzB,EAAYgI,EAAU,CAC/EvG,EAASA,IAAW,EACpBzB,EAAaA,IAAe,EACvBgI,GACHF,EAAYrG,EAAQzB,EAAY,KAAK,MAAM,EAG7C,IAAI0F,EAAM,KAAKjE,EAAS,EAAEzB,CAAU,EAChCiI,EAAM,EACV,KAAOjI,EAAa,IAAMiI,GAAO,MAC/BvC,GAAO,KAAKjE,EAAS,EAAEzB,CAAU,EAAIiI,EAGvC,OAAOvC,CACT,EAEApD,EAAO,UAAU,UACjBA,EAAO,UAAU,UAAY,SAAoBb,EAAQuG,EAAU,CACjE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,EAAYrG,EAAQ,EAAG,KAAK,MAAM,EAC1C,KAAKA,CAAM,CACpB,EAEAa,EAAO,UAAU,aACjBA,EAAO,UAAU,aAAe,SAAuBb,EAAQuG,EAAU,CACvE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,EAAYrG,EAAQ,EAAG,KAAK,MAAM,EAC1C,KAAKA,CAAM,EAAK,KAAKA,EAAS,CAAC,GAAK,CAC7C,EAEAa,EAAO,UAAU,aACjBA,EAAO,UAAU,aAAe,SAAuBb,EAAQuG,EAAU,CACvE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,EAAYrG,EAAQ,EAAG,KAAK,MAAM,EACzC,KAAKA,CAAM,GAAK,EAAK,KAAKA,EAAS,CAAC,CAC9C,EAEAa,EAAO,UAAU,aACjBA,EAAO,UAAU,aAAe,SAAuBb,EAAQuG,EAAU,CACvE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,EAAYrG,EAAQ,EAAG,KAAK,MAAM,GAExC,KAAKA,CAAM,EACf,KAAKA,EAAS,CAAC,GAAK,EACpB,KAAKA,EAAS,CAAC,GAAK,IACpB,KAAKA,EAAS,CAAC,EAAI,QAC1B,EAEAa,EAAO,UAAU,aACjBA,EAAO,UAAU,aAAe,SAAuBb,EAAQuG,EAAU,CACvE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,EAAYrG,EAAQ,EAAG,KAAK,MAAM,EAEzC,KAAKA,CAAM,EAAI,UACnB,KAAKA,EAAS,CAAC,GAAK,GACrB,KAAKA,EAAS,CAAC,GAAK,EACrB,KAAKA,EAAS,CAAC,EACnB,EAEAa,EAAO,UAAU,gBAAkB4F,GAAmB,SAA0BzG,EAAQ,CACtFA,EAASA,IAAW,EACpB0G,GAAe1G,EAAQ,QAAQ,EAC/B,MAAM2G,EAAQ,KAAK3G,CAAM,EACnB4G,EAAO,KAAK5G,EAAS,CAAC,GACxB2G,IAAU,QAAaC,IAAS,SAClCC,GAAY7G,EAAQ,KAAK,OAAS,CAAC,EAGrC,MAAM8G,EAAKH,EACT,KAAK,EAAE3G,CAAM,EAAI,GAAK,EACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,GACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,GAElB+G,EAAK,KAAK,EAAE/G,CAAM,EACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,EACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,GACtB4G,EAAO,GAAK,GAEd,OAAO,OAAOE,CAAE,GAAK,OAAOC,CAAE,GAAK,OAAO,EAAE,EAC9C,CAAC,EAEDlG,EAAO,UAAU,gBAAkB4F,GAAmB,SAA0BzG,EAAQ,CACtFA,EAASA,IAAW,EACpB0G,GAAe1G,EAAQ,QAAQ,EAC/B,MAAM2G,EAAQ,KAAK3G,CAAM,EACnB4G,EAAO,KAAK5G,EAAS,CAAC,GACxB2G,IAAU,QAAaC,IAAS,SAClCC,GAAY7G,EAAQ,KAAK,OAAS,CAAC,EAGrC,MAAM+G,EAAKJ,EAAQ,GAAK,GACtB,KAAK,EAAE3G,CAAM,EAAI,GAAK,GACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,EACtB,KAAK,EAAEA,CAAM,EAET8G,EAAK,KAAK,EAAE9G,CAAM,EAAI,GAAK,GAC/B,KAAK,EAAEA,CAAM,EAAI,GAAK,GACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,EACtB4G,EAEF,OAAQ,OAAOG,CAAE,GAAK,OAAO,EAAE,GAAK,OAAOD,CAAE,CAC/C,CAAC,EAEDjG,EAAO,UAAU,UAAY,SAAoBb,EAAQzB,EAAYgI,EAAU,CAC7EvG,EAASA,IAAW,EACpBzB,EAAaA,IAAe,EACvBgI,GAAUF,EAAYrG,EAAQzB,EAAY,KAAK,MAAM,EAE1D,IAAI0F,EAAM,KAAKjE,CAAM,EACjBwG,EAAM,EACN9X,EAAI,EACR,KAAO,EAAEA,EAAI6P,IAAeiI,GAAO,MACjCvC,GAAO,KAAKjE,EAAStR,CAAC,EAAI8X,EAE5B,OAAAA,GAAO,IAEHvC,GAAOuC,IAAKvC,GAAO,KAAK,IAAI,EAAG,EAAI1F,CAAU,GAE1C0F,CACT,EAEApD,EAAO,UAAU,UAAY,SAAoBb,EAAQzB,EAAYgI,EAAU,CAC7EvG,EAASA,IAAW,EACpBzB,EAAaA,IAAe,EACvBgI,GAAUF,EAAYrG,EAAQzB,EAAY,KAAK,MAAM,EAE1D,IAAI7P,EAAI6P,EACJiI,EAAM,EACNvC,EAAM,KAAKjE,EAAS,EAAEtR,CAAC,EAC3B,KAAOA,EAAI,IAAM8X,GAAO,MACtBvC,GAAO,KAAKjE,EAAS,EAAEtR,CAAC,EAAI8X,EAE9B,OAAAA,GAAO,IAEHvC,GAAOuC,IAAKvC,GAAO,KAAK,IAAI,EAAG,EAAI1F,CAAU,GAE1C0F,CACT,EAEApD,EAAO,UAAU,SAAW,SAAmBb,EAAQuG,EAAU,CAG/D,OAFAvG,EAASA,IAAW,EACfuG,GAAUF,EAAYrG,EAAQ,EAAG,KAAK,MAAM,EAC3C,KAAKA,CAAM,EAAI,KACZ,IAAO,KAAKA,CAAM,EAAI,GAAK,GADA,KAAKA,CAAM,CAEjD,EAEAa,EAAO,UAAU,YAAc,SAAsBb,EAAQuG,EAAU,CACrEvG,EAASA,IAAW,EACfuG,GAAUF,EAAYrG,EAAQ,EAAG,KAAK,MAAM,EACjD,MAAMiE,EAAM,KAAKjE,CAAM,EAAK,KAAKA,EAAS,CAAC,GAAK,EAChD,OAAQiE,EAAM,MAAUA,EAAM,WAAaA,CAC7C,EAEApD,EAAO,UAAU,YAAc,SAAsBb,EAAQuG,EAAU,CACrEvG,EAASA,IAAW,EACfuG,GAAUF,EAAYrG,EAAQ,EAAG,KAAK,MAAM,EACjD,MAAMiE,EAAM,KAAKjE,EAAS,CAAC,EAAK,KAAKA,CAAM,GAAK,EAChD,OAAQiE,EAAM,MAAUA,EAAM,WAAaA,CAC7C,EAEApD,EAAO,UAAU,YAAc,SAAsBb,EAAQuG,EAAU,CACrE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,EAAYrG,EAAQ,EAAG,KAAK,MAAM,EAEzC,KAAKA,CAAM,EAChB,KAAKA,EAAS,CAAC,GAAK,EACpB,KAAKA,EAAS,CAAC,GAAK,GACpB,KAAKA,EAAS,CAAC,GAAK,EACzB,EAEAa,EAAO,UAAU,YAAc,SAAsBb,EAAQuG,EAAU,CACrE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,EAAYrG,EAAQ,EAAG,KAAK,MAAM,EAEzC,KAAKA,CAAM,GAAK,GACrB,KAAKA,EAAS,CAAC,GAAK,GACpB,KAAKA,EAAS,CAAC,GAAK,EACpB,KAAKA,EAAS,CAAC,CACpB,EAEAa,EAAO,UAAU,eAAiB4F,GAAmB,SAAyBzG,EAAQ,CACpFA,EAASA,IAAW,EACpB0G,GAAe1G,EAAQ,QAAQ,EAC/B,MAAM2G,EAAQ,KAAK3G,CAAM,EACnB4G,EAAO,KAAK5G,EAAS,CAAC,GACxB2G,IAAU,QAAaC,IAAS,SAClCC,GAAY7G,EAAQ,KAAK,OAAS,CAAC,EAGrC,MAAMiE,EAAM,KAAKjE,EAAS,CAAC,EACzB,KAAKA,EAAS,CAAC,EAAI,GAAK,EACxB,KAAKA,EAAS,CAAC,EAAI,GAAK,IACvB4G,GAAQ,IAEX,OAAQ,OAAO3C,CAAG,GAAK,OAAO,EAAE,GAC9B,OAAO0C,EACP,KAAK,EAAE3G,CAAM,EAAI,GAAK,EACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,GACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,EAAE,CAC5B,CAAC,EAEDa,EAAO,UAAU,eAAiB4F,GAAmB,SAAyBzG,EAAQ,CACpFA,EAASA,IAAW,EACpB0G,GAAe1G,EAAQ,QAAQ,EAC/B,MAAM2G,EAAQ,KAAK3G,CAAM,EACnB4G,EAAO,KAAK5G,EAAS,CAAC,GACxB2G,IAAU,QAAaC,IAAS,SAClCC,GAAY7G,EAAQ,KAAK,OAAS,CAAC,EAGrC,MAAMiE,GAAO0C,GAAS,IACpB,KAAK,EAAE3G,CAAM,EAAI,GAAK,GACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,EACtB,KAAK,EAAEA,CAAM,EAEf,OAAQ,OAAOiE,CAAG,GAAK,OAAO,EAAE,GAC9B,OAAO,KAAK,EAAEjE,CAAM,EAAI,GAAK,GAC7B,KAAK,EAAEA,CAAM,EAAI,GAAK,GACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,EACtB4G,CAAI,CACR,CAAC,EAED/F,EAAO,UAAU,YAAc,SAAsBb,EAAQuG,EAAU,CACrE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,EAAYrG,EAAQ,EAAG,KAAK,MAAM,EAC1CW,EAAU,KAAK,KAAMX,EAAQ,GAAM,GAAI,CAAC,CACjD,EAEAa,EAAO,UAAU,YAAc,SAAsBb,EAAQuG,EAAU,CACrE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,EAAYrG,EAAQ,EAAG,KAAK,MAAM,EAC1CW,EAAU,KAAK,KAAMX,EAAQ,GAAO,GAAI,CAAC,CAClD,EAEAa,EAAO,UAAU,aAAe,SAAuBb,EAAQuG,EAAU,CACvE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,EAAYrG,EAAQ,EAAG,KAAK,MAAM,EAC1CW,EAAU,KAAK,KAAMX,EAAQ,GAAM,GAAI,CAAC,CACjD,EAEAa,EAAO,UAAU,aAAe,SAAuBb,EAAQuG,EAAU,CACvE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,EAAYrG,EAAQ,EAAG,KAAK,MAAM,EAC1CW,EAAU,KAAK,KAAMX,EAAQ,GAAO,GAAI,CAAC,CAClD,EAEA,SAASgH,GAAU1F,EAAK7P,EAAOuO,EAAQsG,EAAKpY,EAAK+Y,EAAK,CACpD,GAAI,CAACpG,EAAO,SAASS,CAAG,EAAG,MAAM,IAAI,UAAU,6CAA6C,EAC5F,GAAI7P,EAAQvD,GAAOuD,EAAQwV,EAAK,MAAM,IAAI,WAAW,mCAAmC,EACxF,GAAIjH,EAASsG,EAAMhF,EAAI,OAAQ,MAAM,IAAI,WAAW,oBAAoB,CAC1E,CAEAT,EAAO,UAAU,YACjBA,EAAO,UAAU,YAAc,SAAsBpP,EAAOuO,EAAQzB,EAAYgI,EAAU,CAIxF,GAHA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACpBzB,EAAaA,IAAe,EACxB,CAACgI,EAAU,CACb,MAAMW,GAAW,KAAK,IAAI,EAAG,EAAI3I,CAAU,EAAI,EAC/CyI,GAAS,KAAMvV,EAAOuO,EAAQzB,EAAY2I,GAAU,CAAC,CACvD,CAEA,IAAIV,EAAM,EACN9X,EAAI,EAER,IADA,KAAKsR,CAAM,EAAIvO,EAAQ,IAChB,EAAE/C,EAAI6P,IAAeiI,GAAO,MACjC,KAAKxG,EAAStR,CAAC,EAAK+C,EAAQ+U,EAAO,IAGrC,OAAOxG,EAASzB,CAClB,EAEAsC,EAAO,UAAU,YACjBA,EAAO,UAAU,YAAc,SAAsBpP,EAAOuO,EAAQzB,EAAYgI,EAAU,CAIxF,GAHA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACpBzB,EAAaA,IAAe,EACxB,CAACgI,EAAU,CACb,MAAMW,GAAW,KAAK,IAAI,EAAG,EAAI3I,CAAU,EAAI,EAC/CyI,GAAS,KAAMvV,EAAOuO,EAAQzB,EAAY2I,GAAU,CAAC,CACvD,CAEA,IAAIxY,EAAI6P,EAAa,EACjBiI,EAAM,EAEV,IADA,KAAKxG,EAAStR,CAAC,EAAI+C,EAAQ,IACpB,EAAE/C,GAAK,IAAM8X,GAAO,MACzB,KAAKxG,EAAStR,CAAC,EAAK+C,EAAQ+U,EAAO,IAGrC,OAAOxG,EAASzB,CAClB,EAEAsC,EAAO,UAAU,WACjBA,EAAO,UAAU,WAAa,SAAqBpP,EAAOuO,EAAQuG,EAAU,CAC1E,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,IAAM,CAAC,EACvD,KAAKA,CAAM,EAAKvO,EAAQ,IACjBuO,EAAS,CAClB,EAEAa,EAAO,UAAU,cACjBA,EAAO,UAAU,cAAgB,SAAwBpP,EAAOuO,EAAQuG,EAAU,CAChF,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,MAAQ,CAAC,EACzD,KAAKA,CAAM,EAAKvO,EAAQ,IACxB,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,EACvBuO,EAAS,CAClB,EAEAa,EAAO,UAAU,cACjBA,EAAO,UAAU,cAAgB,SAAwBpP,EAAOuO,EAAQuG,EAAU,CAChF,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,MAAQ,CAAC,EACzD,KAAKA,CAAM,EAAKvO,IAAU,EAC1B,KAAKuO,EAAS,CAAC,EAAKvO,EAAQ,IACrBuO,EAAS,CAClB,EAEAa,EAAO,UAAU,cACjBA,EAAO,UAAU,cAAgB,SAAwBpP,EAAOuO,EAAQuG,EAAU,CAChF,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,WAAY,CAAC,EAC7D,KAAKA,EAAS,CAAC,EAAKvO,IAAU,GAC9B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,GAC9B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,EAC9B,KAAKuO,CAAM,EAAKvO,EAAQ,IACjBuO,EAAS,CAClB,EAEAa,EAAO,UAAU,cACjBA,EAAO,UAAU,cAAgB,SAAwBpP,EAAOuO,EAAQuG,EAAU,CAChF,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,WAAY,CAAC,EAC7D,KAAKA,CAAM,EAAKvO,IAAU,GAC1B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,GAC9B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,EAC9B,KAAKuO,EAAS,CAAC,EAAKvO,EAAQ,IACrBuO,EAAS,CAClB,EAEA,SAASmH,GAAgB7F,EAAK7P,EAAOuO,EAAQiH,EAAK/Y,EAAK,CACrDkZ,GAAW3V,EAAOwV,EAAK/Y,EAAKoT,EAAKtB,EAAQ,CAAC,EAE1C,IAAI8G,EAAK,OAAOrV,EAAQ,OAAO,UAAU,CAAC,EAC1C6P,EAAItB,GAAQ,EAAI8G,EAChBA,EAAKA,GAAM,EACXxF,EAAItB,GAAQ,EAAI8G,EAChBA,EAAKA,GAAM,EACXxF,EAAItB,GAAQ,EAAI8G,EAChBA,EAAKA,GAAM,EACXxF,EAAItB,GAAQ,EAAI8G,EAChB,IAAIC,EAAK,OAAOtV,GAAS,OAAO,EAAE,EAAI,OAAO,UAAU,CAAC,EACxD,OAAA6P,EAAItB,GAAQ,EAAI+G,EAChBA,EAAKA,GAAM,EACXzF,EAAItB,GAAQ,EAAI+G,EAChBA,EAAKA,GAAM,EACXzF,EAAItB,GAAQ,EAAI+G,EAChBA,EAAKA,GAAM,EACXzF,EAAItB,GAAQ,EAAI+G,EACT/G,CACT,CAEA,SAASqH,GAAgB/F,EAAK7P,EAAOuO,EAAQiH,EAAK/Y,EAAK,CACrDkZ,GAAW3V,EAAOwV,EAAK/Y,EAAKoT,EAAKtB,EAAQ,CAAC,EAE1C,IAAI8G,EAAK,OAAOrV,EAAQ,OAAO,UAAU,CAAC,EAC1C6P,EAAItB,EAAS,CAAC,EAAI8G,EAClBA,EAAKA,GAAM,EACXxF,EAAItB,EAAS,CAAC,EAAI8G,EAClBA,EAAKA,GAAM,EACXxF,EAAItB,EAAS,CAAC,EAAI8G,EAClBA,EAAKA,GAAM,EACXxF,EAAItB,EAAS,CAAC,EAAI8G,EAClB,IAAIC,EAAK,OAAOtV,GAAS,OAAO,EAAE,EAAI,OAAO,UAAU,CAAC,EACxD,OAAA6P,EAAItB,EAAS,CAAC,EAAI+G,EAClBA,EAAKA,GAAM,EACXzF,EAAItB,EAAS,CAAC,EAAI+G,EAClBA,EAAKA,GAAM,EACXzF,EAAItB,EAAS,CAAC,EAAI+G,EAClBA,EAAKA,GAAM,EACXzF,EAAItB,CAAM,EAAI+G,EACP/G,EAAS,CAClB,CAEAa,EAAO,UAAU,iBAAmB4F,GAAmB,SAA2BhV,EAAOuO,EAAS,EAAG,CACnG,OAAOmH,GAAe,KAAM1V,EAAOuO,EAAQ,OAAO,CAAC,EAAG,OAAO,oBAAoB,CAAC,CACpF,CAAC,EAEDa,EAAO,UAAU,iBAAmB4F,GAAmB,SAA2BhV,EAAOuO,EAAS,EAAG,CACnG,OAAOqH,GAAe,KAAM5V,EAAOuO,EAAQ,OAAO,CAAC,EAAG,OAAO,oBAAoB,CAAC,CACpF,CAAC,EAEDa,EAAO,UAAU,WAAa,SAAqBpP,EAAOuO,EAAQzB,EAAYgI,EAAU,CAGtF,GAFA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EAChB,CAACuG,EAAU,CACb,MAAMe,GAAQ,KAAK,IAAI,EAAI,EAAI/I,EAAc,CAAC,EAE9CyI,GAAS,KAAMvV,EAAOuO,EAAQzB,EAAY+I,GAAQ,EAAG,CAACA,EAAK,CAC7D,CAEA,IAAI5Y,EAAI,EACJ8X,EAAM,EACNe,GAAM,EAEV,IADA,KAAKvH,CAAM,EAAIvO,EAAQ,IAChB,EAAE/C,EAAI6P,IAAeiI,GAAO,MAC7B/U,EAAQ,GAAK8V,KAAQ,GAAK,KAAKvH,EAAStR,EAAI,CAAC,IAAM,IACrD6Y,GAAM,GAER,KAAKvH,EAAStR,CAAC,GAAM+C,EAAQ+U,GAAQ,GAAKe,GAAM,IAGlD,OAAOvH,EAASzB,CAClB,EAEAsC,EAAO,UAAU,WAAa,SAAqBpP,EAAOuO,EAAQzB,EAAYgI,EAAU,CAGtF,GAFA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EAChB,CAACuG,EAAU,CACb,MAAMe,GAAQ,KAAK,IAAI,EAAI,EAAI/I,EAAc,CAAC,EAE9CyI,GAAS,KAAMvV,EAAOuO,EAAQzB,EAAY+I,GAAQ,EAAG,CAACA,EAAK,CAC7D,CAEA,IAAI5Y,EAAI6P,EAAa,EACjBiI,EAAM,EACNe,GAAM,EAEV,IADA,KAAKvH,EAAStR,CAAC,EAAI+C,EAAQ,IACpB,EAAE/C,GAAK,IAAM8X,GAAO,MACrB/U,EAAQ,GAAK8V,KAAQ,GAAK,KAAKvH,EAAStR,EAAI,CAAC,IAAM,IACrD6Y,GAAM,GAER,KAAKvH,EAAStR,CAAC,GAAM+C,EAAQ+U,GAAQ,GAAKe,GAAM,IAGlD,OAAOvH,EAASzB,CAClB,EAEAsC,EAAO,UAAU,UAAY,SAAoBpP,EAAOuO,EAAQuG,EAAU,CACxE,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,IAAM,IAAK,EACvDvO,EAAQ,IAAGA,EAAQ,IAAOA,EAAQ,GACtC,KAAKuO,CAAM,EAAKvO,EAAQ,IACjBuO,EAAS,CAClB,EAEAa,EAAO,UAAU,aAAe,SAAuBpP,EAAOuO,EAAQuG,EAAU,CAC9E,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,MAAQ,MAAO,EAC/D,KAAKA,CAAM,EAAKvO,EAAQ,IACxB,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,EACvBuO,EAAS,CAClB,EAEAa,EAAO,UAAU,aAAe,SAAuBpP,EAAOuO,EAAQuG,EAAU,CAC9E,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,MAAQ,MAAO,EAC/D,KAAKA,CAAM,EAAKvO,IAAU,EAC1B,KAAKuO,EAAS,CAAC,EAAKvO,EAAQ,IACrBuO,EAAS,CAClB,EAEAa,EAAO,UAAU,aAAe,SAAuBpP,EAAOuO,EAAQuG,EAAU,CAC9E,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,WAAY,WAAW,EACvE,KAAKA,CAAM,EAAKvO,EAAQ,IACxB,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,EAC9B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,GAC9B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,GACvBuO,EAAS,CAClB,EAEAa,EAAO,UAAU,aAAe,SAAuBpP,EAAOuO,EAAQuG,EAAU,CAC9E,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,WAAY,WAAW,EACnEvO,EAAQ,IAAGA,EAAQ,WAAaA,EAAQ,GAC5C,KAAKuO,CAAM,EAAKvO,IAAU,GAC1B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,GAC9B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,EAC9B,KAAKuO,EAAS,CAAC,EAAKvO,EAAQ,IACrBuO,EAAS,CAClB,EAEAa,EAAO,UAAU,gBAAkB4F,GAAmB,SAA0BhV,EAAOuO,EAAS,EAAG,CACjG,OAAOmH,GAAe,KAAM1V,EAAOuO,EAAQ,CAAC,OAAO,oBAAoB,EAAG,OAAO,oBAAoB,CAAC,CACxG,CAAC,EAEDa,EAAO,UAAU,gBAAkB4F,GAAmB,SAA0BhV,EAAOuO,EAAS,EAAG,CACjG,OAAOqH,GAAe,KAAM5V,EAAOuO,EAAQ,CAAC,OAAO,oBAAoB,EAAG,OAAO,oBAAoB,CAAC,CACxG,CAAC,EAED,SAASwH,GAAclG,EAAK7P,EAAOuO,EAAQsG,EAAKpY,EAAK+Y,EAAK,CACxD,GAAIjH,EAASsG,EAAMhF,EAAI,OAAQ,MAAM,IAAI,WAAW,oBAAoB,EACxE,GAAItB,EAAS,EAAG,MAAM,IAAI,WAAW,oBAAoB,CAC3D,CAEA,SAASyH,GAAYnG,EAAK7P,EAAOuO,EAAQ0H,EAAcnB,EAAU,CAC/D,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GACHiB,GAAalG,EAAK7P,EAAOuO,EAAQ,CAAC,EAEpCW,EAAU,MAAMW,EAAK7P,EAAOuO,EAAQ0H,EAAc,GAAI,CAAC,EAChD1H,EAAS,CAClB,CAEAa,EAAO,UAAU,aAAe,SAAuBpP,EAAOuO,EAAQuG,EAAU,CAC9E,OAAOkB,GAAW,KAAMhW,EAAOuO,EAAQ,GAAMuG,CAAQ,CACvD,EAEA1F,EAAO,UAAU,aAAe,SAAuBpP,EAAOuO,EAAQuG,EAAU,CAC9E,OAAOkB,GAAW,KAAMhW,EAAOuO,EAAQ,GAAOuG,CAAQ,CACxD,EAEA,SAASoB,GAAarG,EAAK7P,EAAOuO,EAAQ0H,EAAcnB,EAAU,CAChE,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GACHiB,GAAalG,EAAK7P,EAAOuO,EAAQ,CAAC,EAEpCW,EAAU,MAAMW,EAAK7P,EAAOuO,EAAQ0H,EAAc,GAAI,CAAC,EAChD1H,EAAS,CAClB,CAEAa,EAAO,UAAU,cAAgB,SAAwBpP,EAAOuO,EAAQuG,EAAU,CAChF,OAAOoB,GAAY,KAAMlW,EAAOuO,EAAQ,GAAMuG,CAAQ,CACxD,EAEA1F,EAAO,UAAU,cAAgB,SAAwBpP,EAAOuO,EAAQuG,EAAU,CAChF,OAAOoB,GAAY,KAAMlW,EAAOuO,EAAQ,GAAOuG,CAAQ,CACzD,EAGA1F,EAAO,UAAU,KAAO,SAAejV,EAAQgc,EAAa3P,EAAOC,EAAK,CACtE,GAAI,CAAC2I,EAAO,SAASjV,CAAM,EAAG,MAAM,IAAI,UAAU,6BAA6B,EAS/E,GARKqM,IAAOA,EAAQ,GAChB,CAACC,GAAOA,IAAQ,IAAGA,EAAM,KAAK,QAC9B0P,GAAehc,EAAO,SAAQgc,EAAchc,EAAO,QAClDgc,IAAaA,EAAc,GAC5B1P,EAAM,GAAKA,EAAMD,IAAOC,EAAMD,GAG9BC,IAAQD,GACRrM,EAAO,SAAW,GAAK,KAAK,SAAW,EAAG,MAAO,GAGrD,GAAIgc,EAAc,EAChB,MAAM,IAAI,WAAW,2BAA2B,EAElD,GAAI3P,EAAQ,GAAKA,GAAS,KAAK,OAAQ,MAAM,IAAI,WAAW,oBAAoB,EAChF,GAAIC,EAAM,EAAG,MAAM,IAAI,WAAW,yBAAyB,EAGvDA,EAAM,KAAK,SAAQA,EAAM,KAAK,QAC9BtM,EAAO,OAASgc,EAAc1P,EAAMD,IACtCC,EAAMtM,EAAO,OAASgc,EAAc3P,GAGtC,MAAM4G,EAAM3G,EAAMD,EAElB,OAAI,OAASrM,GAAU,OAAOoV,EAAiB,UAAU,YAAe,WAEtE,KAAK,WAAW4G,EAAa3P,EAAOC,CAAG,EAEvC8I,EAAiB,UAAU,IAAI,KAC7BpV,EACA,KAAK,SAASqM,EAAOC,CAAG,EACxB0P,CACP,EAGU/I,CACT,EAMAgC,EAAO,UAAU,KAAO,SAAeoD,EAAKhM,EAAOC,EAAKmK,EAAU,CAEhE,GAAI,OAAO4B,GAAQ,SAAU,CAS3B,GARI,OAAOhM,GAAU,UACnBoK,EAAWpK,EACXA,EAAQ,EACRC,EAAM,KAAK,QACF,OAAOA,GAAQ,WACxBmK,EAAWnK,EACXA,EAAM,KAAK,QAETmK,IAAa,QAAa,OAAOA,GAAa,SAChD,MAAM,IAAI,UAAU,2BAA2B,EAEjD,GAAI,OAAOA,GAAa,UAAY,CAACxB,EAAO,WAAWwB,CAAQ,EAC7D,MAAM,IAAI,UAAU,qBAAuBA,CAAQ,EAErD,GAAI4B,EAAI,SAAW,EAAG,CACpB,MAAMpQ,EAAOoQ,EAAI,WAAW,CAAC,GACxB5B,IAAa,QAAUxO,EAAO,KAC/BwO,IAAa,YAEf4B,EAAMpQ,EAEV,CACF,MAAW,OAAOoQ,GAAQ,SACxBA,EAAMA,EAAM,IACH,OAAOA,GAAQ,YACxBA,EAAM,OAAOA,CAAG,GAIlB,GAAIhM,EAAQ,GAAK,KAAK,OAASA,GAAS,KAAK,OAASC,EACpD,MAAM,IAAI,WAAW,oBAAoB,EAG3C,GAAIA,GAAOD,EACT,OAAO,KAGTA,EAAQA,IAAU,EAClBC,EAAMA,IAAQ,OAAY,KAAK,OAASA,IAAQ,EAE3C+L,IAAKA,EAAM,GAEhB,IAAIvV,EACJ,GAAI,OAAOuV,GAAQ,SACjB,IAAKvV,EAAIuJ,EAAOvJ,EAAIwJ,EAAK,EAAExJ,EACzB,KAAKA,CAAC,EAAIuV,MAEP,CACL,MAAMkC,EAAQtF,EAAO,SAASoD,CAAG,EAC7BA,EACApD,EAAO,KAAKoD,EAAK5B,CAAQ,EACvBxD,GAAMsH,EAAM,OAClB,GAAItH,KAAQ,EACV,MAAM,IAAI,UAAU,cAAgBoF,EAClC,mCAAmC,EAEvC,IAAKvV,EAAI,EAAGA,EAAIwJ,EAAMD,EAAO,EAAEvJ,EAC7B,KAAKA,EAAIuJ,CAAK,EAAIkO,EAAMzX,EAAImQ,EAAG,CAEnC,CAEA,OAAO,IACT,EAMA,MAAMgJ,GAAS,CAAA,EACf,SAAS1d,GAAG2d,EAAKC,EAAYC,EAAM,CACjCH,GAAOC,CAAG,EAAI,cAAwBE,CAAK,CACzC,aAAe,CACb,MAAK,EAEL,OAAO,eAAe,KAAM,UAAW,CACrC,MAAOD,EAAW,MAAM,KAAM,SAAS,EACvC,SAAU,GACV,aAAc,EACvB,CAAQ,EAGD,KAAK,KAAO,GAAG,KAAK,IAAI,KAAKD,CAAG,IAGhC,KAAK,MAEL,OAAO,KAAK,IACd,CAEA,IAAI,MAAQ,CACV,OAAOA,CACT,CAEA,IAAI,KAAMrW,EAAO,CACf,OAAO,eAAe,KAAM,OAAQ,CAClC,aAAc,GACd,WAAY,GACZ,MAAAA,EACA,SAAU,EACnB,CAAQ,CACH,CAEA,UAAY,CACV,MAAO,GAAG,KAAK,IAAI,KAAKqW,CAAG,MAAM,KAAK,OAAO,EAC/C,CACL,CACC,CAEA3d,GAAE,2BACA,SAAUmF,EAAM,CACd,OAAIA,EACK,GAAGA,CAAI,+BAGT,gDACT,EAAG,UAAU,EACfnF,GAAE,uBACA,SAAUmF,EAAMiT,EAAQ,CACtB,MAAO,QAAQjT,CAAI,oDAAoD,OAAOiT,CAAM,EACtF,EAAG,SAAS,EACdpY,GAAE,mBACA,SAAUmG,EAAK2X,EAAO/T,EAAO,CAC3B,IAAIgU,EAAM,iBAAiB5X,CAAG,qBAC1B6X,EAAWjU,EACf,OAAI,OAAO,UAAUA,CAAK,GAAK,KAAK,IAAIA,CAAK,EAAI,GAAK,GACpDiU,EAAWC,GAAsB,OAAOlU,CAAK,CAAC,EACrC,OAAOA,GAAU,WAC1BiU,EAAW,OAAOjU,CAAK,GACnBA,EAAQ,OAAO,CAAC,GAAK,OAAO,EAAE,GAAKA,EAAQ,EAAE,OAAO,CAAC,GAAK,OAAO,EAAE,MACrEiU,EAAWC,GAAsBD,CAAQ,GAE3CA,GAAY,KAEdD,GAAO,eAAeD,CAAK,cAAcE,CAAQ,GAC1CD,CACT,EAAG,UAAU,EAEf,SAASE,GAAuBnE,EAAK,CACnC,IAAI9R,EAAM,GACNzD,EAAIuV,EAAI,OACZ,MAAMhM,EAAQgM,EAAI,CAAC,IAAM,IAAM,EAAI,EACnC,KAAOvV,GAAKuJ,EAAQ,EAAGvJ,GAAK,EAC1ByD,EAAM,IAAI8R,EAAI,MAAMvV,EAAI,EAAGA,CAAC,CAAC,GAAGyD,CAAG,GAErC,MAAO,GAAG8R,EAAI,MAAM,EAAGvV,CAAC,CAAC,GAAGyD,CAAG,EACjC,CAKA,SAASkW,GAAa/G,EAAKtB,EAAQzB,EAAY,CAC7CmI,GAAe1G,EAAQ,QAAQ,GAC3BsB,EAAItB,CAAM,IAAM,QAAasB,EAAItB,EAASzB,CAAU,IAAM,SAC5DsI,GAAY7G,EAAQsB,EAAI,QAAU/C,EAAa,EAAE,CAErD,CAEA,SAAS6I,GAAY3V,EAAOwV,EAAK/Y,EAAKoT,EAAKtB,EAAQzB,EAAY,CAC7D,GAAI9M,EAAQvD,GAAOuD,EAAQwV,EAAK,CAC9B,MAAM5d,EAAI,OAAO4d,GAAQ,SAAW,IAAM,GAC1C,IAAIgB,GAEF,MAAIhB,IAAQ,GAAKA,IAAQ,OAAO,CAAC,EAC/BgB,GAAQ,OAAO5e,CAAC,WAAWA,CAAC,QAAQkV,EAAa,GAAK,CAAC,GAAGlV,CAAC,GAE3D4e,GAAQ,SAAS5e,CAAC,QAAQkV,EAAa,GAAK,EAAI,CAAC,GAAGlV,CAAC,iBACzCkV,EAAa,GAAK,EAAI,CAAC,GAAGlV,CAAC,GAKrC,IAAIwe,GAAO,iBAAiB,QAASI,GAAOxW,CAAK,CACzD,CACA4W,GAAY/G,EAAKtB,EAAQzB,CAAU,CACrC,CAEA,SAASmI,GAAgBjV,EAAOnC,EAAM,CACpC,GAAI,OAAOmC,GAAU,SACnB,MAAM,IAAIoW,GAAO,qBAAqBvY,EAAM,SAAUmC,CAAK,CAE/D,CAEA,SAASoV,GAAapV,EAAO1F,EAAQyD,EAAM,CACzC,MAAI,KAAK,MAAMiC,CAAK,IAAMA,GACxBiV,GAAejV,EAAOjC,CAAI,EACpB,IAAIqY,GAAO,iBAAyB,SAAU,aAAcpW,CAAK,GAGrE1F,EAAS,EACL,IAAI8b,GAAO,yBAGb,IAAIA,GAAO,iBAAyB,SACR,eAA6B9b,CAAM,GACnC0F,CAAK,CACzC,CAKA,MAAM6W,GAAoB,oBAE1B,SAASC,GAAajY,EAAK,CAMzB,GAJAA,EAAMA,EAAI,MAAM,GAAG,EAAE,CAAC,EAEtBA,EAAMA,EAAI,KAAI,EAAG,QAAQgY,GAAmB,EAAE,EAE1ChY,EAAI,OAAS,EAAG,MAAO,GAE3B,KAAOA,EAAI,OAAS,IAAM,GACxBA,EAAMA,EAAM,IAEd,OAAOA,CACT,CAEA,SAAS4S,GAAa/W,EAAQqc,EAAO,CACnCA,EAAQA,GAAS,IACjB,IAAIjD,EACJ,MAAMxZ,EAASI,EAAO,OACtB,IAAIsc,EAAgB,KACpB,MAAMtC,EAAQ,CAAA,EAEd,QAASzX,EAAI,EAAGA,EAAI3C,EAAQ,EAAE2C,EAAG,CAI/B,GAHA6W,EAAYpZ,EAAO,WAAWuC,CAAC,EAG3B6W,EAAY,OAAUA,EAAY,MAAQ,CAE5C,GAAI,CAACkD,EAAe,CAElB,GAAIlD,EAAY,MAAQ,EAEjBiD,GAAS,GAAK,IAAIrC,EAAM,KAAK,IAAM,IAAM,GAAI,EAClD,QACF,SAAWzX,EAAI,IAAM3C,EAAQ,EAEtByc,GAAS,GAAK,IAAIrC,EAAM,KAAK,IAAM,IAAM,GAAI,EAClD,QACF,CAGAsC,EAAgBlD,EAEhB,QACF,CAGA,GAAIA,EAAY,MAAQ,EACjBiD,GAAS,GAAK,IAAIrC,EAAM,KAAK,IAAM,IAAM,GAAI,EAClDsC,EAAgBlD,EAChB,QACF,CAGAA,GAAakD,EAAgB,OAAU,GAAKlD,EAAY,OAAU,KACpE,MAAWkD,IAEJD,GAAS,GAAK,IAAIrC,EAAM,KAAK,IAAM,IAAM,GAAI,EAMpD,GAHAsC,EAAgB,KAGZlD,EAAY,IAAM,CACpB,IAAKiD,GAAS,GAAK,EAAG,MACtBrC,EAAM,KAAKZ,CAAS,CACtB,SAAWA,EAAY,KAAO,CAC5B,IAAKiD,GAAS,GAAK,EAAG,MACtBrC,EAAM,KACJZ,GAAa,EAAM,IACnBA,EAAY,GAAO,GAC5B,CACK,SAAWA,EAAY,MAAS,CAC9B,IAAKiD,GAAS,GAAK,EAAG,MACtBrC,EAAM,KACJZ,GAAa,GAAM,IACnBA,GAAa,EAAM,GAAO,IAC1BA,EAAY,GAAO,GAC5B,CACK,SAAWA,EAAY,QAAU,CAC/B,IAAKiD,GAAS,GAAK,EAAG,MACtBrC,EAAM,KACJZ,GAAa,GAAO,IACpBA,GAAa,GAAM,GAAO,IAC1BA,GAAa,EAAM,GAAO,IAC1BA,EAAY,GAAO,GAC5B,CACK,KACE,OAAM,IAAI,MAAM,oBAAoB,CAExC,CAEA,OAAOY,CACT,CAEA,SAASjB,GAAc5U,EAAK,CAC1B,MAAMoY,EAAY,CAAA,EAClB,QAASha,EAAI,EAAGA,EAAI4B,EAAI,OAAQ,EAAE5B,EAEhCga,EAAU,KAAKpY,EAAI,WAAW5B,CAAC,EAAI,GAAI,EAEzC,OAAOga,CACT,CAEA,SAASrD,GAAgB/U,EAAKkY,EAAO,CACnC,IAAI5f,EAAGme,EAAID,EACX,MAAM4B,EAAY,CAAA,EAClB,QAASha,EAAI,EAAGA,EAAI4B,EAAI,QACjB,GAAAkY,GAAS,GAAK,GADW,EAAE9Z,EAGhC9F,EAAI0H,EAAI,WAAW5B,CAAC,EACpBqY,EAAKne,GAAK,EACVke,EAAKle,EAAI,IACT8f,EAAU,KAAK5B,CAAE,EACjB4B,EAAU,KAAK3B,CAAE,EAGnB,OAAO2B,CACT,CAEA,SAASvF,GAAe7S,EAAK,CAC3B,OAAOoQ,EAAO,YAAY6H,GAAYjY,CAAG,CAAC,CAC5C,CAEA,SAAS0U,GAAY2D,EAAKC,EAAK5I,EAAQjU,EAAQ,CAC7C,IAAI2C,EACJ,IAAKA,EAAI,EAAGA,EAAI3C,GACT,EAAA2C,EAAIsR,GAAU4I,EAAI,QAAYla,GAAKia,EAAI,QADtB,EAAEja,EAExBka,EAAIla,EAAIsR,CAAM,EAAI2I,EAAIja,CAAC,EAEzB,OAAOA,CACT,CAKA,SAASmT,GAAYhQ,EAAKrC,EAAM,CAC9B,OAAOqC,aAAerC,GACnBqC,GAAO,MAAQA,EAAI,aAAe,MAAQA,EAAI,YAAY,MAAQ,MACjEA,EAAI,YAAY,OAASrC,EAAK,IACpC,CACA,SAASqT,GAAahR,EAAK,CAEzB,OAAOA,IAAQA,CACjB,CAIA,MAAMqU,IAAuB,UAAY,CACvC,MAAM2C,EAAW,mBACXC,EAAQ,IAAI,MAAM,GAAG,EAC3B,QAASpa,EAAI,EAAGA,EAAI,GAAI,EAAEA,EAAG,CAC3B,MAAMqa,EAAMra,EAAI,GAChB,QAASgW,EAAI,EAAGA,EAAI,GAAI,EAAEA,EACxBoE,EAAMC,EAAMrE,CAAC,EAAImE,EAASna,CAAC,EAAIma,EAASnE,CAAC,CAE7C,CACA,OAAOoE,CACT,GAAC,EAGD,SAASrC,GAAoBuC,EAAI,CAC/B,OAAO,OAAO,OAAW,IAAcC,GAAyBD,CAClE,CAEA,SAASC,IAA0B,CACjC,MAAM,IAAI,MAAM,sBAAsB,CACxC,CACD,GAAGxb,EAAM,EAEJ,MAACoT,GAASpT,GAAO,gEC5yEtB,OAAO,iBAAiBjE,EAAS,CAAE,WAAY,CAAE,MAAO,IAAQ,CAAC,OAAO,WAAW,EAAG,CAAE,MAAO,QAAQ,CAAE,CAAE,EAE3G,IAAIiE,EAAS,CAAA,EAET6Q,EAAW,CAAA,EAEfA,EAAS,WAAaC,EACtBD,EAAS,YAAcE,EACvBF,EAAS,cAAgBG,EAOzB,QALIC,EAAS,CAAA,EACTC,EAAY,CAAA,EACZC,EAAM,OAAO,WAAe,IAAc,WAAa,MAEvD/K,EAAO,mEACFnF,EAAI,EAAGmQ,EAAMhL,EAAK,OAAQnF,EAAImQ,EAAK,EAAEnQ,EAC5CgQ,EAAOhQ,CAAC,EAAImF,EAAKnF,CAAC,EAClBiQ,EAAU9K,EAAK,WAAWnF,CAAC,CAAC,EAAIA,EAKlCiQ,EAAU,EAAiB,EAAI,GAC/BA,EAAU,EAAiB,EAAI,GAE/B,SAASG,EAASC,EAAK,CACrB,IAAIF,EAAME,EAAI,OAEd,GAAIF,EAAM,EAAI,EACZ,MAAM,IAAI,MAAM,gDAAgD,EAKlE,IAAIG,EAAWD,EAAI,QAAQ,GAAG,EAC1BC,IAAa,KAAIA,EAAWH,GAEhC,IAAII,EAAkBD,IAAaH,EAC/B,EACA,EAAKG,EAAW,EAEpB,MAAO,CAACA,EAAUC,CAAe,CACnC,CAGA,SAASV,EAAYQ,EAAK,CACxB,IAAIG,EAAOJ,EAAQC,CAAG,EAClBC,EAAWE,EAAK,CAAC,EACjBD,EAAkBC,EAAK,CAAC,EAC5B,OAASF,EAAWC,GAAmB,EAAI,EAAKA,CAClD,CAEA,SAASE,EAAaJ,EAAKC,EAAUC,EAAiB,CACpD,OAASD,EAAWC,GAAmB,EAAI,EAAKA,CAClD,CAEA,SAAST,EAAaO,EAAK,CACzB,IAAIrE,EACAwE,EAAOJ,EAAQC,CAAG,EAClBC,EAAWE,EAAK,CAAC,EACjBD,EAAkBC,EAAK,CAAC,EAExBE,EAAM,IAAIR,EAAIO,EAAYJ,EAAKC,EAAUC,CAAe,CAAC,EAEzDI,EAAU,EAGVR,EAAMI,EAAkB,EACxBD,EAAW,EACXA,EAEAtQ,EACJ,IAAKA,EAAI,EAAGA,EAAImQ,EAAKnQ,GAAK,EACxBgM,EACGiE,EAAUI,EAAI,WAAWrQ,CAAC,CAAC,GAAK,GAChCiQ,EAAUI,EAAI,WAAWrQ,EAAI,CAAC,CAAC,GAAK,GACpCiQ,EAAUI,EAAI,WAAWrQ,EAAI,CAAC,CAAC,GAAK,EACrCiQ,EAAUI,EAAI,WAAWrQ,EAAI,CAAC,CAAC,EACjC0Q,EAAIC,GAAS,EAAK3E,GAAO,GAAM,IAC/B0E,EAAIC,GAAS,EAAK3E,GAAO,EAAK,IAC9B0E,EAAIC,GAAS,EAAI3E,EAAM,IAGzB,OAAIuE,IAAoB,IACtBvE,EACGiE,EAAUI,EAAI,WAAWrQ,CAAC,CAAC,GAAK,EAChCiQ,EAAUI,EAAI,WAAWrQ,EAAI,CAAC,CAAC,GAAK,EACvC0Q,EAAIC,GAAS,EAAI3E,EAAM,KAGrBuE,IAAoB,IACtBvE,EACGiE,EAAUI,EAAI,WAAWrQ,CAAC,CAAC,GAAK,GAChCiQ,EAAUI,EAAI,WAAWrQ,EAAI,CAAC,CAAC,GAAK,EACpCiQ,EAAUI,EAAI,WAAWrQ,EAAI,CAAC,CAAC,GAAK,EACvC0Q,EAAIC,GAAS,EAAK3E,GAAO,EAAK,IAC9B0E,EAAIC,GAAS,EAAI3E,EAAM,KAGlB0E,CACT,CAEA,SAASE,EAAiBC,EAAK,CAC7B,OAAOb,EAAOa,GAAO,GAAK,EAAI,EAC5Bb,EAAOa,GAAO,GAAK,EAAI,EACvBb,EAAOa,GAAO,EAAI,EAAI,EACtBb,EAAOa,EAAM,EAAI,CACrB,CAEA,SAASC,EAAaC,EAAOxH,EAAOC,EAAK,CAGvC,QAFIwC,EACAgF,EAAS,CAAA,EACJhR,EAAIuJ,EAAOvJ,EAAIwJ,EAAKxJ,GAAK,EAChCgM,GACI+E,EAAM/Q,CAAC,GAAK,GAAM,WAClB+Q,EAAM/Q,EAAI,CAAC,GAAK,EAAK,QACtB+Q,EAAM/Q,EAAI,CAAC,EAAI,KAClBgR,EAAO,KAAKJ,EAAgB5E,CAAG,CAAC,EAElC,OAAOgF,EAAO,KAAK,EAAE,CACvB,CAEA,SAASjB,EAAegB,EAAO,CAQ7B,QAPI/E,EACAmE,EAAMY,EAAM,OACZE,EAAad,EAAM,EACnBe,EAAQ,CAAA,EACRC,EAAiB,MAGZnR,EAAI,EAAGoR,EAAOjB,EAAMc,EAAYjR,EAAIoR,EAAMpR,GAAKmR,EACtDD,EAAM,KAAKJ,EAAYC,EAAO/Q,EAAIA,EAAImR,EAAkBC,EAAOA,EAAQpR,EAAImR,CAAe,CAAC,EAI7F,OAAIF,IAAe,GACjBjF,EAAM+E,EAAMZ,EAAM,CAAC,EACnBe,EAAM,KACJlB,EAAOhE,GAAO,CAAC,EACfgE,EAAQhE,GAAO,EAAK,EAAI,EACxB,OAEOiF,IAAe,IACxBjF,GAAO+E,EAAMZ,EAAM,CAAC,GAAK,GAAKY,EAAMZ,EAAM,CAAC,EAC3Ce,EAAM,KACJlB,EAAOhE,GAAO,EAAE,EAChBgE,EAAQhE,GAAO,EAAK,EAAI,EACxBgE,EAAQhE,GAAO,EAAK,EAAI,EACxB,MAIGkF,EAAM,KAAK,EAAE,CACtB,CAEA,IAAIG,EAAU,CAAA,EAEd,yFAEAA,EAAQ,KAAO,SAAUtS,EAAQuS,EAAQC,EAAMC,EAAMC,EAAQ,CAC3D,IAAIrX,EAAGK,EACHiX,EAAQD,EAAS,EAAKD,EAAO,EAC7BG,GAAQ,GAAKD,GAAQ,EACrBE,EAAQD,GAAQ,EAChBE,EAAQ,GACR7R,EAAIuR,EAAQE,EAAS,EAAK,EAC1BtX,EAAIoX,EAAO,GAAK,EAChBO,EAAI/S,EAAOuS,EAAStR,CAAC,EAOzB,IALAA,GAAK7F,EAELC,EAAI0X,GAAM,GAAM,CAACD,GAAU,EAC3BC,IAAO,CAACD,EACRA,GAASH,EACFG,EAAQ,EAAGzX,EAAKA,EAAI,IAAO2E,EAAOuS,EAAStR,CAAC,EAAGA,GAAK7F,EAAG0X,GAAS,EAAG,CAK1E,IAHApX,EAAIL,GAAM,GAAM,CAACyX,GAAU,EAC3BzX,IAAO,CAACyX,EACRA,GAASL,EACFK,EAAQ,EAAGpX,EAAKA,EAAI,IAAOsE,EAAOuS,EAAStR,CAAC,EAAGA,GAAK7F,EAAG0X,GAAS,EAAG,CAE1E,GAAIzX,IAAM,EACRA,EAAI,EAAIwX,MACH,IAAIxX,IAAMuX,EACf,OAAOlX,EAAI,KAAQqX,EAAI,GAAK,GAAK,MAEjCrX,EAAIA,EAAI,KAAK,IAAI,EAAG+W,CAAI,EACxBpX,EAAIA,EAAIwX,EAEV,OAAQE,EAAI,GAAK,GAAKrX,EAAI,KAAK,IAAI,EAAGL,EAAIoX,CAAI,CAChD,EAEAH,EAAQ,MAAQ,SAAUtS,EAAQgE,EAAOuO,EAAQC,EAAMC,EAAMC,EAAQ,CACnE,IAAIrX,EAAGK,EAAGP,EACNwX,EAAQD,EAAS,EAAKD,EAAO,EAC7BG,GAAQ,GAAKD,GAAQ,EACrBE,EAAQD,GAAQ,EAChBI,EAAMP,IAAS,GAAK,KAAK,IAAI,EAAG,GAAG,EAAI,KAAK,IAAI,EAAG,GAAG,EAAI,EAC1DxR,EAAIuR,EAAO,EAAKE,EAAS,EACzBtX,EAAIoX,EAAO,EAAI,GACfO,EAAI/O,EAAQ,GAAMA,IAAU,GAAK,EAAIA,EAAQ,EAAK,EAAI,EAmC1D,IAjCAA,EAAQ,KAAK,IAAIA,CAAK,EAElB,MAAMA,CAAK,GAAKA,IAAU,KAC5BtI,EAAI,MAAMsI,CAAK,EAAI,EAAI,EACvB3I,EAAIuX,IAEJvX,EAAI,KAAK,MAAM,KAAK,IAAI2I,CAAK,EAAI,KAAK,GAAG,EACrCA,GAAS7I,EAAI,KAAK,IAAI,EAAG,CAACE,CAAC,GAAK,IAClCA,IACAF,GAAK,GAEHE,EAAIwX,GAAS,EACf7O,GAASgP,EAAK7X,EAEd6I,GAASgP,EAAK,KAAK,IAAI,EAAG,EAAIH,CAAK,EAEjC7O,EAAQ7I,GAAK,IACfE,IACAF,GAAK,GAGHE,EAAIwX,GAASD,GACflX,EAAI,EACJL,EAAIuX,GACKvX,EAAIwX,GAAS,GACtBnX,GAAMsI,EAAQ7I,EAAK,GAAK,KAAK,IAAI,EAAGsX,CAAI,EACxCpX,EAAIA,EAAIwX,IAERnX,EAAIsI,EAAQ,KAAK,IAAI,EAAG6O,EAAQ,CAAC,EAAI,KAAK,IAAI,EAAGJ,CAAI,EACrDpX,EAAI,IAIDoX,GAAQ,EAAGzS,EAAOuS,EAAStR,CAAC,EAAIvF,EAAI,IAAMuF,GAAK7F,EAAGM,GAAK,IAAK+W,GAAQ,EAAG,CAI9E,IAFApX,EAAKA,GAAKoX,EAAQ/W,EAClBiX,GAAQF,EACDE,EAAO,EAAG3S,EAAOuS,EAAStR,CAAC,EAAI5F,EAAI,IAAM4F,GAAK7F,EAAGC,GAAK,IAAKsX,GAAQ,EAAG,CAE7E3S,EAAOuS,EAAStR,EAAI7F,CAAC,GAAK2X,EAAI,GAChC,EAEA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOC,SAAUhX,EAAS,CAEnB,MAAMkX,EAASpC,EACTqC,EAAYZ,EACZa,EACH,OAAO,QAAW,YAAc,OAAO,OAAO,KAAW,WACtD,OAAO,IAAO,4BAA4B,EAC1C,KAENpX,EAAQ,OAASqX,EACjBrX,EAAQ,WAAasX,EACrBtX,EAAQ,kBAAoB,GAE5B,MAAMuX,EAAe,WACrBvX,EAAQ,WAAauX,EACrB,KAAM,CAAE,WAAYC,EAAkB,YAAaC,EAAmB,kBAAmBC,CAAuB,EAAK,WAgBrHL,EAAO,oBAAsBM,EAAiB,EAE1C,CAACN,EAAO,qBAAuB,OAAO,QAAY,KAClD,OAAO,QAAQ,OAAU,YAC3B,QAAQ,MACN,iJAKJ,SAASM,GAAqB,CAE5B,GAAI,CACF,MAAM/B,EAAM,IAAI4B,EAAiB,CAAC,EAC5BI,EAAQ,CAAE,IAAK,UAAY,CAAE,MAAO,GAAE,CAAE,EAC9C,cAAO,eAAeA,EAAOJ,EAAiB,SAAS,EACvD,OAAO,eAAe5B,EAAKgC,CAAK,EACzBhC,EAAI,QAAU,EAC1B,MAAe,CACV,MAAO,EACZ,CACA,CAEC,OAAO,eAAeyB,EAAO,UAAW,SAAU,CAChD,WAAY,GACZ,IAAK,UAAY,CACf,GAAKA,EAAO,SAAS,IAAI,EACzB,OAAO,KAAK,MACjB,CACA,CAAE,EAED,OAAO,eAAeA,EAAO,UAAW,SAAU,CAChD,WAAY,GACZ,IAAK,UAAY,CACf,GAAKA,EAAO,SAAS,IAAI,EACzB,OAAO,KAAK,UACjB,CACA,CAAE,EAED,SAASQ,EAActV,EAAQ,CAC7B,GAAIA,EAASgV,EACX,MAAM,IAAI,WAAW,cAAgBhV,EAAS,gCAAgC,EAGhF,MAAMuV,EAAM,IAAIN,EAAiBjV,CAAM,EACvC,cAAO,eAAeuV,EAAKT,EAAO,SAAS,EACpCS,CACV,CAYC,SAAST,EAAQU,EAAKC,EAAkBzV,EAAQ,CAE9C,GAAI,OAAOwV,GAAQ,SAAU,CAC3B,GAAI,OAAOC,GAAqB,SAC9B,MAAM,IAAI,UACR,oEACT,EAEK,OAAOC,EAAYF,CAAG,CAC3B,CACG,OAAOG,EAAKH,EAAKC,EAAkBzV,CAAM,CAC5C,CAEC8U,EAAO,SAAW,KAElB,SAASa,EAAMjQ,EAAO+P,EAAkBzV,EAAQ,CAC9C,GAAI,OAAO0F,GAAU,SACnB,OAAOkQ,EAAWlQ,EAAO+P,CAAgB,EAG3C,GAAIP,EAAkB,OAAOxP,CAAK,EAChC,OAAOmQ,EAAcnQ,CAAK,EAG5B,GAAIA,GAAS,KACX,MAAM,IAAI,UACR,kHAC0C,OAAOA,CACxD,EAQG,GALIoQ,GAAWpQ,EAAOwP,CAAiB,GAClCxP,GAASoQ,GAAWpQ,EAAM,OAAQwP,CAAiB,GAIpD,OAAOC,EAA4B,MAClCW,GAAWpQ,EAAOyP,CAAuB,GACzCzP,GAASoQ,GAAWpQ,EAAM,OAAQyP,CAAuB,GAC5D,OAAOY,EAAgBrQ,EAAO+P,EAAkBzV,CAAM,EAGxD,GAAI,OAAO0F,GAAU,SACnB,MAAM,IAAI,UACR,uEACP,EAGG,MAAMsQ,EAAUtQ,EAAM,SAAWA,EAAM,QAAO,EAC9C,GAAIsQ,GAAW,MAAQA,IAAYtQ,EACjC,OAAOoP,EAAO,KAAKkB,EAASP,EAAkBzV,CAAM,EAGtD,MAAMpD,EAAIqZ,EAAWvQ,CAAK,EAC1B,GAAI9I,EAAG,OAAOA,EAEd,GAAI,OAAO,OAAW,KAAe,OAAO,aAAe,MACvD,OAAO8I,EAAM,OAAO,WAAW,GAAM,WACvC,OAAOoP,EAAO,KAAKpP,EAAM,OAAO,WAAW,EAAE,QAAQ,EAAG+P,EAAkBzV,CAAM,EAGlF,MAAM,IAAI,UACR,kHAC0C,OAAO0F,CACtD,CACA,CAUCoP,EAAO,KAAO,SAAUpP,EAAO+P,EAAkBzV,EAAQ,CACvD,OAAO2V,EAAKjQ,EAAO+P,EAAkBzV,CAAM,CAC9C,EAIC,OAAO,eAAe8U,EAAO,UAAWG,EAAiB,SAAS,EAClE,OAAO,eAAeH,EAAQG,CAAgB,EAE9C,SAASiB,EAAYC,EAAM,CACzB,GAAI,OAAOA,GAAS,SAClB,MAAM,IAAI,UAAU,wCAAwC,EACvD,GAAIA,EAAO,EAChB,MAAM,IAAI,WAAW,cAAgBA,EAAO,gCAAgC,CAEjF,CAEC,SAASC,EAAOD,EAAME,EAAMC,EAAU,CAEpC,OADAJ,EAAWC,CAAI,EACXA,GAAQ,EACHb,EAAaa,CAAI,EAEtBE,IAAS,OAIJ,OAAOC,GAAa,SACvBhB,EAAaa,CAAI,EAAE,KAAKE,EAAMC,CAAQ,EACtChB,EAAaa,CAAI,EAAE,KAAKE,CAAI,EAE3Bf,EAAaa,CAAI,CAC3B,CAMCrB,EAAO,MAAQ,SAAUqB,EAAME,EAAMC,EAAU,CAC7C,OAAOF,EAAMD,EAAME,EAAMC,CAAQ,CACpC,EAEC,SAASZ,EAAaS,EAAM,CAC1B,OAAAD,EAAWC,CAAI,EACRb,EAAaa,EAAO,EAAI,EAAII,EAAQJ,CAAI,EAAI,CAAC,CACvD,CAKCrB,EAAO,YAAc,SAAUqB,EAAM,CACnC,OAAOT,EAAYS,CAAI,CAC1B,EAICrB,EAAO,gBAAkB,SAAUqB,EAAM,CACvC,OAAOT,EAAYS,CAAI,CAC1B,EAEC,SAASP,EAAYxV,EAAQkW,EAAU,CAKrC,IAJI,OAAOA,GAAa,UAAYA,IAAa,MAC/CA,EAAW,QAGT,CAACxB,EAAO,WAAWwB,CAAQ,EAC7B,MAAM,IAAI,UAAU,qBAAuBA,CAAQ,EAGrD,MAAMtW,EAASwS,EAAWpS,EAAQkW,CAAQ,EAAI,EAC9C,IAAIf,EAAMD,EAAatV,CAAM,EAE7B,MAAMwW,EAASjB,EAAI,MAAMnV,EAAQkW,CAAQ,EAEzC,OAAIE,IAAWxW,IAIbuV,EAAMA,EAAI,MAAM,EAAGiB,CAAM,GAGpBjB,CACV,CAEC,SAASkB,EAAeC,EAAO,CAC7B,MAAM1W,EAAS0W,EAAM,OAAS,EAAI,EAAIH,EAAQG,EAAM,MAAM,EAAI,EACxDnB,EAAMD,EAAatV,CAAM,EAC/B,QAAS2C,EAAI,EAAGA,EAAI3C,EAAQ2C,GAAK,EAC/B4S,EAAI5S,CAAC,EAAI+T,EAAM/T,CAAC,EAAI,IAEtB,OAAO4S,CACV,CAEC,SAASM,EAAec,EAAW,CACjC,GAAIb,GAAWa,EAAW1B,CAAgB,EAAG,CAC3C,MAAM2B,EAAO,IAAI3B,EAAiB0B,CAAS,EAC3C,OAAOZ,EAAgBa,EAAK,OAAQA,EAAK,WAAYA,EAAK,UAAU,CACzE,CACG,OAAOH,EAAcE,CAAS,CACjC,CAEC,SAASZ,EAAiBW,EAAOG,EAAY7W,EAAQ,CACnD,GAAI6W,EAAa,GAAKH,EAAM,WAAaG,EACvC,MAAM,IAAI,WAAW,sCAAsC,EAG7D,GAAIH,EAAM,WAAaG,GAAc7W,GAAU,GAC7C,MAAM,IAAI,WAAW,sCAAsC,EAG7D,IAAIuV,EACJ,OAAIsB,IAAe,QAAa7W,IAAW,OACzCuV,EAAM,IAAIN,EAAiByB,CAAK,EACvB1W,IAAW,OACpBuV,EAAM,IAAIN,EAAiByB,EAAOG,CAAU,EAE5CtB,EAAM,IAAIN,EAAiByB,EAAOG,EAAY7W,CAAM,EAItD,OAAO,eAAeuV,EAAKT,EAAO,SAAS,EAEpCS,CACV,CAEC,SAASU,EAAYnQ,EAAK,CACxB,GAAIgP,EAAO,SAAShP,CAAG,EAAG,CACxB,MAAMgN,EAAMyD,EAAQzQ,EAAI,MAAM,EAAI,EAC5ByP,EAAMD,EAAaxC,CAAG,EAE5B,OAAIyC,EAAI,SAAW,GAInBzP,EAAI,KAAKyP,EAAK,EAAG,EAAGzC,CAAG,EAChByC,CACZ,CAEG,GAAIzP,EAAI,SAAW,OACjB,OAAI,OAAOA,EAAI,QAAW,UAAYgR,GAAYhR,EAAI,MAAM,EACnDwP,EAAa,CAAC,EAEhBmB,EAAc3Q,CAAG,EAG1B,GAAIA,EAAI,OAAS,UAAY,MAAM,QAAQA,EAAI,IAAI,EACjD,OAAO2Q,EAAc3Q,EAAI,IAAI,CAElC,CAEC,SAASyQ,EAASvW,EAAQ,CAGxB,GAAIA,GAAUgV,EACZ,MAAM,IAAI,WAAW,0DACaA,EAAa,SAAS,EAAE,EAAI,QAAQ,EAExE,OAAOhV,EAAS,CACnB,CAEC,SAAS+U,EAAY/U,EAAQ,CAC3B,MAAI,CAACA,GAAUA,IACbA,EAAS,GAEJ8U,EAAO,MAAM,CAAC9U,CAAM,CAC9B,CAEC8U,EAAO,SAAW,SAAmBlY,EAAG,CACtC,OAAOA,GAAK,MAAQA,EAAE,YAAc,IAClCA,IAAMkY,EAAO,SAClB,EAECA,EAAO,QAAU,SAAkBnY,EAAGC,EAAG,CAGvC,GAFIkZ,GAAWnZ,EAAGsY,CAAgB,IAAGtY,EAAImY,EAAO,KAAKnY,EAAGA,EAAE,OAAQA,EAAE,UAAU,GAC1EmZ,GAAWlZ,EAAGqY,CAAgB,IAAGrY,EAAIkY,EAAO,KAAKlY,EAAGA,EAAE,OAAQA,EAAE,UAAU,GAC1E,CAACkY,EAAO,SAASnY,CAAC,GAAK,CAACmY,EAAO,SAASlY,CAAC,EAC3C,MAAM,IAAI,UACR,uEACP,EAGG,GAAID,IAAMC,EAAG,MAAO,GAEpB,IAAIW,EAAIZ,EAAE,OACNoB,EAAInB,EAAE,OAEV,QAAS+F,EAAI,EAAGmQ,GAAM,KAAK,IAAIvV,EAAGQ,CAAC,EAAG4E,EAAImQ,GAAK,EAAEnQ,EAC/C,GAAIhG,EAAEgG,CAAC,IAAM/F,EAAE+F,CAAC,EAAG,CACjBpF,EAAIZ,EAAEgG,CAAC,EACP5E,EAAInB,EAAE+F,CAAC,EACP,KACP,CAGG,OAAIpF,EAAIQ,EAAU,GACdA,EAAIR,EAAU,EACX,CACV,EAECuX,EAAO,WAAa,SAAqBwB,EAAU,CACjD,OAAQ,OAAOA,CAAQ,EAAE,YAAW,EAAE,CACpC,IAAK,MACL,IAAK,OACL,IAAK,QACL,IAAK,QACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,MAAO,GACT,QACE,MAAO,EACd,CACA,EAECxB,EAAO,OAAS,SAAiBiC,EAAM/W,EAAQ,CAC7C,GAAI,CAAC,MAAM,QAAQ+W,CAAI,EACrB,MAAM,IAAI,UAAU,6CAA6C,EAGnE,GAAIA,EAAK,SAAW,EAClB,OAAOjC,EAAO,MAAM,CAAC,EAGvB,IAAInS,EACJ,GAAI3C,IAAW,OAEb,IADAA,EAAS,EACJ2C,EAAI,EAAGA,EAAIoU,EAAK,OAAQ,EAAEpU,EAC7B3C,GAAU+W,EAAKpU,CAAC,EAAE,OAItB,MAAMjB,EAASoT,EAAO,YAAY9U,CAAM,EACxC,IAAIgX,EAAM,EACV,IAAKrU,EAAI,EAAGA,EAAIoU,EAAK,OAAQ,EAAEpU,EAAG,CAChC,IAAI4S,GAAMwB,EAAKpU,CAAC,EAChB,GAAImT,GAAWP,GAAKN,CAAgB,EAC9B+B,EAAMzB,GAAI,OAAS7T,EAAO,QACvBoT,EAAO,SAASS,EAAG,IAAGA,GAAMT,EAAO,KAAKS,EAAG,GAChDA,GAAI,KAAK7T,EAAQsV,CAAG,GAEpB/B,EAAiB,UAAU,IAAI,KAC7BvT,EACA6T,GACAyB,WAGMlC,EAAO,SAASS,EAAG,EAG7BA,GAAI,KAAK7T,EAAQsV,CAAG,MAFpB,OAAM,IAAI,UAAU,6CAA6C,EAInEA,GAAOzB,GAAI,MAChB,CACG,OAAO7T,CACV,EAEC,SAAS8Q,EAAYpS,EAAQkW,EAAU,CACrC,GAAIxB,EAAO,SAAS1U,CAAM,EACxB,OAAOA,EAAO,OAEhB,GAAI8U,EAAkB,OAAO9U,CAAM,GAAK0V,GAAW1V,EAAQ8U,CAAiB,EAC1E,OAAO9U,EAAO,WAEhB,GAAI,OAAOA,GAAW,SACpB,MAAM,IAAI,UACR,2FACmB,OAAOA,CACjC,EAGG,MAAM0S,EAAM1S,EAAO,OACb6W,EAAa,UAAU,OAAS,GAAK,UAAU,CAAC,IAAM,GAC5D,GAAI,CAACA,GAAanE,IAAQ,EAAG,MAAO,GAGpC,IAAIoE,EAAc,GAClB,OACE,OAAQZ,EAAQ,CACd,IAAK,QACL,IAAK,SACL,IAAK,SACH,OAAOxD,EACT,IAAK,OACL,IAAK,QACH,OAAOqE,GAAY/W,CAAM,EAAE,OAC7B,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAO0S,EAAM,EACf,IAAK,MACH,OAAOA,IAAQ,EACjB,IAAK,SACH,OAAOsE,GAAchX,CAAM,EAAE,OAC/B,QACE,GAAI8W,EACF,OAAOD,EAAY,GAAKE,GAAY/W,CAAM,EAAE,OAE9CkW,GAAY,GAAKA,GAAU,YAAW,EACtCY,EAAc,EACvB,CAEA,CACCpC,EAAO,WAAatC,EAEpB,SAAS6E,GAAcf,EAAUpK,EAAOC,EAAK,CAC3C,IAAI+K,EAAc,GA8BlB,IArBIhL,IAAU,QAAaA,EAAQ,KACjCA,EAAQ,GAINA,EAAQ,KAAK,UAIbC,IAAQ,QAAaA,EAAM,KAAK,UAClCA,EAAM,KAAK,QAGTA,GAAO,KAKXA,KAAS,EACTD,KAAW,EAEPC,GAAOD,GACT,MAAO,GAKT,IAFKoK,IAAUA,EAAW,UAGxB,OAAQA,EAAQ,CACd,IAAK,MACH,OAAOgB,GAAS,KAAMpL,EAAOC,CAAG,EAElC,IAAK,OACL,IAAK,QACH,OAAOoL,GAAU,KAAMrL,EAAOC,CAAG,EAEnC,IAAK,QACH,OAAOqL,GAAW,KAAMtL,EAAOC,CAAG,EAEpC,IAAK,SACL,IAAK,SACH,OAAOsL,GAAY,KAAMvL,EAAOC,CAAG,EAErC,IAAK,SACH,OAAOuL,GAAY,KAAMxL,EAAOC,CAAG,EAErC,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAOwL,GAAa,KAAMzL,EAAOC,CAAG,EAEtC,QACE,GAAI+K,EAAa,MAAM,IAAI,UAAU,qBAAuBZ,CAAQ,EACpEA,GAAYA,EAAW,IAAI,YAAW,EACtCY,EAAc,EACvB,CAEA,CAQCpC,EAAO,UAAU,UAAY,GAE7B,SAAS8C,GAAMhb,EAAGU,EAAGF,EAAG,CACtB,MAAMuF,EAAI/F,EAAEU,CAAC,EACbV,EAAEU,CAAC,EAAIV,EAAEQ,CAAC,EACVR,EAAEQ,CAAC,EAAIuF,CACV,CAECmS,EAAO,UAAU,OAAS,UAAmB,CAC3C,MAAMhC,EAAM,KAAK,OACjB,GAAIA,EAAM,IAAM,EACd,MAAM,IAAI,WAAW,2CAA2C,EAElE,QAASnQ,EAAI,EAAGA,EAAImQ,EAAKnQ,GAAK,EAC5BiV,GAAK,KAAMjV,EAAGA,EAAI,CAAC,EAErB,OAAO,IACV,EAECmS,EAAO,UAAU,OAAS,UAAmB,CAC3C,MAAMhC,EAAM,KAAK,OACjB,GAAIA,EAAM,IAAM,EACd,MAAM,IAAI,WAAW,2CAA2C,EAElE,QAASnQ,EAAI,EAAGA,EAAImQ,EAAKnQ,GAAK,EAC5BiV,GAAK,KAAMjV,EAAGA,EAAI,CAAC,EACnBiV,GAAK,KAAMjV,EAAI,EAAGA,EAAI,CAAC,EAEzB,OAAO,IACV,EAECmS,EAAO,UAAU,OAAS,UAAmB,CAC3C,MAAMhC,EAAM,KAAK,OACjB,GAAIA,EAAM,IAAM,EACd,MAAM,IAAI,WAAW,2CAA2C,EAElE,QAASnQ,EAAI,EAAGA,EAAImQ,EAAKnQ,GAAK,EAC5BiV,GAAK,KAAMjV,EAAGA,EAAI,CAAC,EACnBiV,GAAK,KAAMjV,EAAI,EAAGA,EAAI,CAAC,EACvBiV,GAAK,KAAMjV,EAAI,EAAGA,EAAI,CAAC,EACvBiV,GAAK,KAAMjV,EAAI,EAAGA,EAAI,CAAC,EAEzB,OAAO,IACV,EAECmS,EAAO,UAAU,SAAW,UAAqB,CAC/C,MAAM9U,EAAS,KAAK,OACpB,OAAIA,IAAW,EAAU,GACrB,UAAU,SAAW,EAAUuX,GAAU,KAAM,EAAGvX,CAAM,EACrDqX,GAAa,MAAM,KAAM,SAAS,CAC5C,EAECvC,EAAO,UAAU,eAAiBA,EAAO,UAAU,SAEnDA,EAAO,UAAU,OAAS,SAAiBlY,EAAG,CAC5C,GAAI,CAACkY,EAAO,SAASlY,CAAC,EAAG,MAAM,IAAI,UAAU,2BAA2B,EACxE,OAAI,OAASA,EAAU,GAChBkY,EAAO,QAAQ,KAAMlY,CAAC,IAAM,CACtC,EAECkY,EAAO,UAAU,QAAU,UAAoB,CAC7C,IAAIvQ,EAAM,GACV,MAAMpC,EAAM1E,EAAQ,kBACpB,OAAA8G,EAAM,KAAK,SAAS,MAAO,EAAGpC,CAAG,EAAE,QAAQ,UAAW,KAAK,EAAE,KAAI,EAC7D,KAAK,OAASA,IAAKoC,GAAO,SACvB,WAAaA,EAAM,GAC7B,EACKsQ,IACFC,EAAO,UAAUD,CAAmB,EAAIC,EAAO,UAAU,SAG3DA,EAAO,UAAU,QAAU,SAAkBjV,EAAQqM,EAAOC,EAAK0L,EAAWC,EAAS,CAInF,GAHIhC,GAAWjW,EAAQoV,CAAgB,IACrCpV,EAASiV,EAAO,KAAKjV,EAAQA,EAAO,OAAQA,EAAO,UAAU,GAE3D,CAACiV,EAAO,SAASjV,CAAM,EACzB,MAAM,IAAI,UACR,iFACoB,OAAOA,CAClC,EAgBG,GAbIqM,IAAU,SACZA,EAAQ,GAENC,IAAQ,SACVA,EAAMtM,EAASA,EAAO,OAAS,GAE7BgY,IAAc,SAChBA,EAAY,GAEVC,IAAY,SACdA,EAAU,KAAK,QAGb5L,EAAQ,GAAKC,EAAMtM,EAAO,QAAUgY,EAAY,GAAKC,EAAU,KAAK,OACtE,MAAM,IAAI,WAAW,oBAAoB,EAG3C,GAAID,GAAaC,GAAW5L,GAASC,EACnC,MAAO,GAET,GAAI0L,GAAaC,EACf,MAAO,GAET,GAAI5L,GAASC,EACX,MAAO,GAQT,GALAD,KAAW,EACXC,KAAS,EACT0L,KAAe,EACfC,KAAa,EAET,OAASjY,EAAQ,MAAO,GAE5B,IAAItC,GAAIua,EAAUD,EACd9Z,GAAIoO,EAAMD,EACd,MAAM4G,GAAM,KAAK,IAAIvV,GAAGQ,EAAC,EAEnBga,GAAW,KAAK,MAAMF,EAAWC,CAAO,EACxCE,GAAanY,EAAO,MAAMqM,EAAOC,CAAG,EAE1C,QAASxJ,GAAI,EAAGA,GAAImQ,GAAK,EAAEnQ,GACzB,GAAIoV,GAASpV,EAAC,IAAMqV,GAAWrV,EAAC,EAAG,CACjCpF,GAAIwa,GAASpV,EAAC,EACd5E,GAAIia,GAAWrV,EAAC,EAChB,KACP,CAGG,OAAIpF,GAAIQ,GAAU,GACdA,GAAIR,GAAU,EACX,CACV,EAWC,SAAS0a,GAAsBvW,EAAQwW,EAAKrB,EAAYP,EAAU6B,EAAK,CAErE,GAAIzW,EAAO,SAAW,EAAG,MAAO,GAmBhC,GAhBI,OAAOmV,GAAe,UACxBP,EAAWO,EACXA,EAAa,GACJA,EAAa,WACtBA,EAAa,WACJA,EAAa,cACtBA,EAAa,aAEfA,EAAa,CAACA,EACVC,GAAYD,CAAU,IAExBA,EAAasB,EAAM,EAAKzW,EAAO,OAAS,GAItCmV,EAAa,IAAGA,EAAanV,EAAO,OAASmV,GAC7CA,GAAcnV,EAAO,OAAQ,CAC/B,GAAIyW,EAAK,MAAO,GACXtB,EAAanV,EAAO,OAAS,CACvC,SAAcmV,EAAa,EACtB,GAAIsB,EAAKtB,EAAa,MACjB,OAAO,GASd,GALI,OAAOqB,GAAQ,WACjBA,EAAMpD,EAAO,KAAKoD,EAAK5B,CAAQ,GAI7BxB,EAAO,SAASoD,CAAG,EAErB,OAAIA,EAAI,SAAW,EACV,GAEFE,GAAa1W,EAAQwW,EAAKrB,EAAYP,EAAU6B,CAAG,EACrD,GAAI,OAAOD,GAAQ,SAExB,OADAA,EAAMA,EAAM,IACR,OAAOjD,EAAiB,UAAU,SAAY,WAC5CkD,EACKlD,EAAiB,UAAU,QAAQ,KAAKvT,EAAQwW,EAAKrB,CAAU,EAE/D5B,EAAiB,UAAU,YAAY,KAAKvT,EAAQwW,EAAKrB,CAAU,EAGvEuB,GAAa1W,EAAQ,CAACwW,CAAG,EAAGrB,EAAYP,EAAU6B,CAAG,EAG9D,MAAM,IAAI,UAAU,sCAAsC,CAC7D,CAEC,SAASC,GAAc/E,EAAK6E,EAAKrB,EAAYP,EAAU6B,EAAK,CAC1D,IAAIE,EAAY,EACZC,GAAYjF,EAAI,OAChBkF,GAAYL,EAAI,OAEpB,GAAI5B,IAAa,SACfA,EAAW,OAAOA,CAAQ,EAAE,YAAW,EACnCA,IAAa,QAAUA,IAAa,SACpCA,IAAa,WAAaA,IAAa,YAAY,CACrD,GAAIjD,EAAI,OAAS,GAAK6E,EAAI,OAAS,EACjC,MAAO,GAETG,EAAY,EACZC,IAAa,EACbC,IAAa,EACb1B,GAAc,CACrB,CAGG,SAAS2B,GAAMjD,GAAK5S,GAAG,CACrB,OAAI0V,IAAc,EACT9C,GAAI5S,EAAC,EAEL4S,GAAI,aAAa5S,GAAI0V,CAAS,CAE5C,CAEG,IAAI1V,GACJ,GAAIwV,EAAK,CACP,IAAIM,GAAa,GACjB,IAAK9V,GAAIkU,EAAYlU,GAAI2V,GAAW3V,KAClC,GAAI6V,GAAKnF,EAAK1Q,EAAC,IAAM6V,GAAKN,EAAKO,KAAe,GAAK,EAAI9V,GAAI8V,EAAU,GAEnE,GADIA,KAAe,KAAIA,GAAa9V,IAChCA,GAAI8V,GAAa,IAAMF,GAAW,OAAOE,GAAaJ,OAEtDI,KAAe,KAAI9V,IAAKA,GAAI8V,IAChCA,GAAa,EAGtB,KAEK,KADI5B,EAAa0B,GAAYD,KAAWzB,EAAayB,GAAYC,IAC5D5V,GAAIkU,EAAYlU,IAAK,EAAGA,KAAK,CAChC,IAAI+V,GAAQ,GACZ,QAASC,GAAI,EAAGA,GAAIJ,GAAWI,KAC7B,GAAIH,GAAKnF,EAAK1Q,GAAIgW,EAAC,IAAMH,GAAKN,EAAKS,EAAC,EAAG,CACrCD,GAAQ,GACR,KACX,CAEO,GAAIA,GAAO,OAAO/V,EACzB,CAGG,MAAO,EACV,CAECmS,EAAO,UAAU,SAAW,SAAmBoD,EAAKrB,EAAYP,EAAU,CACxE,OAAO,KAAK,QAAQ4B,EAAKrB,EAAYP,CAAQ,IAAM,EACtD,EAECxB,EAAO,UAAU,QAAU,SAAkBoD,EAAKrB,EAAYP,EAAU,CACtE,OAAO2B,GAAqB,KAAMC,EAAKrB,EAAYP,EAAU,EAAI,CACpE,EAECxB,EAAO,UAAU,YAAc,SAAsBoD,EAAKrB,EAAYP,EAAU,CAC9E,OAAO2B,GAAqB,KAAMC,EAAKrB,EAAYP,EAAU,EAAK,CACrE,EAEC,SAASsC,GAAUrD,EAAKnV,EAAQ6T,EAAQjU,EAAQ,CAC9CiU,EAAS,OAAOA,CAAM,GAAK,EAC3B,MAAM4E,EAAYtD,EAAI,OAAStB,EAC1BjU,GAGHA,EAAS,OAAOA,CAAM,EAClBA,EAAS6Y,IACX7Y,EAAS6Y,IAJX7Y,EAAS6Y,EAQX,MAAMC,EAAS1Y,EAAO,OAElBJ,EAAS8Y,EAAS,IACpB9Y,EAAS8Y,EAAS,GAEpB,IAAInW,GACJ,IAAKA,GAAI,EAAGA,GAAI3C,EAAQ,EAAE2C,GAAG,CAC3B,MAAMoW,GAAS,SAAS3Y,EAAO,OAAOuC,GAAI,EAAG,CAAC,EAAG,EAAE,EACnD,GAAImU,GAAYiC,EAAM,EAAG,OAAOpW,GAChC4S,EAAItB,EAAStR,EAAC,EAAIoW,EACvB,CACG,OAAOpW,EACV,CAEC,SAASqW,GAAWzD,EAAKnV,EAAQ6T,EAAQjU,EAAQ,CAC/C,OAAOiZ,GAAW9B,GAAY/W,EAAQmV,EAAI,OAAStB,CAAM,EAAGsB,EAAKtB,EAAQjU,CAAM,CAClF,CAEC,SAASkZ,GAAY3D,EAAKnV,EAAQ6T,EAAQjU,EAAQ,CAChD,OAAOiZ,GAAWE,GAAa/Y,CAAM,EAAGmV,EAAKtB,EAAQjU,CAAM,CAC9D,CAEC,SAASoZ,GAAa7D,EAAKnV,EAAQ6T,EAAQjU,EAAQ,CACjD,OAAOiZ,GAAW7B,GAAchX,CAAM,EAAGmV,EAAKtB,EAAQjU,CAAM,CAC/D,CAEC,SAASqZ,GAAW9D,EAAKnV,EAAQ6T,EAAQjU,EAAQ,CAC/C,OAAOiZ,GAAWK,GAAelZ,EAAQmV,EAAI,OAAStB,CAAM,EAAGsB,EAAKtB,EAAQjU,CAAM,CACrF,CAEC8U,EAAO,UAAU,MAAQ,SAAgB1U,EAAQ6T,EAAQjU,EAAQsW,EAAU,CAEzE,GAAIrC,IAAW,OACbqC,EAAW,OACXtW,EAAS,KAAK,OACdiU,EAAS,UAEAjU,IAAW,QAAa,OAAOiU,GAAW,SACnDqC,EAAWrC,EACXjU,EAAS,KAAK,OACdiU,EAAS,UAEA,SAASA,CAAM,EACxBA,EAASA,IAAW,EAChB,SAASjU,CAAM,GACjBA,EAASA,IAAW,EAChBsW,IAAa,SAAWA,EAAW,UAEvCA,EAAWtW,EACXA,EAAS,YAGX,OAAM,IAAI,MACR,yEACP,EAGG,MAAM6Y,EAAY,KAAK,OAAS5E,EAGhC,IAFIjU,IAAW,QAAaA,EAAS6Y,KAAW7Y,EAAS6Y,GAEpDzY,EAAO,OAAS,IAAMJ,EAAS,GAAKiU,EAAS,IAAOA,EAAS,KAAK,OACrE,MAAM,IAAI,WAAW,wCAAwC,EAG1DqC,IAAUA,EAAW,QAE1B,IAAIY,GAAc,GAClB,OACE,OAAQZ,EAAQ,CACd,IAAK,MACH,OAAOsC,GAAS,KAAMxY,EAAQ6T,EAAQjU,CAAM,EAE9C,IAAK,OACL,IAAK,QACH,OAAOgZ,GAAU,KAAM5Y,EAAQ6T,EAAQjU,CAAM,EAE/C,IAAK,QACL,IAAK,SACL,IAAK,SACH,OAAOkZ,GAAW,KAAM9Y,EAAQ6T,EAAQjU,CAAM,EAEhD,IAAK,SAEH,OAAOoZ,GAAY,KAAMhZ,EAAQ6T,EAAQjU,CAAM,EAEjD,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAOqZ,GAAU,KAAMjZ,EAAQ6T,EAAQjU,CAAM,EAE/C,QACE,GAAIkX,GAAa,MAAM,IAAI,UAAU,qBAAuBZ,CAAQ,EACpEA,GAAY,GAAKA,GAAU,YAAW,EACtCY,GAAc,EACvB,CAEA,EAECpC,EAAO,UAAU,OAAS,UAAmB,CAC3C,MAAO,CACL,KAAM,SACN,KAAM,MAAM,UAAU,MAAM,KAAK,KAAK,MAAQ,KAAM,CAAC,CAC1D,CACA,EAEC,SAAS4C,GAAanC,EAAKrJ,EAAOC,EAAK,CACrC,OAAID,IAAU,GAAKC,IAAQoJ,EAAI,OACtBZ,EAAO,cAAcY,CAAG,EAExBZ,EAAO,cAAcY,EAAI,MAAMrJ,EAAOC,CAAG,CAAC,CAEtD,CAEC,SAASoL,GAAWhC,EAAKrJ,EAAOC,EAAK,CACnCA,EAAM,KAAK,IAAIoJ,EAAI,OAAQpJ,CAAG,EAC9B,MAAM/F,EAAM,CAAA,EAEZ,IAAIzD,EAAIuJ,EACR,KAAOvJ,EAAIwJ,GAAK,CACd,MAAMoN,EAAYhE,EAAI5S,CAAC,EACvB,IAAI6W,GAAY,KACZC,GAAoBF,EAAY,IAChC,EACCA,EAAY,IACT,EACCA,EAAY,IACT,EACA,EAEZ,GAAI5W,EAAI8W,IAAoBtN,EAAK,CAC/B,IAAIuN,GAAYC,GAAWC,GAAYC,GAEvC,OAAQJ,GAAgB,CACtB,IAAK,GACCF,EAAY,MACdC,GAAYD,GAEd,MACF,IAAK,GACHG,GAAanE,EAAI5S,EAAI,CAAC,GACjB+W,GAAa,OAAU,MAC1BG,IAAiBN,EAAY,KAAS,EAAOG,GAAa,GACtDG,GAAgB,MAClBL,GAAYK,KAGhB,MACF,IAAK,GACHH,GAAanE,EAAI5S,EAAI,CAAC,EACtBgX,GAAYpE,EAAI5S,EAAI,CAAC,GAChB+W,GAAa,OAAU,MAASC,GAAY,OAAU,MACzDE,IAAiBN,EAAY,KAAQ,IAAOG,GAAa,KAAS,EAAOC,GAAY,GACjFE,GAAgB,OAAUA,GAAgB,OAAUA,GAAgB,SACtEL,GAAYK,KAGhB,MACF,IAAK,GACHH,GAAanE,EAAI5S,EAAI,CAAC,EACtBgX,GAAYpE,EAAI5S,EAAI,CAAC,EACrBiX,GAAarE,EAAI5S,EAAI,CAAC,GACjB+W,GAAa,OAAU,MAASC,GAAY,OAAU,MAASC,GAAa,OAAU,MACzFC,IAAiBN,EAAY,KAAQ,IAAQG,GAAa,KAAS,IAAOC,GAAY,KAAS,EAAOC,GAAa,GAC/GC,GAAgB,OAAUA,GAAgB,UAC5CL,GAAYK,IAG3B,CACA,CAESL,KAAc,MAGhBA,GAAY,MACZC,GAAmB,GACVD,GAAY,QAErBA,IAAa,MACbpT,EAAI,KAAKoT,KAAc,GAAK,KAAQ,KAAM,EAC1CA,GAAY,MAASA,GAAY,MAGnCpT,EAAI,KAAKoT,EAAS,EAClB7W,GAAK8W,EACV,CAEG,OAAOK,GAAsB1T,CAAG,CACnC,CAKC,MAAM2T,GAAuB,KAE7B,SAASD,GAAuBE,EAAY,CAC1C,MAAMlH,EAAMkH,EAAW,OACvB,GAAIlH,GAAOiH,GACT,OAAO,OAAO,aAAa,MAAM,OAAQC,CAAU,EAIrD,IAAI5T,EAAM,GACNzD,EAAI,EACR,KAAOA,EAAImQ,GACT1M,GAAO,OAAO,aAAa,MACzB,OACA4T,EAAW,MAAMrX,EAAGA,GAAKoX,EAAoB,GAGjD,OAAO3T,CACV,CAEC,SAASoR,GAAYjC,EAAKrJ,EAAOC,EAAK,CACpC,IAAI8N,EAAM,GACV9N,EAAM,KAAK,IAAIoJ,EAAI,OAAQpJ,CAAG,EAE9B,QAASxJ,EAAIuJ,EAAOvJ,EAAIwJ,EAAK,EAAExJ,EAC7BsX,GAAO,OAAO,aAAa1E,EAAI5S,CAAC,EAAI,GAAI,EAE1C,OAAOsX,CACV,CAEC,SAASxC,GAAalC,EAAKrJ,EAAOC,EAAK,CACrC,IAAI8N,EAAM,GACV9N,EAAM,KAAK,IAAIoJ,EAAI,OAAQpJ,CAAG,EAE9B,QAASxJ,EAAIuJ,EAAOvJ,EAAIwJ,EAAK,EAAExJ,EAC7BsX,GAAO,OAAO,aAAa1E,EAAI5S,CAAC,CAAC,EAEnC,OAAOsX,CACV,CAEC,SAAS3C,GAAU/B,EAAKrJ,EAAOC,EAAK,CAClC,MAAM2G,EAAMyC,EAAI,QAEZ,CAACrJ,GAASA,EAAQ,KAAGA,EAAQ,IAC7B,CAACC,GAAOA,EAAM,GAAKA,EAAM2G,KAAK3G,EAAM2G,GAExC,IAAIoH,EAAM,GACV,QAASvX,EAAIuJ,EAAOvJ,EAAIwJ,EAAK,EAAExJ,EAC7BuX,GAAOC,GAAoB5E,EAAI5S,CAAC,CAAC,EAEnC,OAAOuX,CACV,CAEC,SAASvC,GAAcpC,EAAKrJ,EAAOC,EAAK,CACtC,MAAMiO,EAAQ7E,EAAI,MAAMrJ,EAAOC,CAAG,EAClC,IAAI/F,EAAM,GAEV,QAASzD,EAAI,EAAGA,EAAIyX,EAAM,OAAS,EAAGzX,GAAK,EACzCyD,GAAO,OAAO,aAAagU,EAAMzX,CAAC,EAAKyX,EAAMzX,EAAI,CAAC,EAAI,GAAI,EAE5D,OAAOyD,CACV,CAEC0O,EAAO,UAAU,MAAQ,SAAgB5I,EAAOC,EAAK,CACnD,MAAM2G,EAAM,KAAK,OACjB5G,EAAQ,CAAC,CAACA,EACVC,EAAMA,IAAQ,OAAY2G,EAAM,CAAC,CAAC3G,EAE9BD,EAAQ,GACVA,GAAS4G,EACL5G,EAAQ,IAAGA,EAAQ,IACdA,EAAQ4G,IACjB5G,EAAQ4G,GAGN3G,EAAM,GACRA,GAAO2G,EACH3G,EAAM,IAAGA,EAAM,IACVA,EAAM2G,IACf3G,EAAM2G,GAGJ3G,EAAMD,IAAOC,EAAMD,GAEvB,MAAMmO,EAAS,KAAK,SAASnO,EAAOC,CAAG,EAEvC,cAAO,eAAekO,EAAQvF,EAAO,SAAS,EAEvCuF,CACV,EAKC,SAASC,GAAarG,EAAQsG,EAAKva,EAAQ,CACzC,GAAKiU,EAAS,IAAO,GAAKA,EAAS,EAAG,MAAM,IAAI,WAAW,oBAAoB,EAC/E,GAAIA,EAASsG,EAAMva,EAAQ,MAAM,IAAI,WAAW,uCAAuC,CAC1F,CAEC8U,EAAO,UAAU,WACjBA,EAAO,UAAU,WAAa,SAAqBb,EAAQzB,EAAYgI,EAAU,CAC/EvG,EAASA,IAAW,EACpBzB,EAAaA,IAAe,EACvBgI,GAAUF,GAAYrG,EAAQzB,EAAY,KAAK,MAAM,EAE1D,IAAI0F,EAAM,KAAKjE,CAAM,EACjBwG,EAAM,EACN9X,GAAI,EACR,KAAO,EAAEA,GAAI6P,IAAeiI,GAAO,MACjCvC,GAAO,KAAKjE,EAAStR,EAAC,EAAI8X,EAG5B,OAAOvC,CACV,EAECpD,EAAO,UAAU,WACjBA,EAAO,UAAU,WAAa,SAAqBb,EAAQzB,EAAYgI,EAAU,CAC/EvG,EAASA,IAAW,EACpBzB,EAAaA,IAAe,EACvBgI,GACHF,GAAYrG,EAAQzB,EAAY,KAAK,MAAM,EAG7C,IAAI0F,EAAM,KAAKjE,EAAS,EAAEzB,CAAU,EAChCiI,EAAM,EACV,KAAOjI,EAAa,IAAMiI,GAAO,MAC/BvC,GAAO,KAAKjE,EAAS,EAAEzB,CAAU,EAAIiI,EAGvC,OAAOvC,CACV,EAECpD,EAAO,UAAU,UACjBA,EAAO,UAAU,UAAY,SAAoBb,EAAQuG,EAAU,CACjE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,GAAYrG,EAAQ,EAAG,KAAK,MAAM,EAC1C,KAAKA,CAAM,CACrB,EAECa,EAAO,UAAU,aACjBA,EAAO,UAAU,aAAe,SAAuBb,EAAQuG,EAAU,CACvE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,GAAYrG,EAAQ,EAAG,KAAK,MAAM,EAC1C,KAAKA,CAAM,EAAK,KAAKA,EAAS,CAAC,GAAK,CAC9C,EAECa,EAAO,UAAU,aACjBA,EAAO,UAAU,aAAe,SAAuBb,EAAQuG,EAAU,CACvE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,GAAYrG,EAAQ,EAAG,KAAK,MAAM,EACzC,KAAKA,CAAM,GAAK,EAAK,KAAKA,EAAS,CAAC,CAC/C,EAECa,EAAO,UAAU,aACjBA,EAAO,UAAU,aAAe,SAAuBb,EAAQuG,EAAU,CACvE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,GAAYrG,EAAQ,EAAG,KAAK,MAAM,GAExC,KAAKA,CAAM,EACf,KAAKA,EAAS,CAAC,GAAK,EACpB,KAAKA,EAAS,CAAC,GAAK,IACpB,KAAKA,EAAS,CAAC,EAAI,QAC3B,EAECa,EAAO,UAAU,aACjBA,EAAO,UAAU,aAAe,SAAuBb,EAAQuG,EAAU,CACvE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,GAAYrG,EAAQ,EAAG,KAAK,MAAM,EAEzC,KAAKA,CAAM,EAAI,UACnB,KAAKA,EAAS,CAAC,GAAK,GACrB,KAAKA,EAAS,CAAC,GAAK,EACrB,KAAKA,EAAS,CAAC,EACpB,EAECa,EAAO,UAAU,gBAAkB4F,GAAmB,SAA0BzG,EAAQ,CACtFA,EAASA,IAAW,EACpB0G,EAAe1G,EAAQ,QAAQ,EAC/B,MAAM2G,EAAQ,KAAK3G,CAAM,EACnB4G,EAAO,KAAK5G,EAAS,CAAC,GACxB2G,IAAU,QAAaC,IAAS,SAClCC,EAAY7G,EAAQ,KAAK,OAAS,CAAC,EAGrC,MAAM8G,EAAKH,EACT,KAAK,EAAE3G,CAAM,EAAI,GAAK,EACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,GACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,GAElB+G,EAAK,KAAK,EAAE/G,CAAM,EACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,EACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,GACtB4G,EAAO,GAAK,GAEd,OAAO,OAAOE,CAAE,GAAK,OAAOC,CAAE,GAAK,OAAO,EAAE,EAC/C,CAAE,EAEDlG,EAAO,UAAU,gBAAkB4F,GAAmB,SAA0BzG,EAAQ,CACtFA,EAASA,IAAW,EACpB0G,EAAe1G,EAAQ,QAAQ,EAC/B,MAAM2G,EAAQ,KAAK3G,CAAM,EACnB4G,EAAO,KAAK5G,EAAS,CAAC,GACxB2G,IAAU,QAAaC,IAAS,SAClCC,EAAY7G,EAAQ,KAAK,OAAS,CAAC,EAGrC,MAAM+G,EAAKJ,EAAQ,GAAK,GACtB,KAAK,EAAE3G,CAAM,EAAI,GAAK,GACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,EACtB,KAAK,EAAEA,CAAM,EAET8G,EAAK,KAAK,EAAE9G,CAAM,EAAI,GAAK,GAC/B,KAAK,EAAEA,CAAM,EAAI,GAAK,GACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,EACtB4G,EAEF,OAAQ,OAAOG,CAAE,GAAK,OAAO,EAAE,GAAK,OAAOD,CAAE,CAChD,CAAE,EAEDjG,EAAO,UAAU,UAAY,SAAoBb,EAAQzB,EAAYgI,EAAU,CAC7EvG,EAASA,IAAW,EACpBzB,EAAaA,IAAe,EACvBgI,GAAUF,GAAYrG,EAAQzB,EAAY,KAAK,MAAM,EAE1D,IAAI0F,EAAM,KAAKjE,CAAM,EACjBwG,EAAM,EACN9X,GAAI,EACR,KAAO,EAAEA,GAAI6P,IAAeiI,GAAO,MACjCvC,GAAO,KAAKjE,EAAStR,EAAC,EAAI8X,EAE5B,OAAAA,GAAO,IAEHvC,GAAOuC,IAAKvC,GAAO,KAAK,IAAI,EAAG,EAAI1F,CAAU,GAE1C0F,CACV,EAECpD,EAAO,UAAU,UAAY,SAAoBb,EAAQzB,EAAYgI,EAAU,CAC7EvG,EAASA,IAAW,EACpBzB,EAAaA,IAAe,EACvBgI,GAAUF,GAAYrG,EAAQzB,EAAY,KAAK,MAAM,EAE1D,IAAI7P,EAAI6P,EACJiI,EAAM,EACNvC,GAAM,KAAKjE,EAAS,EAAEtR,CAAC,EAC3B,KAAOA,EAAI,IAAM8X,GAAO,MACtBvC,IAAO,KAAKjE,EAAS,EAAEtR,CAAC,EAAI8X,EAE9B,OAAAA,GAAO,IAEHvC,IAAOuC,IAAKvC,IAAO,KAAK,IAAI,EAAG,EAAI1F,CAAU,GAE1C0F,EACV,EAECpD,EAAO,UAAU,SAAW,SAAmBb,EAAQuG,EAAU,CAG/D,OAFAvG,EAASA,IAAW,EACfuG,GAAUF,GAAYrG,EAAQ,EAAG,KAAK,MAAM,EAC3C,KAAKA,CAAM,EAAI,KACZ,IAAO,KAAKA,CAAM,EAAI,GAAK,GADA,KAAKA,CAAM,CAElD,EAECa,EAAO,UAAU,YAAc,SAAsBb,EAAQuG,EAAU,CACrEvG,EAASA,IAAW,EACfuG,GAAUF,GAAYrG,EAAQ,EAAG,KAAK,MAAM,EACjD,MAAMiE,EAAM,KAAKjE,CAAM,EAAK,KAAKA,EAAS,CAAC,GAAK,EAChD,OAAQiE,EAAM,MAAUA,EAAM,WAAaA,CAC9C,EAECpD,EAAO,UAAU,YAAc,SAAsBb,EAAQuG,EAAU,CACrEvG,EAASA,IAAW,EACfuG,GAAUF,GAAYrG,EAAQ,EAAG,KAAK,MAAM,EACjD,MAAMiE,EAAM,KAAKjE,EAAS,CAAC,EAAK,KAAKA,CAAM,GAAK,EAChD,OAAQiE,EAAM,MAAUA,EAAM,WAAaA,CAC9C,EAECpD,EAAO,UAAU,YAAc,SAAsBb,EAAQuG,EAAU,CACrE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,GAAYrG,EAAQ,EAAG,KAAK,MAAM,EAEzC,KAAKA,CAAM,EAChB,KAAKA,EAAS,CAAC,GAAK,EACpB,KAAKA,EAAS,CAAC,GAAK,GACpB,KAAKA,EAAS,CAAC,GAAK,EAC1B,EAECa,EAAO,UAAU,YAAc,SAAsBb,EAAQuG,EAAU,CACrE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,GAAYrG,EAAQ,EAAG,KAAK,MAAM,EAEzC,KAAKA,CAAM,GAAK,GACrB,KAAKA,EAAS,CAAC,GAAK,GACpB,KAAKA,EAAS,CAAC,GAAK,EACpB,KAAKA,EAAS,CAAC,CACrB,EAECa,EAAO,UAAU,eAAiB4F,GAAmB,SAAyBzG,EAAQ,CACpFA,EAASA,IAAW,EACpB0G,EAAe1G,EAAQ,QAAQ,EAC/B,MAAM2G,EAAQ,KAAK3G,CAAM,EACnB4G,EAAO,KAAK5G,EAAS,CAAC,GACxB2G,IAAU,QAAaC,IAAS,SAClCC,EAAY7G,EAAQ,KAAK,OAAS,CAAC,EAGrC,MAAMiE,EAAM,KAAKjE,EAAS,CAAC,EACzB,KAAKA,EAAS,CAAC,EAAI,GAAK,EACxB,KAAKA,EAAS,CAAC,EAAI,GAAK,IACvB4G,GAAQ,IAEX,OAAQ,OAAO3C,CAAG,GAAK,OAAO,EAAE,GAC9B,OAAO0C,EACP,KAAK,EAAE3G,CAAM,EAAI,GAAK,EACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,GACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,EAAE,CAC7B,CAAE,EAEDa,EAAO,UAAU,eAAiB4F,GAAmB,SAAyBzG,EAAQ,CACpFA,EAASA,IAAW,EACpB0G,EAAe1G,EAAQ,QAAQ,EAC/B,MAAM2G,EAAQ,KAAK3G,CAAM,EACnB4G,EAAO,KAAK5G,EAAS,CAAC,GACxB2G,IAAU,QAAaC,IAAS,SAClCC,EAAY7G,EAAQ,KAAK,OAAS,CAAC,EAGrC,MAAMiE,GAAO0C,GAAS,IACpB,KAAK,EAAE3G,CAAM,EAAI,GAAK,GACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,EACtB,KAAK,EAAEA,CAAM,EAEf,OAAQ,OAAOiE,CAAG,GAAK,OAAO,EAAE,GAC9B,OAAO,KAAK,EAAEjE,CAAM,EAAI,GAAK,GAC7B,KAAK,EAAEA,CAAM,EAAI,GAAK,GACtB,KAAK,EAAEA,CAAM,EAAI,GAAK,EACtB4G,CAAI,CACT,CAAE,EAED/F,EAAO,UAAU,YAAc,SAAsBb,EAAQuG,EAAU,CACrE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,GAAYrG,EAAQ,EAAG,KAAK,MAAM,EAC1CW,EAAU,KAAK,KAAMX,EAAQ,GAAM,GAAI,CAAC,CAClD,EAECa,EAAO,UAAU,YAAc,SAAsBb,EAAQuG,EAAU,CACrE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,GAAYrG,EAAQ,EAAG,KAAK,MAAM,EAC1CW,EAAU,KAAK,KAAMX,EAAQ,GAAO,GAAI,CAAC,CACnD,EAECa,EAAO,UAAU,aAAe,SAAuBb,EAAQuG,EAAU,CACvE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,GAAYrG,EAAQ,EAAG,KAAK,MAAM,EAC1CW,EAAU,KAAK,KAAMX,EAAQ,GAAM,GAAI,CAAC,CAClD,EAECa,EAAO,UAAU,aAAe,SAAuBb,EAAQuG,EAAU,CACvE,OAAAvG,EAASA,IAAW,EACfuG,GAAUF,GAAYrG,EAAQ,EAAG,KAAK,MAAM,EAC1CW,EAAU,KAAK,KAAMX,EAAQ,GAAO,GAAI,CAAC,CACnD,EAEC,SAASgH,GAAU1F,EAAK7P,EAAOuO,EAAQsG,EAAKpY,EAAK+Y,EAAK,CACpD,GAAI,CAACpG,EAAO,SAASS,CAAG,EAAG,MAAM,IAAI,UAAU,6CAA6C,EAC5F,GAAI7P,EAAQvD,GAAOuD,EAAQwV,EAAK,MAAM,IAAI,WAAW,mCAAmC,EACxF,GAAIjH,EAASsG,EAAMhF,EAAI,OAAQ,MAAM,IAAI,WAAW,oBAAoB,CAC3E,CAECT,EAAO,UAAU,YACjBA,EAAO,UAAU,YAAc,SAAsBpP,EAAOuO,EAAQzB,EAAYgI,EAAU,CAIxF,GAHA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACpBzB,EAAaA,IAAe,EACxB,CAACgI,EAAU,CACb,MAAMW,GAAW,KAAK,IAAI,EAAG,EAAI3I,CAAU,EAAI,EAC/CyI,GAAS,KAAMvV,EAAOuO,EAAQzB,EAAY2I,GAAU,CAAC,CAC1D,CAEG,IAAIV,EAAM,EACN9X,GAAI,EAER,IADA,KAAKsR,CAAM,EAAIvO,EAAQ,IAChB,EAAE/C,GAAI6P,IAAeiI,GAAO,MACjC,KAAKxG,EAAStR,EAAC,EAAK+C,EAAQ+U,EAAO,IAGrC,OAAOxG,EAASzB,CACnB,EAECsC,EAAO,UAAU,YACjBA,EAAO,UAAU,YAAc,SAAsBpP,EAAOuO,EAAQzB,EAAYgI,EAAU,CAIxF,GAHA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACpBzB,EAAaA,IAAe,EACxB,CAACgI,EAAU,CACb,MAAMW,GAAW,KAAK,IAAI,EAAG,EAAI3I,CAAU,EAAI,EAC/CyI,GAAS,KAAMvV,EAAOuO,EAAQzB,EAAY2I,GAAU,CAAC,CAC1D,CAEG,IAAIxY,EAAI6P,EAAa,EACjBiI,GAAM,EAEV,IADA,KAAKxG,EAAStR,CAAC,EAAI+C,EAAQ,IACpB,EAAE/C,GAAK,IAAM8X,IAAO,MACzB,KAAKxG,EAAStR,CAAC,EAAK+C,EAAQ+U,GAAO,IAGrC,OAAOxG,EAASzB,CACnB,EAECsC,EAAO,UAAU,WACjBA,EAAO,UAAU,WAAa,SAAqBpP,EAAOuO,EAAQuG,EAAU,CAC1E,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,IAAM,CAAC,EACvD,KAAKA,CAAM,EAAKvO,EAAQ,IACjBuO,EAAS,CACnB,EAECa,EAAO,UAAU,cACjBA,EAAO,UAAU,cAAgB,SAAwBpP,EAAOuO,EAAQuG,EAAU,CAChF,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,MAAQ,CAAC,EACzD,KAAKA,CAAM,EAAKvO,EAAQ,IACxB,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,EACvBuO,EAAS,CACnB,EAECa,EAAO,UAAU,cACjBA,EAAO,UAAU,cAAgB,SAAwBpP,EAAOuO,EAAQuG,EAAU,CAChF,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,MAAQ,CAAC,EACzD,KAAKA,CAAM,EAAKvO,IAAU,EAC1B,KAAKuO,EAAS,CAAC,EAAKvO,EAAQ,IACrBuO,EAAS,CACnB,EAECa,EAAO,UAAU,cACjBA,EAAO,UAAU,cAAgB,SAAwBpP,EAAOuO,EAAQuG,EAAU,CAChF,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,WAAY,CAAC,EAC7D,KAAKA,EAAS,CAAC,EAAKvO,IAAU,GAC9B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,GAC9B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,EAC9B,KAAKuO,CAAM,EAAKvO,EAAQ,IACjBuO,EAAS,CACnB,EAECa,EAAO,UAAU,cACjBA,EAAO,UAAU,cAAgB,SAAwBpP,EAAOuO,EAAQuG,EAAU,CAChF,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,WAAY,CAAC,EAC7D,KAAKA,CAAM,EAAKvO,IAAU,GAC1B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,GAC9B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,EAC9B,KAAKuO,EAAS,CAAC,EAAKvO,EAAQ,IACrBuO,EAAS,CACnB,EAEC,SAASmH,GAAgB7F,EAAK7P,EAAOuO,EAAQiH,EAAK/Y,EAAK,CACrDkZ,EAAW3V,EAAOwV,EAAK/Y,EAAKoT,EAAKtB,EAAQ,CAAC,EAE1C,IAAI8G,EAAK,OAAOrV,EAAQ,OAAO,UAAU,CAAC,EAC1C6P,EAAItB,GAAQ,EAAI8G,EAChBA,EAAKA,GAAM,EACXxF,EAAItB,GAAQ,EAAI8G,EAChBA,EAAKA,GAAM,EACXxF,EAAItB,GAAQ,EAAI8G,EAChBA,EAAKA,GAAM,EACXxF,EAAItB,GAAQ,EAAI8G,EAChB,IAAIC,GAAK,OAAOtV,GAAS,OAAO,EAAE,EAAI,OAAO,UAAU,CAAC,EACxD,OAAA6P,EAAItB,GAAQ,EAAI+G,GAChBA,GAAKA,IAAM,EACXzF,EAAItB,GAAQ,EAAI+G,GAChBA,GAAKA,IAAM,EACXzF,EAAItB,GAAQ,EAAI+G,GAChBA,GAAKA,IAAM,EACXzF,EAAItB,GAAQ,EAAI+G,GACT/G,CACV,CAEC,SAASqH,GAAgB/F,EAAK7P,EAAOuO,EAAQiH,EAAK/Y,EAAK,CACrDkZ,EAAW3V,EAAOwV,EAAK/Y,EAAKoT,EAAKtB,EAAQ,CAAC,EAE1C,IAAI8G,EAAK,OAAOrV,EAAQ,OAAO,UAAU,CAAC,EAC1C6P,EAAItB,EAAS,CAAC,EAAI8G,EAClBA,EAAKA,GAAM,EACXxF,EAAItB,EAAS,CAAC,EAAI8G,EAClBA,EAAKA,GAAM,EACXxF,EAAItB,EAAS,CAAC,EAAI8G,EAClBA,EAAKA,GAAM,EACXxF,EAAItB,EAAS,CAAC,EAAI8G,EAClB,IAAIC,GAAK,OAAOtV,GAAS,OAAO,EAAE,EAAI,OAAO,UAAU,CAAC,EACxD,OAAA6P,EAAItB,EAAS,CAAC,EAAI+G,GAClBA,GAAKA,IAAM,EACXzF,EAAItB,EAAS,CAAC,EAAI+G,GAClBA,GAAKA,IAAM,EACXzF,EAAItB,EAAS,CAAC,EAAI+G,GAClBA,GAAKA,IAAM,EACXzF,EAAItB,CAAM,EAAI+G,GACP/G,EAAS,CACnB,CAECa,EAAO,UAAU,iBAAmB4F,GAAmB,SAA2BhV,EAAOuO,EAAS,EAAG,CACnG,OAAOmH,GAAe,KAAM1V,EAAOuO,EAAQ,OAAO,CAAC,EAAG,OAAO,oBAAoB,CAAC,CACrF,CAAE,EAEDa,EAAO,UAAU,iBAAmB4F,GAAmB,SAA2BhV,EAAOuO,EAAS,EAAG,CACnG,OAAOqH,GAAe,KAAM5V,EAAOuO,EAAQ,OAAO,CAAC,EAAG,OAAO,oBAAoB,CAAC,CACrF,CAAE,EAEDa,EAAO,UAAU,WAAa,SAAqBpP,EAAOuO,EAAQzB,EAAYgI,EAAU,CAGtF,GAFA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EAChB,CAACuG,EAAU,CACb,MAAMe,GAAQ,KAAK,IAAI,EAAI,EAAI/I,EAAc,CAAC,EAE9CyI,GAAS,KAAMvV,EAAOuO,EAAQzB,EAAY+I,GAAQ,EAAG,CAACA,EAAK,CAChE,CAEG,IAAI5Y,EAAI,EACJ8X,GAAM,EACNe,GAAM,EAEV,IADA,KAAKvH,CAAM,EAAIvO,EAAQ,IAChB,EAAE/C,EAAI6P,IAAeiI,IAAO,MAC7B/U,EAAQ,GAAK8V,KAAQ,GAAK,KAAKvH,EAAStR,EAAI,CAAC,IAAM,IACrD6Y,GAAM,GAER,KAAKvH,EAAStR,CAAC,GAAM+C,EAAQ+U,IAAQ,GAAKe,GAAM,IAGlD,OAAOvH,EAASzB,CACnB,EAECsC,EAAO,UAAU,WAAa,SAAqBpP,EAAOuO,EAAQzB,EAAYgI,EAAU,CAGtF,GAFA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EAChB,CAACuG,EAAU,CACb,MAAMe,GAAQ,KAAK,IAAI,EAAI,EAAI/I,EAAc,CAAC,EAE9CyI,GAAS,KAAMvV,EAAOuO,EAAQzB,EAAY+I,GAAQ,EAAG,CAACA,EAAK,CAChE,CAEG,IAAI5Y,EAAI6P,EAAa,EACjBiI,GAAM,EACNe,GAAM,EAEV,IADA,KAAKvH,EAAStR,CAAC,EAAI+C,EAAQ,IACpB,EAAE/C,GAAK,IAAM8X,IAAO,MACrB/U,EAAQ,GAAK8V,KAAQ,GAAK,KAAKvH,EAAStR,EAAI,CAAC,IAAM,IACrD6Y,GAAM,GAER,KAAKvH,EAAStR,CAAC,GAAM+C,EAAQ+U,IAAQ,GAAKe,GAAM,IAGlD,OAAOvH,EAASzB,CACnB,EAECsC,EAAO,UAAU,UAAY,SAAoBpP,EAAOuO,EAAQuG,EAAU,CACxE,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,IAAM,IAAK,EACvDvO,EAAQ,IAAGA,EAAQ,IAAOA,EAAQ,GACtC,KAAKuO,CAAM,EAAKvO,EAAQ,IACjBuO,EAAS,CACnB,EAECa,EAAO,UAAU,aAAe,SAAuBpP,EAAOuO,EAAQuG,EAAU,CAC9E,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,MAAQ,MAAO,EAC/D,KAAKA,CAAM,EAAKvO,EAAQ,IACxB,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,EACvBuO,EAAS,CACnB,EAECa,EAAO,UAAU,aAAe,SAAuBpP,EAAOuO,EAAQuG,EAAU,CAC9E,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,MAAQ,MAAO,EAC/D,KAAKA,CAAM,EAAKvO,IAAU,EAC1B,KAAKuO,EAAS,CAAC,EAAKvO,EAAQ,IACrBuO,EAAS,CACnB,EAECa,EAAO,UAAU,aAAe,SAAuBpP,EAAOuO,EAAQuG,EAAU,CAC9E,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,WAAY,WAAW,EACvE,KAAKA,CAAM,EAAKvO,EAAQ,IACxB,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,EAC9B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,GAC9B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,GACvBuO,EAAS,CACnB,EAECa,EAAO,UAAU,aAAe,SAAuBpP,EAAOuO,EAAQuG,EAAU,CAC9E,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GAAUS,GAAS,KAAMvV,EAAOuO,EAAQ,EAAG,WAAY,WAAW,EACnEvO,EAAQ,IAAGA,EAAQ,WAAaA,EAAQ,GAC5C,KAAKuO,CAAM,EAAKvO,IAAU,GAC1B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,GAC9B,KAAKuO,EAAS,CAAC,EAAKvO,IAAU,EAC9B,KAAKuO,EAAS,CAAC,EAAKvO,EAAQ,IACrBuO,EAAS,CACnB,EAECa,EAAO,UAAU,gBAAkB4F,GAAmB,SAA0BhV,EAAOuO,EAAS,EAAG,CACjG,OAAOmH,GAAe,KAAM1V,EAAOuO,EAAQ,CAAC,OAAO,oBAAoB,EAAG,OAAO,oBAAoB,CAAC,CACzG,CAAE,EAEDa,EAAO,UAAU,gBAAkB4F,GAAmB,SAA0BhV,EAAOuO,EAAS,EAAG,CACjG,OAAOqH,GAAe,KAAM5V,EAAOuO,EAAQ,CAAC,OAAO,oBAAoB,EAAG,OAAO,oBAAoB,CAAC,CACzG,CAAE,EAED,SAASwH,GAAclG,EAAK7P,EAAOuO,EAAQsG,EAAKpY,EAAK+Y,EAAK,CACxD,GAAIjH,EAASsG,EAAMhF,EAAI,OAAQ,MAAM,IAAI,WAAW,oBAAoB,EACxE,GAAItB,EAAS,EAAG,MAAM,IAAI,WAAW,oBAAoB,CAC5D,CAEC,SAASyH,GAAYnG,EAAK7P,EAAOuO,EAAQ0H,EAAcnB,EAAU,CAC/D,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GACHiB,GAAalG,EAAK7P,EAAOuO,EAAQ,CAAC,EAEpCW,EAAU,MAAMW,EAAK7P,EAAOuO,EAAQ0H,EAAc,GAAI,CAAC,EAChD1H,EAAS,CACnB,CAECa,EAAO,UAAU,aAAe,SAAuBpP,EAAOuO,EAAQuG,EAAU,CAC9E,OAAOkB,GAAW,KAAMhW,EAAOuO,EAAQ,GAAMuG,CAAQ,CACxD,EAEC1F,EAAO,UAAU,aAAe,SAAuBpP,EAAOuO,EAAQuG,EAAU,CAC9E,OAAOkB,GAAW,KAAMhW,EAAOuO,EAAQ,GAAOuG,CAAQ,CACzD,EAEC,SAASoB,GAAarG,EAAK7P,EAAOuO,EAAQ0H,EAAcnB,EAAU,CAChE,OAAA9U,EAAQ,CAACA,EACTuO,EAASA,IAAW,EACfuG,GACHiB,GAAalG,EAAK7P,EAAOuO,EAAQ,CAAC,EAEpCW,EAAU,MAAMW,EAAK7P,EAAOuO,EAAQ0H,EAAc,GAAI,CAAC,EAChD1H,EAAS,CACnB,CAECa,EAAO,UAAU,cAAgB,SAAwBpP,EAAOuO,EAAQuG,EAAU,CAChF,OAAOoB,GAAY,KAAMlW,EAAOuO,EAAQ,GAAMuG,CAAQ,CACzD,EAEC1F,EAAO,UAAU,cAAgB,SAAwBpP,EAAOuO,EAAQuG,EAAU,CAChF,OAAOoB,GAAY,KAAMlW,EAAOuO,EAAQ,GAAOuG,CAAQ,CAC1D,EAGC1F,EAAO,UAAU,KAAO,SAAejV,EAAQgc,EAAa3P,EAAOC,EAAK,CACtE,GAAI,CAAC2I,EAAO,SAASjV,CAAM,EAAG,MAAM,IAAI,UAAU,6BAA6B,EAS/E,GARKqM,IAAOA,EAAQ,GAChB,CAACC,GAAOA,IAAQ,IAAGA,EAAM,KAAK,QAC9B0P,GAAehc,EAAO,SAAQgc,EAAchc,EAAO,QAClDgc,IAAaA,EAAc,GAC5B1P,EAAM,GAAKA,EAAMD,IAAOC,EAAMD,GAG9BC,IAAQD,GACRrM,EAAO,SAAW,GAAK,KAAK,SAAW,EAAG,MAAO,GAGrD,GAAIgc,EAAc,EAChB,MAAM,IAAI,WAAW,2BAA2B,EAElD,GAAI3P,EAAQ,GAAKA,GAAS,KAAK,OAAQ,MAAM,IAAI,WAAW,oBAAoB,EAChF,GAAIC,EAAM,EAAG,MAAM,IAAI,WAAW,yBAAyB,EAGvDA,EAAM,KAAK,SAAQA,EAAM,KAAK,QAC9BtM,EAAO,OAASgc,EAAc1P,EAAMD,IACtCC,EAAMtM,EAAO,OAASgc,EAAc3P,GAGtC,MAAM4G,EAAM3G,EAAMD,EAElB,OAAI,OAASrM,GAAU,OAAOoV,EAAiB,UAAU,YAAe,WAEtE,KAAK,WAAW4G,EAAa3P,EAAOC,CAAG,EAEvC8I,EAAiB,UAAU,IAAI,KAC7BpV,EACA,KAAK,SAASqM,EAAOC,CAAG,EACxB0P,GAIG/I,CACV,EAMCgC,EAAO,UAAU,KAAO,SAAeoD,EAAKhM,EAAOC,EAAKmK,EAAU,CAEhE,GAAI,OAAO4B,GAAQ,SAAU,CAS3B,GARI,OAAOhM,GAAU,UACnBoK,EAAWpK,EACXA,EAAQ,EACRC,EAAM,KAAK,QACF,OAAOA,GAAQ,WACxBmK,EAAWnK,EACXA,EAAM,KAAK,QAETmK,IAAa,QAAa,OAAOA,GAAa,SAChD,MAAM,IAAI,UAAU,2BAA2B,EAEjD,GAAI,OAAOA,GAAa,UAAY,CAACxB,EAAO,WAAWwB,CAAQ,EAC7D,MAAM,IAAI,UAAU,qBAAuBA,CAAQ,EAErD,GAAI4B,EAAI,SAAW,EAAG,CACpB,MAAMpQ,GAAOoQ,EAAI,WAAW,CAAC,GACxB5B,IAAa,QAAUxO,GAAO,KAC/BwO,IAAa,YAEf4B,EAAMpQ,GAEf,CACA,MAAc,OAAOoQ,GAAQ,SACxBA,EAAMA,EAAM,IACH,OAAOA,GAAQ,YACxBA,EAAM,OAAOA,CAAG,GAIlB,GAAIhM,EAAQ,GAAK,KAAK,OAASA,GAAS,KAAK,OAASC,EACpD,MAAM,IAAI,WAAW,oBAAoB,EAG3C,GAAIA,GAAOD,EACT,OAAO,KAGTA,EAAQA,IAAU,EAClBC,EAAMA,IAAQ,OAAY,KAAK,OAASA,IAAQ,EAE3C+L,IAAKA,EAAM,GAEhB,IAAIvV,EACJ,GAAI,OAAOuV,GAAQ,SACjB,IAAKvV,EAAIuJ,EAAOvJ,EAAIwJ,EAAK,EAAExJ,EACzB,KAAKA,CAAC,EAAIuV,MAEP,CACL,MAAMkC,GAAQtF,EAAO,SAASoD,CAAG,EAC7BA,EACApD,EAAO,KAAKoD,EAAK5B,CAAQ,EACvBxD,GAAMsH,GAAM,OAClB,GAAItH,KAAQ,EACV,MAAM,IAAI,UAAU,cAAgBoF,EAClC,mCAAmC,EAEvC,IAAKvV,EAAI,EAAGA,EAAIwJ,EAAMD,EAAO,EAAEvJ,EAC7B,KAAKA,EAAIuJ,CAAK,EAAIkO,GAAMzX,EAAImQ,EAAG,CAEtC,CAEG,OAAO,IACV,EAMC,MAAMgJ,GAAS,CAAA,EACf,SAAS1d,EAAG2d,EAAKC,EAAYC,EAAM,CACjCH,GAAOC,CAAG,EAAI,cAAwBE,CAAK,CACzC,aAAe,CACb,MAAK,EAEL,OAAO,eAAe,KAAM,UAAW,CACrC,MAAOD,EAAW,MAAM,KAAM,SAAS,EACvC,SAAU,GACV,aAAc,EACvB,CAAQ,EAGD,KAAK,KAAO,GAAG,KAAK,IAAI,KAAKD,CAAG,IAGhC,KAAK,MAEL,OAAO,KAAK,IACnB,CAEK,IAAI,MAAQ,CACV,OAAOA,CACd,CAEK,IAAI,KAAMrW,EAAO,CACf,OAAO,eAAe,KAAM,OAAQ,CAClC,aAAc,GACd,WAAY,GACZ,MAAAA,EACA,SAAU,EACnB,CAAQ,CACR,CAEK,UAAY,CACV,MAAO,GAAG,KAAK,IAAI,KAAKqW,CAAG,MAAM,KAAK,OAAO,EACpD,EAEA,CAEC3d,EAAE,2BACA,SAAUmF,EAAM,CACd,OAAIA,EACK,GAAGA,CAAI,+BAGT,gDACZ,EAAM,UAAU,EACfnF,EAAE,uBACA,SAAUmF,EAAMiT,EAAQ,CACtB,MAAO,QAAQjT,CAAI,oDAAoD,OAAOiT,CAAM,EACzF,EAAM,SAAS,EACdpY,EAAE,mBACA,SAAUmG,EAAK2X,EAAO/T,EAAO,CAC3B,IAAIgU,EAAM,iBAAiB5X,CAAG,qBAC1B6X,EAAWjU,EACf,OAAI,OAAO,UAAUA,CAAK,GAAK,KAAK,IAAIA,CAAK,EAAI,GAAK,GACpDiU,EAAWC,EAAsB,OAAOlU,CAAK,CAAC,EACrC,OAAOA,GAAU,WAC1BiU,EAAW,OAAOjU,CAAK,GACnBA,EAAQ,OAAO,CAAC,GAAK,OAAO,EAAE,GAAKA,EAAQ,EAAE,OAAO,CAAC,GAAK,OAAO,EAAE,MACrEiU,EAAWC,EAAsBD,CAAQ,GAE3CA,GAAY,KAEdD,GAAO,eAAeD,CAAK,cAAcE,CAAQ,GAC1CD,CACZ,EAAM,UAAU,EAEf,SAASE,EAAuBnE,EAAK,CACnC,IAAI9R,EAAM,GACNzD,EAAIuV,EAAI,OACZ,MAAMhM,EAAQgM,EAAI,CAAC,IAAM,IAAM,EAAI,EACnC,KAAOvV,GAAKuJ,EAAQ,EAAGvJ,GAAK,EAC1ByD,EAAM,IAAI8R,EAAI,MAAMvV,EAAI,EAAGA,CAAC,CAAC,GAAGyD,CAAG,GAErC,MAAO,GAAG8R,EAAI,MAAM,EAAGvV,CAAC,CAAC,GAAGyD,CAAG,EAClC,CAKC,SAASkW,EAAa/G,EAAKtB,EAAQzB,EAAY,CAC7CmI,EAAe1G,EAAQ,QAAQ,GAC3BsB,EAAItB,CAAM,IAAM,QAAasB,EAAItB,EAASzB,CAAU,IAAM,SAC5DsI,EAAY7G,EAAQsB,EAAI,QAAU/C,EAAa,EAAE,CAEtD,CAEC,SAAS6I,EAAY3V,EAAOwV,EAAK/Y,EAAKoT,EAAKtB,EAAQzB,EAAY,CAC7D,GAAI9M,EAAQvD,GAAOuD,EAAQwV,EAAK,CAC9B,MAAM5d,GAAI,OAAO4d,GAAQ,SAAW,IAAM,GAC1C,IAAIgB,GAEF,MAAIhB,IAAQ,GAAKA,IAAQ,OAAO,CAAC,EAC/BgB,GAAQ,OAAO5e,EAAC,WAAWA,EAAC,QAAQkV,EAAa,GAAK,CAAC,GAAGlV,EAAC,GAE3D4e,GAAQ,SAAS5e,EAAC,QAAQkV,EAAa,GAAK,EAAI,CAAC,GAAGlV,EAAC,iBACzCkV,EAAa,GAAK,EAAI,CAAC,GAAGlV,EAAC,GAKrC,IAAIwe,GAAO,iBAAiB,QAASI,GAAOxW,CAAK,CAC5D,CACG4W,EAAY/G,EAAKtB,EAAQzB,CAAU,CACtC,CAEC,SAASmI,EAAgBjV,EAAOnC,EAAM,CACpC,GAAI,OAAOmC,GAAU,SACnB,MAAM,IAAIoW,GAAO,qBAAqBvY,EAAM,SAAUmC,CAAK,CAEhE,CAEC,SAASoV,EAAapV,EAAO1F,EAAQyD,EAAM,CACzC,MAAI,KAAK,MAAMiC,CAAK,IAAMA,GACxBiV,EAAejV,EAAOjC,CAAI,EACpB,IAAIqY,GAAO,iBAAyB,SAAU,aAAcpW,CAAK,GAGrE1F,EAAS,EACL,IAAI8b,GAAO,yBAGb,IAAIA,GAAO,iBAAyB,SACR,eAA6B9b,CAAM,GACnC0F,CAAK,CAC1C,CAKC,MAAM6W,EAAoB,oBAE1B,SAASC,GAAajY,EAAK,CAMzB,GAJAA,EAAMA,EAAI,MAAM,GAAG,EAAE,CAAC,EAEtBA,EAAMA,EAAI,KAAI,EAAG,QAAQgY,EAAmB,EAAE,EAE1ChY,EAAI,OAAS,EAAG,MAAO,GAE3B,KAAOA,EAAI,OAAS,IAAM,GACxBA,EAAMA,EAAM,IAEd,OAAOA,CACV,CAEC,SAAS4S,GAAa/W,EAAQqc,EAAO,CACnCA,EAAQA,GAAS,IACjB,IAAIjD,EACJ,MAAMxZ,EAASI,EAAO,OACtB,IAAIsc,EAAgB,KACpB,MAAMtC,EAAQ,CAAA,EAEd,QAASzX,GAAI,EAAGA,GAAI3C,EAAQ,EAAE2C,GAAG,CAI/B,GAHA6W,EAAYpZ,EAAO,WAAWuC,EAAC,EAG3B6W,EAAY,OAAUA,EAAY,MAAQ,CAE5C,GAAI,CAACkD,EAAe,CAElB,GAAIlD,EAAY,MAAQ,EAEjBiD,GAAS,GAAK,IAAIrC,EAAM,KAAK,IAAM,IAAM,GAAI,EAClD,QACX,SAAoBzX,GAAI,IAAM3C,EAAQ,EAEtByc,GAAS,GAAK,IAAIrC,EAAM,KAAK,IAAM,IAAM,GAAI,EAClD,QACX,CAGSsC,EAAgBlD,EAEhB,QACT,CAGO,GAAIA,EAAY,MAAQ,EACjBiD,GAAS,GAAK,IAAIrC,EAAM,KAAK,IAAM,IAAM,GAAI,EAClDsC,EAAgBlD,EAChB,QACT,CAGOA,GAAakD,EAAgB,OAAU,GAAKlD,EAAY,OAAU,KACzE,MAAgBkD,IAEJD,GAAS,GAAK,IAAIrC,EAAM,KAAK,IAAM,IAAM,GAAI,EAMpD,GAHAsC,EAAgB,KAGZlD,EAAY,IAAM,CACpB,IAAKiD,GAAS,GAAK,EAAG,MACtBrC,EAAM,KAAKZ,CAAS,CAC3B,SAAgBA,EAAY,KAAO,CAC5B,IAAKiD,GAAS,GAAK,EAAG,MACtBrC,EAAM,KACJZ,GAAa,EAAM,IACnBA,EAAY,GAAO,IAE5B,SAAgBA,EAAY,MAAS,CAC9B,IAAKiD,GAAS,GAAK,EAAG,MACtBrC,EAAM,KACJZ,GAAa,GAAM,IACnBA,GAAa,EAAM,GAAO,IAC1BA,EAAY,GAAO,IAE5B,SAAgBA,EAAY,QAAU,CAC/B,IAAKiD,GAAS,GAAK,EAAG,MACtBrC,EAAM,KACJZ,GAAa,GAAO,IACpBA,GAAa,GAAM,GAAO,IAC1BA,GAAa,EAAM,GAAO,IAC1BA,EAAY,GAAO,IAE5B,KACO,OAAM,IAAI,MAAM,oBAAoB,CAE3C,CAEG,OAAOY,CACV,CAEC,SAASjB,GAAc5U,EAAK,CAC1B,MAAMoY,EAAY,CAAA,EAClB,QAASha,EAAI,EAAGA,EAAI4B,EAAI,OAAQ,EAAE5B,EAEhCga,EAAU,KAAKpY,EAAI,WAAW5B,CAAC,EAAI,GAAI,EAEzC,OAAOga,CACV,CAEC,SAASrD,GAAgB/U,EAAKkY,EAAO,CACnC,IAAI5f,EAAGme,EAAID,EACX,MAAM4B,EAAY,CAAA,EAClB,QAASha,GAAI,EAAGA,GAAI4B,EAAI,QACjB,GAAAkY,GAAS,GAAK,GADW,EAAE9Z,GAGhC9F,EAAI0H,EAAI,WAAW5B,EAAC,EACpBqY,EAAKne,GAAK,EACVke,EAAKle,EAAI,IACT8f,EAAU,KAAK5B,CAAE,EACjB4B,EAAU,KAAK3B,CAAE,EAGnB,OAAO2B,CACV,CAEC,SAASvF,GAAe7S,EAAK,CAC3B,OAAOoQ,EAAO,YAAY6H,GAAYjY,CAAG,CAAC,CAC7C,CAEC,SAAS0U,GAAY2D,EAAKC,EAAK5I,EAAQjU,EAAQ,CAC7C,IAAI2C,EACJ,IAAKA,EAAI,EAAGA,EAAI3C,GACT,EAAA2C,EAAIsR,GAAU4I,EAAI,QAAYla,GAAKia,EAAI,QADtB,EAAEja,EAExBka,EAAIla,EAAIsR,CAAM,EAAI2I,EAAIja,CAAC,EAEzB,OAAOA,CACV,CAKC,SAASmT,GAAYhQ,EAAKrC,EAAM,CAC9B,OAAOqC,aAAerC,GACnBqC,GAAO,MAAQA,EAAI,aAAe,MAAQA,EAAI,YAAY,MAAQ,MACjEA,EAAI,YAAY,OAASrC,EAAK,IACrC,CACC,SAASqT,GAAahR,EAAK,CAEzB,OAAOA,IAAQA,CAClB,CAIC,MAAMqU,IAAuB,UAAY,CACvC,MAAM2C,EAAW,mBACXC,EAAQ,IAAI,MAAM,GAAG,EAC3B,QAASpa,EAAI,EAAGA,EAAI,GAAI,EAAEA,EAAG,CAC3B,MAAMqa,EAAMra,EAAI,GAChB,QAASgW,EAAI,EAAGA,EAAI,GAAI,EAAEA,EACxBoE,EAAMC,EAAMrE,CAAC,EAAImE,EAASna,CAAC,EAAIma,EAASnE,CAAC,CAEhD,CACG,OAAOoE,CACV,GAAE,EAGD,SAASrC,GAAoBuC,EAAI,CAC/B,OAAO,OAAO,OAAW,IAAcC,GAAyBD,CACnE,CAEC,SAASC,IAA0B,CACjC,MAAM,IAAI,MAAM,sBAAsB,CACzC,CACA,GAAGxb,CAAM,EAET,MAAMoT,EAASpT,EAAO,OAEtBjE,EAAA,KAAeiE,EAAO,KACtBjE,EAAA,YAAsBiE,EAAO,YAC7BjE,EAAA,OAAiBiE,EAAO,OACxBjE,EAAA,KAAeiE,EAAO,KACtBjE,EAAA,YAAsBiE,EAAO,YAC7BjE,EAAA,kBAA4BiE,EAAO,kBACnCjE,EAAA,WAAqBiE,EAAO,WAC5BjE,EAAA,kBAA4BiE,EAAO,kBACnCjE,EAAA,KAAeiE,EAAO,KACtBjE,EAAA,KAAeiE,EAAO,KACtBjE,EAAA,UAAoBiE,EAAO,UAC3BjE,EAAA,QAAkBqX,EAClBrX,EAAA,QAAkBiE,EAAO,QACzBjE,EAAA,OAAiBiE,EAAO,OACxBjE,EAAA,WAAqBiE,EAAO,WAC5BjE,EAAA,iBAA2BiE,EAAO,iBAClCjE,EAAA,iBAA2BiE,EAAO,iBAClCjE,EAAA,UAAoBiE,EAAO,iECr0E3B,IAAIyb,EAAQ,CACV,MAAO,SAAUzX,EAAO,CAAE,OAAOA,GAAU,MAA+BA,EAAM,cAAgB,KAAK,EACrG,QAAS,SAAUA,EAAO,CAAE,OAAO,OAAOA,GAAU,SAAS,EAC7D,SAAU,SAAUA,EAAO,CAAE,OAAO,OAAOA,GAAU,UAAU,EAC/D,IAAK,SAAUA,EAAO,CAAE,OAA8BA,GAAU,IAAI,EACpE,OAAQ,SAAUA,EAAO,CAAE,OAAO,OAAOA,GAAU,QAAQ,EAC3D,OAAQ,SAAUA,EAAO,CAAE,OAAO,OAAOA,GAAU,QAAQ,EAC3D,OAAQ,SAAUA,EAAO,CAAE,OAAO,OAAOA,GAAU,QAAQ,EAC3D,GAAI,UAAY,CAAE,MAAO,EAAI,CAC/B,EAGAyX,EAAM,KAAOA,EAAM,IAEnB,QAASC,KAAYD,EACnBA,EAAMC,CAAQ,EAAE,OAAS,SAAU,EAAG,CACpC,OAAO,CACX,EAAI,KAAK,KAAMA,CAAQ,EAGvB,OAAAC,GAAiBF,kDCpBjB,IAAIE,EAAS/d,GAAA,EAEb,SAASge,EAAaL,EAAI,CACxB,OAAOA,EAAG,MAAQA,EAAG,SAAQ,EAAG,MAAM,qBAAqB,EAAE,CAAC,CAChE,CAEA,SAASM,EAAkB7X,EAAO,CAChC,OAAO2X,EAAO,IAAI3X,CAAK,EAAI,GAAK4X,EAAY5X,EAAM,WAAW,CAC/D,CAEA,SAAS8X,EAAU9X,EAAO,CACxB,OAAI2X,EAAO,SAAS3X,CAAK,EAAU,GAC/B2X,EAAO,OAAO3X,CAAK,EAAU,KAAK,UAAUA,CAAK,EACjDA,GAAS2X,EAAO,OAAO3X,CAAK,EAAU,GACnCA,CACT,CAEA,SAAS+X,EAAmB1gB,EAAGc,EAAG,CAC5B,MAAM,mBACR,MAAM,kBAAkBd,EAAGc,CAAC,CAEhC,CAEA,SAAS6f,EAAQja,EAAM,CACrB,OAAI4Z,EAAO,SAAS5Z,CAAI,EAAUA,EAAK,OAASA,EAAK,SAAW6Z,EAAY7Z,CAAI,EAC5E4Z,EAAO,MAAM5Z,CAAI,EAAU,QAC3BA,GAAQ4Z,EAAO,OAAO5Z,CAAI,EAAU,SAEjCA,IAAS,OAAYA,EAAO,EACrC,CAEA,SAASka,EAAela,EAAMiC,EAAOkY,EAAe,CAClD,IAAIC,EAAYL,EAAS9X,CAAK,EAE9B,MAAO,YAAcgY,EAAOja,CAAI,EAAI,SACjCma,IAAkB,GAAK,IAAMA,EAAgB,KAC7CC,IAAc,GAAK,IAAMA,EAAY,GAC1C,CAEA,SAASC,EAAara,EAAMiC,EAAOkY,EAAe,CAChDA,EAAgBA,GAAiBL,EAAiB7X,CAAK,EACvD,KAAK,QAAUiY,EAAcla,EAAMiC,EAAOkY,CAAa,EAEvDH,EAAkB,KAAMK,CAAW,EACnC,KAAK,OAASra,EACd,KAAK,QAAUiC,EACf,KAAK,gBAAkBkY,CACzB,CAEAE,EAAY,UAAY,OAAO,OAAO,MAAM,SAAS,EACrDA,EAAY,UAAU,YAAcA,EAEpC,SAASC,EAAuBta,EAAMua,EAAOza,EAAMmC,EAAOkY,EAAe,CACvE,IAAIK,EAAc,aAClB,OAAID,IAAU,QAAOC,EAAc,oBAE5BN,EAAc,aAAeD,EAAOna,CAAI,EAAI0a,EAAcP,EAAOja,CAAI,EAAGiC,EAAOkY,CAAa,CACrG,CAEA,SAASM,EAAqBza,EAAM0a,EAAUH,EAAOtY,EAAOkY,EAAe,CACrEna,GACFma,EAAgBA,GAAiBL,EAAiB7X,CAAK,EACvD,KAAK,QAAUqY,EAAsBta,EAAMua,EAAOG,EAAUzY,EAAOkY,CAAa,GAEhF,KAAK,QAAU,wBAA0BO,EAAW,IAGtDV,EAAkB,KAAMK,CAAW,EACnC,KAAK,QAAUE,EACf,KAAK,WAAaG,EAClB,KAAK,OAAS1a,EACd,KAAK,QAAUiC,EACf,KAAK,gBAAkBkY,CACzB,CAEAM,EAAoB,UAAY,OAAO,OAAO,MAAM,SAAS,EAC7DA,EAAoB,UAAU,YAAcJ,EAE5C,SAASM,EAAeC,EAAU7H,EAAQ,CACxC,OAAO,IAAIsH,EAAYO,EAAU,CAAA,EAAI7H,CAAM,CAC7C,CAEA,SAAS8H,EAAYvhB,EAAGohB,EAAUH,EAAO,CAEvC,OAAIjhB,aAAamhB,GACfC,EAAWA,EAAW,IAAMphB,EAAE,WAE9BA,EAAI,IAAImhB,EACNnhB,EAAE,OAAQohB,EAAUphB,EAAE,QAASA,EAAE,QAASA,EAAE,eAClD,GAGaA,aAAa+gB,IACtB/gB,EAAI,IAAImhB,EACNnhB,EAAE,OAAQohB,EAAUH,EAAOjhB,EAAE,QAASA,EAAE,eAC9C,GAGE0gB,EAAkB1gB,CAAC,EACZA,CACT,CAEA,OAAA+e,GAAiB,CACf,YAAagC,EACb,oBAAqBI,EACrB,cAAeE,EACf,WAAYE,EACZ,OAAQZ,EACR,iBAAkBH,CACpB,kDC7GA,IAAIgB,EAASjf,GAAA,EACTkf,EAASC,GAAA,EAEb,SAASC,EAAShZ,EAAO,CACvB,OAAOoP,GAAO,SAASpP,CAAK,CAC9B,CAEA,SAASiZ,EAAKjZ,EAAO,CACnB,OAAO,OAAOA,GAAU,UAAY,oBAAoB,KAAKA,CAAK,CACpE,CAEA,SAASkZ,EAAUnb,EAAMzD,EAAQ,CAC/B,IAAIuD,EAAOE,EAAK,OAAM,EAEtB,SAASob,EAAQnZ,EAAO,CACtB,GAAI,CAACjC,EAAKiC,CAAK,EAAG,MAAO,GACzB,GAAIA,EAAM,SAAW1F,EAAQ,MAAO,GAEpC,MAAMwe,EAAO,cAAcjb,EAAO,YAAcvD,EAAS,IAAKuD,EAAO,YAAcmC,EAAM,OAAS,GAAG,CACzG,CACE,OAAAmZ,EAAO,OAAS,UAAY,CAAE,OAAOtb,CAAI,EAElCsb,CACT,CAEA,IAAIC,EAAUF,EAAS,KAAK,KAAML,EAAO,KAAK,EAC1CQ,EAAWH,EAAS,KAAK,KAAMF,CAAO,EACtCM,EAAQJ,EAAS,KAAK,KAAMD,CAAG,EAC/BM,EAAWL,EAAS,KAAK,KAAML,EAAO,MAAM,EAEhD,SAASW,EAAOviB,EAAGC,EAAGF,EAAG,CACvBA,EAAIA,GAAK6hB,EAAO,OAChB,SAASY,EAAQzZ,EAAO0Z,EAAQ,CAC9B,OAAO1iB,EAAEgJ,EAAO0Z,CAAM,GAAM1Z,EAAQ/I,GAAO+I,EAAQ9I,CACvD,CACE,OAAAuiB,EAAO,OAAS,UAAY,CAC1B,MAAO,GAAGziB,EAAE,OAAM,CAAE,aAAaC,CAAC,KAAKC,CAAC,GAC5C,EACSuiB,CACT,CAEA,IAAIE,EAAY,KAAK,IAAI,EAAG,EAAE,EAAI,EAElC,SAASC,EAAQ5Z,EAAO,CACtB,OAAO,OAAOA,GAAU,UAAY,SAASA,CAAK,CACpD,CACA,SAAS6Z,EAAM7Z,EAAO,CAAE,OAASA,GAAS,IAAO,KAAQA,CAAK,CAC9D,SAAS8Z,EAAO9Z,EAAO,CAAE,OAASA,GAAS,IAAO,KAAQA,CAAK,CAC/D,SAAS+Z,EAAO/Z,EAAO,CAAE,OAAQA,EAAQ,KAAOA,CAAK,CACrD,SAASga,EAAOha,EAAO,CACrB,OAAO,OAAOA,GAAU,UACtBA,GAAS,CAAC2Z,GACV3Z,GAAS2Z,GACT,KAAK,MAAM3Z,CAAK,IAAMA,CAC1B,CACA,SAASia,EAAOja,EAAO,CAAE,OAAQA,EAAQ,OAAUA,CAAK,CACxD,SAASka,EAAQla,EAAO,CAAE,OAAQA,EAAQ,SAAYA,CAAK,CAC3D,SAASma,EAAQna,EAAO,CAAE,OAAQA,IAAU,IAAOA,CAAK,CACxD,SAASoa,EAAQpa,EAAO,CACtB,OAAO,OAAOA,GAAU,UACtBA,GAAS,GACTA,GAAS2Z,GACT,KAAK,MAAM3Z,CAAK,IAAMA,CAC1B,CAEA,IAAIyX,EAAQ,CACV,OAAQ2B,EACR,OAAQJ,EACR,QAASK,EACT,OAAQO,EACR,IAAKX,EACL,KAAMK,EACN,KAAMO,EACN,MAAOC,EACP,MAAOC,EACP,MAAOC,EACP,MAAOR,EACP,QAASD,EACT,MAAOU,EACP,OAAQC,EACR,OAAQC,EACR,OAAQC,CACV,EAEA,QAAS1C,KAAYD,EACnBA,EAAMC,CAAQ,EAAE,OAAS,SAAUvf,EAAG,CACpC,OAAOA,CACX,EAAI,KAAK,KAAMuf,CAAQ,EAGvB,OAAA2C,GAAiB5C,kDC1FjB,IAAIqB,EAASlf,GAAA,EACTif,EAASE,GAAA,EAGTf,EAASc,EAAO,OAChBV,EAAcU,EAAO,YACrBN,EAAsBM,EAAO,oBAC7BF,EAAaE,EAAO,WACpBjB,EAAmBiB,EAAO,iBAE1BwB,EAAQ,CACV,QAAS,SAAkBvc,EAAMpB,EAAS,CACxCoB,EAAOwc,EAAQxc,CAAI,EACnBpB,EAAUA,GAAW,CAAA,EAErB,SAAS6d,EAAUxJ,EAAO0I,EAAQ,CAKhC,MAJI,CAACb,EAAO,MAAM7H,CAAK,GACnB6H,EAAO,IAAI7H,CAAK,GAChBrU,EAAQ,YAAc,QAAaqU,EAAM,OAASrU,EAAQ,WAC1DA,EAAQ,YAAc,QAAaqU,EAAM,OAASrU,EAAQ,WAC1DA,EAAQ,SAAW,QAAaqU,EAAM,SAAWrU,EAAQ,OAAe,GAErEqU,EAAM,MAAM,SAAUhR,EAAO/C,EAAG,CACrC,GAAI,CACF,OAAOwd,EAAU1c,EAAMiC,EAAO0Z,CAAM,CAC9C,OAAiBriB,EAAG,CACV,MAAMuhB,EAAWvhB,EAAG4F,CAAC,CAC/B,CACA,CAAO,CACP,CACI,OAAAud,EAAS,OAAS,UAAY,CAC5B,IAAI3b,EAAM,IAAMmZ,EAAOja,CAAI,EAAI,IAC/B,OAAIpB,EAAQ,SAAW,OACrBkC,GAAO,IAAMlC,EAAQ,OAAS,KACrBA,EAAQ,YAAc,QAAaA,EAAQ,YAAc,UAClEkC,GAAO,KACJlC,EAAQ,YAAc,OAAY,EAAIA,EAAQ,WAAa,KAC3DA,EAAQ,YAAc,OAAY,IAAWA,EAAQ,WAAa,KAEhEkC,CACb,EAEW2b,CACX,EAEE,MAAO,SAASE,EAAO3c,EAAM,CAC3BA,EAAOwc,EAAQxc,CAAI,EAEnB,SAAS4c,EAAQ3a,EAAO0Z,EAAQ,CAC9B,OAAOb,EAAO,IAAI7Y,CAAK,GAAKjC,EAAKiC,EAAO0Z,EAAQgB,CAAK,CAC3D,CACI,OAAAC,EAAO,OAAS,UAAY,CAAE,MAAO,IAAM3C,EAAOja,CAAI,CAAC,EAEhD4c,CACX,EAEE,IAAK,SAAcC,EAAcC,EAAiB,CAChDD,EAAeL,EAAQK,CAAY,EAC/BC,IAAiBA,EAAkBN,EAAQM,CAAe,GAE9D,SAASC,EAAM9a,EAAO0Z,EAAQ,CAE5B,GADI,CAACb,EAAO,OAAO7Y,CAAK,GACpB6Y,EAAO,IAAI7Y,CAAK,EAAG,MAAO,GAE9B,QAAS+a,KAAgB/a,EAAO,CAC9B,GAAI,CACE6a,GACFJ,EAAUI,EAAiBE,EAAcrB,CAAM,CAE3D,OAAiBriB,EAAG,CACV,MAAMuhB,EAAWvhB,EAAG0jB,EAAc,KAAK,CACjD,CAEQ,GAAI,CACF,IAAIC,EAAgBhb,EAAM+a,CAAY,EACtCN,EAAUG,EAAcI,EAAetB,CAAM,CACvD,OAAiBriB,EAAG,CACV,MAAMuhB,EAAWvhB,EAAG0jB,CAAY,CAC1C,CACA,CAEM,MAAO,EACb,CAEI,OAAIF,EACFC,EAAK,OAAS,UAAY,CACxB,MAAO,IAAM9C,EAAO6C,CAAe,EAAI,KAAO7C,EAAO4C,CAAY,EAAI,GAC7E,EAEME,EAAK,OAAS,UAAY,CAAE,MAAO,IAAM9C,EAAO4C,CAAY,EAAI,GAAG,EAG9DE,CACX,EAEE,OAAQ,SAAiBG,EAAY,CACnC,IAAIld,EAAO,CAAA,EAEX,QAASmd,KAAoBD,EAC3Bld,EAAKmd,CAAgB,EAAIX,EAAQU,EAAWC,CAAgB,CAAC,EAG/D,SAASC,EAASnb,EAAO0Z,EAAQ,CAE/B,GADI,CAACb,EAAO,OAAO7Y,CAAK,GACpB6Y,EAAO,IAAI7Y,CAAK,EAAG,MAAO,GAE9B,IAAI+a,EAEJ,GAAI,CACF,IAAKA,KAAgBhd,EAAM,CACzB,IAAI6c,EAAe7c,EAAKgd,CAAY,EAChCC,EAAgBhb,EAAM+a,CAAY,EAEtCN,EAAUG,EAAcI,EAAetB,CAAM,CACvD,CACA,OAAeriB,EAAG,CACV,MAAMuhB,EAAWvhB,EAAG0jB,CAAY,CACxC,CAEM,GAAIrB,GACF,IAAKqB,KAAgB/a,EACnB,GAAI,CAAAjC,EAAKgd,CAAY,EAErB,MAAM,IAAIvC,EAAoB,OAAWuC,CAAY,EAIzD,MAAO,EACb,CACI,OAAAI,EAAQ,OAAS,UAAY,CAAE,OAAOnD,EAAOja,CAAI,CAAC,EAE3Cod,CACX,EAEE,MAAO,UAAkB,CACvB,IAAI1D,EAAQ,CAAA,EAAG,MAAM,KAAK,SAAS,EAAE,IAAI8C,CAAO,EAEhD,SAASa,EAAQpb,EAAO0Z,EAAQ,CAC9B,OAAOjC,EAAM,KAAK,SAAU1Z,EAAM,CAChC,GAAI,CACF,OAAO0c,EAAU1c,EAAMiC,EAAO0Z,CAAM,CAC9C,MAAoB,CACV,MAAO,EACjB,CACA,CAAO,CACP,CACI,OAAA0B,EAAO,OAAS,UAAY,CAAE,OAAO3D,EAAM,IAAIO,CAAM,EAAE,KAAK,GAAG,CAAC,EAEzDoD,CACX,EAEE,MAAO,UAAkB,CACvB,IAAI3D,EAAQ,CAAA,EAAG,MAAM,KAAK,SAAS,EAAE,IAAI8C,CAAO,EAEhD,SAASc,EAAQrb,EAAO0Z,EAAQ,CAC9B,OAAOjC,EAAM,MAAM,SAAU1Z,EAAM,CACjC,GAAI,CACF,OAAO0c,EAAU1c,EAAMiC,EAAO0Z,CAAM,CAC9C,MAAoB,CACV,MAAO,EACjB,CACA,CAAO,CACP,CACI,OAAA2B,EAAO,OAAS,UAAY,CAAE,OAAO5D,EAAM,IAAIO,CAAM,EAAE,KAAK,KAAK,CAAC,EAE3DqD,CACX,EAEE,WAAY,SAAqBtd,EAAM,CACrC,SAASud,EAAatb,EAAO,CAC3B,OAAOjC,IAAS8Z,EAAiB7X,CAAK,CAC5C,CACI,OAAAsb,EAAY,OAAS,UAAY,CAAE,OAAOvd,CAAI,EAEvCud,CACX,EAEE,MAAO,UAAkB,CACvB,IAAI7D,EAAQ,CAAA,EAAG,MAAM,KAAK,SAAS,EAAE,IAAI8C,CAAO,EAEhD,SAASgB,EAAQC,EAAQ9B,EAAQ,CAG/B,OAFIb,EAAO,IAAI2C,CAAM,GACjB3C,EAAO,IAAI2C,EAAO,MAAM,GACxB9B,GAAW8B,EAAO,SAAW/D,EAAM,OAAgB,GAEhDA,EAAM,MAAM,SAAU1Z,EAAMd,EAAG,CACpC,GAAI,CACF,OAAOwd,EAAU1c,EAAMyd,EAAOve,CAAC,EAAGyc,CAAM,CAClD,OAAiBriB,EAAG,CACV,MAAMuhB,EAAWvhB,EAAG4F,CAAC,CAC/B,CACA,CAAO,CACP,CACI,OAAAse,EAAO,OAAS,UAAY,CAAE,MAAO,IAAM9D,EAAM,IAAIO,CAAM,EAAE,KAAK,IAAI,EAAI,GAAG,EAEtEuD,CACX,EAEE,MAAO,SAAgB5C,EAAU,CAC/B,SAAS8C,EAAQ3K,EAAQ,CACvB,OAAOA,IAAW6H,CACxB,CACI,OAAA8C,EAAO,OAAS,UAAY,CAAE,OAAO9C,CAAQ,EAEtC8C,CACX,CACA,EAGAnB,EAAM,MAAQA,EAAM,MAEpB,SAASC,EAASxc,EAAM,CACtB,GAAI8a,EAAO,OAAO9a,CAAI,EACpB,OAAIA,EAAK,CAAC,IAAM,IAAYuc,EAAM,MAAMvc,EAAK,MAAM,CAAC,CAAC,EAE9C8a,EAAO9a,CAAI,GAAKuc,EAAM,WAAWvc,CAAI,EACvC,GAAIA,GAAQ8a,EAAO,OAAO9a,CAAI,EAAG,CACtC,GAAI8a,EAAO,MAAM9a,CAAI,EAAG,CACtB,GAAIA,EAAK,SAAW,EAAG,MAAM,IAAI,UAAU,wDAAwD,EACnG,OAAOuc,EAAM,QAAQvc,EAAK,CAAC,CAAC,CAClC,CAEI,OAAOuc,EAAM,OAAOvc,CAAI,CAC5B,SAAa8a,EAAO,SAAS9a,CAAI,EAC7B,OAAOA,EAGT,OAAOuc,EAAM,MAAMvc,CAAI,CACzB,CAEA,SAAS0c,EAAW1c,EAAMiC,EAAO0Z,EAAQgC,EAAW,CAClD,GAAI7C,EAAO,SAAS9a,CAAI,EAAG,CACzB,GAAIA,EAAKiC,EAAO0Z,CAAM,EAAG,MAAO,GAEhC,MAAM,IAAItB,EAAYsD,GAAa3d,EAAMiC,CAAK,CAClD,CAGE,OAAOya,EAAUF,EAAQxc,CAAI,EAAGiC,EAAO0Z,CAAM,CAC/C,CAGA,QAAShC,KAAYmB,EACnB4B,EAAU/C,CAAQ,EAAImB,EAAOnB,CAAQ,EAGvC,IAAKA,KAAY4C,EACfG,EAAU/C,CAAQ,EAAI4C,EAAM5C,CAAQ,EAGtC,IAAIiE,EAAQC,GAAA,EACZ,IAAKlE,KAAYiE,EACflB,EAAU/C,CAAQ,EAAIiE,EAAMjE,CAAQ,EAGtC,OAAA+C,EAAU,QAAUF,EACpBE,EAAU,YAAcrC,EACxBqC,EAAU,oBAAsBjC,EAEhCqD,GAAiBpB,yEClQjB,OAAO,eAAeqB,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,OAAiB,OACjBA,GAAA,OAAiB,OAAO,YAAe,UAAY,WAAY,WAAa,WAAW,OAAS,8DCEhG,sEACA,OAAO,eAAc/jB,EAAU,aAAc,CAAE,MAAO,GAAM,EAC5DA,EAAA,2BAAqCA,EAAA,wBAAkCA,kBAA0BA,EAAA,KAAeA,EAAA,SAAmBA,aAAqBA,EAAA,aAAuBA,EAAA,UAAoBA,EAAA,KAAe,OAClNA,EAAA,QAAkBgkB,EAClBhkB,EAAA,QAAkBikB,EAClBjkB,EAAA,OAAiBkkB,EACjBlkB,EAAA,MAAgBmkB,EAChBnkB,EAAA,QAAkBokB,EAClBpkB,EAAA,QAAkBqkB,EAClBrkB,EAAA,GAAaskB,EACbtkB,EAAA,IAAcukB,EACdvkB,EAAA,MAAgBwkB,EAChBxkB,EAAA,WAAqBykB,EACrBzkB,EAAA,KAAe0kB,EACf1kB,EAAA,KAAe2kB,EACf3kB,EAAA,SAAmB4kB,EACnB5kB,EAAA,WAAqB6kB,EACrB7kB,EAAA,WAAqB8kB,EACrB9kB,EAAA,WAAqB+kB,EACrB/kB,EAAA,UAAoBglB,EACpBhlB,EAAA,YAAsB0Z,EACtB1Z,EAAA,YAAsBilB,EACtBjlB,EAAA,QAAkBklB,EAClBllB,EAAA,gBAA0BmlB,EAC1BnlB,EAAA,YAAsBolB,EACtBplB,EAAA,UAAoBqlB,EACpBrlB,EAAA,aAAuBslB,EACvBtlB,EAAA,gBAA0BulB,EAC1BvlB,EAAA,YAAsBwlB,EACtBxlB,EAAA,YAAsBylB,EAOtB,MAAMC,EAAW7jB,GAAA,EAEjB,SAASmiB,EAAQ9kB,EAAG,CAChB,OAAOA,aAAa,YAAe,YAAY,OAAOA,CAAC,GAAKA,EAAE,YAAY,OAAS,YACvF,CAEA,SAAS+kB,EAAQpkB,EAAG,CAChB,GAAI,CAAC,OAAO,cAAcA,CAAC,GAAKA,EAAI,EAChC,MAAM,IAAI,MAAM,kCAAoCA,CAAC,CAC7D,CAEA,SAASqkB,EAAO/kB,KAAMwmB,EAAS,CAC3B,GAAI,CAAC3B,EAAQ7kB,CAAC,EACV,MAAM,IAAI,MAAM,qBAAqB,EACzC,GAAIwmB,EAAQ,OAAS,GAAK,CAACA,EAAQ,SAASxmB,EAAE,MAAM,EAChD,MAAM,IAAI,MAAM,iCAAmCwmB,EAAU,gBAAkBxmB,EAAE,MAAM,CAC/F,CAEA,SAASglB,EAAM3kB,EAAG,CACd,GAAI,OAAOA,GAAM,YAAc,OAAOA,EAAE,QAAW,WAC/C,MAAM,IAAI,MAAM,8CAA8C,EAClEykB,EAAQzkB,EAAE,SAAS,EACnBykB,EAAQzkB,EAAE,QAAQ,CACtB,CAEA,SAAS4kB,EAAQwB,EAAUC,EAAgB,GAAM,CAC7C,GAAID,EAAS,UACT,MAAM,IAAI,MAAM,kCAAkC,EACtD,GAAIC,GAAiBD,EAAS,SAC1B,MAAM,IAAI,MAAM,uCAAuC,CAC/D,CAEA,SAASvB,EAAQ5H,EAAKmJ,EAAU,CAC5B1B,EAAOzH,CAAG,EACV,MAAMgB,EAAMmI,EAAS,UACrB,GAAInJ,EAAI,OAASgB,EACb,MAAM,IAAI,MAAM,yDAA2DA,CAAG,CAEtF,CAEA,SAAS6G,EAAG1O,EAAK,CACb,OAAO,IAAI,WAAWA,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,CACpE,CAEA,SAAS2O,EAAI3O,EAAK,CACd,OAAO,IAAI,YAAYA,EAAI,OAAQA,EAAI,WAAY,KAAK,MAAMA,EAAI,WAAa,CAAC,CAAC,CACrF,CAEA,SAAS4O,KAASsB,EAAQ,CACtB,QAAS5gB,EAAI,EAAGA,EAAI4gB,EAAO,OAAQ5gB,IAC/B4gB,EAAO5gB,CAAC,EAAE,KAAK,CAAC,CAExB,CAEA,SAASuf,EAAW7O,EAAK,CACrB,OAAO,IAAI,SAASA,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,CAClE,CAEA,SAAS8O,EAAKqB,EAAMC,EAAO,CACvB,OAAQD,GAAS,GAAKC,EAAWD,IAASC,CAC9C,CAEA,SAASrB,EAAKoB,EAAMC,EAAO,CACvB,OAAQD,GAAQC,EAAWD,IAAU,GAAKC,IAAY,CAC1D,CAEAhmB,EAAA,KAAsB,IAAI,WAAW,IAAI,YAAY,CAAC,SAAU,CAAC,EAAE,MAAM,EAAE,CAAC,IAAM,GAElF,SAAS4kB,EAASmB,EAAM,CACpB,OAAUA,GAAQ,GAAM,WAClBA,GAAQ,EAAK,SACbA,IAAS,EAAK,MACdA,IAAS,GAAM,GACzB,CAEA/lB,EAAA,UAAoBA,EAAQ,KACrBH,GAAMA,EACNA,GAAM+kB,EAAS/kB,CAAC,EAEvBG,EAAA,aAAuBA,EAAQ,UAE/B,SAAS6kB,EAAWjP,EAAK,CACrB,QAAS1Q,EAAI,EAAGA,EAAI0Q,EAAI,OAAQ1Q,IAC5B0Q,EAAI1Q,CAAC,EAAI0f,EAAShP,EAAI1Q,CAAC,CAAC,EAE5B,OAAO0Q,CACX,CACA5V,EAAA,WAAqBA,EAAQ,KACtBK,GAAMA,EACPwkB,EAEN,MAAMoB,EAEN,OAAO,WAAW,KAAK,CAAA,CAAE,EAAE,OAAU,YAAc,OAAO,WAAW,SAAY,WAE3EC,EAAwB,MAAM,KAAK,CAAE,OAAQ,GAAG,EAAI,CAACC,EAAGjhB,IAAMA,EAAE,SAAS,EAAE,EAAE,SAAS,EAAG,GAAG,CAAC,EAKnG,SAAS4f,EAAWnI,EAAO,CAGvB,GAFAuH,EAAOvH,CAAK,EAERsJ,EACA,OAAOtJ,EAAM,MAAK,EAEtB,IAAIyJ,EAAM,GACV,QAASlhB,EAAI,EAAGA,EAAIyX,EAAM,OAAQzX,IAC9BkhB,GAAOF,EAAMvJ,EAAMzX,CAAC,CAAC,EAEzB,OAAOkhB,CACX,CAEA,MAAMC,EAAS,CAAE,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAG,EAC5D,SAASC,EAAcve,EAAI,CACvB,GAAIA,GAAMse,EAAO,IAAMte,GAAMse,EAAO,GAChC,OAAOte,EAAKse,EAAO,GACvB,GAAIte,GAAMse,EAAO,GAAKte,GAAMse,EAAO,EAC/B,OAAOte,GAAMse,EAAO,EAAI,IAC5B,GAAIte,GAAMse,EAAO,GAAKte,GAAMse,EAAO,EAC/B,OAAOte,GAAMse,EAAO,EAAI,GAEhC,CAKA,SAAStB,EAAWqB,EAAK,CACrB,GAAI,OAAOA,GAAQ,SACf,MAAM,IAAI,MAAM,4BAA8B,OAAOA,CAAG,EAE5D,GAAIH,EACA,OAAO,WAAW,QAAQG,CAAG,EACjC,MAAMG,EAAKH,EAAI,OACTI,EAAKD,EAAK,EAChB,GAAIA,EAAK,EACL,MAAM,IAAI,MAAM,mDAAqDA,CAAE,EAC3E,MAAMtN,EAAQ,IAAI,WAAWuN,CAAE,EAC/B,QAASC,EAAK,EAAGlJ,EAAK,EAAGkJ,EAAKD,EAAIC,IAAMlJ,GAAM,EAAG,CAC7C,MAAMmJ,GAAKJ,EAAcF,EAAI,WAAW7I,CAAE,CAAC,EACrCoJ,GAAKL,EAAcF,EAAI,WAAW7I,EAAK,CAAC,CAAC,EAC/C,GAAImJ,KAAO,QAAaC,KAAO,OAAW,CACtC,MAAMC,GAAOR,EAAI7I,CAAE,EAAI6I,EAAI7I,EAAK,CAAC,EACjC,MAAM,IAAI,MAAM,+CAAiDqJ,GAAO,cAAgBrJ,CAAE,CACtG,CACQtE,EAAMwN,CAAE,EAAIC,GAAK,GAAKC,EAC9B,CACI,OAAO1N,CACX,CAMA,MAAM4N,EAAW,SAAY,CAAA,EAC7B7mB,EAAA,SAAmB6mB,EAEnB,eAAe7B,EAAU8B,EAAOC,EAAMC,EAAI,CACtC,IAAIC,EAAK,KAAK,IAAG,EACjB,QAAS/hB,EAAI,EAAGA,EAAI4hB,EAAO5hB,IAAK,CAC5B8hB,EAAG9hB,CAAC,EAEJ,MAAMgiB,EAAO,KAAK,IAAG,EAAKD,EACtBC,GAAQ,GAAKA,EAAOH,IAExB,QAAU/mB,EAAQ,UAAQ,EAC1BinB,GAAMC,EACd,CACA,CAKA,SAASxN,EAAY5S,EAAK,CACtB,GAAI,OAAOA,GAAQ,SACf,MAAM,IAAI,MAAM,iBAAiB,EACrC,OAAO,IAAI,WAAW,IAAI,YAAW,EAAG,OAAOA,CAAG,CAAC,CACvD,CAKA,SAASme,EAAYtI,EAAO,CACxB,OAAO,IAAI,YAAW,EAAG,OAAOA,CAAK,CACzC,CAMA,SAASuI,EAAQnf,EAAM,CACnB,OAAI,OAAOA,GAAS,WAChBA,EAAO2T,EAAY3T,CAAI,GAC3Bme,EAAOne,CAAI,EACJA,CACX,CAKA,SAASof,EAAgBpf,EAAM,CAC3B,OAAI,OAAOA,GAAS,WAChBA,EAAO2T,EAAY3T,CAAI,GAC3Bme,EAAOne,CAAI,EACJA,CACX,CAEA,SAASqf,KAAeU,EAAQ,CAC5B,IAAIqB,EAAM,EACV,QAASjiB,EAAI,EAAGA,EAAI4gB,EAAO,OAAQ5gB,IAAK,CACpC,MAAMhG,EAAI4mB,EAAO5gB,CAAC,EAClBgf,EAAOhlB,CAAC,EACRioB,GAAOjoB,EAAE,MACjB,CACI,MAAMyJ,EAAM,IAAI,WAAWwe,CAAG,EAC9B,QAASjiB,EAAI,EAAGkiB,EAAM,EAAGliB,EAAI4gB,EAAO,OAAQ5gB,IAAK,CAC7C,MAAMhG,EAAI4mB,EAAO5gB,CAAC,EAClByD,EAAI,IAAIzJ,EAAGkoB,CAAG,EACdA,GAAOloB,EAAE,MACjB,CACI,OAAOyJ,CACX,CACA,SAAS0c,EAAUgC,EAAUC,EAAM,CAC/B,GAAIA,IAAS,QAAa,CAAA,EAAG,SAAS,KAAKA,CAAI,IAAM,kBACjD,MAAM,IAAI,MAAM,uCAAuC,EAE3D,OADe,OAAO,OAAOD,EAAUC,CAAI,CAE/C,CAEA,MAAMC,CAAK,CACX,CACAvnB,EAAA,KAAeunB,EAEf,SAASjC,EAAakC,EAAU,CAC5B,MAAMC,EAAS/I,GAAQ8I,EAAQ,EAAG,OAAOtC,EAAQxG,CAAG,CAAC,EAAE,OAAM,EACvDxN,EAAMsW,EAAQ,EACpB,OAAAC,EAAM,UAAYvW,EAAI,UACtBuW,EAAM,SAAWvW,EAAI,SACrBuW,EAAM,OAAS,IAAMD,EAAQ,EACtBC,CACX,CACA,SAASlC,EAAgBiC,EAAU,CAC/B,MAAMC,EAAQ,CAAC/I,EAAK4I,IAASE,EAASF,CAAI,EAAE,OAAOpC,EAAQxG,CAAG,CAAC,EAAE,OAAM,EACjExN,EAAMsW,EAAS,EAAE,EACvB,OAAAC,EAAM,UAAYvW,EAAI,UACtBuW,EAAM,SAAWvW,EAAI,SACrBuW,EAAM,OAAUH,GAASE,EAASF,CAAI,EAC/BG,CACX,CACA,SAASjC,EAAYgC,EAAU,CAC3B,MAAMC,EAAQ,CAAC/I,EAAK4I,IAASE,EAASF,CAAI,EAAE,OAAOpC,EAAQxG,CAAG,CAAC,EAAE,OAAM,EACjExN,EAAMsW,EAAS,EAAE,EACvB,OAAAC,EAAM,UAAYvW,EAAI,UACtBuW,EAAM,SAAWvW,EAAI,SACrBuW,EAAM,OAAUH,GAASE,EAASF,CAAI,EAC/BG,CACX,CACAznB,EAAA,gBAA0BslB,EAC1BtlB,EAAA,wBAAkCulB,EAClCvlB,EAAA,2BAAqCwlB,EAErC,SAASC,EAAYiC,EAAc,GAAI,CACnC,GAAIhC,EAAS,QAAU,OAAOA,EAAS,OAAO,iBAAoB,WAC9D,OAAOA,EAAS,OAAO,gBAAgB,IAAI,WAAWgC,CAAW,CAAC,EAGtE,GAAIhC,EAAS,QAAU,OAAOA,EAAS,OAAO,aAAgB,WAC1D,OAAO,WAAW,KAAKA,EAAS,OAAO,YAAYgC,CAAW,CAAC,EAEnE,MAAM,IAAI,MAAM,wCAAwC,CAC5D,sDCtTA,OAAO,eAAeC,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,UAAoBA,GAAA,UAAoBA,GAAA,UAAoBA,aAAoBA,GAAA,OAAiB,OACjGA,GAAA,aAAuBC,EACvBD,GAAA,IAAcE,EACdF,GAAA,IAAcG,EAKd,MAAMC,EAAalmB,GAAA,EAEnB,SAAS+lB,EAAaI,EAAM5O,EAAYnR,EAAOwO,EAAM,CACjD,GAAI,OAAOuR,EAAK,cAAiB,WAC7B,OAAOA,EAAK,aAAa5O,EAAYnR,EAAOwO,CAAI,EACpD,MAAMwR,EAAO,OAAO,EAAE,EAChBC,EAAW,OAAO,UAAU,EAC5BC,EAAK,OAAQlgB,GAASggB,EAAQC,CAAQ,EACtCE,EAAK,OAAOngB,EAAQigB,CAAQ,EAC5B1oB,EAAIiX,EAAO,EAAI,EACf1W,EAAI0W,EAAO,EAAI,EACrBuR,EAAK,UAAU5O,EAAa5Z,EAAG2oB,EAAI1R,CAAI,EACvCuR,EAAK,UAAU5O,EAAarZ,EAAGqoB,EAAI3R,CAAI,CAC3C,CAEA,SAASoR,EAAI3oB,EAAGC,EAAGC,EAAG,CAClB,OAAQF,EAAIC,EAAM,CAACD,EAAIE,CAC3B,CAEA,SAAS0oB,EAAI5oB,EAAGC,EAAGC,EAAG,CAClB,OAAQF,EAAIC,EAAMD,EAAIE,EAAMD,EAAIC,CACpC,CAKA,MAAMipB,UAAeN,EAAW,IAAK,CACjC,YAAYO,EAAUC,EAAWC,EAAW/R,EAAM,CAC9C,MAAK,EACL,KAAK,SAAW,GAChB,KAAK,OAAS,EACd,KAAK,IAAM,EACX,KAAK,UAAY,GACjB,KAAK,SAAW6R,EAChB,KAAK,UAAYC,EACjB,KAAK,UAAYC,EACjB,KAAK,KAAO/R,EACZ,KAAK,OAAS,IAAI,WAAW6R,CAAQ,EACrC,KAAK,QAAWP,EAAW,YAAY,KAAK,MAAM,CAC1D,CACI,OAAOhiB,EAAM,IACLgiB,EAAW,SAAS,IAAI,EAC5BhiB,KAAWgiB,EAAW,SAAShiB,CAAI,KAC/BgiB,EAAW,QAAQhiB,CAAI,EAC3B,KAAM,CAAE,KAAAiiB,EAAM,OAAA/jB,EAAQ,SAAAqkB,CAAQ,EAAK,KAC7BjT,EAAMtP,EAAK,OACjB,QAASwT,EAAM,EAAGA,EAAMlE,GAAM,CAC1B,MAAMoT,EAAO,KAAK,IAAIH,EAAW,KAAK,IAAKjT,EAAMkE,CAAG,EAEpD,GAAIkP,IAASH,EAAU,CACnB,MAAMI,KAAeX,EAAW,YAAYhiB,CAAI,EAChD,KAAOuiB,GAAYjT,EAAMkE,EAAKA,GAAO+O,EACjC,KAAK,QAAQI,EAAUnP,CAAG,EAC9B,QAChB,CACYtV,EAAO,IAAI8B,EAAK,SAASwT,EAAKA,EAAMkP,CAAI,EAAG,KAAK,GAAG,EACnD,KAAK,KAAOA,EACZlP,GAAOkP,EACH,KAAK,MAAQH,IACb,KAAK,QAAQN,EAAM,CAAC,EACpB,KAAK,IAAM,EAE3B,CACQ,YAAK,QAAUjiB,EAAK,OACpB,KAAK,WAAU,EACR,IACf,CACI,WAAW0W,EAAK,IACRsL,EAAW,SAAS,IAAI,KACxBA,EAAW,SAAStL,EAAK,IAAI,EACjC,KAAK,SAAW,GAIhB,KAAM,CAAE,OAAAxY,EAAQ,KAAA+jB,EAAM,SAAAM,EAAU,KAAA7R,CAAI,EAAK,KACzC,GAAI,CAAE,IAAA8C,CAAG,EAAK,KAEdtV,EAAOsV,GAAK,EAAI,OACZwO,EAAW,OAAO,KAAK,OAAO,SAASxO,CAAG,CAAC,EAG3C,KAAK,UAAY+O,EAAW/O,IAC5B,KAAK,QAAQyO,EAAM,CAAC,EACpBzO,EAAM,GAGV,QAASrU,EAAIqU,EAAKrU,EAAIojB,EAAUpjB,IAC5BjB,EAAOiB,CAAC,EAAI,EAIhB0iB,EAAaI,EAAMM,EAAW,EAAG,OAAO,KAAK,OAAS,CAAC,EAAG7R,CAAI,EAC9D,KAAK,QAAQuR,EAAM,CAAC,EACpB,MAAMW,KAAYZ,EAAW,YAAYtL,CAAG,EACtCpH,EAAM,KAAK,UAEjB,GAAIA,EAAM,EACN,MAAM,IAAI,MAAM,6CAA6C,EACjE,MAAMuT,EAASvT,EAAM,EACftH,EAAQ,KAAK,IAAG,EACtB,GAAI6a,EAAS7a,EAAM,OACf,MAAM,IAAI,MAAM,oCAAoC,EACxD,QAAS7I,EAAI,EAAGA,EAAI0jB,EAAQ1jB,IACxByjB,EAAM,UAAU,EAAIzjB,EAAG6I,EAAM7I,CAAC,EAAGuR,CAAI,CACjD,CACI,QAAS,CACL,KAAM,CAAE,OAAAxS,EAAQ,UAAAskB,CAAS,EAAK,KAC9B,KAAK,WAAWtkB,CAAM,EACtB,MAAM0E,EAAM1E,EAAO,MAAM,EAAGskB,CAAS,EACrC,YAAK,QAAO,EACL5f,CACf,CACI,WAAWkgB,EAAI,CACXA,IAAOA,EAAK,IAAI,KAAK,aACrBA,EAAG,IAAI,GAAG,KAAK,IAAG,CAAE,EACpB,KAAM,CAAE,SAAAP,EAAU,OAAArkB,EAAQ,OAAA1B,EAAQ,SAAAumB,EAAU,UAAAC,EAAW,IAAAxP,CAAG,EAAK,KAC/D,OAAAsP,EAAG,UAAYE,EACfF,EAAG,SAAWC,EACdD,EAAG,OAAStmB,EACZsmB,EAAG,IAAMtP,EACLhX,EAAS+lB,GACTO,EAAG,OAAO,IAAI5kB,CAAM,EACjB4kB,CACf,CACI,OAAQ,CACJ,OAAO,KAAK,WAAU,CAC9B,CACA,CACA,OAAAlB,GAAA,OAAiBU,EAMjBV,GAAA,UAAoB,YAAY,KAAK,CACjC,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UACxF,CAAC,EAEDA,GAAA,UAAoB,YAAY,KAAK,CACjC,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,UACxF,CAAC,EAEDA,GAAA,UAAoB,YAAY,KAAK,CACjC,WAAY,WAAY,WAAY,UAAY,WAAY,UAAY,UAAY,WACpF,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UACxF,CAAC,EAEDA,GAAA,UAAoB,YAAY,KAAK,CACjC,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WACpF,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,SACxF,CAAC,+CC/JD,OAAO,eAAeqB,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,UAAoBA,GAAA,UAAoBA,GAAA,IAAcA,GAAA,IAAcA,GAAA,KAAeA,GAAA,KAAe,OAWlG,MAAMC,EAAWpnB,GAAA,EACXkmB,EAAa/G,GAAA,EAEbkI,EAA0B,YAAY,KAAK,CAC7C,WAAY,WAAY,WAAY,UAAY,UACpD,CAAC,EAEKC,EAAyB,IAAI,YAAY,EAAE,EAEjD,MAAMC,UAAaH,EAAS,MAAO,CAC/B,aAAc,CACV,MAAM,GAAI,GAAI,EAAG,EAAK,EACtB,KAAK,EAAIC,EAAQ,CAAC,EAAI,EACtB,KAAK,EAAIA,EAAQ,CAAC,EAAI,EACtB,KAAK,EAAIA,EAAQ,CAAC,EAAI,EACtB,KAAK,EAAIA,EAAQ,CAAC,EAAI,EACtB,KAAK,EAAIA,EAAQ,CAAC,EAAI,CAC9B,CACI,KAAM,CACF,KAAM,CAAE,EAAA1oB,EAAG,EAAAC,EAAG,EAAAb,EAAG,EAAAc,EAAG,EAAAC,CAAC,EAAK,KAC1B,MAAO,CAACH,EAAGC,EAAGb,EAAGc,EAAGC,CAAC,CAC7B,CACI,IAAIH,EAAGC,EAAGb,EAAGc,EAAGC,EAAG,CACf,KAAK,EAAIH,EAAI,EACb,KAAK,EAAIC,EAAI,EACb,KAAK,EAAIb,EAAI,EACb,KAAK,EAAIc,EAAI,EACb,KAAK,EAAIC,EAAI,CACrB,CACI,QAAQqnB,EAAMxR,EAAQ,CAClB,QAAStR,EAAI,EAAGA,EAAI,GAAIA,IAAKsR,GAAU,EACnC2S,EAAOjkB,CAAC,EAAI8iB,EAAK,UAAUxR,EAAQ,EAAK,EAC5C,QAAStR,EAAI,GAAIA,EAAI,GAAIA,IACrBikB,EAAOjkB,CAAC,KAAQ6iB,EAAW,MAAMoB,EAAOjkB,EAAI,CAAC,EAAIikB,EAAOjkB,EAAI,CAAC,EAAIikB,EAAOjkB,EAAI,EAAE,EAAIikB,EAAOjkB,EAAI,EAAE,EAAG,CAAC,EAEvG,GAAI,CAAE,EAAA1E,EAAG,EAAG,EAAAZ,EAAG,EAAAc,EAAG,EAAAC,CAAC,EAAK,KACxB,QAASuE,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,IAAItE,EAAGK,EACHiE,EAAI,IACJtE,KAAQqoB,EAAS,KAAK,EAAGrpB,EAAGc,CAAC,EAC7BO,EAAI,YAECiE,EAAI,IACTtE,EAAI,EAAIhB,EAAIc,EACZO,EAAI,YAECiE,EAAI,IACTtE,KAAQqoB,EAAS,KAAK,EAAGrpB,EAAGc,CAAC,EAC7BO,EAAI,aAGJL,EAAI,EAAIhB,EAAIc,EACZO,EAAI,YAER,MAAMS,KAASqmB,EAAW,MAAMvnB,EAAG,CAAC,EAAII,EAAID,EAAIM,EAAIkoB,EAAOjkB,CAAC,EAAK,EACjEvE,EAAID,EACJA,EAAId,EACJA,KAAQmoB,EAAW,MAAM,EAAG,EAAE,EAC9B,EAAIvnB,EACJA,EAAIkB,CAChB,CAEQlB,EAAKA,EAAI,KAAK,EAAK,EACnB,EAAK,EAAI,KAAK,EAAK,EACnBZ,EAAKA,EAAI,KAAK,EAAK,EACnBc,EAAKA,EAAI,KAAK,EAAK,EACnBC,EAAKA,EAAI,KAAK,EAAK,EACnB,KAAK,IAAIH,EAAG,EAAGZ,EAAGc,EAAGC,CAAC,CAC9B,CACI,YAAa,IACLonB,EAAW,OAAOoB,CAAM,CACpC,CACI,SAAU,CACN,KAAK,IAAI,EAAG,EAAG,EAAG,EAAG,CAAC,KAClBpB,EAAW,OAAO,KAAK,MAAM,CACzC,CACA,CACAiB,GAAA,KAAeI,EAEfJ,GAAA,QAAmBjB,EAAW,cAAc,IAAM,IAAIqB,CAAM,EAE5D,MAAMC,EAAsB,KAAK,IAAI,EAAG,EAAE,EACpCpoB,EAAoB,MAAM,KAAK,CAAE,OAAQ,EAAE,EAAI,CAACklB,EAAGjhB,IAAM,KAAK,MAAMmkB,EAAM,KAAK,IAAI,KAAK,IAAInkB,EAAI,CAAC,CAAC,CAAC,CAAC,EAEpGokB,EAAyBJ,EAAQ,MAAM,EAAG,CAAC,EAE3CK,EAAwB,IAAI,YAAY,EAAE,EAEhD,MAAMC,UAAYP,EAAS,MAAO,CAC9B,aAAc,CACV,MAAM,GAAI,GAAI,EAAG,EAAI,EACrB,KAAK,EAAIK,EAAO,CAAC,EAAI,EACrB,KAAK,EAAIA,EAAO,CAAC,EAAI,EACrB,KAAK,EAAIA,EAAO,CAAC,EAAI,EACrB,KAAK,EAAIA,EAAO,CAAC,EAAI,CAC7B,CACI,KAAM,CACF,KAAM,CAAE,EAAA9oB,EAAG,EAAAC,EAAG,EAAAb,EAAG,EAAAc,CAAC,EAAK,KACvB,MAAO,CAACF,EAAGC,EAAGb,EAAGc,CAAC,CAC1B,CACI,IAAIF,EAAGC,EAAGb,EAAGc,EAAG,CACZ,KAAK,EAAIF,EAAI,EACb,KAAK,EAAIC,EAAI,EACb,KAAK,EAAIb,EAAI,EACb,KAAK,EAAIc,EAAI,CACrB,CACI,QAAQsnB,EAAMxR,EAAQ,CAClB,QAAStR,EAAI,EAAGA,EAAI,GAAIA,IAAKsR,GAAU,EACnC+S,EAAMrkB,CAAC,EAAI8iB,EAAK,UAAUxR,EAAQ,EAAI,EAE1C,GAAI,CAAE,EAAAhW,EAAG,EAAG,EAAAZ,EAAG,EAAAc,CAAC,EAAK,KACrB,QAASwE,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,IAAItE,EAAGrB,EAAGyX,EACN9R,EAAI,IACJtE,KAAQqoB,EAAS,KAAK,EAAGrpB,EAAGc,CAAC,EAC7BnB,EAAI2F,EACJ8R,EAAI,CAAC,EAAG,GAAI,GAAI,EAAE,GAEb9R,EAAI,IACTtE,KAAQqoB,EAAS,KAAKvoB,EAAG,EAAGd,CAAC,EAC7BL,GAAK,EAAI2F,EAAI,GAAK,GAClB8R,EAAI,CAAC,EAAG,EAAG,GAAI,EAAE,GAEZ9R,EAAI,IACTtE,EAAI,EAAIhB,EAAIc,EACZnB,GAAK,EAAI2F,EAAI,GAAK,GAClB8R,EAAI,CAAC,EAAG,GAAI,GAAI,EAAE,IAGlBpW,EAAIhB,GAAK,EAAI,CAACc,GACdnB,EAAK,EAAI2F,EAAK,GACd8R,EAAI,CAAC,EAAG,GAAI,GAAI,EAAE,GAEtBpW,EAAIA,EAAIJ,EAAIS,EAAEiE,CAAC,EAAIqkB,EAAMhqB,CAAC,EAC1BiB,EAAIE,EACJA,EAAId,EACJA,EAAI,EACJ,EAAI,KAAQmoB,EAAW,MAAMnnB,EAAGoW,EAAE9R,EAAI,CAAC,CAAC,CACpD,CAEQ1E,EAAKA,EAAI,KAAK,EAAK,EACnB,EAAK,EAAI,KAAK,EAAK,EACnBZ,EAAKA,EAAI,KAAK,EAAK,EACnBc,EAAKA,EAAI,KAAK,EAAK,EACnB,KAAK,IAAIF,EAAG,EAAGZ,EAAGc,CAAC,CAC3B,CACI,YAAa,IACLqnB,EAAW,OAAOwB,CAAK,CACnC,CACI,SAAU,CACN,KAAK,IAAI,EAAG,EAAG,EAAG,CAAC,KACfxB,EAAW,OAAO,KAAK,MAAM,CACzC,CACA,CACAiB,GAAA,IAAcQ,EAUdR,GAAA,OAAkBjB,EAAW,cAAc,IAAM,IAAIyB,CAAK,EAE1D,MAAMC,EAAyB,WAAW,KAAK,CAC3C,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,CACvD,CAAC,EACKC,EAA+B,WAAW,KAAK,IAAI,MAAM,EAAE,EAAE,KAAK,CAAC,EAAE,IAAI,CAACvD,EAAGjhB,IAAMA,CAAC,CAAC,EACrFykB,EAA+BD,EAAM,IAAKxkB,IAAO,EAAIA,EAAI,GAAK,EAAE,EAChE0kB,GAAyB,IAAM,CAGjC,MAAMjhB,EAAM,CAFF,CAAC+gB,CAAK,EACN,CAACC,CAAK,CACC,EACjB,QAASzkB,EAAI,EAAGA,EAAI,EAAGA,IACnB,QAASgW,KAAKvS,EACVuS,EAAE,KAAKA,EAAEhW,CAAC,EAAE,IAAKzF,GAAMgqB,EAAOhqB,CAAC,CAAC,CAAC,EACzC,OAAOkJ,CACX,GAAC,EACKkhB,EAA8BD,EAAM,CAAC,EACrCE,EAA8BF,EAAM,CAAC,EAErCG,EAA4B,CAC9B,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,CAAC,EACvD,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,CAAC,EACvD,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,CAAC,EACvD,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,CAAC,EACvD,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,CAAC,CAC3D,EAAE,IAAK7kB,GAAM,WAAW,KAAKA,CAAC,CAAC,EACzB8kB,EAA6BH,EAAK,IAAI,CAACvf,EAAKpF,IAAMoF,EAAI,IAAK4Q,GAAM6O,EAAU7kB,CAAC,EAAEgW,CAAC,CAAC,CAAC,EACjF+O,EAA6BH,EAAK,IAAI,CAACxf,EAAKpF,IAAMoF,EAAI,IAAK4Q,GAAM6O,EAAU7kB,CAAC,EAAEgW,CAAC,CAAC,CAAC,EACjFgP,EAAwB,YAAY,KAAK,CAC3C,EAAY,WAAY,WAAY,WAAY,UACpD,CAAC,EACKC,EAAwB,YAAY,KAAK,CAC3C,WAAY,WAAY,WAAY,WAAY,CACpD,CAAC,EAED,SAASC,EAASC,EAAOvqB,EAAGQ,EAAGC,EAAG,CAC9B,OAAI8pB,IAAU,EACHvqB,EAAIQ,EAAIC,EACf8pB,IAAU,EACFvqB,EAAIQ,EAAM,CAACR,EAAIS,EACvB8pB,IAAU,GACFvqB,EAAI,CAACQ,GAAKC,EAClB8pB,IAAU,EACFvqB,EAAIS,EAAMD,EAAI,CAACC,EACpBT,GAAKQ,EAAI,CAACC,EACrB,CAEA,MAAM+pB,EAA0B,IAAI,YAAY,EAAE,EAClD,MAAMC,UAAkBtB,EAAS,MAAO,CACpC,aAAc,CACV,MAAM,GAAI,GAAI,EAAG,EAAI,EACrB,KAAK,GAAK,WACV,KAAK,GAAK,WACV,KAAK,GAAK,YACV,KAAK,GAAK,UACV,KAAK,GAAK,WAClB,CACI,KAAM,CACF,KAAM,CAAE,GAAAuB,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,CAAE,EAAK,KAC/B,MAAO,CAACJ,EAAIC,EAAIC,EAAIC,EAAIC,CAAE,CAClC,CACI,IAAIJ,EAAIC,EAAIC,EAAIC,EAAIC,EAAI,CACpB,KAAK,GAAKJ,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKC,EAAK,CACvB,CACI,QAAQ5C,EAAMxR,EAAQ,CAClB,QAAStR,EAAI,EAAGA,EAAI,GAAIA,IAAKsR,GAAU,EACnC8T,EAAQplB,CAAC,EAAI8iB,EAAK,UAAUxR,EAAQ,EAAI,EAE5C,IAAIgQ,EAAK,KAAK,GAAK,EAAGqE,EAAKrE,EAAIsE,EAAK,KAAK,GAAK,EAAGC,EAAKD,EAAIE,EAAK,KAAK,GAAK,EAAGC,EAAKD,EAAIE,EAAK,KAAK,GAAK,EAAGC,EAAKD,EAAIE,EAAK,KAAK,GAAK,EAAGC,EAAKD,EAGvI,QAASf,EAAQ,EAAGA,EAAQ,EAAGA,IAAS,CACpC,MAAMiB,EAAS,EAAIjB,EACbkB,EAAMrB,EAAMG,CAAK,EAAGmB,EAAMrB,EAAME,CAAK,EACrCoB,GAAK5B,EAAKQ,CAAK,EAAGqB,GAAK5B,EAAKO,CAAK,EACjCsB,GAAK3B,EAAWK,CAAK,EAAGuB,GAAK3B,EAAWI,CAAK,EACnD,QAASnlB,GAAI,EAAGA,GAAI,GAAIA,KAAK,CACzB,MAAM2mB,MAAU9D,EAAW,MAAMvB,EAAK4D,EAASC,EAAOS,EAAIE,EAAIE,CAAE,EAAIZ,EAAQmB,GAAGvmB,EAAC,CAAC,EAAIqmB,EAAKI,GAAGzmB,EAAC,CAAC,EAAIkmB,EAAM,EACzG5E,EAAK4E,EAAIA,EAAKF,EAAIA,KAASnD,EAAW,MAAMiD,EAAI,EAAE,EAAI,EAAGA,EAAKF,EAAIA,EAAKe,EACvF,CAEY,QAAS3mB,GAAI,EAAGA,GAAI,GAAIA,KAAK,CACzB,MAAM4mB,MAAU/D,EAAW,MAAM8C,EAAKT,EAASkB,EAAQP,EAAIE,EAAIE,CAAE,EAAIb,EAAQoB,GAAGxmB,EAAC,CAAC,EAAIsmB,EAAKI,GAAG1mB,EAAC,CAAC,EAAImmB,EAAM,EAC1GR,EAAKQ,EAAIA,EAAKF,EAAIA,KAASpD,EAAW,MAAMkD,EAAI,EAAE,EAAI,EAAGA,EAAKF,EAAIA,EAAKe,EACvF,CACA,CAEQ,KAAK,IAAK,KAAK,GAAKd,EAAKG,EAAM,EAAI,KAAK,GAAKD,EAAKG,EAAM,EAAI,KAAK,GAAKD,EAAKP,EAAM,EAAI,KAAK,GAAKrE,EAAKuE,EAAM,EAAI,KAAK,GAAKD,EAAKG,EAAM,CAAC,CAC5I,CACI,YAAa,IACLlD,EAAW,OAAOuC,CAAO,CACrC,CACI,SAAU,CACN,KAAK,UAAY,MACbvC,EAAW,OAAO,KAAK,MAAM,EACjC,KAAK,IAAI,EAAG,EAAG,EAAG,EAAG,CAAC,CAC9B,CACA,CACA,OAAAiB,GAAA,UAAoBuB,EAMpBvB,GAAA,aAAwBjB,EAAW,cAAc,IAAM,IAAIwC,CAAW,+CC5RtE,OAAO,eAAewB,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,UAAoBA,GAAA,UAAoB,OAQxC,MAAMC,EAAcnqB,GAAA,EAEpBkqB,OAAAA,GAAA,UAAoBC,EAAY,UAEhCD,GAAA,UAAoBC,EAAY,6DCbhC,OAAO,eAAeC,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,KAAeA,GAAA,KAAe,OAM9B,MAAMD,EAAcnqB,GAAA,EAEpB,OAAAoqB,GAAA,KAAeD,EAAY,KAE3BC,GAAA,KAAeD,EAAY,oECX3B,OAAO,eAAeE,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,MAAgBA,GAAA,MAAgBA,GAAA,MAAgBA,UAAiBA,GAAA,OAAiBA,GAAA,OAAiBA,GAAA,OAAiBA,WAAkBA,GAAA,QAAkBA,GAAA,OAAiBA,GAAA,OAAiBA,UAAiBA,GAAA,OAAiBA,GAAA,MAAgBA,GAAA,MAAgBA,GAAA,MAAgBA,SAAgBA,GAAA,MAAgBA,GAAA,MAAgB,OAC5TA,GAAA,IAAcC,EACdD,GAAA,QAAkBE,EAClBF,GAAA,MAAgBG,EAMhB,MAAMC,EAA6B,OAAO,GAAK,GAAK,CAAC,EAC/CrE,EAAuB,OAAO,EAAE,EACtC,SAASmE,EAAQvsB,EAAG0sB,EAAK,GAAO,CAC5B,OAAIA,EACO,CAAE,EAAG,OAAO1sB,EAAIysB,CAAU,EAAG,EAAG,OAAQzsB,GAAKooB,EAAQqE,CAAU,CAAC,EACpE,CAAE,EAAG,OAAQzsB,GAAKooB,EAAQqE,CAAU,EAAI,EAAG,EAAG,OAAOzsB,EAAIysB,CAAU,EAAI,CAAC,CACnF,CACA,SAASD,EAAMG,EAAKD,EAAK,GAAO,CAC5B,MAAMlX,EAAMmX,EAAI,OAChB,IAAIC,EAAK,IAAI,YAAYpX,CAAG,EACxBqX,EAAK,IAAI,YAAYrX,CAAG,EAC5B,QAASnQ,EAAI,EAAGA,EAAImQ,EAAKnQ,IAAK,CAC1B,KAAM,CAAE,EAAA1F,EAAG,EAAAO,CAAC,EAAKqsB,EAAQI,EAAItnB,CAAC,EAAGqnB,CAAE,EACnC,CAACE,EAAGvnB,CAAC,EAAGwnB,EAAGxnB,CAAC,CAAC,EAAI,CAAC1F,EAAGO,CAAC,CAC9B,CACI,MAAO,CAAC0sB,EAAIC,CAAE,CAClB,CACA,MAAMC,EAAQ,CAACntB,EAAGO,IAAO,OAAOP,IAAM,CAAC,GAAKyoB,EAAQ,OAAOloB,IAAM,CAAC,EAClEmsB,GAAA,MAAgBS,EAEhB,MAAMC,EAAQ,CAACptB,EAAGqtB,EAAI7V,IAAMxX,IAAMwX,EAClCkV,GAAA,MAAgBU,EAChB,MAAME,EAAQ,CAACttB,EAAGO,EAAGiX,IAAOxX,GAAM,GAAKwX,EAAOjX,IAAMiX,EACpDkV,GAAA,MAAgBY,EAEhB,MAAMC,EAAS,CAACvtB,EAAGO,EAAGiX,IAAOxX,IAAMwX,EAAMjX,GAAM,GAAKiX,EACpDkV,GAAA,OAAiBa,EACjB,MAAMC,EAAS,CAACxtB,EAAGO,EAAGiX,IAAOxX,GAAM,GAAKwX,EAAOjX,IAAMiX,EACrDkV,GAAA,OAAiBc,EAEjB,MAAMC,EAAS,CAACztB,EAAGO,EAAGiX,IAAOxX,GAAM,GAAKwX,EAAOjX,IAAOiX,EAAI,GAC1DkV,GAAA,OAAiBe,EACjB,MAAMC,EAAS,CAAC1tB,EAAGO,EAAGiX,IAAOxX,IAAOwX,EAAI,GAAQjX,GAAM,GAAKiX,EAC3DkV,GAAA,OAAiBgB,EAEjB,MAAMC,EAAU,CAACC,EAAIrtB,IAAMA,EAC3BmsB,GAAA,QAAkBiB,EAClB,MAAME,EAAU,CAAC7tB,EAAGqtB,IAAOrtB,EAC3B0sB,GAAA,QAAkBmB,EAElB,MAAMC,EAAS,CAAC9tB,EAAGO,EAAGiX,IAAOxX,GAAKwX,EAAMjX,IAAO,GAAKiX,EACpDkV,GAAA,OAAiBoB,EACjB,MAAMC,EAAS,CAAC/tB,EAAGO,EAAGiX,IAAOjX,GAAKiX,EAAMxX,IAAO,GAAKwX,EACpDkV,GAAA,OAAiBqB,EAEjB,MAAMC,EAAS,CAAChuB,EAAGO,EAAGiX,IAAOjX,GAAMiX,EAAI,GAAQxX,IAAO,GAAKwX,EAC3DkV,GAAA,OAAiBsB,EACjB,MAAMC,EAAS,CAACjuB,EAAGO,EAAGiX,IAAOxX,GAAMwX,EAAI,GAAQjX,IAAO,GAAKiX,EAC3DkV,GAAA,OAAiBuB,EAGjB,SAAStB,EAAIM,EAAIC,EAAIgB,EAAIC,EAAI,CACzB,MAAM5tB,GAAK2sB,IAAO,IAAMiB,IAAO,GAC/B,MAAO,CAAE,EAAIlB,EAAKiB,GAAO3tB,EAAI,GAAK,GAAM,GAAM,EAAG,EAAGA,EAAI,CAAC,CAC7D,CAEA,MAAM6tB,EAAQ,CAAClB,EAAIiB,EAAIE,KAAQnB,IAAO,IAAMiB,IAAO,IAAME,IAAO,GAChE3B,GAAA,MAAgB0B,EAChB,MAAME,EAAQ,CAACC,EAAKtB,EAAIiB,EAAIM,IAAQvB,EAAKiB,EAAKM,GAAOD,EAAM,GAAK,GAAM,GAAM,EAC5E7B,GAAA,MAAgB4B,EAChB,MAAMG,EAAQ,CAACvB,EAAIiB,EAAIE,EAAIK,KAAQxB,IAAO,IAAMiB,IAAO,IAAME,IAAO,IAAMK,IAAO,GACjFhC,GAAA,MAAgB+B,EAChB,MAAME,EAAQ,CAACJ,EAAKtB,EAAIiB,EAAIM,EAAII,IAAQ3B,EAAKiB,EAAKM,EAAKI,GAAOL,EAAM,GAAK,GAAM,GAAM,EACrF7B,GAAA,MAAgBiC,EAChB,MAAME,EAAQ,CAAC3B,EAAIiB,EAAIE,EAAIK,EAAII,KAAQ5B,IAAO,IAAMiB,IAAO,IAAME,IAAO,IAAMK,IAAO,IAAMI,IAAO,GAClGpC,GAAA,MAAgBmC,EAChB,MAAME,EAAQ,CAACR,EAAKtB,EAAIiB,EAAIM,EAAII,EAAII,IAAQ/B,EAAKiB,EAAKM,EAAKI,EAAKI,GAAOT,EAAM,GAAK,GAAM,GAAM,EAC9F7B,GAAA,MAAgBqC,EAEhB,MAAME,EAAM,CACR,QAAArC,EAAS,MAAAC,EAAO,MAAAM,EAChB,MAAAC,EAAO,MAAAE,EACP,OAAAC,EAAQ,OAAAC,EAAQ,OAAAC,EAAQ,OAAAC,EACxB,QAAAC,EAAS,QAAAE,EACT,OAAAC,EAAQ,OAAAC,EAAQ,OAAAC,EAAQ,OAAAC,EACxB,IAAAtB,EAAK,MAAAyB,EAAO,MAAAE,EAAO,MAAAG,EAAO,MAAAE,EAAO,MAAAI,EAAO,MAAAF,GAE5C,OAAAnC,GAAA,QAAkBuC,+CCvFlB,OAAO,eAAeC,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,WAAqBA,GAAA,WAAqBA,GAAA,OAAiBA,UAAiBA,GAAA,OAAiBA,GAAA,OAAiBA,GAAA,WAAqBA,GAAA,WAAqBA,GAAA,OAAiBA,GAAA,OAAiBA,UAAiBA,GAAA,OAAiB,OAQ5N,MAAMzF,EAAWpnB,GAAA,EACX4sB,EAAMzN,GAAA,EACN+G,EAAalE,GAAA,EAMb8K,EAA2B,YAAY,KAAK,CAC9C,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WACpF,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WACpF,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WACpF,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UACpF,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WACpF,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UACpF,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WACpF,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UACxF,CAAC,EAEKC,EAA2B,IAAI,YAAY,EAAE,EACnD,MAAMC,UAAe5F,EAAS,MAAO,CACjC,YAAYV,EAAY,GAAI,CACxB,MAAM,GAAIA,EAAW,EAAG,EAAK,EAG7B,KAAK,EAAIU,EAAS,UAAU,CAAC,EAAI,EACjC,KAAK,EAAIA,EAAS,UAAU,CAAC,EAAI,EACjC,KAAK,EAAIA,EAAS,UAAU,CAAC,EAAI,EACjC,KAAK,EAAIA,EAAS,UAAU,CAAC,EAAI,EACjC,KAAK,EAAIA,EAAS,UAAU,CAAC,EAAI,EACjC,KAAK,EAAIA,EAAS,UAAU,CAAC,EAAI,EACjC,KAAK,EAAIA,EAAS,UAAU,CAAC,EAAI,EACjC,KAAK,EAAIA,EAAS,UAAU,CAAC,EAAI,CACzC,CACI,KAAM,CACF,KAAM,CAAE,EAAAzoB,EAAG,EAAAC,EAAG,EAAAb,EAAG,EAAAc,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,CAAC,EAAK,KACnC,MAAO,CAACN,EAAGC,EAAGb,EAAGc,EAAGC,EAAGC,EAAGC,EAAGC,CAAC,CACtC,CAEI,IAAIN,EAAGC,EAAGb,EAAGc,EAAGC,EAAGC,EAAGC,EAAGC,EAAG,CACxB,KAAK,EAAIN,EAAI,EACb,KAAK,EAAIC,EAAI,EACb,KAAK,EAAIb,EAAI,EACb,KAAK,EAAIc,EAAI,EACb,KAAK,EAAIC,EAAI,EACb,KAAK,EAAIC,EAAI,EACb,KAAK,EAAIC,EAAI,EACb,KAAK,EAAIC,EAAI,CACrB,CACI,QAAQknB,EAAMxR,EAAQ,CAElB,QAAStR,EAAI,EAAGA,EAAI,GAAIA,IAAKsR,GAAU,EACnCoY,EAAS1pB,CAAC,EAAI8iB,EAAK,UAAUxR,EAAQ,EAAK,EAC9C,QAAStR,EAAI,GAAIA,EAAI,GAAIA,IAAK,CAC1B,MAAM4pB,EAAMF,EAAS1pB,EAAI,EAAE,EACrB6pB,EAAKH,EAAS1pB,EAAI,CAAC,EACnB8pB,KAASjH,EAAW,MAAM+G,EAAK,CAAC,KAAQ/G,EAAW,MAAM+G,EAAK,EAAE,EAAKA,IAAQ,EAC7EG,KAASlH,EAAW,MAAMgH,EAAI,EAAE,KAAQhH,EAAW,MAAMgH,EAAI,EAAE,EAAKA,IAAO,GACjFH,EAAS1pB,CAAC,EAAK+pB,EAAKL,EAAS1pB,EAAI,CAAC,EAAI8pB,EAAKJ,EAAS1pB,EAAI,EAAE,EAAK,CAC3E,CAEQ,GAAI,CAAE,EAAA1E,EAAG,EAAAC,EAAG,EAAAb,EAAG,EAAAc,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,CAAC,EAAK,KACjC,QAASoE,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,MAAMgqB,KAAanH,EAAW,MAAMpnB,EAAG,CAAC,KAAQonB,EAAW,MAAMpnB,EAAG,EAAE,KAAQonB,EAAW,MAAMpnB,EAAG,EAAE,EAC9FwuB,EAAMruB,EAAIouB,KAAajG,EAAS,KAAKtoB,EAAGC,EAAGC,CAAC,EAAI8tB,EAASzpB,CAAC,EAAI0pB,EAAS1pB,CAAC,EAAK,EAE7EkqB,MADarH,EAAW,MAAMvnB,EAAG,CAAC,KAAQunB,EAAW,MAAMvnB,EAAG,EAAE,KAAQunB,EAAW,MAAMvnB,EAAG,EAAE,MAC3EyoB,EAAS,KAAKzoB,EAAGC,EAAGb,CAAC,EAAK,EACnDkB,EAAID,EACJA,EAAID,EACJA,EAAID,EACJA,EAAKD,EAAIyuB,EAAM,EACfzuB,EAAId,EACJA,EAAIa,EACJA,EAAID,EACJA,EAAK2uB,EAAKC,EAAM,CAC5B,CAEQ5uB,EAAKA,EAAI,KAAK,EAAK,EACnBC,EAAKA,EAAI,KAAK,EAAK,EACnBb,EAAKA,EAAI,KAAK,EAAK,EACnBc,EAAKA,EAAI,KAAK,EAAK,EACnBC,EAAKA,EAAI,KAAK,EAAK,EACnBC,EAAKA,EAAI,KAAK,EAAK,EACnBC,EAAKA,EAAI,KAAK,EAAK,EACnBC,EAAKA,EAAI,KAAK,EAAK,EACnB,KAAK,IAAIN,EAAGC,EAAGb,EAAGc,EAAGC,EAAGC,EAAGC,EAAGC,CAAC,CACvC,CACI,YAAa,IACLinB,EAAW,OAAO6G,CAAQ,CACtC,CACI,SAAU,CACN,KAAK,IAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,KAC3B7G,EAAW,OAAO,KAAK,MAAM,CACzC,CACA,CACA2G,GAAA,OAAiBG,EACjB,MAAMQ,UAAeR,CAAO,CACxB,aAAc,CACV,MAAM,EAAE,EACR,KAAK,EAAI5F,EAAS,UAAU,CAAC,EAAI,EACjC,KAAK,EAAIA,EAAS,UAAU,CAAC,EAAI,EACjC,KAAK,EAAIA,EAAS,UAAU,CAAC,EAAI,EACjC,KAAK,EAAIA,EAAS,UAAU,CAAC,EAAI,EACjC,KAAK,EAAIA,EAAS,UAAU,CAAC,EAAI,EACjC,KAAK,EAAIA,EAAS,UAAU,CAAC,EAAI,EACjC,KAAK,EAAIA,EAAS,UAAU,CAAC,EAAI,EACjC,KAAK,EAAIA,EAAS,UAAU,CAAC,EAAI,CACzC,CACA,CACAyF,GAAA,OAAiBW,EAKjB,MAAMC,EAA8Bb,EAAI,MAAM,CAC1C,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,sBACpE,IAAI5uB,GAAK,OAAOA,CAAC,CAAC,CAAC,EACf0vB,EAAmCD,EAAK,CAAC,EACzCE,EAAmCF,EAAK,CAAC,EAEzCG,EAA6B,IAAI,YAAY,EAAE,EAC/CC,EAA6B,IAAI,YAAY,EAAE,EACrD,MAAMC,UAAe1G,EAAS,MAAO,CACjC,YAAYV,EAAY,GAAI,CACxB,MAAM,IAAKA,EAAW,GAAI,EAAK,EAI/B,KAAK,GAAKU,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,EAAE,EAAI,EACnC,KAAK,GAAKA,EAAS,UAAU,EAAE,EAAI,EACnC,KAAK,GAAKA,EAAS,UAAU,EAAE,EAAI,EACnC,KAAK,GAAKA,EAAS,UAAU,EAAE,EAAI,EACnC,KAAK,GAAKA,EAAS,UAAU,EAAE,EAAI,EACnC,KAAK,GAAKA,EAAS,UAAU,EAAE,EAAI,CAC3C,CAEI,KAAM,CACF,KAAM,CAAE,GAAAwD,EAAI,GAAAC,EAAI,GAAAgB,EAAI,GAAAC,EAAI,GAAAK,EAAI,GAAAH,EAAI,GAAAO,EAAI,GAAAF,EAAI,GAAAM,EAAI,GAAAF,EAAI,GAAAsB,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,CAAE,EAAK,KAC3E,MAAO,CAACxD,EAAIC,EAAIgB,EAAIC,EAAIK,EAAIH,EAAIO,EAAIF,EAAIM,EAAIF,EAAIsB,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,CAAE,CAC9E,CAEI,IAAIxD,EAAIC,EAAIgB,EAAIC,EAAIK,EAAIH,EAAIO,EAAIF,EAAIM,EAAIF,EAAIsB,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAI,CAChE,KAAK,GAAKxD,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKgB,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKK,EAAK,EACf,KAAK,GAAKH,EAAK,EACf,KAAK,GAAKO,EAAK,EACf,KAAK,GAAKF,EAAK,EACf,KAAK,GAAKM,EAAK,EACf,KAAK,GAAKF,EAAK,EACf,KAAK,GAAKsB,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKC,EAAK,CACvB,CACI,QAAQjI,EAAMxR,EAAQ,CAElB,QAAStR,EAAI,EAAGA,EAAI,GAAIA,IAAKsR,GAAU,EACnCiZ,EAAWvqB,CAAC,EAAI8iB,EAAK,UAAUxR,CAAM,EACrCkZ,EAAWxqB,CAAC,EAAI8iB,EAAK,UAAWxR,GAAU,CAAC,EAE/C,QAAStR,EAAI,GAAIA,EAAI,GAAIA,IAAK,CAE1B,MAAMgrB,EAAOT,EAAWvqB,EAAI,EAAE,EAAI,EAC5BirB,EAAOT,EAAWxqB,EAAI,EAAE,EAAI,EAC5BkrB,EAAM3B,EAAI,OAAOyB,EAAMC,EAAM,CAAC,EAAI1B,EAAI,OAAOyB,EAAMC,EAAM,CAAC,EAAI1B,EAAI,MAAMyB,EAAMC,EAAM,CAAC,EACrFE,GAAM5B,EAAI,OAAOyB,EAAMC,EAAM,CAAC,EAAI1B,EAAI,OAAOyB,EAAMC,EAAM,CAAC,EAAI1B,EAAI,MAAMyB,EAAMC,EAAM,CAAC,EAErFG,GAAMb,EAAWvqB,EAAI,CAAC,EAAI,EAC1BqrB,GAAMb,EAAWxqB,EAAI,CAAC,EAAI,EAC1BsrB,GAAM/B,EAAI,OAAO6B,GAAKC,GAAK,EAAE,EAAI9B,EAAI,OAAO6B,GAAKC,GAAK,EAAE,EAAI9B,EAAI,MAAM6B,GAAKC,GAAK,CAAC,EACjFE,GAAMhC,EAAI,OAAO6B,GAAKC,GAAK,EAAE,EAAI9B,EAAI,OAAO6B,GAAKC,GAAK,EAAE,EAAI9B,EAAI,MAAM6B,GAAKC,GAAK,CAAC,EAEjFG,GAAOjC,EAAI,MAAM4B,GAAKI,GAAKf,EAAWxqB,EAAI,CAAC,EAAGwqB,EAAWxqB,EAAI,EAAE,CAAC,EAChEyrB,GAAOlC,EAAI,MAAMiC,GAAMN,EAAKI,GAAKf,EAAWvqB,EAAI,CAAC,EAAGuqB,EAAWvqB,EAAI,EAAE,CAAC,EAC5EuqB,EAAWvqB,CAAC,EAAIyrB,GAAO,EACvBjB,EAAWxqB,CAAC,EAAIwrB,GAAO,CACnC,CACQ,GAAI,CAAE,GAAAjE,EAAI,GAAAC,EAAI,GAAAgB,EAAI,GAAAC,EAAI,GAAAK,EAAI,GAAAH,EAAI,GAAAO,EAAI,GAAAF,EAAI,GAAAM,EAAI,GAAAF,EAAI,GAAAsB,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,CAAE,EAAK,KAEzE,QAAS/qB,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAEzB,MAAM0rB,EAAUnC,EAAI,OAAOD,EAAIF,EAAI,EAAE,EAAIG,EAAI,OAAOD,EAAIF,EAAI,EAAE,EAAIG,EAAI,OAAOD,EAAIF,EAAI,EAAE,EACjFuC,EAAUpC,EAAI,OAAOD,EAAIF,EAAI,EAAE,EAAIG,EAAI,OAAOD,EAAIF,EAAI,EAAE,EAAIG,EAAI,OAAOD,EAAIF,EAAI,EAAE,EAEjFwC,EAAQtC,EAAKoB,EAAO,CAACpB,EAAKsB,EAC1BiB,GAAQzC,EAAKuB,EAAO,CAACvB,EAAKyB,EAG1BiB,GAAOvC,EAAI,MAAMwB,EAAIY,EAASE,GAAMvB,EAAUtqB,CAAC,EAAGwqB,EAAWxqB,CAAC,CAAC,EAC/D+rB,GAAMxC,EAAI,MAAMuC,GAAMhB,EAAIY,EAASE,EAAMvB,EAAUrqB,CAAC,EAAGuqB,EAAWvqB,CAAC,CAAC,EACpEgsB,GAAMF,GAAO,EAEbG,GAAU1C,EAAI,OAAOhC,EAAIC,EAAI,EAAE,EAAI+B,EAAI,OAAOhC,EAAIC,EAAI,EAAE,EAAI+B,EAAI,OAAOhC,EAAIC,EAAI,EAAE,EACjF0E,GAAU3C,EAAI,OAAOhC,EAAIC,EAAI,EAAE,EAAI+B,EAAI,OAAOhC,EAAIC,EAAI,EAAE,EAAI+B,EAAI,OAAOhC,EAAIC,EAAI,EAAE,EACjF2E,GAAQ5E,EAAKiB,EAAOjB,EAAKuB,EAAON,EAAKM,EACrCsD,GAAQ5E,EAAKiB,EAAOjB,EAAKmB,EAAOF,EAAKE,EAC3CmC,EAAKF,EAAK,EACVG,EAAKF,EAAK,EACVD,EAAKF,EAAK,EACVG,EAAKF,EAAK,EACVD,EAAKpB,EAAK,EACVqB,EAAKvB,EAAK,EACT,CAAE,EAAGE,EAAI,EAAGF,CAAE,EAAKG,EAAI,IAAIL,EAAK,EAAGF,EAAK,EAAG+C,GAAM,EAAGC,GAAM,CAAC,EAC5D9C,EAAKJ,EAAK,EACVE,EAAKL,EAAK,EACVG,EAAKN,EAAK,EACVG,EAAKF,EAAK,EACVD,EAAKjB,EAAK,EACVkB,EAAKjB,EAAK,EACV,MAAM6E,GAAM9C,EAAI,MAAMyC,GAAKE,GAASE,EAAI,EACxC7E,EAAKgC,EAAI,MAAM8C,GAAKN,GAAKE,GAASE,EAAI,EACtC3E,EAAK6E,GAAM,CACvB,EAES,CAAE,EAAG9E,EAAI,EAAGC,GAAO+B,EAAI,IAAI,KAAK,GAAK,EAAG,KAAK,GAAK,EAAGhC,EAAK,EAAGC,EAAK,CAAC,GACnE,CAAE,EAAGgB,EAAI,EAAGC,GAAOc,EAAI,IAAI,KAAK,GAAK,EAAG,KAAK,GAAK,EAAGf,EAAK,EAAGC,EAAK,CAAC,EACnE,CAAE,EAAGK,EAAI,EAAGH,GAAOY,EAAI,IAAI,KAAK,GAAK,EAAG,KAAK,GAAK,EAAGT,EAAK,EAAGH,EAAK,CAAC,EACnE,CAAE,EAAGO,EAAI,EAAGF,GAAOO,EAAI,IAAI,KAAK,GAAK,EAAG,KAAK,GAAK,EAAGL,EAAK,EAAGF,EAAK,CAAC,EACnE,CAAE,EAAGM,EAAI,EAAGF,GAAOG,EAAI,IAAI,KAAK,GAAK,EAAG,KAAK,GAAK,EAAGD,EAAK,EAAGF,EAAK,CAAC,EACnE,CAAE,EAAGsB,EAAI,EAAGC,GAAOpB,EAAI,IAAI,KAAK,GAAK,EAAG,KAAK,GAAK,EAAGmB,EAAK,EAAGC,EAAK,CAAC,EACnE,CAAE,EAAGC,EAAI,EAAGC,GAAOtB,EAAI,IAAI,KAAK,GAAK,EAAG,KAAK,GAAK,EAAGqB,EAAK,EAAGC,EAAK,CAAC,EACnE,CAAE,EAAGC,EAAI,EAAGC,GAAOxB,EAAI,IAAI,KAAK,GAAK,EAAG,KAAK,GAAK,EAAGuB,EAAK,EAAGC,EAAK,CAAC,EACpE,KAAK,IAAIxD,EAAIC,EAAIgB,EAAIC,EAAIK,EAAIH,EAAIO,EAAIF,EAAIM,EAAIF,EAAIsB,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,CAAE,CAC/E,CACI,YAAa,IACLlI,EAAW,OAAO0H,EAAYC,CAAU,CACpD,CACI,SAAU,IACF3H,EAAW,OAAO,KAAK,MAAM,EACjC,KAAK,IAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAC/D,CACA,CACA2G,GAAA,OAAiBiB,EACjB,MAAM6B,UAAe7B,CAAO,CACxB,aAAc,CACV,MAAM,EAAE,EACR,KAAK,GAAK1G,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,CAAC,EAAI,EAClC,KAAK,GAAKA,EAAS,UAAU,EAAE,EAAI,EACnC,KAAK,GAAKA,EAAS,UAAU,EAAE,EAAI,EACnC,KAAK,GAAKA,EAAS,UAAU,EAAE,EAAI,EACnC,KAAK,GAAKA,EAAS,UAAU,EAAE,EAAI,EACnC,KAAK,GAAKA,EAAS,UAAU,EAAE,EAAI,EACnC,KAAK,GAAKA,EAAS,UAAU,EAAE,EAAI,CAC3C,CACA,CACAyF,GAAA,OAAiB8C,EAQjB,MAAMC,EAA0B,YAAY,KAAK,CAC7C,WAAY,UAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WACpF,UAAY,WAAY,WAAY,SAAY,WAAY,WAAY,UAAY,UACxF,CAAC,EAEKC,EAA0B,YAAY,KAAK,CAC7C,UAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WACpF,WAAY,WAAY,WAAY,WAAY,UAAY,UAAY,UAAY,UACxF,CAAC,EACD,MAAMC,UAAmBhC,CAAO,CAC5B,aAAc,CACV,MAAM,EAAE,EACR,KAAK,GAAK8B,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,EAAE,EAAI,EACxB,KAAK,GAAKA,EAAQ,EAAE,EAAI,EACxB,KAAK,GAAKA,EAAQ,EAAE,EAAI,EACxB,KAAK,GAAKA,EAAQ,EAAE,EAAI,EACxB,KAAK,GAAKA,EAAQ,EAAE,EAAI,EACxB,KAAK,GAAKA,EAAQ,EAAE,EAAI,CAChC,CACA,CACA/C,GAAA,WAAqBiD,EACrB,MAAMC,UAAmBjC,CAAO,CAC5B,aAAc,CACV,MAAM,EAAE,EACR,KAAK,GAAK+B,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,CAAC,EAAI,EACvB,KAAK,GAAKA,EAAQ,EAAE,EAAI,EACxB,KAAK,GAAKA,EAAQ,EAAE,EAAI,EACxB,KAAK,GAAKA,EAAQ,EAAE,EAAI,EACxB,KAAK,GAAKA,EAAQ,EAAE,EAAI,EACxB,KAAK,GAAKA,EAAQ,EAAE,EAAI,EACxB,KAAK,GAAKA,EAAQ,EAAE,EAAI,CAChC,CACA,CACA,OAAAhD,GAAA,WAAqBkD,EAQrBlD,GAAA,UAAqB3G,EAAW,cAAc,IAAM,IAAI8G,CAAQ,EAEhEH,GAAA,UAAqB3G,EAAW,cAAc,IAAM,IAAIsH,CAAQ,EAEhEX,GAAA,UAAqB3G,EAAW,cAAc,IAAM,IAAI4H,CAAQ,EAEhEjB,GAAA,UAAqB3G,EAAW,cAAc,IAAM,IAAIyJ,CAAQ,EAKhE9C,GAAA,cAAyB3G,EAAW,cAAc,IAAM,IAAI6J,CAAY,EAKxElD,GAAA,cAAyB3G,EAAW,cAAc,IAAM,IAAI4J,CAAY,+CC7XxE,OAAO,eAAeE,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,OAAiBA,UAAiBA,GAAA,OAAiBA,GAAA,OAAiB,OAWpE,MAAMC,EAAYjwB,GAAA,EAElBgwB,OAAAA,GAAA,OAAiBC,EAAU,OAE3BD,GAAA,OAAiBC,EAAU,OAE3BD,GAAA,OAAiBC,EAAU,OAE3BD,GAAA,OAAiBC,EAAU,uDCf3B,SAASC,EAAMC,EAAU,CACvB,GAAIA,EAAS,QAAU,IAAO,MAAM,IAAI,UAAU,mBAAmB,EAErE,QADIC,EAAW,IAAI,WAAW,GAAG,EACxB/W,EAAI,EAAGA,EAAI+W,EAAS,OAAQ/W,IACnC+W,EAAS/W,CAAC,EAAI,IAEhB,QAAShW,EAAI,EAAGA,EAAI8sB,EAAS,OAAQ9sB,IAAK,CACxC,IAAIpF,EAAIkyB,EAAS,OAAO9sB,CAAC,EACrBgtB,EAAKpyB,EAAE,WAAW,CAAC,EACvB,GAAImyB,EAASC,CAAE,IAAM,IAAO,MAAM,IAAI,UAAUpyB,EAAI,eAAe,EACnEmyB,EAASC,CAAE,EAAIhtB,CACnB,CACE,IAAIitB,EAAOH,EAAS,OAChBI,EAASJ,EAAS,OAAO,CAAC,EAC1BK,EAAS,KAAK,IAAIF,CAAI,EAAI,KAAK,IAAI,GAAG,EACtCG,EAAU,KAAK,IAAI,GAAG,EAAI,KAAK,IAAIH,CAAI,EAC3C,SAASI,EAAQlwB,EAAQ,CAOvB,GANIA,aAAkB,aACX,YAAY,OAAOA,CAAM,EAClCA,EAAS,IAAI,WAAWA,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,EAClE,MAAM,QAAQA,CAAM,IAC7BA,EAAS,WAAW,KAAKA,CAAM,IAE7B,EAAEA,aAAkB,YAAe,MAAM,IAAI,UAAU,qBAAqB,EAChF,GAAIA,EAAO,SAAW,EAAK,MAAO,GAMlC,QAJImwB,EAAS,EACTjwB,EAAS,EACTkwB,EAAS,EACTC,EAAOrwB,EAAO,OACXowB,IAAWC,GAAQrwB,EAAOowB,CAAM,IAAM,GAC3CA,IACAD,IAMF,QAHI9Z,GAASga,EAAOD,GAAUH,EAAU,IAAO,EAC3CK,EAAM,IAAI,WAAWja,CAAI,EAEtB+Z,IAAWC,GAAM,CAItB,QAHIE,EAAQvwB,EAAOowB,CAAM,EAErBvtB,EAAI,EACC2tB,EAAMna,EAAO,GAAIka,IAAU,GAAK1tB,EAAI3C,IAAYswB,IAAQ,GAAKA,IAAO3tB,IAC3E0tB,GAAU,IAAMD,EAAIE,CAAG,IAAO,EAC9BF,EAAIE,CAAG,EAAKD,EAAQT,IAAU,EAC9BS,EAASA,EAAQT,IAAU,EAE7B,GAAIS,IAAU,EAAK,MAAM,IAAI,MAAM,gBAAgB,EACnDrwB,EAAS2C,EACTutB,GACN,CAGI,QADIK,EAAMpa,EAAOnW,EACVuwB,IAAQpa,GAAQia,EAAIG,CAAG,IAAM,GAClCA,IAIF,QADIhsB,EAAMsrB,EAAO,OAAOI,CAAM,EACvBM,EAAMpa,EAAM,EAAEoa,EAAOhsB,GAAOkrB,EAAS,OAAOW,EAAIG,CAAG,CAAC,EAC3D,OAAOhsB,CACX,CACE,SAASisB,EAAc1wB,EAAQ,CAC7B,GAAI,OAAOA,GAAW,SAAY,MAAM,IAAI,UAAU,iBAAiB,EACvE,GAAIA,EAAO,SAAW,EAAK,OAAO,IAAI,WAKtC,QAJI2wB,EAAM,EAENR,EAAS,EACTjwB,EAAS,EACNF,EAAO2wB,CAAG,IAAMZ,GACrBI,IACAQ,IAMF,QAHIta,GAAUrW,EAAO,OAAS2wB,GAAOX,EAAU,IAAO,EAClDY,EAAO,IAAI,WAAWva,CAAI,EAEvBrW,EAAO2wB,CAAG,GAAG,CAElB,IAAIE,EAAW7wB,EAAO,WAAW2wB,CAAG,EAEpC,GAAIE,EAAW,IAAO,OAEtB,IAAIN,EAAQX,EAASiB,CAAQ,EAE7B,GAAIN,IAAU,IAAO,OAErB,QADI1tB,EAAI,EACCiuB,EAAMza,EAAO,GAAIka,IAAU,GAAK1tB,EAAI3C,IAAY4wB,IAAQ,GAAKA,IAAOjuB,IAC3E0tB,GAAUT,EAAOc,EAAKE,CAAG,IAAO,EAChCF,EAAKE,CAAG,EAAKP,EAAQ,MAAS,EAC9BA,EAASA,EAAQ,MAAS,EAE5B,GAAIA,IAAU,EAAK,MAAM,IAAI,MAAM,gBAAgB,EACnDrwB,EAAS2C,EACT8tB,GACN,CAGI,QADII,EAAM1a,EAAOnW,EACV6wB,IAAQ1a,GAAQua,EAAKG,CAAG,IAAM,GACnCA,IAIF,QAFIC,EAAM,IAAI,WAAWb,GAAU9Z,EAAO0a,EAAI,EAC1ClY,EAAIsX,EACDY,IAAQ1a,GACb2a,EAAInY,GAAG,EAAI+X,EAAKG,GAAK,EAEvB,OAAOC,CACX,CACE,SAASC,EAAQ3wB,EAAQ,CACvB,IAAIsB,EAAS8uB,EAAapwB,CAAM,EAChC,GAAIsB,EAAU,OAAOA,EACrB,MAAM,IAAI,MAAM,WAAakuB,EAAO,YAAY,CACpD,CACE,MAAO,CACL,OAAQI,EACR,aAAcQ,EACd,OAAQO,CACZ,CACA,CACAnU,OAAAA,GAAiB4S,8CCzHjBwB,GAHc1xB,GAAA,EACG,4DAEc,mDCD/B,IAAI2xB,EAAS3xB,GAAA,EAEbkwB,OAAAA,GAAiB,SAAU0B,EAAY,CAErC,SAASlB,EAAQmB,EAAS,CACxB,IAAIC,EAAY,WAAW,KAAKD,CAAO,EACnCE,EAAWH,EAAWE,CAAS,EAC/BpxB,EAASoxB,EAAU,OAAS,EAC5BE,EAAO,IAAI,WAAWtxB,CAAM,EAChC,OAAAsxB,EAAK,IAAIF,EAAW,CAAC,EACrBE,EAAK,IAAID,EAAS,SAAS,EAAG,CAAC,EAAGD,EAAU,MAAM,EAC3CH,EAAO,OAAOK,EAAMtxB,CAAM,CACrC,CAEE,SAASuxB,EAAW7vB,EAAQ,CAC1B,IAAIyvB,EAAUzvB,EAAO,MAAM,EAAG,EAAE,EAC5B2vB,EAAW3vB,EAAO,MAAM,EAAE,EAC1B8vB,EAAcN,EAAWC,CAAO,EAEpC,GAAI,EAAAE,EAAS,CAAC,EAAIG,EAAY,CAAC,EAC3BH,EAAS,CAAC,EAAIG,EAAY,CAAC,EAC3BH,EAAS,CAAC,EAAIG,EAAY,CAAC,EAC3BH,EAAS,CAAC,EAAIG,EAAY,CAAC,GAE/B,OAAOL,CACX,CAGE,SAASX,EAAcpwB,EAAQ,CAC7B,IAAIsB,EAASuvB,EAAO,aAAa7wB,CAAM,EACvC,GAAKsB,EAEL,OAAO6vB,EAAU7vB,CAAM,CAC3B,CAEE,SAASqvB,EAAQ3wB,EAAQ,CACvB,IAAIsB,EAASuvB,EAAO,OAAO7wB,CAAM,EAC7B+wB,EAAUI,EAAU7vB,CAAkB,EAC1C,GAAI,CAACyvB,EAAS,MAAM,IAAI,MAAM,kBAAkB,EAChD,OAAOA,CACX,CAEE,MAAO,CACL,OAAQnB,EACR,OAAQe,EACR,aAAcP,CAClB,CACA,kDC/CA,GAAI,CAAE,OAAAlB,CAAM,EAAKhwB,GAAA,EACbmyB,EAAgBhT,GAAA,EAGpB,SAASiT,EAAUhwB,EAAQ,CACzB,OAAO4tB,EAAOA,EAAO5tB,CAAM,CAAC,CAC9B,CAEAiwB,OAAAA,GAAiBF,EAAcC,CAAQ,qDCTvC,OAAO,eAAeE,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,QAAkBA,GAAA,OAAiB,OACnC,MAAMnC,EAAW,mCACXoC,EAAe,CAAA,EACrB,QAAS7zB,EAAI,EAAGA,EAAIyxB,EAAS,OAAQzxB,IAAK,CACtC,MAAMT,EAAIkyB,EAAS,OAAOzxB,CAAC,EAC3B6zB,EAAat0B,CAAC,EAAIS,CACtB,CACA,SAAS8zB,EAAYC,EAAK,CACtB,MAAMn1B,EAAIm1B,GAAO,GACjB,OAAUA,EAAM,WAAc,EACzB,EAAGn1B,GAAK,EAAK,GAAK,UAClB,EAAGA,GAAK,EAAK,GAAK,UAClB,EAAGA,GAAK,EAAK,GAAK,UAClB,EAAGA,GAAK,EAAK,GAAK,WAClB,EAAGA,GAAK,EAAK,GAAK,SAC3B,CACA,SAASo1B,EAAUhmB,EAAQ,CACvB,IAAIimB,EAAM,EACV,QAAStvB,EAAI,EAAGA,EAAIqJ,EAAO,OAAQ,EAAErJ,EAAG,CACpC,MAAM9F,EAAImP,EAAO,WAAWrJ,CAAC,EAC7B,GAAI9F,EAAI,IAAMA,EAAI,IACd,MAAO,mBAAqBmP,EAAS,IACzCimB,EAAMH,EAAYG,CAAG,EAAKp1B,GAAK,CACvC,CACIo1B,EAAMH,EAAYG,CAAG,EACrB,QAAStvB,EAAI,EAAGA,EAAIqJ,EAAO,OAAQ,EAAErJ,EAAG,CACpC,MAAMuvB,EAAIlmB,EAAO,WAAWrJ,CAAC,EAC7BsvB,EAAMH,EAAYG,CAAG,EAAKC,EAAI,EACtC,CACI,OAAOD,CACX,CACA,SAASE,EAAQ3uB,EAAM4uB,EAAQC,EAASxN,EAAK,CACzC,IAAInf,EAAQ,EACR0C,EAAO,EACX,MAAMkqB,GAAQ,GAAKD,GAAW,EACxB/xB,EAAS,CAAA,EACf,QAASqC,EAAI,EAAGA,EAAIa,EAAK,OAAQ,EAAEb,EAG/B,IAFA+C,EAASA,GAAS0sB,EAAU5uB,EAAKb,CAAC,EAClCyF,GAAQgqB,EACDhqB,GAAQiqB,GACXjqB,GAAQiqB,EACR/xB,EAAO,KAAMoF,GAAS0C,EAAQkqB,CAAI,EAG1C,GAAIzN,EACIzc,EAAO,GACP9H,EAAO,KAAMoF,GAAU2sB,EAAUjqB,EAASkqB,CAAI,MAGjD,CACD,GAAIlqB,GAAQgqB,EACR,MAAO,iBACX,GAAK1sB,GAAU2sB,EAAUjqB,EAASkqB,EAC9B,MAAO,kBACnB,CACI,OAAOhyB,CACX,CACA,SAASiyB,EAAQnY,EAAO,CACpB,OAAO+X,EAAQ/X,EAAO,EAAG,EAAG,EAAI,CACpC,CACA,SAASoY,EAAgBC,EAAO,CAC5B,MAAMrsB,EAAM+rB,EAAQM,EAAO,EAAG,EAAG,EAAK,EACtC,GAAI,MAAM,QAAQrsB,CAAG,EACjB,OAAOA,CACf,CACA,SAASssB,EAAUD,EAAO,CACtB,MAAMrsB,EAAM+rB,EAAQM,EAAO,EAAG,EAAG,EAAK,EACtC,GAAI,MAAM,QAAQrsB,CAAG,EACjB,OAAOA,EACX,MAAM,IAAI,MAAMA,CAAG,CACvB,CACA,SAASusB,EAAuBrc,EAAU,CACtC,IAAIsc,EACAtc,IAAa,SACbsc,EAAiB,EAGjBA,EAAiB,UAErB,SAAS5C,EAAOhkB,EAAQymB,EAAOI,EAAO,CAElC,GADAA,EAAQA,GAAS,GACb7mB,EAAO,OAAS,EAAIymB,EAAM,OAASI,EACnC,MAAM,IAAI,UAAU,sBAAsB,EAC9C7mB,EAASA,EAAO,YAAW,EAE3B,IAAIimB,EAAMD,EAAUhmB,CAAM,EAC1B,GAAI,OAAOimB,GAAQ,SACf,MAAM,IAAI,MAAMA,CAAG,EACvB,IAAI3xB,EAAS0L,EAAS,IACtB,QAASrJ,EAAI,EAAGA,EAAI8vB,EAAM,OAAQ,EAAE9vB,EAAG,CACnC,MAAMpF,EAAIk1B,EAAM9vB,CAAC,EACjB,GAAIpF,GAAK,IAAM,EACX,MAAM,IAAI,MAAM,gBAAgB,EACpC00B,EAAMH,EAAYG,CAAG,EAAI10B,EACzB+C,GAAUmvB,EAAS,OAAOlyB,CAAC,CACvC,CACQ,QAASoF,EAAI,EAAGA,EAAI,EAAG,EAAEA,EACrBsvB,EAAMH,EAAYG,CAAG,EAEzBA,GAAOW,EACP,QAASjwB,EAAI,EAAGA,EAAI,EAAG,EAAEA,EAAG,CACxB,MAAMuvB,EAAKD,IAAS,EAAItvB,GAAK,EAAM,GACnCrC,GAAUmvB,EAAS,OAAOyC,CAAC,CACvC,CACQ,OAAO5xB,CACf,CACI,SAASwyB,EAASvuB,EAAKsuB,EAAO,CAE1B,GADAA,EAAQA,GAAS,GACbtuB,EAAI,OAAS,EACb,OAAOA,EAAM,aACjB,GAAIA,EAAI,OAASsuB,EACb,MAAO,uBAEX,MAAME,EAAUxuB,EAAI,YAAW,EACzByuB,EAAUzuB,EAAI,YAAW,EAC/B,GAAIA,IAAQwuB,GAAWxuB,IAAQyuB,EAC3B,MAAO,qBAAuBzuB,EAClCA,EAAMwuB,EACN,MAAMjJ,EAAQvlB,EAAI,YAAY,GAAG,EACjC,GAAIulB,IAAU,GACV,MAAO,8BAAgCvlB,EAC3C,GAAIulB,IAAU,EACV,MAAO,sBAAwBvlB,EACnC,MAAMyH,EAASzH,EAAI,MAAM,EAAGulB,CAAK,EAC3BmJ,EAAY1uB,EAAI,MAAMulB,EAAQ,CAAC,EACrC,GAAImJ,EAAU,OAAS,EACnB,MAAO,iBACX,IAAIhB,EAAMD,EAAUhmB,CAAM,EAC1B,GAAI,OAAOimB,GAAQ,SACf,OAAOA,EACX,MAAMQ,EAAQ,CAAA,EACd,QAAS9vB,EAAI,EAAGA,EAAIswB,EAAU,OAAQ,EAAEtwB,EAAG,CACvC,MAAM9F,EAAIo2B,EAAU,OAAOtwB,CAAC,EACtBuvB,EAAIL,EAAah1B,CAAC,EACxB,GAAIq1B,IAAM,OACN,MAAO,qBAAuBr1B,EAClCo1B,EAAMH,EAAYG,CAAG,EAAIC,EAErB,EAAAvvB,EAAI,GAAKswB,EAAU,SAEvBR,EAAM,KAAKP,CAAC,CACxB,CACQ,OAAID,IAAQW,EACD,wBAA0BruB,EAC9B,CAAE,OAAAyH,EAAQ,MAAAymB,CAAK,CAC9B,CACI,SAASjC,EAAajsB,EAAKsuB,EAAO,CAC9B,MAAMzsB,EAAM0sB,EAASvuB,EAAKsuB,CAAK,EAC/B,GAAI,OAAOzsB,GAAQ,SACf,OAAOA,CACnB,CACI,SAAS2qB,EAAOxsB,EAAKsuB,EAAO,CACxB,MAAMzsB,EAAM0sB,EAASvuB,EAAKsuB,CAAK,EAC/B,GAAI,OAAOzsB,GAAQ,SACf,OAAOA,EACX,MAAM,IAAI,MAAMA,CAAG,CAC3B,CACI,MAAO,CACH,aAAAoqB,EACA,OAAAO,EACA,OAAAf,EACA,QAAAuC,EACA,gBAAAC,EACA,UAAAE,EAER,CACA,OAAAd,GAAA,OAAiBe,EAAuB,QAAQ,EAChDf,GAAA,QAAkBe,EAAuB,SAAS,kKCvKlD,IAAIjxB,EAASpC,GAAA,EACTwV,EAASpT,EAAO,OAGpB,SAASwxB,EAAWtW,EAAKC,EAAK,CAC5B,QAAS5c,KAAO2c,EACdC,EAAI5c,CAAG,EAAI2c,EAAI3c,CAAG,CAEtB,CACI6U,EAAO,MAAQA,EAAO,OAASA,EAAO,aAAeA,EAAO,gBAC9Dqe,EAAA,QAAiBzxB,GAGjBwxB,EAAUxxB,EAAQjE,CAAO,EACzBA,EAAA,OAAiB21B,GAGnB,SAASA,EAAY5d,EAAKC,EAAkBzV,EAAQ,CAClD,OAAO8U,EAAOU,EAAKC,EAAkBzV,CAAM,CAC7C,CAEAozB,EAAW,UAAY,OAAO,OAAOte,EAAO,SAAS,EAGrDoe,EAAUpe,EAAQse,CAAU,EAE5BA,EAAW,KAAO,SAAU5d,EAAKC,EAAkBzV,EAAQ,CACzD,GAAI,OAAOwV,GAAQ,SACjB,MAAM,IAAI,UAAU,+BAA+B,EAErD,OAAOV,EAAOU,EAAKC,EAAkBzV,CAAM,CAC7C,EAEAozB,EAAW,MAAQ,SAAUjd,EAAME,EAAMC,EAAU,CACjD,GAAI,OAAOH,GAAS,SAClB,MAAM,IAAI,UAAU,2BAA2B,EAEjD,IAAIZ,EAAMT,EAAOqB,CAAI,EACrB,OAAIE,IAAS,OACP,OAAOC,GAAa,SACtBf,EAAI,KAAKc,EAAMC,CAAQ,EAEvBf,EAAI,KAAKc,CAAI,EAGfd,EAAI,KAAK,CAAC,EAELA,CACT,EAEA6d,EAAW,YAAc,SAAUjd,EAAM,CACvC,GAAI,OAAOA,GAAS,SAClB,MAAM,IAAI,UAAU,2BAA2B,EAEjD,OAAOrB,EAAOqB,CAAI,CACpB,EAEAid,EAAW,gBAAkB,SAAUjd,EAAM,CAC3C,GAAI,OAAOA,GAAS,SAClB,MAAM,IAAI,UAAU,2BAA2B,EAEjD,OAAOzU,EAAO,WAAWyU,CAAI,CAC/B,4EC/DA,IAAIrB,EAASxV,KAAuB,OAGhC+zB,EAAmB,iBAEvB,SAASC,EAAah2B,EAAG,CACvB,GAAIA,EAAI,GAAKA,EAAI+1B,GAAoB/1B,EAAI,IAAM,EAAG,MAAM,IAAI,WAAW,oBAAoB,CAC7F,CAEA,SAAS0yB,EAAQvvB,EAAQiB,EAAQuS,EAAQ,CAIvC,GAHAqf,EAAY7yB,CAAM,EAEbiB,IAAQA,EAASoT,EAAO,YAAYye,EAAe9yB,CAAM,CAAC,GAC3D,CAACqU,EAAO,SAASpT,CAAM,EAAG,MAAM,IAAI,UAAU,kCAAkC,EACpF,OAAKuS,IAAQA,EAAS,GAGlBxT,EAAS,KACXiB,EAAO,WAAWjB,EAAQwT,CAAM,EAChC+b,EAAO,MAAQ,GAGNvvB,GAAU,OACnBiB,EAAO,WAAW,IAAMuS,CAAM,EAC9BvS,EAAO,cAAcjB,EAAQwT,EAAS,CAAC,EACvC+b,EAAO,MAAQ,GAGNvvB,GAAU,YACnBiB,EAAO,WAAW,IAAMuS,CAAM,EAC9BvS,EAAO,cAAcjB,EAAQwT,EAAS,CAAC,EACvC+b,EAAO,MAAQ,IAIftuB,EAAO,WAAW,IAAMuS,CAAM,EAC9BvS,EAAO,cAAcjB,IAAW,EAAGwT,EAAS,CAAC,EAC7CvS,EAAO,cAAejB,EAAS,WAAe,EAAGwT,EAAS,CAAC,EAC3D+b,EAAO,MAAQ,GAGVtuB,CACT,CAEA,SAASqvB,EAAQrvB,EAAQuS,EAAQ,CAC/B,GAAI,CAACa,EAAO,SAASpT,CAAM,EAAG,MAAM,IAAI,UAAU,kCAAkC,EAC/EuS,IAAQA,EAAS,GAEtB,IAAI2G,EAAQlZ,EAAO,UAAUuS,CAAM,EAGnC,GAAI2G,EAAQ,IACV,OAAAmW,EAAO,MAAQ,EACRnW,EAGF,GAAIA,IAAU,IACnB,OAAAmW,EAAO,MAAQ,EACRrvB,EAAO,aAAauS,EAAS,CAAC,EAGhC,GAAI2G,IAAU,IACnB,OAAAmW,EAAO,MAAQ,EACRrvB,EAAO,aAAauS,EAAS,CAAC,EAIrC8c,EAAO,MAAQ,EACf,IAAIhW,EAAKrZ,EAAO,aAAauS,EAAS,CAAC,EACnC+G,EAAKtZ,EAAO,aAAauS,EAAS,CAAC,EACnCxT,EAASua,EAAK,WAAeD,EACjC,OAAAuY,EAAY7yB,CAAM,EAEXA,CAEX,CAEA,SAAS8yB,EAAgB9yB,EAAQ,CAC/B,OAAA6yB,EAAY7yB,CAAM,EAGhBA,EAAS,IAAO,EACZA,GAAU,MAAS,EACjBA,GAAU,WAAa,EACrB,CAEZ,CAEA,OAAA+yB,GAAiB,CAAE,OAAQxD,EAAQ,OAAQe,EAAQ,eAAgBwC,CAAc,4FCxFjF,OAAO,eAAc91B,EAAU,aAAc,CAAE,MAAO,GAAM,GAE3D,SAASg2B,EAAa,CACrBA,EAAaA,EAAY,YAAiB,CAAC,EAAK,cAChDA,EAAaA,EAAY,YAAiB,CAAC,EAAK,aAClD,GAAkBh2B,EAAQ,cAAgBA,EAAA,YAAsB,CAAA,EAAG,EACnEA,EAAA,kBAA4B,CAAC,aAAc,YAAY,GAEtD,SAASi2B,EAAY,CACpBA,EAAYA,EAAW,iBAAsB,CAAC,EAAK,mBACnDA,EAAYA,EAAW,aAAkB,CAAC,EAAK,eAC/CA,EAAYA,EAAW,YAAiB,CAAC,EAAK,cAC9CA,EAAYA,EAAW,aAAkB,CAAC,EAAK,eAC/CA,EAAYA,EAAW,cAAmB,CAAC,EAAK,gBAChDA,EAAYA,EAAW,eAAoB,CAAC,EAAK,iBACjDA,EAAYA,EAAW,iBAAsB,CAAC,EAAK,mBACnDA,EAAYA,EAAW,gBAAqB,CAAC,EAAK,kBAClDA,EAAYA,EAAW,oBAAyB,CAAC,EAAK,sBACtDA,EAAYA,EAAW,eAAoB,CAAC,EAAK,iBACjDA,EAAYA,EAAW,YAAiB,EAAE,EAAK,cAC/CA,EAAYA,EAAW,eAAoB,EAAE,EAAK,iBAClDA,EAAYA,EAAW,gBAAqB,EAAE,EAAK,kBACnDA,EAAYA,EAAW,qBAA0B,EAAE,EACjD,uBACFA,EAAYA,EAAW,iBAAsB,EAAE,EAAK,mBACpDA,EAAYA,EAAW,gBAAqB,EAAE,EAAK,iBACrD,GAAiBj2B,EAAQ,aAAeA,EAAA,WAAqB,CAAA,EAAG,EAChEA,EAAA,iBAA2B,CACzB,iBACA,cACA,aACA,cACA,eACA,gBACA,kBACA,iBACA,qBACA,gBACA,YACA,eACA,gBACA,qBACA,iBACA,kBAGD,SAASk2B,EAAa,CACrBA,EAAaA,EAAY,cAAmB,CAAC,EAAK,gBAClDA,EAAaA,EAAY,eAAoB,CAAC,EAAK,iBACnDA,EAAaA,EAAY,iBAAsB,CAAC,EAAK,mBACrDA,EAAaA,EAAY,iBAAsB,CAAC,EAAK,mBACrDA,EAAaA,EAAY,SAAc,CAAC,EAAK,WAC7CA,EAAaA,EAAY,qBAA0B,CAAC,EAClD,sBACJ,GAAkBl2B,EAAQ,cAAgBA,EAAA,YAAsB,CAAA,EAAG,EACnEA,EAAA,kBAA4B,CAC1B,eACA,gBACA,kBACA,iBACA,UACA,gFC7DF,OAAO,eAAem2B,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMC,EAAev0B,GAAA,EACf4c,EAAQ5e,GAAK,CAAC,GAAG,MAAMA,CAAC,EAAE,MAAM,EACtC,SAASyzB,EAAO+C,EAAQ,CACtB,GAAIA,EAAO,IAAI,CAAC,IAAMD,EAAa,YAAY,YAC7C,MAAM,IAAI,MACR,wDACEC,EAAO,IAAI,SAAS,KAAK,GAG/B,GAAIA,EAAO,IAAI,SAAW,IAAM,CAAC,CAAC,EAAG,CAAC,EAAE,SAASA,EAAO,IAAI,EAAE,CAAC,EAC7D,MAAM,IAAI,MACR,iEACEA,EAAO,IAAI,SAAS,KAAK,GAG/B,GAAKA,EAAO,MAAM,OAAS,EAAK,IAAM,EACpC,MAAM,IAAI,MACR,yEAGJ,MAAMC,EAAiBD,EAAO,IAAI,MAAM,CAAC,EACnCtwB,EAAO,CACX,kBAAmBswB,EAAO,MAAM,MAAM,EAAG,CAAC,EAC1C,eAAAC,EACA,KAAM,KAER,UAAWpxB,KAAKuZ,EAAM4X,EAAO,MAAM,OAAS,EAAI,CAAC,EAAG,CAClD,MAAM5b,EAAM4b,EAAO,MAAM,aAAanxB,EAAI,EAAI,CAAC,EACzCqxB,EAAS,CAAC,EAAE9b,EAAM,YAClBnQ,EAAMmQ,EAAM,WAClB1U,EAAK,MAAQ,IAAMuE,EAAI,SAAS,EAAE,GAAKisB,EAAS,IAAM,GAC1D,CACE,OAAOxwB,CACT,CACAowB,GAAA,OAAiB7C,EACjB,SAASf,EAAOxsB,EAAM,CACpB,MAAMzB,EAAO+S,GAAO,KAAK,CAAC+e,EAAa,YAAY,WAAW,CAAC,EACzD5zB,EAAM6U,GAAO,OAAO,CAAC/S,EAAMyB,EAAK,cAAc,CAAC,EAC/CywB,EAAYzwB,EAAK,KAAK,MAAM,GAAG,EAC/BkC,EAAQoP,GAAO,YAAYmf,EAAU,OAAS,CAAC,EACrDzwB,EAAK,kBAAkB,KAAKkC,EAAO,CAAC,EACpC,IAAIuO,EAAS,EACb,OAAAggB,EAAU,MAAM,CAAC,EAAE,QAAQC,GAAS,CAClC,MAAMF,EAASE,EAAM,MAAM,EAAE,IAAM,IACnC,IAAI1gB,EAAM,WAAa,SAASwgB,EAASE,EAAM,MAAM,EAAG,EAAE,EAAIA,EAAO,EAAE,EACnEF,IAAQxgB,GAAO,YACnB9N,EAAM,cAAc8N,EAAKS,CAAM,EAC/BA,GAAU,CACd,CAAG,EACM,CACL,IAAAhU,EACA,MAAAyF,EAEJ,CACAkuB,GAAA,OAAiB5D,EACjB4D,GAAA,SACE,uEACF,SAASO,EAAM3wB,EAAM,CACnB,MAAM4wB,EAAM5wB,EAAK,eACX6wB,EAAM7wB,EAAK,kBACX9F,EAAI8F,EAAK,KACf,OACEsR,GAAO,SAASsf,CAAG,GACnBA,EAAI,SAAW,IACf,CAAC,EAAG,CAAC,EAAE,QAAQA,EAAI,EAAE,CAAC,EAAI,IAC1Btf,GAAO,SAASuf,CAAG,GACnBA,EAAI,SAAW,GACf,OAAO32B,GAAM,UACb,CAAC,CAACA,EAAE,MAAM,eAAe,CAE7B,CACAk2B,GAAA,MAAgBO,EAChB,SAASG,EAAc5d,EAAO6d,EAAMC,EAAS,CAC3C,MAAMC,EAAaF,EAAK,eAAe,SAAS,KAAK,EACrD,OAAIC,EAAQ,IAAIC,CAAU,EAAU,IACpCD,EAAQ,IAAIC,CAAU,EAEpB/d,EAAM,OAAOwb,GAAKA,EAAE,eAAe,OAAOqC,EAAK,cAAc,CAAC,EAAE,SAAW,EAE/E,CACA,OAAAX,GAAA,cAAwBU,qDCjFxB,OAAO,eAAeI,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMb,EAAev0B,GAAA,EACrB,SAAS0wB,EAAOxsB,EAAM,CACpB,MAAO,CACL,IAAKsR,GAAO,KAAK,CAAC+e,EAAa,YAAY,WAAW,CAAC,EACvD,MAAOrwB,EAAK,SAAQ,EAExB,CACA,OAAAkxB,GAAA,OAAiB1E,qDCRjB,OAAO,eAAe2E,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMd,EAAev0B,GAAA,EACrB,SAASyxB,EAAO+C,EAAQ,CACtB,GAAIA,EAAO,IAAI,CAAC,IAAMD,EAAa,WAAW,gBAC5C,MAAM,IAAI,MACR,4DACEC,EAAO,IAAI,SAAS,KAAK,GAG/B,OAAOA,EAAO,KAChB,CACAa,GAAA,OAAiB5D,EACjB,SAASf,EAAOxsB,EAAM,CAEpB,MAAO,CACL,IAFUsR,GAAO,KAAK,CAAC+e,EAAa,WAAW,eAAe,CAAC,EAG/D,MAAOrwB,EAEX,CACAmxB,GAAA,OAAiB3E,EACjB2E,GAAA,SAAmB,SACnB,SAASR,EAAM3wB,EAAM,CACnB,OAAOsR,GAAO,SAAStR,CAAI,CAC7B,CACAmxB,GAAA,MAAgBR,EAChB,SAASS,EAAOC,EAAaC,EAAS,CACpC,MAAO,CAAC,CAACD,GAAe,CAAC,CAACC,GAAWD,EAAY,iBAAmB,MACtE,CACA,OAAAF,GAAA,OAAiBC,qDC5BjB,OAAO,eAAeG,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMlB,EAAev0B,GAAA,EACrB,SAASyxB,EAAO+C,EAAQ,CACtB,GAAIA,EAAO,IAAI,CAAC,IAAMD,EAAa,WAAW,oBAC5C,MAAM,IAAI,MACR,gEACEC,EAAO,IAAI,SAAS,KAAK,GAG/B,OAAOA,EAAO,KAChB,CACAiB,GAAA,OAAiBhE,EACjB,SAASf,EAAOxsB,EAAM,CAEpB,MAAO,CACL,IAFUsR,GAAO,KAAK,CAAC+e,EAAa,WAAW,mBAAmB,CAAC,EAGnE,MAAOrwB,EAEX,CACAuxB,GAAA,OAAiB/E,EACjB+E,GAAA,SAAmB,SACnB,SAASZ,EAAM3wB,EAAM,CACnB,OAAOsR,GAAO,SAAStR,CAAI,CAC7B,CACAuxB,GAAA,MAAgBZ,EAChB,SAASS,EAAOC,EAAaC,EAAS,CACpC,MACE,CAAC,CAACD,GAAe,CAAC,CAACC,GAAWD,EAAY,qBAAuB,MAErE,CACA,OAAAE,GAAA,OAAiBH,qDC9BjB,OAAO,eAAeI,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMnB,EAAev0B,GAAA,EACrB,SAASyxB,EAAO+C,EAAQ,CACtB,GAAIA,EAAO,IAAI,CAAC,IAAMD,EAAa,WAAW,iBAC5C,MAAM,IAAI,MACR,4DACEC,EAAO,IAAI,SAAS,KAAK,GAG/B,OAAOA,EAAO,KAChB,CACAkB,GAAA,OAAiBjE,EACjB,SAASf,EAAOxsB,EAAM,CACpB,MAAO,CACL,IAAKsR,GAAO,KAAK,CAAC+e,EAAa,WAAW,gBAAgB,CAAC,EAC3D,MAAOrwB,EAEX,CACAwxB,GAAA,OAAiBhF,EACjBgF,GAAA,SAAmB,SACnB,SAASb,EAAM3wB,EAAM,CACnB,OAAOsR,GAAO,SAAStR,CAAI,CAC7B,CACAwxB,GAAA,MAAgBb,EAChB,SAASS,EAAOC,EAAaC,EAAS,CACpC,MAAO,CAAC,CAACD,GAAe,CAAC,CAACC,GAAWD,EAAY,iBAAmB,MACtE,CACA,OAAAG,GAAA,OAAiBJ,qDC3BjB,OAAO,eAAeK,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMpB,EAAev0B,GAAA,EACrB,SAASyxB,EAAO+C,EAAQ,CACtB,GAAIA,EAAO,IAAI,CAAC,IAAMD,EAAa,WAAW,YAC5C,MAAM,IAAI,MACR,wDACEC,EAAO,IAAI,SAAS,KAAK,GAG/B,GACE,EAAEA,EAAO,IAAI,SAAW,IAAMA,EAAO,IAAI,SAAW,KACpD,CAAC,CAAC,EAAG,EAAG,CAAC,EAAE,SAASA,EAAO,IAAI,CAAC,CAAC,EAEjC,MAAM,IAAI,MACR,wDACEA,EAAO,IAAI,SAAS,KAAK,GAI/B,MAAO,CACL,OAFaA,EAAO,IAAI,MAAM,CAAC,EAG/B,UAAWA,EAAO,MAEtB,CACAmB,GAAA,OAAiBlE,EACjB,SAASf,EAAOkF,EAAM,CACpB,MAAMnzB,EAAO+S,GAAO,KAAK,CAAC+e,EAAa,WAAW,WAAW,CAAC,EAC9D,MAAO,CACL,IAAK/e,GAAO,OAAO,CAAC/S,EAAMmzB,EAAK,MAAM,CAAC,EACtC,MAAOA,EAAK,UAEhB,CACAD,GAAA,OAAiBjF,EACjBiF,GAAA,SAAmB,yCACnB,SAASd,EAAM3wB,EAAM,CACnB,OACEsR,GAAO,SAAStR,EAAK,MAAM,GAC3BsR,GAAO,SAAStR,EAAK,SAAS,GAC9B,CAAC,GAAI,EAAE,EAAE,SAASA,EAAK,OAAO,MAAM,GACpC,CAAC,EAAG,EAAG,CAAC,EAAE,SAASA,EAAK,OAAO,CAAC,CAAC,GACjC2xB,EAAoB3xB,EAAK,SAAS,CAEtC,CACAyxB,GAAA,MAAgBd,EAChB,SAASgB,EAAoB5f,EAAK,CAIhC,GAHI,CAACT,GAAO,SAASS,CAAG,GAAKA,EAAI,OAAS,GACtCA,EAAI,CAAC,IAAM,IACXA,EAAI,SAAWA,EAAI,CAAC,EAAI,GACxBA,EAAI,CAAC,IAAM,EAAM,MAAO,GAC5B,MAAM6f,EAAO7f,EAAI,CAAC,EAElB,GADI6f,EAAO,IAAMA,EAAO,GACpB7f,EAAI,EAAI6f,EAAO,CAAC,IAAM,EAAM,MAAO,GACvC,MAAMC,EAAO9f,EAAI,EAAI6f,EAAO,CAAC,EAE7B,MADI,EAAAC,EAAO,IAAMA,EAAO,GACpB9f,EAAI,SAAW,EAAI6f,EAAO,EAAIC,EAAO,EAE3C,CACA,SAASf,EAAc5d,EAAO6d,EAAMC,EAAS,CAC3C,MAAMC,EAAaF,EAAK,OAAO,SAAS,KAAK,EAC7C,OAAIC,EAAQ,IAAIC,CAAU,EAAU,IACpCD,EAAQ,IAAIC,CAAU,EACf/d,EAAM,OAAOwb,GAAKA,EAAE,OAAO,OAAOqC,EAAK,MAAM,CAAC,EAAE,SAAW,EACpE,CACA,OAAAU,GAAA,cAAwBX,qDC/DxB,OAAO,eAAegB,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMzB,EAAev0B,GAAA,EACrB,SAASyxB,EAAO+C,EAAQ,CACtB,GAAIA,EAAO,IAAI,CAAC,IAAMD,EAAa,WAAW,eAC5C,MAAM,IAAI,MACR,2DACEC,EAAO,IAAI,SAAS,KAAK,GAG/B,OAAOA,EAAO,MAAM,SAAS,MAAM,CACrC,CACAwB,GAAA,OAAiBvE,EACjB,SAASf,EAAOxsB,EAAM,CAEpB,MAAO,CACL,IAFUsR,GAAO,KAAK,CAAC+e,EAAa,WAAW,cAAc,CAAC,EAG9D,MAAO/e,GAAO,KAAKtR,EAAM,MAAM,EAEnC,CACA8xB,GAAA,OAAiBtF,EACjBsF,GAAA,SAAmB,SACnB,SAASnB,EAAM3wB,EAAM,CACnB,OAAO,OAAOA,GAAS,QACzB,CACA8xB,GAAA,MAAgBnB,EAChB,SAASS,EAAOC,EAAaC,EAAS,CACpC,MAAO,CAAC,CAACD,GAAe,CAAC,CAACC,GAAWD,EAAY,gBAAkB,MACrE,CACA,OAAAS,GAAA,OAAiBV,qDC5BjB,OAAO,eAAeW,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAM1B,EAAev0B,GAAA,EACrB,SAASyxB,EAAO+C,EAAQ,CACtB,GAAIA,EAAO,IAAI,CAAC,IAAMD,EAAa,WAAW,aAC5C,MAAM,IAAI,MACR,yDACEC,EAAO,IAAI,SAAS,KAAK,GAG/B,OAAOA,EAAO,MAAM,aAAa,CAAC,CACpC,CACAyB,GAAA,OAAiBxE,EACjB,SAASf,EAAOxsB,EAAM,CACpB,MAAMvD,EAAM6U,GAAO,KAAK,CAAC+e,EAAa,WAAW,YAAY,CAAC,EACxDnuB,EAAQoP,GAAO,YAAY,CAAC,EAClC,OAAApP,EAAM,cAAclC,EAAM,CAAC,EACpB,CACL,IAAAvD,EACA,MAAAyF,EAEJ,CACA6vB,GAAA,OAAiBvF,EACjBuF,GAAA,SAAmB,SACnB,SAASpB,EAAM3wB,EAAM,CACnB,OAAO,OAAOA,GAAS,QACzB,CACA+xB,GAAA,MAAgBpB,EAChB,SAASS,EAAOC,EAAaC,EAAS,CACpC,MAAO,CAAC,CAACD,GAAe,CAAC,CAACC,GAAWD,EAAY,cAAgB,MACnE,CACA,OAAAU,GAAA,OAAiBX,qDC9BjB,OAAO,eAAeY,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAM3B,EAAev0B,GAAA,EACrB,SAASyxB,EAAO+C,EAAQ,CACtB,GACEA,EAAO,IAAI,CAAC,IAAMD,EAAa,WAAW,aAC1CC,EAAO,IAAI,SAAW,EAEtB,MAAM,IAAI,MACR,uDACEA,EAAO,IAAI,SAAS,KAAK,GAG/B,GAAI,CAACK,EAAML,EAAO,KAAK,EACrB,MAAM,IAAI,MACR,mEAGJ,OAAOA,EAAO,KAChB,CACA0B,GAAA,OAAiBzE,EACjB,SAASf,EAAOtqB,EAAO,CAErB,MAAO,CAAE,IADGoP,GAAO,KAAK,CAAC+e,EAAa,WAAW,WAAW,CAAC,EAC/C,MAAAnuB,CAAK,CACrB,CACA8vB,GAAA,OAAiBxF,EACjBwF,GAAA,SAAmB,SACnB,SAASrB,EAAM3wB,EAAM,CACnB,OAAOsR,GAAO,SAAStR,CAAI,IAAMA,EAAK,SAAW,IAAMA,EAAK,SAAW,GACzE,CACAgyB,GAAA,MAAgBrB,EAChB,SAASS,EAAOC,EAAaC,EAAS,CACpC,MAAO,CAAC,CAACD,GAAe,CAAC,CAACC,GAAWD,EAAY,YAAc,MACjE,CACA,OAAAW,GAAA,OAAiBZ,qDCjCjB,OAAO,eAAea,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAM5B,EAAev0B,GAAA,EACrB,SAASyxB,EAAO+C,EAAQ,CACtB,GAAIA,EAAO,IAAI,CAAC,IAAMD,EAAa,WAAW,gBAC5C,MAAM,IAAI,MACR,2DACEC,EAAO,IAAI,SAAS,KAAK,GAG/B,IAAKA,EAAO,IAAI,OAAS,GAAK,KAAO,EACnC,MAAM,IAAI,MACR,kEACEA,EAAO,IAAI,SAAS,KAAK,GAG/B,MAAM4B,EAAc5B,EAAO,MAAMA,EAAO,MAAM,OAAS,CAAC,EACxD,IAAKA,EAAO,IAAI,CAAC,EAAI,OAAU4B,EAC7B,MAAM,IAAI,MACR,yDACE5B,EAAO,IAAI,SAAS,KAAK,GAG/B,MAAM6B,EAAS7B,EAAO,MAAM,MAAM,EAAG,EAAE,EAEvC,MAAO,CAAE,aADYA,EAAO,IAAI,MAAM,CAAC,EAChB,OAAA6B,EAAQ,YAAAD,CAAW,CAC5C,CACAD,GAAA,OAAiB1E,EACjB,SAASf,EAAO4F,EAAS,CACvB,MAAM7zB,EAAO+S,GAAO,KAAK,CAAC+e,EAAa,WAAW,eAAe,CAAC,EAC5DgC,EAAS/gB,GAAO,KAAK,CAAC8gB,EAAQ,WAAW,CAAC,EAChD,MAAO,CACL,IAAK9gB,GAAO,OAAO,CAAC/S,EAAM6zB,EAAQ,YAAY,CAAC,EAC/C,MAAO9gB,GAAO,OAAO,CAAC8gB,EAAQ,OAAQC,CAAM,CAAC,EAEjD,CACAJ,GAAA,OAAiBzF,EACjByF,GAAA,SACE,iEACF,SAAStB,EAAM3wB,EAAM,CACnB,OACEsR,GAAO,SAAStR,EAAK,YAAY,IAChCA,EAAK,aAAa,OAAS,GAAK,KAAO,IACvCA,EAAK,aAAa,CAAC,EAAI,OAAUA,EAAK,aACvCsR,GAAO,SAAStR,EAAK,MAAM,CAE/B,CACAiyB,GAAA,MAAgBtB,EAChB,SAASG,EAAc5d,EAAO6d,EAAMC,EAAS,CAC3C,MAAMC,EAAaF,EAAK,aAAa,SAAS,KAAK,EACnD,OAAIC,EAAQ,IAAIC,CAAU,EAAU,IACpCD,EAAQ,IAAIC,CAAU,EAEpB/d,EAAM,OAAOwb,GAAKA,EAAE,aAAa,OAAOqC,EAAK,YAAY,CAAC,EAAE,SAAW,EAE3E,CACA,OAAAkB,GAAA,cAAwBnB,qDCvDxB,OAAO,eAAewB,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMjC,EAAev0B,GAAA,EACrB,SAASyxB,EAAO+C,EAAQ,CACtB,GACEA,EAAO,IAAI,CAAC,IAAMD,EAAa,WAAW,iBAC1CC,EAAO,IAAI,SAAW,EAEtB,MAAM,IAAI,MACR,2DACEA,EAAO,IAAI,SAAS,KAAK,GAG/B,GAAI,CAACK,EAAML,EAAO,KAAK,EACrB,MAAM,IAAI,MAAM,gDAAgD,EAElE,OAAOA,EAAO,KAChB,CACAgC,GAAA,OAAiB/E,EACjB,SAASf,EAAOtqB,EAAO,CAErB,MAAO,CAAE,IADGoP,GAAO,KAAK,CAAC+e,EAAa,WAAW,eAAe,CAAC,EACnD,MAAAnuB,CAAK,CACrB,CACAowB,GAAA,OAAiB9F,EACjB8F,GAAA,SAAmB,SACnB,SAAS3B,EAAM3wB,EAAM,CACnB,OAAOsR,GAAO,SAAStR,CAAI,GAAKA,EAAK,SAAW,EAClD,CACAsyB,GAAA,MAAgB3B,EAChB,SAASS,EAAOC,EAAaC,EAAS,CACpC,MAAO,CAAC,CAACD,GAAe,CAAC,CAACC,GAAWD,EAAY,gBAAkB,MACrE,CACA,OAAAiB,GAAA,OAAiBlB,qDC/BjB,OAAO,eAAemB,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMlC,EAAev0B,GAAA,EACrB,SAASyxB,EAAO+C,EAAQ,CACtB,GAAIA,EAAO,IAAI,CAAC,IAAMD,EAAa,WAAW,eAC5C,MAAM,IAAI,MACR,0DACEC,EAAO,IAAI,SAAS,KAAK,GAG/B,GAAIA,EAAO,IAAI,SAAW,GACxB,MAAM,IAAI,MACR,gDACEA,EAAO,IAAI,SAAS,KAAK,GAG/B,GAAIA,EAAO,MAAM,SAAW,IAAMA,EAAO,MAAM,SAAW,GACxD,MAAM,IAAI,MACR,6DACEA,EAAO,IAAI,SAAS,KAAK,GAG/B,MAAMkC,EAASlC,EAAO,IAAI,MAAM,EAAG,EAAE,EAC/BmC,EAAWnC,EAAO,IAAI,MAAM,EAAE,EACpC,MAAO,CACL,OAAAkC,EACA,SAAAC,EACA,UAAWnC,EAAO,MAEtB,CACAiC,GAAA,OAAiBhF,EACjB,SAASf,EAAOkG,EAAM,CACpB,MAAMn0B,EAAO+S,GAAO,KAAK,CAAC+e,EAAa,WAAW,cAAc,CAAC,EACjE,MAAO,CACL,IAAK/e,GAAO,OAAO,CAAC/S,EAAMm0B,EAAK,OAAQA,EAAK,QAAQ,CAAC,EACrD,MAAOA,EAAK,UAEhB,CACAH,GAAA,OAAiB/F,EACjB+F,GAAA,SAAmB,2DACnB,SAAS5B,EAAM3wB,EAAM,CACnB,OACEsR,GAAO,SAAStR,EAAK,MAAM,GAC3BsR,GAAO,SAAStR,EAAK,QAAQ,GAC7BsR,GAAO,SAAStR,EAAK,SAAS,GAC9BA,EAAK,OAAO,SAAW,IACvBA,EAAK,SAAS,SAAW,KACxBA,EAAK,UAAU,SAAW,IAAMA,EAAK,UAAU,SAAW,GAE/D,CACAuyB,GAAA,MAAgB5B,EAChB,SAASG,EAAc5d,EAAO6d,EAAMC,EAAS,CAC3C,MAAMC,EACJF,EAAK,OAAO,SAAS,KAAK,EAAIA,EAAK,SAAS,SAAS,KAAK,EAC5D,OAAIC,EAAQ,IAAIC,CAAU,EAAU,IACpCD,EAAQ,IAAIC,CAAU,EAEpB/d,EAAM,OACJwb,GAAKA,EAAE,OAAO,OAAOqC,EAAK,MAAM,GAAKrC,EAAE,SAAS,OAAOqC,EAAK,QAAQ,GACpE,SAAW,EAEjB,CACA,OAAAwB,GAAA,cAAwBzB,iEC7DxB,OAAO,eAAe6B,GAAS,aAAc,CAAE,MAAO,GAAM,EAE5D,MAAM9C,EAAmB,iBACzB,SAASC,EAAYh2B,EAAG,CACtB,GAAIA,EAAI,GAAKA,EAAI+1B,GAAoB/1B,EAAI,IAAM,EAC7C,MAAM,IAAI,WAAW,oBAAoB,CAC7C,CACA,SAAS0yB,EAAOoG,EAAS10B,EAAQuS,EAAQ,CAGvC,GAFAqf,EAAY8C,CAAO,EACd10B,IAAQA,EAASoT,GAAO,YAAYye,EAAe6C,CAAO,CAAC,GAC5D,CAACthB,GAAO,SAASpT,CAAM,EACzB,MAAM,IAAI,UAAU,kCAAkC,EACxD,OAAKuS,IAAQA,EAAS,GAElBmiB,EAAU,KACZ10B,EAAO,WAAW00B,EAASniB,CAAM,EACjC,OAAO,OAAO+b,EAAQ,CAAE,MAAO,CAAC,CAAE,GAEzBoG,GAAW,OACpB10B,EAAO,WAAW,IAAMuS,CAAM,EAC9BvS,EAAO,cAAc00B,EAASniB,EAAS,CAAC,EACxC,OAAO,OAAO+b,EAAQ,CAAE,MAAO,CAAC,CAAE,GAEzBoG,GAAW,YACpB10B,EAAO,WAAW,IAAMuS,CAAM,EAC9BvS,EAAO,cAAc00B,EAASniB,EAAS,CAAC,EACxC,OAAO,OAAO+b,EAAQ,CAAE,MAAO,CAAC,CAAE,IAGlCtuB,EAAO,WAAW,IAAMuS,CAAM,EAC9BvS,EAAO,cAAc00B,IAAY,EAAGniB,EAAS,CAAC,EAC9CvS,EAAO,cAAe00B,EAAU,WAAe,EAAGniB,EAAS,CAAC,EAC5D,OAAO,OAAO+b,EAAQ,CAAE,MAAO,CAAC,CAAE,GAE7BtuB,CACT,CACAy0B,GAAA,OAAiBnG,EACjB,SAASe,EAAOrvB,EAAQuS,EAAQ,CAC9B,GAAI,CAACa,GAAO,SAASpT,CAAM,EACzB,MAAM,IAAI,UAAU,kCAAkC,EACnDuS,IAAQA,EAAS,GACtB,MAAM2G,EAAQlZ,EAAO,UAAUuS,CAAM,EAErC,GAAI2G,EAAQ,IACV,cAAO,OAAOmW,EAAQ,CAAE,MAAO,CAAC,CAAE,EAC3BnW,EAEF,GAAIA,IAAU,IACnB,cAAO,OAAOmW,EAAQ,CAAE,MAAO,CAAC,CAAE,EAC3BrvB,EAAO,aAAauS,EAAS,CAAC,EAEhC,GAAI2G,IAAU,IACnB,cAAO,OAAOmW,EAAQ,CAAE,MAAO,CAAC,CAAE,EAC3BrvB,EAAO,aAAauS,EAAS,CAAC,EAEhC,CACL,OAAO,OAAO8c,EAAQ,CAAE,MAAO,CAAC,CAAE,EAClC,MAAMhW,EAAKrZ,EAAO,aAAauS,EAAS,CAAC,EAEnCmiB,EADK10B,EAAO,aAAauS,EAAS,CAAC,EACpB,WAAe8G,EACpC,OAAAuY,EAAY8C,CAAO,EACZA,CACX,CACA,CACAD,GAAA,OAAiBpF,EACjB,SAASwC,EAAe6C,EAAS,CAC/B,OAAA9C,EAAY8C,CAAO,EACZA,EAAU,IACb,EACAA,GAAW,MACX,EACAA,GAAW,WACX,EACA,CACN,CACA,OAAAD,GAAA,eAAyB5C,+CC3EzB,OAAO,eAAe8C,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMC,EAAUh3B,GAAA,EAChB+2B,GAAA,MAAgB/4B,GAAK,CAAC,GAAG,MAAMA,CAAC,EAAE,MAAM,EACxC,SAASi5B,EAAc70B,EAAQ,CAC7B,GAAIA,EAAO,OAAS,EAAG,OAAOA,EAC9B,IAAIiX,EAAIjX,EAAO,OAAS,EACpBiN,EAAM,EACV,QAAShM,EAAI,EAAGA,EAAIjB,EAAO,OAAS,EAAGiB,IACrCgM,EAAMjN,EAAOiB,CAAC,EACdjB,EAAOiB,CAAC,EAAIjB,EAAOiX,CAAC,EACpBjX,EAAOiX,CAAC,EAAIhK,EACZgK,IAEF,OAAOjX,CACT,CACA20B,GAAA,cAAwBE,EACxB,SAASC,EAAgBC,EAAS,CAChC,MAAMC,EAAUD,EAAQ,IAAIE,CAAc,EAC1C,OAAAD,EAAQ,KAAK5hB,GAAO,KAAK,CAAC,CAAC,CAAC,CAAC,EACtBA,GAAO,OAAO4hB,CAAO,CAC9B,CACAL,GAAA,gBAA0BG,EAC1B,SAASG,EAAe7C,EAAQ,CAC9B,MAAM8C,EAAS9C,EAAO,IAAI,OACpB+C,EAAS/C,EAAO,MAAM,OACtBgD,EAAeR,EAAQ,eAAeM,CAAM,EAC5CG,EAAeT,EAAQ,eAAeO,CAAM,EAC5Cn1B,EAASoT,GAAO,YACpBgiB,EAAeF,EAASG,EAAeF,GAEzC,OAAAP,EAAQ,OAAOM,EAAQl1B,EAAQ,CAAC,EAChCoyB,EAAO,IAAI,KAAKpyB,EAAQo1B,CAAY,EACpCR,EAAQ,OAAOO,EAAQn1B,EAAQo1B,EAAeF,CAAM,EACpD9C,EAAO,MAAM,KAAKpyB,EAAQo1B,EAAeF,EAASG,CAAY,EACvDr1B,CACT,CACA20B,GAAA,eAAyBM,EAEzB,SAASK,EAAUtxB,EAAOvD,EAAK,CAC7B,GAAI,OAAOuD,GAAU,SACnB,MAAM,IAAI,MAAM,uCAAuC,EACzD,GAAIA,EAAQ,EACV,MAAM,IAAI,MAAM,0DAA0D,EAC5E,GAAIA,EAAQvD,EAAK,MAAM,IAAI,MAAM,gCAAgC,EACjE,GAAI,KAAK,MAAMuD,CAAK,IAAMA,EACxB,MAAM,IAAI,MAAM,kCAAkC,CACtD,CACA,SAASuxB,EAAav1B,EAAQuS,EAAQ,CACpC,MAAMtX,EAAI+E,EAAO,aAAauS,CAAM,EACpC,IAAIrX,EAAI8E,EAAO,aAAauS,EAAS,CAAC,EACtC,OAAArX,GAAK,WACLo6B,EAAUp6B,EAAID,EAAG,gBAAkB,EAC5BC,EAAID,CACb,CACA05B,GAAA,aAAuBY,EACvB,SAASC,EAAcx1B,EAAQgE,EAAOuO,EAAQ,CAC5C,OAAA+iB,EAAUtxB,EAAO,gBAAkB,EACnChE,EAAO,aAAagE,EAAQ,GAAIuO,CAAM,EACtCvS,EAAO,cAAc,KAAK,MAAMgE,EAAQ,UAAW,EAAGuO,EAAS,CAAC,EACzDA,EAAS,CAClB,CACA,OAAAoiB,GAAA,cAAwBa,+CC7DxB,OAAO,eAAeC,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMtD,EAAev0B,GAAA,EACf83B,EAAU3Y,GAAA,EACV6X,EAAUhV,GAAA,EAChB,SAASyP,EAAO+C,EAAQ,CACtB,GAAIA,EAAO,IAAI,CAAC,IAAMD,EAAa,WAAW,aAC5C,MAAM,IAAI,MACR,yDACEC,EAAO,IAAI,SAAS,KAAK,GAG/B,MAAMpuB,EAAQ0xB,EAAQ,aAAatD,EAAO,MAAO,CAAC,EAClD,IAAIuD,EAAU,EACd,MAAMC,EAAYhB,EAAQ,OAAOxC,EAAO,MAAOuD,CAAO,EACtDA,GAAWf,EAAQ,eAAegB,CAAS,EAC3C,MAAM3B,EAAS7B,EAAO,MAAM,MAAMuD,CAAO,EACzC,GAAI1B,EAAO,SAAW2B,EACpB,MAAM,IAAI,MAAM,wDAAwD,EAE1E,MAAO,CACL,OAAA3B,EACA,MAAAjwB,EAEJ,CACAyxB,GAAA,OAAiBpG,EACjB,SAASf,EAAOxsB,EAAM,CACpB,KAAM,CAAE,OAAAmyB,EAAQ,MAAAjwB,CAAK,EAAKlC,EACpB+zB,EAAYjB,EAAQ,eAAeX,EAAO,MAAM,EAChDr1B,EAASwU,GAAO,YAAY,EAAIyiB,EAAY5B,EAAO,MAAM,EAC/D,OAAAyB,EAAQ,cAAc92B,EAAQoF,EAAO,CAAC,EACtC4wB,EAAQ,OAAOX,EAAO,OAAQr1B,EAAQ,CAAC,EACvCq1B,EAAO,KAAKr1B,EAAQ,EAAIi3B,CAAS,EAC1B,CACL,IAAKziB,GAAO,KAAK,CAAC+e,EAAa,WAAW,YAAY,CAAC,EACvD,MAAOvzB,EAEX,CACA62B,GAAA,OAAiBnH,EACjBmH,GAAA,SAAmB,qCACnB,SAAShD,EAAM3wB,EAAM,CACnB,OAAOsR,GAAO,SAAStR,EAAK,MAAM,GAAK,OAAOA,EAAK,OAAU,QAC/D,CACA2zB,GAAA,MAAgBhD,EAChB,SAASS,EAAOC,EAAaC,EAAS,CACpC,MAAO,CAAC,CAACD,GAAe,CAAC,CAACC,GAAWD,EAAY,cAAgB,MACnE,CACA,OAAAsC,GAAA,OAAiBvC,qDC9CjB,OAAO,eAAe4C,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAM3D,EAAev0B,GAAA,EACfg3B,EAAU7X,GAAA,EAChB,SAASsS,EAAO+C,EAAQ,CACtB,GACEA,EAAO,IAAI,CAAC,IAAMD,EAAa,YAAY,UAC3CC,EAAO,IAAI,SAAW,EAEtB,MAAM,IAAI,MACR,qDACEA,EAAO,IAAI,SAAS,KAAK,GAG/B,IAAIuD,EAAU,EACd,MAAM7zB,EAAO,CAAA,EACb,KAAO6zB,EAAUvD,EAAO,MAAM,QAAQ,CACpC,MAAM2D,EAAQ3D,EAAO,MAAMuD,GAAS,EAC9B3B,EAAc5B,EAAO,MAAMuD,GAAS,EACpCC,EAAYhB,EAAQ,OAAOxC,EAAO,MAAOuD,CAAO,EACtDA,GAAWf,EAAQ,eAAegB,CAAS,EAC3C9zB,EAAK,KAAK,CACR,MAAAi0B,EACA,YAAA/B,EACA,OAAQ5B,EAAO,MAAM,MAAMuD,EAASA,EAAUC,CAAS,CAC7D,CAAK,EACDD,GAAWC,CACf,CACE,MAAO,CAAE,OAAQ9zB,CAAI,CACvB,CACAg0B,GAAA,OAAiBzG,EACjB,SAASf,EAAO0H,EAAM,CACpB,MAAMz3B,EAAM6U,GAAO,KAAK,CAAC+e,EAAa,YAAY,QAAQ,CAAC,EACrD8D,EAAO,CAAA,EAAG,OACd,GAAGD,EAAK,OAAO,IAAIE,GAAW,CAC5B9iB,GAAO,GAAG8iB,EAAQ,MAAOA,EAAQ,WAAW,EAC5CtB,EAAQ,OAAOsB,EAAQ,OAAO,MAAM,EACpCA,EAAQ,MACd,CAAK,GAEH,MAAO,CACL,IAAA33B,EACA,MAAO6U,GAAO,OAAO6iB,CAAI,EAE7B,CACAH,GAAA,OAAiBxH,EACjBwH,GAAA,SACE,wEACF,SAASrD,EAAM3wB,EAAM,CACnB,OACE,MAAM,QAAQA,EAAK,MAAM,GACzBA,EAAK,OAAO,MACVo0B,GACEA,EAAQ,OAAS,GACjBA,EAAQ,OAAS,MAChBA,EAAQ,YAAc,OAAUA,EAAQ,aACzC9iB,GAAO,SAAS8iB,EAAQ,MAAM,CACtC,CAEA,CACAJ,GAAA,MAAgBrD,EAChB,SAASS,EAAOC,EAAaC,EAAS,CACpC,MAAO,CAAC,CAACD,GAAe,CAAC,CAACC,GAAWD,EAAY,UAAY,MAC/D,CACA,OAAA2C,GAAA,OAAiB5C,qDC/DjB,OAAO,eAAeiD,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAM3b,EAAQ,GAAK,CAAC,GAAG,MAAM,CAAC,EAAE,MAAM,EAChC4b,EAAgB9B,GACnBA,EAAO,SAAW,IAAM,CAAC,EAAG,CAAC,EAAE,SAASA,EAAO,CAAC,CAAC,GACjDA,EAAO,SAAW,IAAYA,EAAO,CAAC,IAAd,EAC3B,SAAS+B,EAAcC,EAAWC,EAAgBH,EAAe,CAC/D,SAAS/G,EAAO+C,EAAQ,CACtB,GAAIA,EAAO,IAAI,CAAC,IAAMkE,EACpB,MAAM,IAAI,MACR,6DACElE,EAAO,IAAI,SAAS,KAAK,GAG/B,MAAMkC,EAASlC,EAAO,IAAI,MAAM,CAAC,EACjC,GAAI,CAACmE,EAAcjC,CAAM,EACvB,MAAM,IAAI,MACR,6DACElC,EAAO,IAAI,SAAS,KAAK,GAG/B,GAAKA,EAAO,MAAM,OAAS,EAAK,IAAM,EACpC,MAAM,IAAI,MACR,6EAGJ,MAAMtwB,EAAO,CACX,kBAAmBswB,EAAO,MAAM,MAAM,EAAG,CAAC,EAC1C,OAAAkC,EACA,KAAM,KAER,UAAWrzB,KAAKuZ,EAAM4X,EAAO,MAAM,OAAS,EAAI,CAAC,EAAG,CAClD,MAAM5b,EAAM4b,EAAO,MAAM,aAAanxB,EAAI,EAAI,CAAC,EACzCqxB,EAAS,CAAC,EAAE9b,EAAM,YAClBnQ,EAAMmQ,EAAM,WAClB1U,EAAK,MAAQ,IAAMuE,EAAI,SAAS,EAAE,GAAKisB,EAAS,IAAM,GAC5D,CACI,OAAOxwB,CACX,CACE,SAASwsB,EAAOxsB,EAAM,CACpB,MAAMzB,EAAO+S,GAAO,KAAK,CAACkjB,CAAS,CAAC,EAC9B/3B,EAAM6U,GAAO,OAAO,CAAC/S,EAAMyB,EAAK,MAAM,CAAC,EACvCywB,EAAYzwB,EAAK,KAAK,MAAM,GAAG,EAC/BkC,EAAQoP,GAAO,YAAYmf,EAAU,OAAS,CAAC,EACrDzwB,EAAK,kBAAkB,KAAKkC,EAAO,CAAC,EACpC,IAAIuO,EAAS,EACb,OAAAggB,EAAU,MAAM,CAAC,EAAE,QAAQC,GAAS,CAClC,MAAMF,EAASE,EAAM,MAAM,EAAE,IAAM,IACnC,IAAI1gB,EAAM,WAAa,SAASwgB,EAASE,EAAM,MAAM,EAAG,EAAE,EAAIA,EAAO,EAAE,EACnEF,IAAQxgB,GAAO,YACnB9N,EAAM,cAAc8N,EAAKS,CAAM,EAC/BA,GAAU,CAChB,CAAK,EACM,CACL,IAAAhU,EACA,MAAAyF,EAEN,CACE,MAAM2Y,EACJ,+DACF,SAAS8V,EAAM3wB,EAAM,CACnB,OACEsR,GAAO,SAAStR,EAAK,MAAM,GAC3BsR,GAAO,SAAStR,EAAK,iBAAiB,GACtC,OAAOA,EAAK,MAAS,UACrBy0B,EAAcz0B,EAAK,MAAM,GACzBA,EAAK,kBAAkB,SAAW,CAExC,CACE,SAAS8wB,EAAc5d,EAAO6d,EAAMC,EAAS,CAC3C,MAAMC,EAAaF,EAAK,OAAO,SAAS,KAAK,EAC7C,OAAIC,EAAQ,IAAIC,CAAU,EAAU,IACpCD,EAAQ,IAAIC,CAAU,EACf/d,EAAM,OAAOwb,GAAKA,EAAE,OAAO,OAAOqC,EAAK,MAAM,CAAC,EAAE,SAAW,EACtE,CACE,MAAO,CACL,OAAAxD,EACA,OAAAf,EACA,MAAAmE,EACA,SAAA9V,EACA,cAAAiW,EAEJ,CACA,OAAAuD,GAAA,cAAwBE,qDClFxB,OAAO,eAAeG,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,SAASC,EAAYC,EAAa,CAChC,OAAOF,EACP,SAASA,EAAYpE,EAAQ,CAC3B,IAAIkC,EACJ,GAAIoC,EAAY,SAAStE,EAAO,IAAI,CAAC,CAAC,IACpCkC,EAASlC,EAAO,IAAI,MAAM,CAAC,EAEzB,EAAEkC,EAAO,SAAW,IAAMA,EAAO,SAAW,KAC5C,CAAC,CAAC,EAAG,EAAG,CAAC,EAAE,SAASA,EAAO,CAAC,CAAC,GAE7B,MAAM,IAAI,MACR,yCAA2ClC,EAAO,IAAI,SAAS,KAAK,GAI1E,OAAOkC,CACX,CACA,CACA,OAAAkC,GAAA,YAAsBC,qDCnBtB,OAAO,eAAeE,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,SAASN,EAAcC,EAAW,CAChC,SAASjH,EAAO+C,EAAQ,CACtB,GAAIA,EAAO,IAAI,CAAC,IAAMkE,EACpB,MAAM,IAAI,MACR,0DACElE,EAAO,IAAI,SAAS,KAAK,GAG/B,OAAOA,EAAO,KAClB,CACE,SAAS9D,EAAOxsB,EAAM,CAEpB,MAAO,CACL,IAFUsR,GAAO,KAAK,CAACkjB,CAAS,CAAC,EAGjC,MAAOx0B,EAEb,CACE,MAAM6a,EAAW,SACjB,SAAS8V,EAAM3wB,EAAM,CACnB,OAAOsR,GAAO,SAAStR,CAAI,CAC/B,CACE,SAASoxB,EAAOC,EAAaC,EAAS,CACpC,MAAO,CAAC,CAACD,GAAe,CAAC,CAACC,GAAWD,EAAY,eAAiB,MACtE,CACE,MAAO,CACL,OAAA9D,EACA,OAAAf,EACA,MAAAmE,EACA,SAAA9V,EACA,OAAAuW,EAEJ,CACA,OAAAyD,GAAA,cAAwBN,qDCjCxB,OAAO,eAAeO,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMhC,EAAUh3B,GAAA,EACVu4B,EAAkBpZ,GAAA,EAClB8Z,EAAmBvC,GAAUA,EAAO,SAAW,GACrD,SAAS+B,EAAcC,EAAW,CAChC,MAAMQ,EAASX,EAAgB,cAAcG,EAAWO,CAAgB,EACxE,SAASxH,EAAO+C,EAAQ,CACtB,MAAM2E,EAAUnC,EAAQ,OAAOxC,EAAO,KAAK,EACrC4E,EAAapC,EAAQ,eAAemC,CAAO,EAC3CjJ,EAAOgJ,EAAO,OAAO,CACzB,IAAK1E,EAAO,IACZ,MAAOA,EAAO,MAAM,MAAM4E,EAAaD,EAAU,EAAE,CACzD,CAAK,EACKE,EAAa,IAAI,MAAMF,CAAO,EACpC,QAAS91B,EAAI,EAAG00B,EAAUqB,EAAY/1B,EAAI81B,EAAS91B,IAAK00B,GAAW,GACjEsB,EAAWh2B,CAAC,EAAImxB,EAAO,MAAM,MAAMuD,EAASA,EAAU,EAAE,EAE1D,OAAO,OAAO,OAAO,CAAA,EAAI7H,EAAM,CAAE,WAAAmJ,CAAU,CAAE,CACjD,CACE,SAAS3I,EAAOxsB,EAAM,CACpB,MAAMgsB,EAAOgJ,EAAO,OAAOh1B,CAAI,EACzBk1B,EAAapC,EAAQ,eAAe9yB,EAAK,WAAW,MAAM,EAC1Do1B,EAAa9jB,GAAO,YAAY4jB,CAAU,EAChDpC,EAAQ,OAAO9yB,EAAK,WAAW,OAAQo1B,CAAU,EACjD,MAAMlzB,EAAQoP,GAAO,OAAO,CAAC8jB,EAAY,GAAGp1B,EAAK,WAAYgsB,EAAK,KAAK,CAAC,EACxE,OAAO,OAAO,OAAO,CAAA,EAAIA,EAAM,CAAE,MAAA9pB,CAAK,CAAE,CAC5C,CACE,MAAM2Y,EACJ,qFAMF,SAAS8V,EAAM3wB,EAAM,CACnB,OACE,MAAM,QAAQA,EAAK,UAAU,GAC7BA,EAAK,WAAW,MACdyyB,GAAYnhB,GAAO,SAASmhB,CAAQ,GAAKA,EAAS,SAAW,KAE/DuC,EAAO,MAAMh1B,CAAI,CAEvB,CACE,MAAO,CACL,OAAAutB,EACA,OAAAf,EACA,MAAAmE,EACA,SAAA9V,EACA,cAAema,EAAO,cAE1B,CACA,OAAAF,GAAA,cAAwBP,qDCnDxB,OAAO,eAAec,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,SAASd,EAAcC,EAAW,CAChC,SAASjH,EAAO+C,EAAQ,CACtB,GAAIA,EAAO,IAAI,CAAC,IAAMkE,GAAalE,EAAO,IAAI,SAAW,EACvD,MAAM,IAAI,MACR,4DACEA,EAAO,IAAI,SAAS,KAAK,GAG/B,GAAIA,EAAO,MAAM,SAAW,GAC1B,MAAM,IAAI,MACR,4DAGJ,OAAOA,EAAO,KAClB,CACE,SAAS9D,EAAOtqB,EAAO,CAErB,MAAO,CAAE,IADGoP,GAAO,KAAK,CAACkjB,CAAS,CAAC,EACrB,MAAAtyB,CAAK,CACvB,CACE,MAAM2Y,EAAW,SACjB,SAAS8V,EAAM3wB,EAAM,CACnB,OAAOsR,GAAO,SAAStR,CAAI,GAAKA,EAAK,SAAW,EACpD,CACE,SAASoxB,EAAOC,EAAaC,EAAS,CACpC,MACE,CAAC,CAACD,GAAe,CAAC,CAACC,GAAWD,EAAY,iBAAmB,MAEnE,CACE,MAAO,CACL,OAAA9D,EACA,OAAAf,EACA,MAAAmE,EACA,SAAA9V,EACA,OAAAuW,EAEJ,CACA,OAAAiE,GAAA,cAAwBd,qDCrCxB,OAAO,eAAee,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,SAASf,EAAcC,EAAW,CAChC,SAASjH,EAAO+C,EAAQ,CACtB,GAAIA,EAAO,IAAI,CAAC,IAAMkE,EACpB,MAAM,IAAI,MACR,2DACElE,EAAO,IAAI,SAAS,KAAK,GAG/B,OAAOA,EAAO,KAClB,CACE,SAAS9D,EAAOxsB,EAAM,CAEpB,MAAO,CACL,IAFUsR,GAAO,KAAK,CAACkjB,CAAS,CAAC,EAGjC,MAAOx0B,EAEb,CACE,MAAM6a,EAAW,SACjB,SAAS8V,EAAM3wB,EAAM,CACnB,OAAOsR,GAAO,SAAStR,CAAI,CAC/B,CACE,SAASoxB,EAAOC,EAAaC,EAAS,CACpC,MACE,CAAC,CAACD,GAAe,CAAC,CAACC,GAAWD,EAAY,gBAAkB,MAElE,CACE,MAAO,CACL,OAAA9D,EACA,OAAAf,EACA,MAAAmE,EACA,SAAA9V,EACA,OAAAuW,EAEJ,CACA,OAAAkE,GAAA,cAAwBf,+CCnCxB,OAAO,eAAegB,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMlF,EAAev0B,GAAA,EACfs0B,EAAanV,GAAA,EACbiW,EAAapT,GAAA,EACbqT,EAAiBqE,GAAA,EACjBjE,EAAqBkE,GAAA,EACrBjE,EAAiBkE,GAAA,EACjBjE,EAAakE,GAAA,EACb7D,EAAgB8D,GAAA,EAChB7D,EAAc8D,GAAA,EACd7D,EAAY8D,GAAA,EACZ7D,EAAgB8D,GAAA,EAChBzD,EAAgB0D,GAAA,EAChBzD,EAAe0D,GAAA,EACftC,EAAcuC,GAAA,EACdlC,EAAUmC,GAAA,EACV9B,EAAkB+B,GAAA,EAClB1B,EAAc2B,GAAA,EACdxB,EAAeyB,GAAA,EACfxB,EAAqByB,GAAA,EACrBlB,EAAiBmB,GAAA,EACjBlB,EAAgBmB,GAAA,EAChBC,EAAU,CACd,WAAAxF,EACA,WAAAd,EAEA,YAAasE,EAAY,YAAY,EAAE,GAEzCa,GAAA,QAAkBmB,EAClB,MAAMC,EAAS,CACb,eAAAnF,EACA,WAAAC,EACA,YAAAM,EACA,eAAAZ,EACA,mBAAAI,EACA,cAAAO,EACA,YAAA6B,EACA,gBAAiBU,EAAgB,cAC/BhE,EAAa,WAAW,kBAE1B,aAAcwE,EAAa,cACzBxE,EAAa,WAAW,eAE1B,cAAeiF,EAAc,cAC3BjF,EAAa,WAAW,gBAE1B,YAAaqE,EAAY,YAAY,CACnCrE,EAAa,WAAW,YACxBA,EAAa,WAAW,gBAC5B,CAAG,EACD,UAAA2B,EACA,aAAAO,EACA,cAAAN,EACA,mBAAoB6C,EAAmB,cACrCzE,EAAa,WAAW,sBAE1B,eAAgBgF,EAAe,cAC7BhF,EAAa,WAAW,kBAE1B,cAAAiC,GAEFiD,GAAA,OAAiBoB,EACjB,MAAMC,EAAU,CACd,gBAAiBvC,EAAgB,cAC/BhE,EAAa,YAAY,kBAE3B,aAAcwE,EAAa,cACzBxE,EAAa,YAAY,eAE3B,cAAeiF,EAAc,cAC3BjF,EAAa,YAAY,gBAE3B,YAAaqE,EAAY,YAAY,CACnCrE,EAAa,YAAY,gBAC7B,CAAG,EACD,mBAAoByE,EAAmB,cACrCzE,EAAa,YAAY,sBAE3B,QAAA2D,EACA,eAAgBqB,EAAe,cAC7BhF,EAAa,YAAY,mBAG7B,OAAAkF,GAAA,QAAkBqB,+CCnFlB,OAAO,eAAeC,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMlI,EAAU7yB,GAAA,EACV83B,EAAU3Y,GAAA,EACV6X,EAAUhV,GAAA,EACVuS,EAAemF,GAAA,EACrB,SAASsB,EAAe54B,EAAQ64B,EAAU,CACxC,IAAItmB,EAAS,EACb,SAASumB,GAAW,CAClB,MAAM5D,EAASN,EAAQ,OAAO50B,EAAQuS,CAAM,EAC5CA,GAAUqiB,EAAQ,eAAeM,CAAM,EACvC,MAAM32B,EAAMyB,EAAO,MAAMuS,EAAQA,EAAS2iB,CAAM,EAChD,OAAA3iB,GAAU2iB,EACH32B,CACX,CACE,SAASw6B,GAAe,CACtB,MAAMjnB,EAAM9R,EAAO,aAAauS,CAAM,EACtC,OAAAA,GAAU,EACHT,CACX,CACE,SAASknB,GAAY,CACnB,MAAMlnB,EAAM9R,EAAO,UAAUuS,CAAM,EACnC,OAAAA,GAAU,EACHT,CACX,CACE,SAASmnB,GAAc,CACrB,MAAM16B,EAAMu6B,EAAQ,EACd90B,EAAQ80B,EAAQ,EACtB,MAAO,CACL,IAAAv6B,EACA,MAAAyF,EAEN,CACE,SAASk1B,GAAwB,CAC/B,GAAI3mB,GAAUvS,EAAO,OACnB,MAAM,IAAI,MAAM,sCAAsC,EAExD,MAAMm5B,EAAQn5B,EAAO,UAAUuS,CAAM,IAAM,EAC3C,OAAI4mB,GACF5mB,IAEK4mB,CACX,CACE,GAAIJ,EAAY,IAAO,WACrB,MAAM,IAAI,MAAM,oCAAoC,EAEtD,GAAIC,EAAS,IAAO,IAClB,MAAM,IAAI,MACR,iEAGJ,MAAMI,EAAmB,CAAA,EACnBC,EAAiB,CAAA,EACvB,KAAO,CAACH,EAAqB,GAAI,CAC/B,MAAM9G,EAAS6G,EAAW,EACpBK,EAASlH,EAAO,IAAI,SAAS,KAAK,EACxC,GAAIiH,EAAeC,CAAM,EACvB,MAAM,IAAI,MACR,4DAA8DA,GAGlED,EAAeC,CAAM,EAAI,EACzBF,EAAiB,KAAKhH,CAAM,CAChC,CACE,MAAMmH,EAAiBH,EAAiB,OACtChH,GAAUA,EAAO,IAAI,CAAC,IAAMD,EAAa,YAAY,aAEvD,GAAIoH,EAAe,SAAW,EAC5B,MAAM,IAAI,MAAM,4CAA4C,EAE9D,MAAMvG,EAAa6F,EAASU,EAAe,CAAC,EAAE,KAAK,EAE7C,CAAE,WAAAC,EAAY,YAAAC,GAAgBzG,EAAW,qBAAoB,EAC7D0G,EAAe,CAAA,EACfC,EAAgB,CAAA,EAEtB,UAAWt7B,KAASq3B,EAAQ,MAAM8D,CAAU,EAAG,CAC7C,MAAMI,EAAgB,CAAA,EAChBnzB,EAAQ,CAAA,EACd,KAAO,CAACyyB,EAAqB,GAAI,CAC/B,MAAM9G,EAAS6G,EAAW,EACpBK,EAASlH,EAAO,IAAI,SAAS,KAAK,EACxC,GAAIwH,EAAcN,CAAM,EACtB,MAAM,IAAI,MACR,iEAEEj7B,EACA,QACAi7B,GAGNM,EAAcN,CAAM,EAAI,EACxB7yB,EAAM,KAAK2rB,CAAM,CACvB,CACIsH,EAAa,KAAKjzB,CAAK,CAC3B,CACE,UAAWpI,KAASq3B,EAAQ,MAAM+D,CAAW,EAAG,CAC9C,MAAMI,EAAiB,CAAA,EACjB5nB,EAAS,CAAA,EACf,KAAO,CAACinB,EAAqB,GAAI,CAC/B,MAAM9G,EAAS6G,EAAW,EACpBK,EAASlH,EAAO,IAAI,SAAS,KAAK,EACxC,GAAIyH,EAAeP,CAAM,EACvB,MAAM,IAAI,MACR,mEAEEj7B,EACA,QACAi7B,GAGNO,EAAeP,CAAM,EAAI,EACzBrnB,EAAO,KAAKmgB,CAAM,CACxB,CACIuH,EAAc,KAAK1nB,CAAM,CAC7B,CACE,OAAO6nB,EAAgB9G,EAAY,CACjC,iBAAAoG,EACA,aAAAM,EACA,cAAAC,CACJ,CAAG,CACH,CACAhB,GAAA,eAAyBC,EACzB,SAASmB,EAAeh4B,EAAMi4B,EAAQC,EAAQ,CAC5C,GAAI,CAACD,EAAO,OAAO5mB,GAAO,KAAK,CAAC6mB,CAAM,CAAC,CAAC,EACtC,MAAM,IAAI,MACR,yBAAyBl4B,CAAI,SAASi4B,EAAO,SAAS,KAAK,CAAC,GAGlE,CACArB,GAAA,eAAyBoB,EACzB,SAASD,EACP9G,EACA,CAAE,iBAAAoG,EAAkB,aAAAM,EAAc,cAAAC,CAAa,EAC/C,CAEA,MAAMO,EAAY,CAChB,WAAAlH,GAEF,IAAImH,EAAU,EACd,UAAW/H,KAAUgH,EAGnB,OAAQhH,EAAO,IAAI,CAAC,EAAC,CACnB,KAAKD,EAAa,YAAY,YAM5B,GALA4H,EACE,SACA3H,EAAO,IACPD,EAAa,YAAY,aAEvBgI,EAAU,EACZ,MAAM,IAAI,MAAM,kDAAkD,EAEpEA,IACA,MACF,KAAKhI,EAAa,YAAY,YACxB+H,EAAU,aAAe,SAC3BA,EAAU,WAAa,CAAA,GAEzBA,EAAU,WAAW,KAAKzJ,EAAQ,QAAQ,WAAW,OAAO2B,CAAM,CAAC,EACnE,MACF,QAEO8H,EAAU,iBAAgBA,EAAU,eAAiB,CAAA,GAC1DA,EAAU,eAAe,KAAK9H,CAAM,CAC5C,CAGE,MAAMoH,EAAaE,EAAa,OAC1BD,EAAcE,EAAc,OAC5BlB,EAAS,CAAA,EACTC,EAAU,CAAA,EAEhB,UAAWr6B,KAASq3B,EAAQ,MAAM8D,CAAU,EAAG,CAC7C,MAAM/yB,EAAQ,CAAA,EACd,UAAW2rB,KAAUsH,EAAar7B,CAAK,EAErC,OADAoyB,EAAQ,OAAO,YAAY2B,CAAM,EACzBA,EAAO,IAAI,CAAC,EAAC,CACnB,KAAKD,EAAa,WAAW,iBAM3B,GALA4H,EACE,QACA3H,EAAO,IACPD,EAAa,WAAW,kBAEtB1rB,EAAM,iBAAmB,OAC3B,MAAM,IAAI,MACR,qDAGJA,EAAM,eAAiBgqB,EAAQ,OAAO,eAAe,OAAO2B,CAAM,EAClE,MACF,KAAKD,EAAa,WAAW,aAM3B,GALA4H,EACE,QACA3H,EAAO,IACPD,EAAa,WAAW,cAEtB1rB,EAAM,cAAgB,OACxB,MAAM,IAAI,MAAM,+CAA+C,EAEjEA,EAAM,YAAcgqB,EAAQ,OAAO,YAAY,OAAO2B,CAAM,EAC5D,MACF,KAAKD,EAAa,WAAW,YACvB1rB,EAAM,aAAe,SACvBA,EAAM,WAAa,CAAA,GAErBA,EAAM,WAAW,KAAKgqB,EAAQ,OAAO,WAAW,OAAO2B,CAAM,CAAC,EAC9D,MACF,KAAKD,EAAa,WAAW,aAM3B,GALA4H,EACE,QACA3H,EAAO,IACPD,EAAa,WAAW,cAEtB1rB,EAAM,cAAgB,OACxB,MAAM,IAAI,MAAM,+CAA+C,EAEjEA,EAAM,YAAcgqB,EAAQ,OAAO,YAAY,OAAO2B,CAAM,EAC5D,MACF,KAAKD,EAAa,WAAW,cAM3B,GALA4H,EACE,QACA3H,EAAO,IACPD,EAAa,WAAW,eAEtB1rB,EAAM,eAAiB,OACzB,MAAM,IAAI,MAAM,gDAAgD,EAElEA,EAAM,aAAegqB,EAAQ,OAAO,aAAa,OAAO2B,CAAM,EAC9D,MACF,KAAKD,EAAa,WAAW,eAM3B,GALA4H,EACE,QACA3H,EAAO,IACPD,EAAa,WAAW,gBAEtB1rB,EAAM,gBAAkB,OAC1B,MAAM,IAAI,MAAM,iDAAiD,EAEnEA,EAAM,cAAgBgqB,EAAQ,OAAO,cAAc,OAAO2B,CAAM,EAChE,MACF,KAAKD,EAAa,WAAW,iBACvB1rB,EAAM,kBAAoB,SAC5BA,EAAM,gBAAkB,CAAA,GAE1BA,EAAM,gBAAgB,KACpBgqB,EAAQ,OAAO,gBAAgB,OAAO2B,CAAM,GAE9C,MACF,KAAKD,EAAa,WAAW,gBAC3B4H,EACE,QACA3H,EAAO,IACPD,EAAa,WAAW,iBAE1B1rB,EAAM,eAAiBgqB,EAAQ,OAAO,eAAe,OAAO2B,CAAM,EAClE,MACF,KAAKD,EAAa,WAAW,oBAC3B4H,EACE,QACA3H,EAAO,IACPD,EAAa,WAAW,qBAE1B1rB,EAAM,mBAAqBgqB,EAAQ,OAAO,mBAAmB,OAC3D2B,GAEF,MACF,KAAKD,EAAa,WAAW,eAC3B4H,EACE,QACA3H,EAAO,IACPD,EAAa,WAAW,gBAE1B1rB,EAAM,cAAgBgqB,EAAQ,OAAO,cAAc,OAAO2B,CAAM,EAChE,MACF,KAAKD,EAAa,WAAW,YAC3B4H,EACE,QACA3H,EAAO,IACPD,EAAa,WAAW,aAE1B1rB,EAAM,UAAYgqB,EAAQ,OAAO,UAAU,OAAO2B,CAAM,EACxD,MACF,KAAKD,EAAa,WAAW,eACvB1rB,EAAM,eAAiB,SACzBA,EAAM,aAAe,CAAA,GAEvBA,EAAM,aAAa,KAAKgqB,EAAQ,OAAO,aAAa,OAAO2B,CAAM,CAAC,EAClE,MACF,KAAKD,EAAa,WAAW,gBACvB1rB,EAAM,gBAAkB,SAC1BA,EAAM,cAAgB,CAAA,GAExBA,EAAM,cAAc,KAAKgqB,EAAQ,OAAO,cAAc,OAAO2B,CAAM,CAAC,EACpE,MACF,KAAKD,EAAa,WAAW,qBACvB1rB,EAAM,qBAAuB,SAC/BA,EAAM,mBAAqB,CAAA,GAE7BA,EAAM,mBAAmB,KACvBgqB,EAAQ,OAAO,mBAAmB,OAAO2B,CAAM,GAEjD,MACF,KAAKD,EAAa,WAAW,iBAC3B4H,EACE,QACA3H,EAAO,IACPD,EAAa,WAAW,kBAE1B1rB,EAAM,eAAiBgqB,EAAQ,OAAO,eAAe,OAAO2B,CAAM,EAClE,MACF,KAAKD,EAAa,WAAW,gBAC3B4H,EACE,QACA3H,EAAO,IACPD,EAAa,WAAW,iBAE1B1rB,EAAM,cAAgBgqB,EAAQ,OAAO,cAAc,OAAO2B,CAAM,EAChE,MACF,QAEO3rB,EAAM,iBAAgBA,EAAM,eAAiB,CAAA,GAClDA,EAAM,eAAe,KAAK2rB,CAAM,CAC1C,CAEIqG,EAAO,KAAKhyB,CAAK,CACrB,CACE,UAAWpI,KAASq3B,EAAQ,MAAM+D,CAAW,EAAG,CAC9C,MAAMxnB,EAAS,CAAA,EACf,UAAWmgB,KAAUuH,EAAct7B,CAAK,EAEtC,OADAoyB,EAAQ,QAAQ,YAAY2B,CAAM,EAC1BA,EAAO,IAAI,CAAC,EAAC,CACnB,KAAKD,EAAa,YAAY,cAM5B,GALA4H,EACE,SACA3H,EAAO,IACPD,EAAa,YAAY,eAEvBlgB,EAAO,eAAiB,OAC1B,MAAM,IAAI,MAAM,iDAAiD,EAEnEA,EAAO,aAAewe,EAAQ,QAAQ,aAAa,OAAO2B,CAAM,EAChE,MACF,KAAKD,EAAa,YAAY,eAM5B,GALA4H,EACE,SACA3H,EAAO,IACPD,EAAa,YAAY,gBAEvBlgB,EAAO,gBAAkB,OAC3B,MAAM,IAAI,MAAM,kDAAkD,EAEpEA,EAAO,cAAgBwe,EAAQ,QAAQ,cAAc,OAAO2B,CAAM,EAClE,MACF,KAAKD,EAAa,YAAY,iBACxBlgB,EAAO,kBAAoB,SAC7BA,EAAO,gBAAkB,CAAA,GAE3BA,EAAO,gBAAgB,KACrBwe,EAAQ,QAAQ,gBAAgB,OAAO2B,CAAM,GAE/C,MACF,KAAKD,EAAa,YAAY,iBAC5B4H,EACE,SACA3H,EAAO,IACPD,EAAa,YAAY,kBAE3BlgB,EAAO,eAAiBwe,EAAQ,QAAQ,eAAe,OAAO2B,CAAM,EACpE,MACF,KAAKD,EAAa,YAAY,SAC5B4H,EACE,SACA3H,EAAO,IACPD,EAAa,YAAY,UAE3BlgB,EAAO,QAAUwe,EAAQ,QAAQ,QAAQ,OAAO2B,CAAM,EACtD,MACF,KAAKD,EAAa,YAAY,qBACxBlgB,EAAO,qBAAuB,SAChCA,EAAO,mBAAqB,CAAA,GAE9BA,EAAO,mBAAmB,KACxBwe,EAAQ,QAAQ,mBAAmB,OAAO2B,CAAM,GAElD,MACF,QACOngB,EAAO,iBAAgBA,EAAO,eAAiB,CAAA,GACpDA,EAAO,eAAe,KAAKmgB,CAAM,CAC3C,CAEIsG,EAAQ,KAAKzmB,CAAM,CACvB,CACE,MAAO,CAAE,UAAAioB,EAAW,OAAAzB,EAAQ,QAAAC,CAAO,CACrC,CACA,OAAAC,GAAA,gBAA0BmB,qDC1Y1B,OAAO,eAAeM,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAM3J,EAAU7yB,GAAA,EACV83B,EAAU3Y,GAAA,EAChB,SAASsd,EAAa,CAAE,UAAAH,EAAW,OAAAzB,EAAQ,QAAAC,CAAO,EAAI,CACpD,KAAM,CAAE,cAAA4B,EAAe,aAAAZ,EAAc,cAAAC,CAAa,EAAKY,EAAc,CACnE,UAAAL,EACA,OAAAzB,EACA,QAAAC,CACJ,CAAG,EACK8B,EAAe9E,EAAQ,gBAAgB4E,CAAa,EACpDG,EAAyB1F,GAC7BA,EAAQ,SAAW,EACf,CAAC3hB,GAAO,KAAK,CAAC,CAAC,CAAC,CAAC,EACjB2hB,EAAQ,IAAIW,EAAQ,eAAe,EACnCgF,EAAeD,EAAuBf,CAAY,EAClDiB,EAAgBF,EAAuBd,CAAa,EACpDiB,EAASxnB,GAAO,YAAY,CAAC,EACnC,OAAAwnB,EAAO,YAAY,aAAc,EAAG,CAAC,EAC9BxnB,GAAO,OACZ,CAACwnB,EAAQJ,CAAY,EAAE,OAAOE,EAAcC,CAAa,EAE7D,CACAP,GAAA,aAAuBC,EACvB,MAAMQ,EAAc,CAAC5/B,EAAGC,IACfD,EAAE,IAAI,QAAQC,EAAE,GAAG,EAE5B,SAAS4/B,EAAeC,EAAWC,EAAkB,CACnD,MAAMC,EAAY,IAAI,IAChBlG,EAAU,OAAO,QAAQgG,CAAS,EAAE,OAAO,CAACn8B,EAAQ,CAACL,EAAKyF,CAAK,IAAM,CACzE,GAAIzF,IAAQ,iBAAkB,OAAOK,EAGrC,MAAMy4B,EAAY2D,EAAiBz8B,CAAG,EACtC,GAAI84B,IAAc,OAAW,OAAOz4B,EACpC,MAAMs8B,GAAkB,MAAM,QAAQl3B,CAAK,EAAIA,EAAQ,CAACA,CAAK,GAAG,IAC9DqzB,EAAU,QAGZ,OADiB6D,EAAe,IAAIC,GAAMA,EAAG,IAAI,SAAS,KAAK,CAAC,EACvD,QAAQhZ,GAAO,CACtB,GAAI8Y,EAAU,IAAI9Y,CAAG,EACnB,MAAM,IAAI,MAAM,mCAAqCA,CAAG,EAC1D8Y,EAAU,IAAI9Y,CAAG,CACvB,CAAK,EACMvjB,EAAO,OAAOs8B,CAAc,CACvC,EAAK,CAAA,CAAE,EAECE,EAAeL,EAAU,eAC3BA,EAAU,eAAe,OAAO3I,GACvB,CAAC6I,EAAU,IAAI7I,EAAO,IAAI,SAAS,KAAK,CAAC,CACjD,EACD,CAAA,EACJ,OAAO2C,EAAQ,OAAOqG,CAAY,EAAE,KAAKP,CAAW,CACtD,CACA,SAASN,EAAc,CAAE,UAAAL,EAAW,OAAAzB,EAAQ,QAAAC,CAAO,EAAI,CAGrD,MAAO,CACL,cAAeoC,EAAeZ,EAAWzJ,EAAQ,OAAO,EACxD,aAAcgI,EAAO,IAAIx3B,GAAK65B,EAAe75B,EAAGwvB,EAAQ,MAAM,CAAC,EAC/D,cAAeiI,EAAQ,IAAI2C,GAAKP,EAAeO,EAAG5K,EAAQ,OAAO,CAAC,EAEtE,CACA,OAAA2J,GAAA,cAAwBG,wDC9DxB,SAASe,EAAS5/B,EAAG,CACnB,QAASM,KAAKN,EAAQK,EAAQ,eAAeC,CAAC,IAAGD,EAAQC,CAAC,EAAIN,EAAEM,CAAC,EACnE,CACA,OAAO,eAAcD,EAAU,aAAc,CAAE,MAAO,GAAM,EAC5Du/B,EAAS19B,IAAuB,EAChC09B,EAASve,IAAqB,sDCL9B,OAAO,eAAewe,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMC,EAAW59B,GAAA,EACjB,SAAS69B,EAAQC,EAAO,CACtB,MAAMC,EAAOD,EAAM,CAAC,EACdE,EAAcJ,EAAS,cAAcG,CAAI,EACzCE,EAASH,EAAM,MAAM,CAAC,EAC5B,GAAIG,EAAO,SAAW,EAAG,MAAM,IAAI,MAAM,6BAA6B,EACtE,MAAMC,EAASC,EAAMJ,CAAI,EACzB,GAAIG,IAAW,OACb,MAAM,IAAI,MAAM,mCAAmC,EAErD,MAAME,EAAgBC,EAAUL,EAAY,aAAa,EACnDM,EAAgBN,EAAY,aAAa,IAAIK,CAAS,EACtDE,EAAiBP,EAAY,cAAc,IAAIK,CAAS,EAC9D,UAAWG,KAASP,EAAQ,CAC1B,MAAMQ,EAAUN,EAAMK,CAAK,EAC3B,GACEC,IAAY,QACZ,CAACA,EAAQ,SAAQ,EAAG,OAAOP,EAAO,SAAQ,CAAE,EAE5C,MAAM,IAAI,MACR,iEAGJ,MAAMV,EAAeI,EAAS,cAAcY,CAAK,EAC1BH,EAAUb,EAAa,aAAa,EAC5C,QACbkB,EACEN,EACAJ,EAAY,cACZR,EAAa,gBAGMA,EAAa,aAAa,IAAIa,CAAS,EAC/C,QAAQ,CAACM,EAAUl2B,IAChCk2B,EAAS,QACPD,EACEJ,EAAc71B,CAAG,EACjBu1B,EAAY,aAAav1B,CAAG,EAC5B+0B,EAAa,aAAa/0B,CAAG,KAIX+0B,EAAa,cAAc,IAAIa,CAAS,EAChD,QAAQ,CAACO,EAAWn2B,IAClCm2B,EAAU,QACRF,EACEH,EAAe91B,CAAG,EAClBu1B,EAAY,cAAcv1B,CAAG,EAC7B+0B,EAAa,cAAc/0B,CAAG,IAIxC,CACE,OAAOm1B,EAAS,gBAAgBM,EAAQ,CACtC,iBAAkBF,EAAY,cAC9B,aAAcA,EAAY,aAC1B,cAAeA,EAAY,aAC/B,CAAG,CACH,CACAL,GAAA,QAAkBE,EAClB,SAASa,EAAUG,EAASb,EAAaR,EAAc,CACrD,OAAO78B,GAAO,CACZ,GAAIk+B,EAAQ,IAAIl+B,CAAG,EAAG,OACtB,MAAMm+B,EAAQtB,EAAa,OAAOD,GAAMA,EAAG,IAAI,SAAS,KAAK,IAAM58B,CAAG,EAAE,CAAC,EACzEq9B,EAAY,KAAKc,CAAK,EACtBD,EAAQ,IAAIl+B,CAAG,CACnB,CACA,CACA,SAASw9B,EAAMY,EAAM,CACnB,OAAOA,EAAK,UAAU,UACxB,CACA,SAASV,EAAUlH,EAAS,CAC1B,MAAMhtB,EAAM,IAAI,IAChB,OAAAgtB,EAAQ,QAAQ3C,GAAU,CACxB,MAAMjQ,EAAMiQ,EAAO,IAAI,SAAS,KAAK,EACrC,GAAIrqB,EAAI,IAAIoa,CAAG,EACb,MAAM,IAAI,MAAM,6CAA6C,EAC/Dpa,EAAI,IAAIoa,CAAG,CACf,CAAG,EACMpa,CACT,oECjFA,OAAO,eAAchM,EAAU,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMs7B,EAAYz5B,GAAA,EAClB,SAASg/B,EAAcnE,EAAQoE,EAAY,CACzC,MAAMp2B,EAAQgyB,EAAOoE,CAAU,EAC/B,GAAIp2B,IAAU,OAAW,MAAM,IAAI,MAAM,aAAao2B,CAAU,EAAE,EAClE,OAAOp2B,CACT,CACA1K,EAAA,cAAwB6gC,EACxB,SAASE,EAAepE,EAASqE,EAAa,CAC5C,MAAM9qB,EAASymB,EAAQqE,CAAW,EAClC,GAAI9qB,IAAW,OAAW,MAAM,IAAI,MAAM,cAAc8qB,CAAW,EAAE,EACrE,OAAO9qB,CACT,CACAlW,EAAA,eAAyB+gC,EACzB,SAASE,EAAYC,EAAalI,EAASmI,EAAY,CACrD,GAAID,EAAY,IAAI,CAAC,EAAIC,EACvB,MAAM,IAAI,MACR,qEAGJ,GACEnI,GACAA,EAAQ,OAAOoG,GAAMA,EAAG,IAAI,OAAO8B,EAAY,GAAG,CAAC,EAAE,SAAW,EAEhE,MAAM,IAAI,MAAM,kBAAkBA,EAAY,IAAI,SAAS,KAAK,CAAC,EAAE,CAEvE,CACAlhC,EAAA,YAAsBihC,EACtB,SAASG,EAAcC,EAAQ,CAC7B,IAAIz+B,EAAQ,EACZ,cAAO,KAAKy+B,CAAM,EAAE,QAAQ5mB,GAAO,CAC7B,OAAO,MAAM,OAAOA,CAAG,CAAC,CAAC,GAC3B7X,GAEN,CAAG,EACMA,CACT,CACA5C,EAAA,cAAwBohC,EACxB,SAASE,EAA2BR,EAAYp2B,EAAO,CACrD,IAAI7H,EAAS,GACb,GAAI6H,EAAM,gBAAkBA,EAAM,YAAa,CAC7C,MAAM62B,EAAgB,CAAC,CAAC72B,EAAM,aACxB82B,EAAoB,CAAC,CAAC92B,EAAM,cAC5B+2B,EAAc,CAACF,GAAiB,CAAC,CAAC72B,EAAM,eACxCg3B,EAAkB,CAACF,GAAqB,CAAC,CAAC92B,EAAM,mBAChDi3B,EAAc,CAAC,CAACj3B,EAAM,gBAAkB,CAAC,CAACA,EAAM,mBACtD7H,EAAS4+B,GAAeC,GAAmBC,CAC/C,CACE,GAAI9+B,IAAW,GACb,MAAM,IAAI,MACR,UAAUi+B,CAAU,4CAG1B,CACA9gC,EAAA,2BAAqCshC,EACrC,SAASM,EAAoBjiB,EAAU7Z,EAAM8a,EAAU7a,EAAM,CAC3D,MAAM,IAAI,MACR,YAAY4Z,CAAQ,QAAQ7Z,CAAI,2BAC3B8a,CAAQ,YAAY,KAAK,UAAU7a,CAAI,CAAC,GAEjD,CACA,SAAS87B,EAAYliB,EAAU,CAC7B,MAAO,CAACmiB,EAAYC,IAAa,CAC/B,UAAWj8B,KAAQ,OAAO,KAAKg8B,CAAU,EAAG,CAE1C,MAAM/7B,EAAO+7B,EAAWh8B,CAAI,EAEtB,CAAE,OAAAqxB,EAAQ,cAAAN,EAAe,MAAAH,EAAO,SAAA9V,CAAQ,EAE5C0a,EAAU3b,EAAW,GAAG,EAAE7Z,CAAI,GAAK,CAAA,EAC/Bk8B,EAAU,CAAC,CAACnL,EAElB,GAAIH,EACF,GAAIsL,EAAS,CACX,GACE,CAAC,MAAM,QAAQj8B,CAAI,GAElBg8B,EAASj8B,CAAI,GAAK,CAAC,MAAM,QAAQi8B,EAASj8B,CAAI,CAAC,EAEhD,MAAM,IAAI,MAAM,YAAYA,CAAI,mBAAmB,EAEhDC,EAAK,MAAM2wB,CAAK,GACnBkL,EAAoBjiB,EAAU7Z,EAAM8a,EAAU7a,CAAI,EAGpD,MAAM6P,EAAMmsB,EAASj8B,CAAI,GAAK,CAAA,EACxBm8B,EAAe,IAAI,IACzB,GAAI,CAACl8B,EAAK,MAAM0uB,GAAKoC,EAAcjhB,EAAK6e,EAAGwN,CAAY,CAAC,EACtD,MAAM,IAAI,MAAM,qCAAqC,EAGvDF,EAASj8B,CAAI,EAAI8P,EAAI,OAAO7P,CAAI,CAC1C,KAAe,CAIL,GAHK2wB,EAAM3wB,CAAI,GACb67B,EAAoBjiB,EAAU7Z,EAAM8a,EAAU7a,CAAI,EAEhD,CAACoxB,EAAO4K,EAAUh8B,CAAI,EACxB,MAAM,IAAI,MAAM,iCAAiC4Z,CAAQ,EAAE,EAG7DoiB,EAASj8B,CAAI,EAAIC,CAC3B,CAEA,CACA,CACA,CACA/F,EAAA,aAAuB6hC,EAAY,QAAQ,EAC3C7hC,EAAA,YAAsB6hC,EAAY,OAAO,EACzC7hC,EAAA,aAAuB6hC,EAAY,QAAQ,EAC3C,SAASK,EAAmBxF,EAAQ32B,EAAM,CACxC,MAAMzD,EAAQo6B,EAAO,OAAS,EACxBhyB,EAAQm2B,EAAcnE,EAAQp6B,CAAK,EACzCtC,EAAQ,YAAY+F,EAAM2E,CAAK,CACjC,CACA1K,EAAA,mBAA6BkiC,EAC7B,SAASC,EAAoBxF,EAAS52B,EAAM,CAC1C,MAAMzD,EAAQq6B,EAAQ,OAAS,EACzBzmB,EAAS6qB,EAAepE,EAASr6B,CAAK,EAC5CtC,EAAQ,aAAa+F,EAAMmQ,CAAM,CACnC,CACAlW,EAAA,oBAA8BmiC,EAC9B,SAASC,EAAqBC,EAASC,EAAO,CAC5C,GAAI,CAACjrB,GAAO,SAASirB,CAAK,GAAKA,EAAM,OAAS,EAC5C,MAAM,IAAI,MAAM,kCAAkC,EAEpD,OAAAA,EAAM,cAAcD,EAAS,CAAC,EACvBC,CACT,CACAtiC,EAAA,qBAA+BoiC,EAC/B,SAASG,EAAsBC,EAAUF,EAAO,CAC9C,GAAI,CAACjrB,GAAO,SAASirB,CAAK,GAAKA,EAAM,OAAS,EAC5C,MAAM,IAAI,MAAM,mCAAmC,EAErD,OAAAA,EAAM,cAAcE,EAAUF,EAAM,OAAS,CAAC,EACvCA,CACT,CACAtiC,EAAA,sBAAgCuiC,sDCxIhC,OAAO,eAAe3B,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAM6B,EAAa5gC,GAAA,EACb49B,EAAWze,GAAA,EACXoV,EAAevS,GAAA,EACf6e,EAAUnH,GAAA,EAChB,MAAMoH,CAAK,CACT,YAAYC,EAAI,CACd,KAAK,OAAS,CAAA,EACd,KAAK,QAAU,CAAA,EACf,KAAK,UAAY,CACf,WAAYA,EAElB,CACE,OAAO,WAAW78B,EAAM88B,EAAc,CACpC,MAAM5+B,EAASoT,GAAO,KAAKtR,EAAM,QAAQ,EACzC,OAAO,KAAK,WAAW9B,EAAQ4+B,CAAY,CAC/C,CACE,OAAO,QAAQ98B,EAAM88B,EAAc,CACjC,MAAM5+B,EAASoT,GAAO,KAAKtR,EAAM,KAAK,EACtC,OAAO,KAAK,WAAW9B,EAAQ4+B,CAAY,CAC/C,CACE,OAAO,WAAW5+B,EAAQ4+B,EAAc,CACtC,MAAMC,EAAUrD,EAAS,eAAex7B,EAAQ4+B,CAAY,EACtDjC,EAAO,IAAI,KAAKkC,EAAQ,UAAU,UAAU,EAClD,cAAO,OAAOlC,EAAMkC,CAAO,EACpBlC,CACX,CACE,UAAW,CAET,OADe,KAAK,SAAQ,EACd,SAAS,QAAQ,CACnC,CACE,OAAQ,CAEN,OADe,KAAK,SAAQ,EACd,SAAS,KAAK,CAChC,CACE,UAAW,CACT,OAAOnB,EAAS,aAAa,IAAI,CACrC,CACE,aAAaqC,EAAY,CACvB,OAAAY,EAAQ,aAAaZ,EAAY,KAAK,SAAS,EACxC,IACX,CACE,YAAYhB,EAAYgB,EAAY,CAClC,MAAMp3B,EAAQg4B,EAAQ,cAAc,KAAK,OAAQ5B,CAAU,EAC3D,OAAA4B,EAAQ,YAAYZ,EAAYp3B,CAAK,EAC9B,IACX,CACE,aAAas2B,EAAac,EAAY,CACpC,MAAM5rB,EAASwsB,EAAQ,eAAe,KAAK,QAAS1B,CAAW,EAC/D,OAAA0B,EAAQ,aAAaZ,EAAY5rB,CAAM,EAChC,IACX,CACE,yBAAyBmgB,EAAQ,CAC/B,OAAAqM,EAAQ,YACNrM,EACA,KAAK,UAAU,eACfqM,EAAQ,cAActM,EAAa,WAAW,GAE3C,KAAK,UAAU,iBAAgB,KAAK,UAAU,eAAiB,CAAA,GACpE,KAAK,UAAU,eAAe,KAAKC,CAAM,EAClC,IACX,CACE,wBAAwByK,EAAYzK,EAAQ,CAC1C,MAAM3rB,EAAQg4B,EAAQ,cAAc,KAAK,OAAQ5B,CAAU,EAC3D,OAAA4B,EAAQ,YACNrM,EACA3rB,EAAM,eACNg4B,EAAQ,cAActM,EAAa,UAAU,GAE1C1rB,EAAM,iBAAgBA,EAAM,eAAiB,CAAA,GAClDA,EAAM,eAAe,KAAK2rB,CAAM,EACzB,IACX,CACE,yBAAyB2K,EAAa3K,EAAQ,CAC5C,MAAMngB,EAASwsB,EAAQ,eAAe,KAAK,QAAS1B,CAAW,EAC/D,OAAA0B,EAAQ,YACNrM,EACAngB,EAAO,eACPwsB,EAAQ,cAActM,EAAa,WAAW,GAE3ClgB,EAAO,iBAAgBA,EAAO,eAAiB,CAAA,GACpDA,EAAO,eAAe,KAAKmgB,CAAM,EAC1B,IACX,CACE,SAAS0M,EAAW,CAClB,KAAK,UAAU,WAAW,SAASA,CAAS,EAC5C,KAAK,OAAO,KAAK,CACf,eAAgB,CAAA,CACtB,CAAK,EACD,MAAMC,EAAaD,EAAU,gBAAkB,CAAA,EACzCjC,EAAa,KAAK,OAAO,OAAS,EACxC,GAAI,CAAC,MAAM,QAAQkC,CAAU,EAC3B,MAAM,IAAI,MAAM,iCAAiC,EAEnD,OAAAA,EAAW,QAAQ3M,GACjB,KAAK,wBAAwByK,EAAYzK,CAAM,GAEjDqM,EAAQ,mBAAmB,KAAK,OAAQK,CAAS,EAC1C,IACX,CACE,UAAUE,EAAY,CACpB,KAAK,UAAU,WAAW,UAAUA,CAAU,EAC9C,KAAK,QAAQ,KAAK,CAChB,eAAgB,CAAA,CACtB,CAAK,EACD,MAAMD,EAAaC,EAAW,gBAAkB,CAAA,EAC1CjC,EAAc,KAAK,QAAQ,OAAS,EAC1C,GAAI,CAAC,MAAM,QAAQgC,CAAU,EAC3B,MAAM,IAAI,MAAM,iCAAiC,EAEnD,OAAAA,EAAW,QAAQ3M,GACjB,KAAK,yBAAyB2K,EAAa3K,CAAM,GAEnDqM,EAAQ,oBAAoB,KAAK,QAASO,CAAU,EAC7C,IACX,CACE,oBAAoBnC,EAAY,CAC9B,MAAMp2B,EAAQg4B,EAAQ,cAAc,KAAK,OAAQ5B,CAAU,EAC3D4B,EAAQ,2BAA2B5B,EAAYp2B,CAAK,EACpD,UAAWlI,KAAO,OAAO,KAAKkI,CAAK,EAE9B,CACC,cACA,iBACA,iBACA,qBACA,kBACA,SAASlI,CAAG,GAGd,OAAOkI,EAAMlI,CAAG,EAGpB,OAAO,IACX,CACE,WAAW0gC,EAAO,CAGhB,MAAMrgC,EAAS4/B,EAAW,QAAQ,CAAC,IAAI,EAAE,OAAOS,CAAK,CAAC,EACtD,cAAO,OAAO,KAAMrgC,CAAM,EACnB,IACX,CACE,gBAAiB,CACf,OAAO,KAAK,UAAU,WAAW,SAAQ,CAC7C,CACA,CACA,OAAA+9B,GAAA,KAAe+B,KC/If,sEASO,SAAS3e,GAAQ9kB,EAAG,CACvB,OAAOA,aAAa,YAAe,YAAY,OAAOA,CAAC,GAAKA,EAAE,YAAY,OAAS,YACvF,CAEO,SAAS+kB,GAAQpkB,EAAG,CACvB,GAAI,CAAC,OAAO,cAAcA,CAAC,GAAKA,EAAI,EAChC,MAAM,IAAI,MAAM,kCAAoCA,CAAC,CAC7D,CAEO,SAASqkB,GAAO/kB,KAAMwmB,EAAS,CAClC,GAAI,CAAC3B,GAAQ7kB,CAAC,EACV,MAAM,IAAI,MAAM,qBAAqB,EACzC,GAAIwmB,EAAQ,OAAS,GAAK,CAACA,EAAQ,SAASxmB,EAAE,MAAM,EAChD,MAAM,IAAI,MAAM,iCAAmCwmB,EAAU,gBAAkBxmB,EAAE,MAAM,CAC/F,CAEO,SAASglB,GAAM3kB,EAAG,CACrB,GAAI,OAAOA,GAAM,YAAc,OAAOA,EAAE,QAAW,WAC/C,MAAM,IAAI,MAAM,8CAA8C,EAClEykB,GAAQzkB,EAAE,SAAS,EACnBykB,GAAQzkB,EAAE,QAAQ,CACtB,CAEO,SAAS4kB,GAAQwB,EAAUC,EAAgB,GAAM,CACpD,GAAID,EAAS,UACT,MAAM,IAAI,MAAM,kCAAkC,EACtD,GAAIC,GAAiBD,EAAS,SAC1B,MAAM,IAAI,MAAM,uCAAuC,CAC/D,CAEO,SAASvB,GAAQ5H,EAAKmJ,EAAU,CACnC1B,GAAOzH,CAAG,EACV,MAAMgB,EAAMmI,EAAS,UACrB,GAAInJ,EAAI,OAASgB,EACb,MAAM,IAAI,MAAM,yDAA2DA,CAAG,CAEtF,CAUO,SAAS+G,MAASsB,EAAQ,CAC7B,QAAS5gB,EAAI,EAAGA,EAAI4gB,EAAO,OAAQ5gB,IAC/B4gB,EAAO5gB,CAAC,EAAE,KAAK,CAAC,CAExB,CAEO,SAASuf,GAAW7O,EAAK,CAC5B,OAAO,IAAI,SAASA,EAAI,OAAQA,EAAI,WAAYA,EAAI,UAAU,CAClE,CAEO,SAAS8O,GAAKqB,EAAMC,EAAO,CAC9B,OAAQD,GAAS,GAAKC,EAAWD,IAASC,CAC9C,CAEO,SAASrB,GAAKoB,EAAMC,EAAO,CAC9B,OAAQD,GAAQC,EAAWD,IAAU,GAAKC,IAAY,CAC1D,CA4GO,SAAStM,GAAY5S,EAAK,CAC7B,GAAI,OAAOA,GAAQ,SACf,MAAM,IAAI,MAAM,iBAAiB,EACrC,OAAO,IAAI,WAAW,IAAI,YAAW,EAAG,OAAOA,CAAG,CAAC,CACvD,CAaO,SAASoe,GAAQnf,EAAM,CAC1B,OAAI,OAAOA,GAAS,WAChBA,EAAO2T,GAAY3T,CAAI,GAC3Bme,GAAOne,CAAI,EACJA,CACX,CAkCO,MAAMwhB,EAAK,CAClB,CAEO,SAASjC,GAAakC,EAAU,CACnC,MAAMC,EAAS/I,GAAQ8I,EAAQ,EAAG,OAAOtC,GAAQxG,CAAG,CAAC,EAAE,OAAM,EACvDxN,EAAMsW,EAAQ,EACpB,OAAAC,EAAM,UAAYvW,EAAI,UACtBuW,EAAM,SAAWvW,EAAI,SACrBuW,EAAM,OAAS,IAAMD,EAAQ,EACtBC,CACX,CCpPO,MAAM0b,WAAa5b,EAAK,CAC3B,YAAY6b,EAAMC,EAAM,CACpB,MAAK,EACL,KAAK,SAAW,GAChB,KAAK,UAAY,GACjBlf,GAAMif,CAAI,EACV,MAAM5gC,EAAM0iB,GAAQme,CAAI,EAExB,GADA,KAAK,MAAQD,EAAK,OAAM,EACpB,OAAO,KAAK,MAAM,QAAW,WAC7B,MAAM,IAAI,MAAM,qDAAqD,EACzE,KAAK,SAAW,KAAK,MAAM,SAC3B,KAAK,UAAY,KAAK,MAAM,UAC5B,MAAM9a,EAAW,KAAK,SAChBlB,EAAM,IAAI,WAAWkB,CAAQ,EAEnClB,EAAI,IAAI5kB,EAAI,OAAS8lB,EAAW8a,EAAK,OAAM,EAAG,OAAO5gC,CAAG,EAAE,OAAM,EAAKA,CAAG,EACxE,QAAS,EAAI,EAAG,EAAI4kB,EAAI,OAAQ,IAC5BA,EAAI,CAAC,GAAK,GACd,KAAK,MAAM,OAAOA,CAAG,EAErB,KAAK,MAAQgc,EAAK,OAAM,EAExB,QAAS,EAAI,EAAG,EAAIhc,EAAI,OAAQ,IAC5BA,EAAI,CAAC,GAAK,IACd,KAAK,MAAM,OAAOA,CAAG,EACrB5C,GAAM4C,CAAG,CACb,CACA,OAAOtP,EAAK,CACR,OAAAsM,GAAQ,IAAI,EACZ,KAAK,MAAM,OAAOtM,CAAG,EACd,IACX,CACA,WAAW2E,EAAK,CACZ2H,GAAQ,IAAI,EACZF,GAAOzH,EAAK,KAAK,SAAS,EAC1B,KAAK,SAAW,GAChB,KAAK,MAAM,WAAWA,CAAG,EACzB,KAAK,MAAM,OAAOA,CAAG,EACrB,KAAK,MAAM,WAAWA,CAAG,EACzB,KAAK,QAAO,CAChB,CACA,QAAS,CACL,MAAMA,EAAM,IAAI,WAAW,KAAK,MAAM,SAAS,EAC/C,YAAK,WAAWA,CAAG,EACZA,CACX,CACA,WAAWoM,EAAI,CAEXA,IAAOA,EAAK,OAAO,OAAO,OAAO,eAAe,IAAI,EAAG,CAAA,CAAE,GACzD,KAAM,CAAE,MAAAya,EAAO,MAAAC,EAAO,SAAAza,EAAU,UAAAC,EAAW,SAAAT,EAAU,UAAAC,CAAS,EAAK,KACnE,OAAAM,EAAKA,EACLA,EAAG,SAAWC,EACdD,EAAG,UAAYE,EACfF,EAAG,SAAWP,EACdO,EAAG,UAAYN,EACfM,EAAG,MAAQya,EAAM,WAAWza,EAAG,KAAK,EACpCA,EAAG,MAAQ0a,EAAM,WAAW1a,EAAG,KAAK,EAC7BA,CACX,CACA,OAAQ,CACJ,OAAO,KAAK,WAAU,CAC1B,CACA,SAAU,CACN,KAAK,UAAY,GACjB,KAAK,MAAM,QAAO,EAClB,KAAK,MAAM,QAAO,CACtB,CACJ,CAWO,MAAM2a,GAAO,CAACJ,EAAM5gC,EAAKoB,IAAY,IAAIu/B,GAAKC,EAAM5gC,CAAG,EAAE,OAAOoB,CAAO,EAAE,OAAM,EACtF4/B,GAAK,OAAS,CAACJ,EAAM5gC,IAAQ,IAAI2gC,GAAKC,EAAM5gC,CAAG,EC9ExC,SAASolB,GAAaI,EAAM5O,EAAYnR,EAAOwO,EAAM,CACxD,GAAI,OAAOuR,EAAK,cAAiB,WAC7B,OAAOA,EAAK,aAAa5O,EAAYnR,EAAOwO,CAAI,EACpD,MAAMwR,EAAO,OAAO,EAAE,EAChBC,EAAW,OAAO,UAAU,EAC5BC,EAAK,OAAQlgB,GAASggB,EAAQC,CAAQ,EACtCE,EAAK,OAAOngB,EAAQigB,CAAQ,EAC5B1oB,EAAIiX,EAAO,EAAI,EACf1W,EAAI0W,EAAO,EAAI,EACrBuR,EAAK,UAAU5O,EAAa5Z,EAAG2oB,EAAI1R,CAAI,EACvCuR,EAAK,UAAU5O,EAAarZ,EAAGqoB,EAAI3R,CAAI,CAC3C,CAEO,SAASoR,GAAI3oB,EAAGC,EAAGC,EAAG,CACzB,OAAQF,EAAIC,EAAM,CAACD,EAAIE,CAC3B,CAEO,SAAS0oB,GAAI5oB,EAAGC,EAAGC,EAAG,CACzB,OAAQF,EAAIC,EAAMD,EAAIE,EAAMD,EAAIC,CACpC,CAKO,MAAMipB,WAAed,EAAK,CAC7B,YAAYe,EAAUC,EAAWC,EAAW/R,EAAM,CAC9C,MAAK,EACL,KAAK,SAAW,GAChB,KAAK,OAAS,EACd,KAAK,IAAM,EACX,KAAK,UAAY,GACjB,KAAK,SAAW6R,EAChB,KAAK,UAAYC,EACjB,KAAK,UAAYC,EACjB,KAAK,KAAO/R,EACZ,KAAK,OAAS,IAAI,WAAW6R,CAAQ,EACrC,KAAK,KAAO7D,GAAW,KAAK,MAAM,CACtC,CACA,OAAO1e,EAAM,CACTqe,GAAQ,IAAI,EACZre,EAAOmf,GAAQnf,CAAI,EACnBme,GAAOne,CAAI,EACX,KAAM,CAAE,KAAAiiB,EAAM,OAAA/jB,EAAQ,SAAAqkB,CAAQ,EAAK,KAC7BjT,EAAMtP,EAAK,OACjB,QAASwT,EAAM,EAAGA,EAAMlE,GAAM,CAC1B,MAAMoT,EAAO,KAAK,IAAIH,EAAW,KAAK,IAAKjT,EAAMkE,CAAG,EAEpD,GAAIkP,IAASH,EAAU,CACnB,MAAMI,EAAWjE,GAAW1e,CAAI,EAChC,KAAOuiB,GAAYjT,EAAMkE,EAAKA,GAAO+O,EACjC,KAAK,QAAQI,EAAUnP,CAAG,EAC9B,QACJ,CACAtV,EAAO,IAAI8B,EAAK,SAASwT,EAAKA,EAAMkP,CAAI,EAAG,KAAK,GAAG,EACnD,KAAK,KAAOA,EACZlP,GAAOkP,EACH,KAAK,MAAQH,IACb,KAAK,QAAQN,EAAM,CAAC,EACpB,KAAK,IAAM,EAEnB,CACA,YAAK,QAAUjiB,EAAK,OACpB,KAAK,WAAU,EACR,IACX,CACA,WAAW0W,EAAK,CACZ2H,GAAQ,IAAI,EACZC,GAAQ5H,EAAK,IAAI,EACjB,KAAK,SAAW,GAIhB,KAAM,CAAE,OAAAxY,EAAQ,KAAA+jB,EAAM,SAAAM,EAAU,KAAA7R,CAAI,EAAK,KACzC,GAAI,CAAE,IAAA8C,CAAG,EAAK,KAEdtV,EAAOsV,GAAK,EAAI,IAChBiL,GAAM,KAAK,OAAO,SAASjL,CAAG,CAAC,EAG3B,KAAK,UAAY+O,EAAW/O,IAC5B,KAAK,QAAQyO,EAAM,CAAC,EACpBzO,EAAM,GAGV,QAASrU,EAAIqU,EAAKrU,EAAIojB,EAAUpjB,IAC5BjB,EAAOiB,CAAC,EAAI,EAIhB0iB,GAAaI,EAAMM,EAAW,EAAG,OAAO,KAAK,OAAS,CAAC,EAAG7R,CAAI,EAC9D,KAAK,QAAQuR,EAAM,CAAC,EACpB,MAAMW,EAAQlE,GAAWhI,CAAG,EACtBpH,EAAM,KAAK,UAEjB,GAAIA,EAAM,EACN,MAAM,IAAI,MAAM,6CAA6C,EACjE,MAAMuT,EAASvT,EAAM,EACftH,EAAQ,KAAK,IAAG,EACtB,GAAI6a,EAAS7a,EAAM,OACf,MAAM,IAAI,MAAM,oCAAoC,EACxD,QAAS7I,EAAI,EAAGA,EAAI0jB,EAAQ1jB,IACxByjB,EAAM,UAAU,EAAIzjB,EAAG6I,EAAM7I,CAAC,EAAGuR,CAAI,CAC7C,CACA,QAAS,CACL,KAAM,CAAE,OAAAxS,EAAQ,UAAAskB,CAAS,EAAK,KAC9B,KAAK,WAAWtkB,CAAM,EACtB,MAAM0E,EAAM1E,EAAO,MAAM,EAAGskB,CAAS,EACrC,YAAK,QAAO,EACL5f,CACX,CACA,WAAWkgB,EAAI,CACXA,IAAOA,EAAK,IAAI,KAAK,aACrBA,EAAG,IAAI,GAAG,KAAK,IAAG,CAAE,EACpB,KAAM,CAAE,SAAAP,EAAU,OAAArkB,EAAQ,OAAA1B,EAAQ,SAAAumB,EAAU,UAAAC,EAAW,IAAAxP,CAAG,EAAK,KAC/D,OAAAsP,EAAG,UAAYE,EACfF,EAAG,SAAWC,EACdD,EAAG,OAAStmB,EACZsmB,EAAG,IAAMtP,EACLhX,EAAS+lB,GACTO,EAAG,OAAO,IAAI5kB,CAAM,EACjB4kB,CACX,CACA,OAAQ,CACJ,OAAO,KAAK,WAAU,CAC1B,CACJ,CAMO,MAAM4a,GAA4B,YAAY,KAAK,CACtD,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UACxF,CAAC,EAWYC,GAA4B,YAAY,KAAK,CACtD,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WACpF,WAAY,WAAY,WAAY,UAAY,UAAY,WAAY,WAAY,SACxF,CAAC,ECqBKja,GAAyB,WAAW,KAAK,CAC3C,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,CACvD,CAAC,EACKC,GAA+B,WAAW,KAAK,IAAI,MAAM,EAAE,EAAE,KAAK,CAAC,EAAE,IAAI,CAACvD,EAAGjhB,IAAMA,CAAC,CAAC,EACrFykB,GAA+BD,GAAM,IAAKxkB,IAAO,EAAIA,EAAI,GAAK,EAAE,EAChE0kB,IAAyB,IAAM,CAGjC,MAAMjhB,EAAM,CAFF,CAAC+gB,EAAK,EACN,CAACC,EAAK,CACC,EACjB,QAASzkB,EAAI,EAAGA,EAAI,EAAGA,IACnB,QAASgW,KAAKvS,EACVuS,EAAE,KAAKA,EAAEhW,CAAC,EAAE,IAAKzF,GAAMgqB,GAAOhqB,CAAC,CAAC,CAAC,EACzC,OAAOkJ,CACX,GAAC,EACKkhB,GAA8BD,GAAM,CAAC,EACrCE,GAA8BF,GAAM,CAAC,EAErCG,GAA4B,CAC9B,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,CAAC,EACvD,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,CAAC,EACvD,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,CAAC,EACvD,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,CAAC,EACvD,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,CAAC,CAC3D,EAAE,IAAK7kB,GAAM,WAAW,KAAKA,CAAC,CAAC,EACzB8kB,GAA6BH,GAAK,IAAI,CAACvf,EAAKpF,IAAMoF,EAAI,IAAK4Q,GAAM6O,GAAU7kB,CAAC,EAAEgW,CAAC,CAAC,CAAC,EACjF+O,GAA6BH,GAAK,IAAI,CAACxf,EAAKpF,IAAMoF,EAAI,IAAK4Q,GAAM6O,GAAU7kB,CAAC,EAAEgW,CAAC,CAAC,CAAC,EACjFgP,GAAwB,YAAY,KAAK,CAC3C,EAAY,WAAY,WAAY,WAAY,UACpD,CAAC,EACKC,GAAwB,YAAY,KAAK,CAC3C,WAAY,WAAY,WAAY,WAAY,CACpD,CAAC,EAED,SAASC,GAASC,EAAOvqB,EAAGQ,EAAGC,EAAG,CAC9B,OAAI8pB,IAAU,EACHvqB,EAAIQ,EAAIC,EACf8pB,IAAU,EACFvqB,EAAIQ,EAAM,CAACR,EAAIS,EACvB8pB,IAAU,GACFvqB,EAAI,CAACQ,GAAKC,EAClB8pB,IAAU,EACFvqB,EAAIS,EAAMD,EAAI,CAACC,EACpBT,GAAKQ,EAAI,CAACC,EACrB,CAEA,MAAM+pB,GAA0B,IAAI,YAAY,EAAE,EAC3C,MAAMC,WAAkBlC,EAAO,CAClC,aAAc,CACV,MAAM,GAAI,GAAI,EAAG,EAAI,EACrB,KAAK,GAAK,WACV,KAAK,GAAK,WACV,KAAK,GAAK,YACV,KAAK,GAAK,UACV,KAAK,GAAK,WACd,CACA,KAAM,CACF,KAAM,CAAE,GAAAmC,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,CAAE,EAAK,KAC/B,MAAO,CAACJ,EAAIC,EAAIC,EAAIC,EAAIC,CAAE,CAC9B,CACA,IAAIJ,EAAIC,EAAIC,EAAIC,EAAIC,EAAI,CACpB,KAAK,GAAKJ,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKC,EAAK,CACnB,CACA,QAAQ5C,EAAMxR,EAAQ,CAClB,QAAStR,EAAI,EAAGA,EAAI,GAAIA,IAAKsR,GAAU,EACnC8T,GAAQplB,CAAC,EAAI8iB,EAAK,UAAUxR,EAAQ,EAAI,EAE5C,IAAIgQ,EAAK,KAAK,GAAK,EAAGqE,EAAKrE,EAAIsE,EAAK,KAAK,GAAK,EAAGC,EAAKD,EAAIE,EAAK,KAAK,GAAK,EAAGC,EAAKD,EAAIE,EAAK,KAAK,GAAK,EAAGC,EAAKD,EAAIE,EAAK,KAAK,GAAK,EAAGC,EAAKD,EAGvI,QAASf,EAAQ,EAAGA,EAAQ,EAAGA,IAAS,CACpC,MAAMiB,EAAS,EAAIjB,EACbkB,EAAMrB,GAAMG,CAAK,EAAGmB,EAAMrB,GAAME,CAAK,EACrCoB,EAAK5B,GAAKQ,CAAK,EAAGqB,EAAK5B,GAAKO,CAAK,EACjCsB,EAAK3B,GAAWK,CAAK,EAAGuB,EAAK3B,GAAWI,CAAK,EACnD,QAASnlB,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,MAAM2mB,EAAMlH,GAAK6B,EAAK4D,GAASC,EAAOS,EAAIE,EAAIE,CAAE,EAAIZ,GAAQmB,EAAGvmB,CAAC,CAAC,EAAIqmB,EAAKI,EAAGzmB,CAAC,CAAC,EAAIkmB,EAAM,EACzF5E,EAAK4E,EAAIA,EAAKF,EAAIA,EAAKvG,GAAKqG,EAAI,EAAE,EAAI,EAAGA,EAAKF,EAAIA,EAAKe,CAC3D,CAEA,QAAS3mB,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,MAAM4mB,EAAMnH,GAAKkG,EAAKT,GAASkB,EAAQP,EAAIE,EAAIE,CAAE,EAAIb,GAAQoB,EAAGxmB,CAAC,CAAC,EAAIsmB,EAAKI,EAAG1mB,CAAC,CAAC,EAAImmB,EAAM,EAC1FR,EAAKQ,EAAIA,EAAKF,EAAIA,EAAKxG,GAAKsG,EAAI,EAAE,EAAI,EAAGA,EAAKF,EAAIA,EAAKe,CAC3D,CACJ,CAEA,KAAK,IAAK,KAAK,GAAKd,EAAKG,EAAM,EAAI,KAAK,GAAKD,EAAKG,EAAM,EAAI,KAAK,GAAKD,EAAKP,EAAM,EAAI,KAAK,GAAKrE,EAAKuE,EAAM,EAAI,KAAK,GAAKD,EAAKG,EAAM,CAAC,CACxI,CACA,YAAa,CACTzG,GAAM8F,EAAO,CACjB,CACA,SAAU,CACN,KAAK,UAAY,GACjB9F,GAAM,KAAK,MAAM,EACjB,KAAK,IAAI,EAAG,EAAG,EAAG,EAAG,CAAC,CAC1B,CACJ,CAMO,MAAMuH,GAA4BzG,GAAa,IAAM,IAAIiF,EAAW,EC5Q9DwB,GAAY4X,GCNnBrX,GAA6B,OAAO,GAAK,GAAK,CAAC,EAC/CrE,GAAuB,OAAO,EAAE,EACtC,SAASmE,GAAQvsB,EAAG0sB,EAAK,GAAO,CAC5B,OAAIA,EACO,CAAE,EAAG,OAAO1sB,EAAIysB,EAAU,EAAG,EAAG,OAAQzsB,GAAKooB,GAAQqE,EAAU,CAAC,EACpE,CAAE,EAAG,OAAQzsB,GAAKooB,GAAQqE,EAAU,EAAI,EAAG,EAAG,OAAOzsB,EAAIysB,EAAU,EAAI,CAAC,CACnF,CACA,SAASD,GAAMG,EAAKD,EAAK,GAAO,CAC5B,MAAMlX,EAAMmX,EAAI,OAChB,IAAIC,EAAK,IAAI,YAAYpX,CAAG,EACxBqX,EAAK,IAAI,YAAYrX,CAAG,EAC5B,QAASnQ,EAAI,EAAGA,EAAImQ,EAAKnQ,IAAK,CAC1B,KAAM,CAAE,EAAA1F,EAAG,EAAAO,CAAC,EAAKqsB,GAAQI,EAAItnB,CAAC,EAAGqnB,CAAE,EACnC,CAACE,EAAGvnB,CAAC,EAAGwnB,EAAGxnB,CAAC,CAAC,EAAI,CAAC1F,EAAGO,CAAC,CAC1B,CACA,MAAO,CAAC0sB,EAAIC,CAAE,CAClB,CAGA,MAAME,GAAQ,CAACptB,EAAGqtB,EAAI7V,IAAMxX,IAAMwX,EAC5B8V,GAAQ,CAACttB,EAAGO,EAAGiX,IAAOxX,GAAM,GAAKwX,EAAOjX,IAAMiX,EAE9C+V,GAAS,CAACvtB,EAAGO,EAAGiX,IAAOxX,IAAMwX,EAAMjX,GAAM,GAAKiX,EAC9CgW,GAAS,CAACxtB,EAAGO,EAAGiX,IAAOxX,GAAM,GAAKwX,EAAOjX,IAAMiX,EAE/CiW,GAAS,CAACztB,EAAGO,EAAGiX,IAAOxX,GAAM,GAAKwX,EAAOjX,IAAOiX,EAAI,GACpDkW,GAAS,CAAC1tB,EAAGO,EAAGiX,IAAOxX,IAAOwX,EAAI,GAAQjX,GAAM,GAAKiX,EAY3D,SAASmV,GAAIM,EAAIC,EAAIgB,EAAIC,EAAI,CACzB,MAAM5tB,GAAK2sB,IAAO,IAAMiB,IAAO,GAC/B,MAAO,CAAE,EAAIlB,EAAKiB,GAAO3tB,EAAI,GAAK,GAAM,GAAM,EAAG,EAAGA,EAAI,CAAC,CAC7D,CAEA,MAAM6tB,GAAQ,CAAClB,EAAIiB,EAAIE,KAAQnB,IAAO,IAAMiB,IAAO,IAAME,IAAO,GAC1DC,GAAQ,CAACC,EAAKtB,EAAIiB,EAAIM,IAAQvB,EAAKiB,EAAKM,GAAOD,EAAM,GAAK,GAAM,GAAM,EACtEE,GAAQ,CAACvB,EAAIiB,EAAIE,EAAIK,KAAQxB,IAAO,IAAMiB,IAAO,IAAME,IAAO,IAAMK,IAAO,GAC3EC,GAAQ,CAACJ,EAAKtB,EAAIiB,EAAIM,EAAII,IAAQ3B,EAAKiB,EAAKM,EAAKI,GAAOL,EAAM,GAAK,GAAM,GAAM,EAC/EM,GAAQ,CAAC3B,EAAIiB,EAAIE,EAAIK,EAAII,KAAQ5B,IAAO,IAAMiB,IAAO,IAAME,IAAO,IAAMK,IAAO,IAAMI,IAAO,GAC5FC,GAAQ,CAACR,EAAKtB,EAAIiB,EAAIM,EAAII,EAAII,IAAQ/B,EAAKiB,EAAKM,EAAKI,EAAKI,GAAOT,EAAM,GAAK,GAAM,GAAM,ECtCxFY,GAA2B,YAAY,KAAK,CAC9C,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WACpF,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WACpF,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WACpF,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UACpF,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WACpF,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UACpF,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WACpF,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UACxF,CAAC,EAEKC,GAA2B,IAAI,YAAY,EAAE,EAC5C,MAAMC,WAAexG,EAAO,CAC/B,YAAYE,EAAY,GAAI,CACxB,MAAM,GAAIA,EAAW,EAAG,EAAK,EAG7B,KAAK,EAAIkb,GAAU,CAAC,EAAI,EACxB,KAAK,EAAIA,GAAU,CAAC,EAAI,EACxB,KAAK,EAAIA,GAAU,CAAC,EAAI,EACxB,KAAK,EAAIA,GAAU,CAAC,EAAI,EACxB,KAAK,EAAIA,GAAU,CAAC,EAAI,EACxB,KAAK,EAAIA,GAAU,CAAC,EAAI,EACxB,KAAK,EAAIA,GAAU,CAAC,EAAI,EACxB,KAAK,EAAIA,GAAU,CAAC,EAAI,CAC5B,CACA,KAAM,CACF,KAAM,CAAE,EAAAjjC,EAAG,EAAAC,EAAG,EAAAb,EAAG,EAAAc,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,CAAC,EAAK,KACnC,MAAO,CAACN,EAAGC,EAAGb,EAAGc,EAAGC,EAAGC,EAAGC,EAAGC,CAAC,CAClC,CAEA,IAAIN,EAAGC,EAAGb,EAAGc,EAAGC,EAAGC,EAAGC,EAAGC,EAAG,CACxB,KAAK,EAAIN,EAAI,EACb,KAAK,EAAIC,EAAI,EACb,KAAK,EAAIb,EAAI,EACb,KAAK,EAAIc,EAAI,EACb,KAAK,EAAIC,EAAI,EACb,KAAK,EAAIC,EAAI,EACb,KAAK,EAAIC,EAAI,EACb,KAAK,EAAIC,EAAI,CACjB,CACA,QAAQknB,EAAMxR,EAAQ,CAElB,QAAStR,EAAI,EAAGA,EAAI,GAAIA,IAAKsR,GAAU,EACnCoY,GAAS1pB,CAAC,EAAI8iB,EAAK,UAAUxR,EAAQ,EAAK,EAC9C,QAAStR,EAAI,GAAIA,EAAI,GAAIA,IAAK,CAC1B,MAAM4pB,EAAMF,GAAS1pB,EAAI,EAAE,EACrB6pB,EAAKH,GAAS1pB,EAAI,CAAC,EACnB8pB,EAAKtK,GAAKoK,EAAK,CAAC,EAAIpK,GAAKoK,EAAK,EAAE,EAAKA,IAAQ,EAC7CG,EAAKvK,GAAKqK,EAAI,EAAE,EAAIrK,GAAKqK,EAAI,EAAE,EAAKA,IAAO,GACjDH,GAAS1pB,CAAC,EAAK+pB,EAAKL,GAAS1pB,EAAI,CAAC,EAAI8pB,EAAKJ,GAAS1pB,EAAI,EAAE,EAAK,CACnE,CAEA,GAAI,CAAE,EAAA1E,EAAG,EAAAC,EAAG,EAAAb,EAAG,EAAAc,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,CAAC,EAAK,KACjC,QAASoE,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,MAAMgqB,EAASxK,GAAK/jB,EAAG,CAAC,EAAI+jB,GAAK/jB,EAAG,EAAE,EAAI+jB,GAAK/jB,EAAG,EAAE,EAC9CwuB,EAAMruB,EAAIouB,EAASrH,GAAIlnB,EAAGC,EAAGC,CAAC,EAAI8tB,GAASzpB,CAAC,EAAI0pB,GAAS1pB,CAAC,EAAK,EAE/DkqB,GADS1K,GAAKlkB,EAAG,CAAC,EAAIkkB,GAAKlkB,EAAG,EAAE,EAAIkkB,GAAKlkB,EAAG,EAAE,GAC/BsnB,GAAItnB,EAAGC,EAAGb,CAAC,EAAK,EACrCkB,EAAID,EACJA,EAAID,EACJA,EAAID,EACJA,EAAKD,EAAIyuB,EAAM,EACfzuB,EAAId,EACJA,EAAIa,EACJA,EAAID,EACJA,EAAK2uB,EAAKC,EAAM,CACpB,CAEA5uB,EAAKA,EAAI,KAAK,EAAK,EACnBC,EAAKA,EAAI,KAAK,EAAK,EACnBb,EAAKA,EAAI,KAAK,EAAK,EACnBc,EAAKA,EAAI,KAAK,EAAK,EACnBC,EAAKA,EAAI,KAAK,EAAK,EACnBC,EAAKA,EAAI,KAAK,EAAK,EACnBC,EAAKA,EAAI,KAAK,EAAK,EACnBC,EAAKA,EAAI,KAAK,EAAK,EACnB,KAAK,IAAIN,EAAGC,EAAGb,EAAGc,EAAGC,EAAGC,EAAGC,EAAGC,CAAC,CACnC,CACA,YAAa,CACT0jB,GAAMoK,EAAQ,CAClB,CACA,SAAU,CACN,KAAK,IAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAC/BpK,GAAM,KAAK,MAAM,CACrB,CACJ,CAkBA,MAAM8K,GAA8BsU,GAAU,CAC1C,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,qBAClE,qBAAsB,qBAAsB,qBAAsB,oBACtE,EAAE,IAAI/jC,GAAK,OAAOA,CAAC,CAAC,CAAC,EACf0vB,GAAmCD,GAAK,CAAC,EACzCE,GAAmCF,GAAK,CAAC,EAEzCG,GAA6B,IAAI,YAAY,EAAE,EAC/CC,GAA6B,IAAI,YAAY,EAAE,EAC9C,MAAMC,WAAetH,EAAO,CAC/B,YAAYE,EAAY,GAAI,CACxB,MAAM,IAAKA,EAAW,GAAI,EAAK,EAI/B,KAAK,GAAKmb,GAAU,CAAC,EAAI,EACzB,KAAK,GAAKA,GAAU,CAAC,EAAI,EACzB,KAAK,GAAKA,GAAU,CAAC,EAAI,EACzB,KAAK,GAAKA,GAAU,CAAC,EAAI,EACzB,KAAK,GAAKA,GAAU,CAAC,EAAI,EACzB,KAAK,GAAKA,GAAU,CAAC,EAAI,EACzB,KAAK,GAAKA,GAAU,CAAC,EAAI,EACzB,KAAK,GAAKA,GAAU,CAAC,EAAI,EACzB,KAAK,GAAKA,GAAU,CAAC,EAAI,EACzB,KAAK,GAAKA,GAAU,CAAC,EAAI,EACzB,KAAK,GAAKA,GAAU,EAAE,EAAI,EAC1B,KAAK,GAAKA,GAAU,EAAE,EAAI,EAC1B,KAAK,GAAKA,GAAU,EAAE,EAAI,EAC1B,KAAK,GAAKA,GAAU,EAAE,EAAI,EAC1B,KAAK,GAAKA,GAAU,EAAE,EAAI,EAC1B,KAAK,GAAKA,GAAU,EAAE,EAAI,CAC9B,CAEA,KAAM,CACF,KAAM,CAAE,GAAAjX,EAAI,GAAAC,EAAI,GAAAgB,EAAI,GAAAC,EAAI,GAAAK,EAAI,GAAAH,EAAI,GAAAO,EAAI,GAAAF,EAAI,GAAAM,EAAI,GAAAF,EAAI,GAAAsB,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,CAAE,EAAK,KAC3E,MAAO,CAACxD,EAAIC,EAAIgB,EAAIC,EAAIK,EAAIH,EAAIO,EAAIF,EAAIM,EAAIF,EAAIsB,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,CAAE,CAC1E,CAEA,IAAIxD,EAAIC,EAAIgB,EAAIC,EAAIK,EAAIH,EAAIO,EAAIF,EAAIM,EAAIF,EAAIsB,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAI,CAChE,KAAK,GAAKxD,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKgB,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKK,EAAK,EACf,KAAK,GAAKH,EAAK,EACf,KAAK,GAAKO,EAAK,EACf,KAAK,GAAKF,EAAK,EACf,KAAK,GAAKM,EAAK,EACf,KAAK,GAAKF,EAAK,EACf,KAAK,GAAKsB,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKC,EAAK,EACf,KAAK,GAAKC,EAAK,CACnB,CACA,QAAQjI,EAAMxR,EAAQ,CAElB,QAAStR,EAAI,EAAGA,EAAI,GAAIA,IAAKsR,GAAU,EACnCiZ,GAAWvqB,CAAC,EAAI8iB,EAAK,UAAUxR,CAAM,EACrCkZ,GAAWxqB,CAAC,EAAI8iB,EAAK,UAAWxR,GAAU,CAAC,EAE/C,QAAStR,EAAI,GAAIA,EAAI,GAAIA,IAAK,CAE1B,MAAMgrB,EAAOT,GAAWvqB,EAAI,EAAE,EAAI,EAC5BirB,EAAOT,GAAWxqB,EAAI,EAAE,EAAI,EAC5BkrB,EAAMyT,GAAW3T,EAAMC,EAAM,CAAC,EAAI0T,GAAW3T,EAAMC,EAAM,CAAC,EAAI2T,GAAU5T,EAAMC,EAAM,CAAC,EACrFE,EAAM0T,GAAW7T,EAAMC,EAAM,CAAC,EAAI4T,GAAW7T,EAAMC,EAAM,CAAC,EAAI6T,GAAU9T,EAAMC,EAAM,CAAC,EAErFG,EAAMb,GAAWvqB,EAAI,CAAC,EAAI,EAC1BqrB,EAAMb,GAAWxqB,EAAI,CAAC,EAAI,EAC1BsrB,EAAMqT,GAAWvT,EAAKC,EAAK,EAAE,EAAI0T,GAAW3T,EAAKC,EAAK,EAAE,EAAIuT,GAAUxT,EAAKC,EAAK,CAAC,EACjFE,EAAMsT,GAAWzT,EAAKC,EAAK,EAAE,EAAI2T,GAAW5T,EAAKC,EAAK,EAAE,EAAIyT,GAAU1T,EAAKC,EAAK,CAAC,EAEjFG,EAAOyT,GAAU9T,EAAKI,EAAKf,GAAWxqB,EAAI,CAAC,EAAGwqB,GAAWxqB,EAAI,EAAE,CAAC,EAChEyrB,EAAOyT,GAAU1T,EAAMN,EAAKI,EAAKf,GAAWvqB,EAAI,CAAC,EAAGuqB,GAAWvqB,EAAI,EAAE,CAAC,EAC5EuqB,GAAWvqB,CAAC,EAAIyrB,EAAO,EACvBjB,GAAWxqB,CAAC,EAAIwrB,EAAO,CAC3B,CACA,GAAI,CAAE,GAAAjE,EAAI,GAAAC,EAAI,GAAAgB,EAAI,GAAAC,EAAI,GAAAK,EAAI,GAAAH,EAAI,GAAAO,EAAI,GAAAF,EAAI,GAAAM,EAAI,GAAAF,EAAI,GAAAsB,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,EAAI,GAAAC,CAAE,EAAK,KAEzE,QAAS/qB,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAEzB,MAAM0rB,EAAUiT,GAAWrV,EAAIF,EAAI,EAAE,EAAIuV,GAAWrV,EAAIF,EAAI,EAAE,EAAI2V,GAAWzV,EAAIF,EAAI,EAAE,EACjFuC,EAAUkT,GAAWvV,EAAIF,EAAI,EAAE,EAAIyV,GAAWvV,EAAIF,EAAI,EAAE,EAAI4V,GAAW1V,EAAIF,EAAI,EAAE,EAEjFwC,EAAQtC,EAAKoB,EAAO,CAACpB,EAAKsB,EAC1BiB,EAAQzC,EAAKuB,EAAO,CAACvB,EAAKyB,EAG1BiB,EAAOqT,GAAUpU,EAAIY,EAASE,EAAMvB,GAAUtqB,CAAC,EAAGwqB,GAAWxqB,CAAC,CAAC,EAC/D+rB,EAAMqT,GAAUtT,EAAMhB,EAAIY,EAASE,EAAMvB,GAAUrqB,CAAC,EAAGuqB,GAAWvqB,CAAC,CAAC,EACpEgsB,EAAMF,EAAO,EAEbG,EAAU0S,GAAWpX,EAAIC,EAAI,EAAE,EAAIuX,GAAWxX,EAAIC,EAAI,EAAE,EAAIuX,GAAWxX,EAAIC,EAAI,EAAE,EACjF0E,EAAU2S,GAAWtX,EAAIC,EAAI,EAAE,EAAIwX,GAAWzX,EAAIC,EAAI,EAAE,EAAIwX,GAAWzX,EAAIC,EAAI,EAAE,EACjF2E,EAAQ5E,EAAKiB,EAAOjB,EAAKuB,EAAON,EAAKM,EACrCsD,EAAQ5E,EAAKiB,EAAOjB,EAAKmB,EAAOF,EAAKE,EAC3CmC,EAAKF,EAAK,EACVG,EAAKF,EAAK,EACVD,EAAKF,EAAK,EACVG,EAAKF,EAAK,EACVD,EAAKpB,EAAK,EACVqB,EAAKvB,EAAK,EACT,CAAE,EAAGE,EAAI,EAAGF,CAAE,EAAKiW,GAAQnW,EAAK,EAAGF,EAAK,EAAG+C,EAAM,EAAGC,EAAM,CAAC,EAC5D9C,EAAKJ,EAAK,EACVE,EAAKL,EAAK,EACVG,EAAKN,EAAK,EACVG,EAAKF,EAAK,EACVD,EAAKjB,EAAK,EACVkB,EAAKjB,EAAK,EACV,MAAM6E,EAAMiT,GAAUtT,EAAKE,EAASE,CAAI,EACxC7E,EAAKgY,GAAUlT,EAAKN,EAAKE,EAASE,CAAI,EACtC3E,EAAK6E,EAAM,CACf,EAEC,CAAE,EAAG9E,EAAI,EAAGC,CAAE,EAAK6X,GAAQ,KAAK,GAAK,EAAG,KAAK,GAAK,EAAG9X,EAAK,EAAGC,EAAK,CAAC,GACnE,CAAE,EAAGgB,EAAI,EAAGC,CAAE,EAAK4W,GAAQ,KAAK,GAAK,EAAG,KAAK,GAAK,EAAG7W,EAAK,EAAGC,EAAK,CAAC,EACnE,CAAE,EAAGK,EAAI,EAAGH,CAAE,EAAK0W,GAAQ,KAAK,GAAK,EAAG,KAAK,GAAK,EAAGvW,EAAK,EAAGH,EAAK,CAAC,EACnE,CAAE,EAAGO,EAAI,EAAGF,CAAE,EAAKqW,GAAQ,KAAK,GAAK,EAAG,KAAK,GAAK,EAAGnW,EAAK,EAAGF,EAAK,CAAC,EACnE,CAAE,EAAGM,EAAI,EAAGF,CAAE,EAAKiW,GAAQ,KAAK,GAAK,EAAG,KAAK,GAAK,EAAG/V,EAAK,EAAGF,EAAK,CAAC,EACnE,CAAE,EAAGsB,EAAI,EAAGC,CAAE,EAAK0U,GAAQ,KAAK,GAAK,EAAG,KAAK,GAAK,EAAG3U,EAAK,EAAGC,EAAK,CAAC,EACnE,CAAE,EAAGC,EAAI,EAAGC,CAAE,EAAKwU,GAAQ,KAAK,GAAK,EAAG,KAAK,GAAK,EAAGzU,EAAK,EAAGC,EAAK,CAAC,EACnE,CAAE,EAAGC,EAAI,EAAGC,CAAE,EAAKsU,GAAQ,KAAK,GAAK,EAAG,KAAK,GAAK,EAAGvU,EAAK,EAAGC,EAAK,CAAC,EACpE,KAAK,IAAIxD,EAAIC,EAAIgB,EAAIC,EAAIK,EAAIH,EAAIO,EAAIF,EAAIM,EAAIF,EAAIsB,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,CAAE,CAC3E,CACA,YAAa,CACTzL,GAAMiL,GAAYC,EAAU,CAChC,CACA,SAAU,CACNlL,GAAM,KAAK,MAAM,EACjB,KAAK,IAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAC3D,CACJ,CAuFO,MAAMqN,GAAyBvM,GAAa,IAAM,IAAIuJ,EAAQ,EAIxD6V,GAAyBpf,GAAa,IAAM,IAAIqK,EAAQ,EC3VxDkC,GAAS8S,GCFTD,GAASE,GCRf,SAASC,GAAQ5gC,EAAQ,CAC5B,OAAO8nB,GAAU8F,GAAO5tB,CAAM,CAAC,CACnC,CACO,SAAS6gC,GAAWtiC,EAAKuD,EAAM,CAClC,OAAOy9B,GAAKkB,GAAQliC,EAAKuD,CAAI,CACjC,CCTA,MAAMg/B,GAAc,yBACFA,GAAY,MAAM,EAAE,EAAE,IAAK3lC,GAAMA,EAAE,YAAY,CAAC,CAAC,EACnE,MAAM4lC,GAAiB,MAAM,GAAG,EAC3B,KAAK,EAAI,EACT,IAAI,CAAC7e,EAAGjhB,IAAM,CACf,MAAM8R,EAAI,OAAO,cAAc9R,CAAC,EAC1B5C,EAAQyiC,GAAY,QAAQ/tB,CAAC,EAEnC,OAAO1U,EAAQ,EAAI,OAAYA,EAAQ,GAAKA,EAAQA,EAAQ,CAChE,CAAC,EACK2iC,GAAU,IAAI,YACJ,IAAI,YAIb,SAASC,GAASluB,EAAG,CACxB,OAAOiuB,GAAQ,OAAOjuB,CAAC,CAC3B,CACO,SAASmuB,GAAOrf,EAAQ,CAC3B,MAAMsf,EAActf,EAAO,OAAO,CAAC,EAAG3mB,IAAM,EAAIA,EAAE,OAAQ,CAAC,EACrD0D,EAAS,IAAI,WAAWuiC,CAAW,EACzC,IAAI5uB,EAAS,EACb,UAAWyC,KAAS6M,EAChBjjB,EAAO,IAAIoW,EAAOzC,CAAM,EACxBA,GAAUyC,EAAM,OAEpB,OAAOpW,CACX,CA4BO,SAASwiC,GAAQC,EAAW,CAC/B,MAAMC,EAAWN,GAAQ,OAAOK,GAAa,EAAE,EACzCE,EAAc,IAAI,WAAW,KAAK,MAAMD,EAAS,OAAS,CAAC,CAAC,EAClE,IAAIrgC,EACJ,IAAKA,EAAI,EAAGA,EAAIsgC,EAAY,OAAQtgC,IAAK,CACrC,MAAM,EAAI8/B,GAAeO,EAASrgC,EAAI,CAAC,CAAC,EAClC/F,EAAI6lC,GAAeO,EAASrgC,EAAI,EAAI,CAAC,CAAC,EAC5C,GAAI,IAAM,QAAa/F,IAAM,OACzB,MAEJqmC,EAAYtgC,CAAC,EAAK,GAAK,EAAK/F,CAChC,CACA,OAAO+F,IAAMsgC,EAAY,OAASA,EAAcA,EAAY,MAAM,EAAGtgC,CAAC,CAC1E,CAaO,SAASugC,GAAQC,EAAIC,EAAI,CAC5B,MAAMC,EAAY,KAAK,IAAIF,EAAG,OAAQC,EAAG,MAAM,EAC/C,QAASzgC,EAAI,EAAGA,EAAI0gC,EAAW,EAAE1gC,EAC7B,GAAIwgC,EAAGxgC,CAAC,IAAMygC,EAAGzgC,CAAC,EACd,OAAOwgC,EAAGxgC,CAAC,EAAIygC,EAAGzgC,CAAC,EAAI,GAAK,EAGpC,OAAOwgC,EAAG,SAAWC,EAAG,OAAS,EAAID,EAAG,OAASC,EAAG,OAAS,EAAI,EACrE,CACO,SAASE,GAAW5hC,EAAQuS,EAAQvO,EAAO,CAC9C,GAAIuO,EAAS,EAAIvS,EAAO,OACpB,MAAM,IAAI,MAAM,4CAA4C,EAEhE,GAAIgE,EAAQ,IACR,MAAM,IAAI,MAAM,8EAAkFA,CAAK,EAAE,EAE7GhE,EAAOuS,CAAM,EAAIvO,CACrB,CAkBO,SAAS69B,GAAY7hC,EAAQuS,EAAQvO,EAAOiW,EAAc,CAC7D,GAAI1H,EAAS,EAAIvS,EAAO,OACpB,MAAM,IAAI,MAAM,4CAA4C,EAGhE,GADAia,EAAeA,EAAa,YAAW,EACnCjW,EAAQ,WACR,MAAM,IAAI,MAAM,gEAAgE,UAAU,cAAcA,CAAK,EAAE,EAE/GiW,IAAiB,MACjBja,EAAOuS,CAAM,EAAIvO,EAAQ,IACzBhE,EAAOuS,EAAS,CAAC,EAAKvO,GAAS,EAAK,IACpChE,EAAOuS,EAAS,CAAC,EAAKvO,GAAS,GAAM,IACrChE,EAAOuS,EAAS,CAAC,EAAKvO,GAAS,GAAM,MAGrChE,EAAOuS,CAAM,EAAKvO,GAAS,GAAM,IACjChE,EAAOuS,EAAS,CAAC,EAAKvO,GAAS,GAAM,IACrChE,EAAOuS,EAAS,CAAC,EAAKvO,GAAS,EAAK,IACpChE,EAAOuS,EAAS,CAAC,EAAIvO,EAAQ,IAErC,CAsDO,SAAS89B,GAAW9hC,EAAQuS,EAAQ0H,EAAc,CACrD,GAAI1H,EAAS,EAAIvS,EAAO,OACpB,MAAM,IAAI,MAAM,4CAA4C,EAGhE,GADAia,EAAeA,EAAa,YAAW,EACnCA,IAAiB,KAAM,CACvB,IAAInI,EAAM,EACV,OAAAA,GAAQA,GAAO,GAAK9R,EAAOuS,EAAS,CAAC,IAAO,EAC5CT,GAAQA,GAAO,GAAK9R,EAAOuS,EAAS,CAAC,IAAO,EAC5CT,GAAQA,GAAO,GAAK9R,EAAOuS,EAAS,CAAC,IAAO,EAC5CT,GAAQA,GAAO,GAAK9R,EAAOuS,CAAM,IAAO,EACjCT,CACX,KACK,CACD,IAAIA,EAAM,EACV,OAAAA,GAAQA,GAAO,GAAK9R,EAAOuS,CAAM,IAAO,EACxCT,GAAQA,GAAO,GAAK9R,EAAOuS,EAAS,CAAC,IAAO,EAC5CT,GAAQA,GAAO,GAAK9R,EAAOuS,EAAS,CAAC,IAAO,EAC5CT,GAAQA,GAAO,GAAK9R,EAAOuS,EAAS,CAAC,IAAO,EACrCT,CACX,CACJ,CClNA,MAAMvW,GAAK4mB,GAAQ4f,GAAc5f,CAAG,EAC7B,SAAS6f,GAAQC,EAAK,CAazB,GAZAC,GAAOD,EAAI,QAAQ1mC,GAAE,oEAAoE,CAAC,CAAC,EAC3F2mC,GAAO,CAACD,EAAI,QAAQ1mC,GAAE,oEAAoE,CAAC,CAAC,EAC5F2mC,GAAOD,EAAI,UAAU1mC,GAAE,kEAAkE,CAAC,CAAC,EAE3F2mC,GAAOD,EAAI,UAAU1mC,GAAE,kEAAkE,CAAC,CAAC,EAE3F2mC,GAAO,CAACD,EAAI,UAAU1mC,GAAE,kEAAkE,CAAC,CAAC,EAE5F2mC,GAAO,CAACD,EAAI,UAAU1mC,GAAE,kEAAkE,CAAC,CAAC,EAE5F2mC,GAAO,CAACD,EAAI,UAAU1mC,GAAE,kEAAkE,CAAC,CAAC,EAC5F2mC,GAAOC,GAAcF,EAAI,gBAAgB1mC,GAAE,kEAAkE,CAAC,EAAGA,GAAE,oEAAoE,CAAC,IAAM,CAAC,EAC3L0mC,EAAI,mBAAoB,CACxBC,GAAOD,EAAI,mBAAmB1mC,GAAE,kEAAkE,EAAGA,GAAE,kEAAkE,CAAC,IAAM,IAAI,EACpL,IAAI6mC,EAAWH,EAAI,mBAAmB1mC,GAAE,kEAAkE,EAAGA,GAAE,kEAAkE,CAAC,EAClL2mC,GAAOC,GAAcC,EAAS,YAAa7mC,GAAE,kEAAkE,CAAC,IAAM,GAAK6mC,EAAS,SAAW,CAAC,EAChJA,EAAWH,EAAI,mBAAmB1mC,GAAE,kEAAkE,EAAGA,GAAE,kEAAkE,CAAC,CAClL,CACA2mC,GAAOC,GAAcF,EAAI,eAAe1mC,GAAE,oEAAoE,EAAGA,GAAE,kEAAkE,CAAC,EAAGA,GAAE,oEAAoE,CAAC,IAAM,CAAC,EACvQ2mC,GAAOC,GAAcF,EAAI,WAAW1mC,GAAE,kEAAkE,EAAGA,GAAE,kEAAkE,CAAC,EAAGA,GAAE,kEAAkE,CAAC,IAAM,CAAC,EAC3P0mC,EAAI,gBACJC,GAAOC,GAAcF,EAAI,cAAc1mC,GAAE,kEAAkE,CAAC,EAAGA,GAAE,kEAAkE,CAAC,IAAM,CAAC,EAC3L2mC,GAAOC,GAAcF,EAAI,cAAc1mC,GAAE,kEAAkE,CAAC,EAAGA,GAAE,kEAAkE,CAAC,IAAM,CAAC,EAC3L2mC,GAAOC,GAAcF,EAAI,cAAc1mC,GAAE,kEAAkE,CAAC,EAAGA,GAAE,kEAAkE,CAAC,IAAM,CAAC,GAE/L2mC,GAAOC,GAAcF,EAAI,KAAK1mC,GAAE,kEAAkE,EAAGA,GAAE,kEAAkE,CAAC,EAAGA,GAAE,kIAAkI,CAAC,IAAM,CAAC,EACzT2mC,GAAOD,EAAI,OAAO1mC,GAAE,kEAAkE,EAAGA,GAAE,oEAAoE,EAAGA,GAAE,kIAAkI,CAAC,CAAC,EACpS0mC,EAAI,aACJC,GAAOC,GAAcF,EAAI,YAAY1mC,GAAE,kEAAkE,EAAGA,GAAE,kEAAkE,EAAGA,GAAE,kEAAkE,CAAC,EAAGA,GAAE,kIAAkI,CAAC,IAAM,CAAC,EAEvY0mC,EAAI,eACJC,GAAOD,EAAI,cAAc1mC,GAAE,kEAAkE,EAAGA,GAAE,kEAAkE,EAAGA,GAAE,kIAAkI,CAAC,CAAC,CAErT,CACA,SAAS2mC,GAAO1+B,EAAM,CAClB,GAAI,CAACA,EACD,MAAM,IAAI,MAAM,qBAAqB,CAC7C,CCxCA,oEACA,SAASuc,GAAQ9kB,EAAG,CAChB,OAAOA,aAAa,YAAe,YAAY,OAAOA,CAAC,GAAKA,EAAE,YAAY,OAAS,YACvF,CAQA,SAASonC,GAAUC,EAAU3wB,EAAK,CAC9B,OAAK,MAAM,QAAQA,CAAG,EAElBA,EAAI,SAAW,EACR,GACP2wB,EACO3wB,EAAI,MAAOkhB,GAAS,OAAOA,GAAS,QAAQ,EAG5ClhB,EAAI,MAAOkhB,GAAS,OAAO,cAAcA,CAAI,CAAC,EAP9C,EASf,CAEA,SAAS0P,GAAI97B,EAAO,CAChB,GAAI,OAAOA,GAAU,WACjB,MAAM,IAAI,MAAM,mBAAmB,EACvC,MAAO,EACX,CACA,SAAS+7B,GAAKlmB,EAAO7V,EAAO,CACxB,GAAI,OAAOA,GAAU,SACjB,MAAM,IAAI,MAAM,GAAG6V,CAAK,mBAAmB,EAC/C,MAAO,EACX,CACA,SAAS0D,GAAQpkB,EAAG,CAChB,GAAI,CAAC,OAAO,cAAcA,CAAC,EACvB,MAAM,IAAI,MAAM,oBAAoBA,CAAC,EAAE,CAC/C,CACA,SAAS6mC,GAAKh8B,EAAO,CACjB,GAAI,CAAC,MAAM,QAAQA,CAAK,EACpB,MAAM,IAAI,MAAM,gBAAgB,CACxC,CACA,SAASi8B,GAAQpmB,EAAO7V,EAAO,CAC3B,GAAI,CAAC47B,GAAU,GAAM57B,CAAK,EACtB,MAAM,IAAI,MAAM,GAAG6V,CAAK,6BAA6B,CAC7D,CACA,SAASqmB,GAAQrmB,EAAO7V,EAAO,CAC3B,GAAI,CAAC47B,GAAU,GAAO57B,CAAK,EACvB,MAAM,IAAI,MAAM,GAAG6V,CAAK,6BAA6B,CAC7D,CAIA,SAASsmB,MAAS14B,EAAM,CACpB,MAAM24B,EAAM5nC,GAAMA,EAEZ6nC,EAAO,CAAC7nC,EAAGC,IAAOC,GAAMF,EAAEC,EAAEC,CAAC,CAAC,EAE9BmzB,EAASpkB,EAAK,IAAKrO,GAAMA,EAAE,MAAM,EAAE,YAAYinC,EAAMD,CAAE,EAEvDxT,EAASnlB,EAAK,IAAKrO,GAAMA,EAAE,MAAM,EAAE,OAAOinC,EAAMD,CAAE,EACxD,MAAO,CAAE,OAAAvU,EAAQ,OAAAe,CAAM,CAC3B,CAMA,SAASjU,GAAS2nB,EAAS,CAEvB,MAAMC,EAAW,OAAOD,GAAY,SAAWA,EAAQ,MAAM,EAAE,EAAIA,EAC7D3xB,EAAM4xB,EAAS,OACrBN,GAAQ,WAAYM,CAAQ,EAE5B,MAAMC,EAAU,IAAI,IAAID,EAAS,IAAI,CAAClnC,EAAGmF,IAAM,CAACnF,EAAGmF,CAAC,CAAC,CAAC,EACtD,MAAO,CACH,OAASiiC,IACLT,GAAKS,CAAM,EACJA,EAAO,IAAKjiC,GAAM,CACrB,GAAI,CAAC,OAAO,cAAcA,CAAC,GAAKA,EAAI,GAAKA,GAAKmQ,EAC1C,MAAM,IAAI,MAAM,kDAAkDnQ,CAAC,eAAe8hC,CAAO,EAAE,EAC/F,OAAOC,EAAS/hC,CAAC,CACrB,CAAC,GAEL,OAASwF,IACLg8B,GAAKh8B,CAAK,EACHA,EAAM,IAAK08B,GAAW,CACzBX,GAAK,kBAAmBW,CAAM,EAC9B,MAAM,EAAIF,EAAQ,IAAIE,CAAM,EAC5B,GAAI,IAAM,OACN,MAAM,IAAI,MAAM,oBAAoBA,CAAM,eAAeJ,CAAO,EAAE,EACtE,OAAO,CACX,CAAC,EAEb,CACA,CAIA,SAASK,GAAKC,EAAY,GAAI,CAC1B,OAAAb,GAAK,OAAQa,CAAS,EACf,CACH,OAASpvB,IACLyuB,GAAQ,cAAezuB,CAAI,EACpBA,EAAK,KAAKovB,CAAS,GAE9B,OAASze,IACL4d,GAAK,cAAe5d,CAAE,EACfA,EAAG,MAAMye,CAAS,EAErC,CACA,CAwCA,SAASC,GAAaxhC,EAAMmS,EAAM2Q,EAAI,CAElC,GAAI3Q,EAAO,EACP,MAAM,IAAI,MAAM,8BAA8BA,CAAI,8BAA8B,EACpF,GAAI2Q,EAAK,EACL,MAAM,IAAI,MAAM,4BAA4BA,CAAE,8BAA8B,EAEhF,GADA6d,GAAK3gC,CAAI,EACL,CAACA,EAAK,OACN,MAAO,CAAA,EACX,IAAIwT,EAAM,EACV,MAAM5Q,EAAM,CAAA,EACNw+B,EAAS,MAAM,KAAKphC,EAAO1G,GAAM,CAEnC,GADA4kB,GAAQ5kB,CAAC,EACLA,EAAI,GAAKA,GAAK6Y,EACd,MAAM,IAAI,MAAM,oBAAoB7Y,CAAC,EAAE,EAC3C,OAAOA,CACX,CAAC,EACKmoC,EAAOL,EAAO,OACpB,OAAa,CACT,IAAIvU,EAAQ,EACR6U,EAAO,GACX,QAASviC,EAAIqU,EAAKrU,EAAIsiC,EAAMtiC,IAAK,CAC7B,MAAMwiC,EAAQP,EAAOjiC,CAAC,EAChByiC,EAAYzvB,EAAO0a,EACnBgV,EAAYD,EAAYD,EAC9B,GAAI,CAAC,OAAO,cAAcE,CAAS,GAC/BD,EAAYzvB,IAAS0a,GACrBgV,EAAYF,IAAUC,EACtB,MAAM,IAAI,MAAM,8BAA8B,EAElD,MAAME,EAAMD,EAAY/e,EACxB+J,EAAQgV,EAAY/e,EACpB,MAAMif,EAAU,KAAK,MAAMD,CAAG,EAE9B,GADAV,EAAOjiC,CAAC,EAAI4iC,EACR,CAAC,OAAO,cAAcA,CAAO,GAAKA,EAAUjf,EAAK+J,IAAUgV,EAC3D,MAAM,IAAI,MAAM,8BAA8B,EAClD,GAAKH,EAEKK,EAGNL,EAAO,GAFPluB,EAAMrU,MAFN,SAKR,CAEA,GADAyD,EAAI,KAAKiqB,CAAK,EACV6U,EACA,KACR,CACA,QAASviC,EAAI,EAAGA,EAAIa,EAAK,OAAS,GAAKA,EAAKb,CAAC,IAAM,EAAGA,IAClDyD,EAAI,KAAK,CAAC,EACd,OAAOA,EAAI,QAAO,CACtB,CAqDA,SAASo/B,GAAMhyB,EAAK,CAChBkO,GAAQlO,CAAG,EACX,MAAMiyB,EAAO,GAAK,EAClB,MAAO,CACH,OAASrrB,GAAU,CACf,GAAI,CAACqH,GAAQrH,CAAK,EACd,MAAM,IAAI,MAAM,yCAAyC,EAC7D,OAAO4qB,GAAa,MAAM,KAAK5qB,CAAK,EAAGqrB,EAAMjyB,CAAG,CACpD,EACA,OAASoxB,IACLP,GAAQ,eAAgBO,CAAM,EACvB,WAAW,KAAKI,GAAaJ,EAAQpxB,EAAKiyB,CAAI,CAAC,EAElE,CACA,CAiCA,SAASpU,GAASve,EAAKmK,EAAI,CACvB,OAAAyE,GAAQ5O,CAAG,EACXmxB,GAAIhnB,CAAE,EACC,CACH,OAAOzZ,EAAM,CACT,GAAI,CAACie,GAAQje,CAAI,EACb,MAAM,IAAI,MAAM,6CAA6C,EACjE,MAAMohB,EAAM3H,EAAGzZ,CAAI,EAAE,MAAM,EAAGsP,CAAG,EAC3B1M,EAAM,IAAI,WAAW5C,EAAK,OAASsP,CAAG,EAC5C,OAAA1M,EAAI,IAAI5C,CAAI,EACZ4C,EAAI,IAAIwe,EAAKphB,EAAK,MAAM,EACjB4C,CACX,EACA,OAAO5C,EAAM,CACT,GAAI,CAACie,GAAQje,CAAI,EACb,MAAM,IAAI,MAAM,6CAA6C,EACjE,MAAM2tB,EAAU3tB,EAAK,MAAM,EAAG,CAACsP,CAAG,EAC5B4yB,EAAcliC,EAAK,MAAM,CAACsP,CAAG,EAC7B0e,EAAcvU,EAAGkU,CAAO,EAAE,MAAM,EAAGre,CAAG,EAC5C,QAAS,EAAI,EAAG,EAAIA,EAAK,IACrB,GAAI0e,EAAY,CAAC,IAAMkU,EAAY,CAAC,EAChC,MAAM,IAAI,MAAM,kBAAkB,EAC1C,OAAOvU,CACX,CACR,CACA,CAuJA,MAAMwU,GAAwCC,GAAQtB,GAAMkB,GAAM,EAAE,EAAG1oB,GAAS8oB,CAAG,EAAGd,GAAK,EAAE,CAAC,EAUjF7T,GAAS0U,GAAU,4DAA4D,EA4C/EE,GAAqBvW,GAAWgV,GAAMjT,GAAS,EAAI7tB,GAAS8rB,EAAOA,EAAO9rB,CAAI,CAAC,CAAC,EAAGytB,EAAM,EAKzF6U,GAAcD,GCze3B,IAAIE,GAIJ,SAASC,GAAgBC,EAAS,CAChC,MAAO,CACL,KAAMA,GAAS,MAAQF,IAAO,KAC9B,QAASE,GAAS,QAClB,WAAYA,GAAS,YAAcF,IAAO,WAC1C,eAAgBE,GAAS,gBAAkBF,IAAO,cACtD,CACA,CAMA,IAAIG,GAKJ,SAASC,GAAiBC,EAAM,CAC9B,OAAOF,IAAQ,IAAIE,CAAI,CACzB,CAMA,IAAIC,GAKJ,SAASC,GAAiBF,EAAM,CAC9B,OAAOC,IAAQ,IAAID,CAAI,CACzB,CAMA,IAAIG,GAMJ,SAASC,GAAmBC,EAAWL,EAAM,CAC3C,OAAOG,IAAQ,IAAIE,CAAS,GAAG,IAAIL,CAAI,CACzC,CAMA,SAASM,GAAWv+B,EAAO,CACzB,MAAM1E,EAAO,OAAO0E,EACpB,OAAI1E,IAAS,SACJ,IAAI0E,CAAK,IAEd1E,IAAS,UAAYA,IAAS,UAAYA,IAAS,UAC9C,GAAG0E,CAAK,GAEb1E,IAAS,UAAYA,IAAS,YACxB0E,GAAS,OAAO,eAAeA,CAAK,GAAG,aAAa,OAAS,OAEhE1E,CACT,CAGA,SAASkjC,GAAUC,EAAS5oB,EAAO6oB,EAASZ,EAASnI,EAAO,CAC1D,MAAM31B,EAAQ21B,GAAS,UAAWA,EAAQA,EAAM,MAAQ+I,EAAQ,MAC1DxoB,EAAWyf,GAAO,UAAY8I,EAAQ,SAAW,KACjDxqB,EAAW0hB,GAAO,UAAY4I,GAAWv+B,CAAK,EAC9C2+B,EAAQ,CACZ,KAAMF,EAAQ,KACd,KAAMA,EAAQ,KACd,MAAAz+B,EACA,SAAAkW,EACA,SAAAjC,EACA,QAAS,WAAW4B,CAAK,KAAKK,EAAW,YAAYA,CAAQ,SAAW,GAAG,WAAWjC,CAAQ,GAE9F,YAAawqB,EAAQ,YACrB,KAAM9I,GAAO,KACb,OAAQA,GAAO,OACf,KAAMmI,EAAQ,KACd,WAAYA,EAAQ,WACpB,eAAgBA,EAAQ,cAC5B,EACQc,EAAWH,EAAQ,OAAS,SAC5BvlC,EAAUy8B,GAAO,SACvB8I,EAAQ,SAAWJ,GAAmBI,EAAQ,UAAWE,EAAM,IAAI,IAAMC,EAAWT,GAAiBQ,EAAM,IAAI,EAAI,OAASb,EAAQ,SAAWE,GAAiBW,EAAM,IAAI,EACtKzlC,IACFylC,EAAM,QAAU,OAAOzlC,GAAY,WAAaA,EAAQylC,CAAK,EAAIzlC,GAE/D0lC,IACFF,EAAQ,MAAQ,IAEdA,EAAQ,OACVA,EAAQ,OAAO,KAAKC,CAAK,EAEzBD,EAAQ,OAAS,CAACC,CAAK,CAE3B,CAmEA,IAAIE,GAAY,cAAc,KAAM,CAIlC,OAMA,YAAYC,EAAQ,CAClB,MAAMA,EAAO,CAAC,EAAE,OAAO,EACvB,KAAK,KAAO,YACZ,KAAK,OAASA,CAChB,CACF,EAihBA,SAASC,GAAQ7lC,EAAS,CACxB,MAAO,CACL,KAAM,aACN,KAAM,UACN,UAAW6lC,GACX,MAAO,GACP,QAAS,KACT,YAAa,OAAO,UACpB,QAAA7lC,EACA,KAAKwlC,EAASZ,EAAS,CACrB,OAAIY,EAAQ,OAAS,CAAC,KAAK,YAAYA,EAAQ,KAAK,GAClDF,GAAU,KAAM,UAAWE,EAASZ,CAAO,EAEtCY,CACT,CACJ,CACA,CA8KA,SAAS7mC,GAAOmnC,EAAa9lC,EAAS,CACpC,MAAO,CACL,KAAM,aACN,KAAM,SACN,UAAWrB,GACX,MAAO,GACP,QAAS,GAAGmnC,CAAW,GACvB,YAAAA,EACA,QAAA9lC,EACA,KAAKwlC,EAASZ,EAAS,CACrB,OAAIY,EAAQ,OAASA,EAAQ,MAAM,SAAW,KAAK,aACjDF,GAAU,KAAM,SAAUE,EAASZ,EAAS,CAC1C,SAAU,GAAGY,EAAQ,MAAM,MAAM,EAC3C,CAAS,EAEIA,CACT,CACJ,CACA,CA6IA,SAASO,GAASD,EAAa9lC,EAAS,CACtC,MAAO,CACL,KAAM,aACN,KAAM,YACN,UAAW+lC,GACX,MAAO,GACP,QAAS,KAAKD,aAAuB,KAAOA,EAAY,SAAWT,GAAWS,CAAW,CAAC,GAC1F,YAAAA,EACA,QAAA9lC,EACA,KAAKwlC,EAASZ,EAAS,CACrB,OAAIY,EAAQ,OAASA,EAAQ,MAAQ,KAAK,aACxCF,GAAU,KAAM,QAASE,EAASZ,EAAS,CACzC,SAAUY,EAAQ,iBAAiB,KAAOA,EAAQ,MAAM,OAAM,EAAKH,GAAWG,EAAQ,KAAK,CACrG,CAAS,EAEIA,CACT,CACJ,CACA,CA0FA,SAASQ,GAASF,EAAa9lC,EAAS,CACtC,MAAO,CACL,KAAM,aACN,KAAM,YACN,UAAWgmC,GACX,MAAO,GACP,QAAS,KAAKF,aAAuB,KAAOA,EAAY,SAAWT,GAAWS,CAAW,CAAC,GAC1F,YAAAA,EACA,QAAA9lC,EACA,KAAKwlC,EAASZ,EAAS,CACrB,OAAIY,EAAQ,OAASA,EAAQ,MAAQ,KAAK,aACxCF,GAAU,KAAM,QAASE,EAASZ,EAAS,CACzC,SAAUY,EAAQ,iBAAiB,KAAOA,EAAQ,MAAM,OAAM,EAAKH,GAAWG,EAAQ,KAAK,CACrG,CAAS,EAEIA,CACT,CACJ,CACA,CAoVA,SAASS,GAAMH,EAAa9lC,EAAS,CACnC,MAAO,CACL,KAAM,aACN,KAAM,QACN,UAAWimC,GACX,MAAO,GACP,QAAS,GAAGH,CAAW,GACvB,YAAAA,EACA,QAAA9lC,EACA,KAAKwlC,EAASZ,EAAS,CACrB,OAAIY,EAAQ,OAAS,CAAC,KAAK,YAAY,KAAKA,EAAQ,KAAK,GACvDF,GAAU,KAAM,SAAUE,EAASZ,CAAO,EAErCY,CACT,CACJ,CACA,CAw2BA,SAASxjB,GAASkkB,EAAQlmC,EAAS,CACjC,MAAO,CACL,KAAM,SACN,KAAM,WACN,UAAWgiB,GACX,QAASkkB,EAAO,KAChB,MAAO,GACP,MAAOA,EACP,QAAAlmC,EACA,KAAKwlC,EAASZ,EAAS,CACrB,OAAIY,EAAQ,iBAAiB,KAAK,MAChCA,EAAQ,MAAQ,GAEhBF,GAAU,KAAM,OAAQE,EAASZ,CAAO,EAEnCY,CACT,CACJ,CACA,CA08BA,SAASpmC,GAAOY,EAAS,CACvB,MAAO,CACL,KAAM,SACN,KAAM,SACN,UAAWZ,GACX,QAAS,SACT,MAAO,GACP,QAAAY,EACA,KAAKwlC,EAASZ,EAAS,CACrB,OAAI,OAAOY,EAAQ,OAAU,UAAY,CAAC,MAAMA,EAAQ,KAAK,EAC3DA,EAAQ,MAAQ,GAEhBF,GAAU,KAAM,OAAQE,EAASZ,CAAO,EAEnCY,CACT,CACJ,CACA,CAGA,SAAShiC,GAAO2iC,EAASnmC,EAAS,CAChC,MAAO,CACL,KAAM,SACN,KAAM,SACN,UAAWwD,GACX,QAAS,SACT,MAAO,GACP,QAAA2iC,EACA,QAAAnmC,EACA,KAAKwlC,EAASZ,EAAS,CACrB,MAAM99B,EAAQ0+B,EAAQ,MACtB,GAAI1+B,GAAS,OAAOA,GAAU,SAAU,CACtC0+B,EAAQ,MAAQ,GAChBA,EAAQ,MAAQ,CAAA,EAChB,UAAW5mC,KAAO,KAAK,QAAS,CAC9B,MAAMwnC,EAASt/B,EAAMlI,CAAG,EAClBynC,EAAe,KAAK,QAAQznC,CAAG,EAAE,KACrC,CAAE,MAAO,GAAO,MAAOwnC,CAAM,EAC7BxB,CACZ,EACU,GAAIyB,EAAa,OAAQ,CACvB,MAAMC,EAAW,CACf,KAAM,SACN,OAAQ,QACR,MAAAx/B,EACA,IAAAlI,EACA,MAAOwnC,CACrB,EACY,UAAWX,KAASY,EAAa,OAC3BZ,EAAM,KACRA,EAAM,KAAK,QAAQa,CAAQ,EAE3Bb,EAAM,KAAO,CAACa,CAAQ,EAExBd,EAAQ,QAAQ,KAAKC,CAAK,EAK5B,GAHKD,EAAQ,SACXA,EAAQ,OAASa,EAAa,QAE5BzB,EAAQ,WAAY,CACtBY,EAAQ,MAAQ,GAChB,KACF,CACF,CACKa,EAAa,QAChBb,EAAQ,MAAQ,KAEda,EAAa,QAAU,QAAUznC,KAAOkI,KAC1C0+B,EAAQ,MAAM5mC,CAAG,EAAIynC,EAAa,MAEtC,CACF,MACEf,GAAU,KAAM,OAAQE,EAASZ,CAAO,EAE1C,OAAOY,CACT,CACJ,CACA,CAi/BA,SAASzmC,GAAOiB,EAAS,CACvB,MAAO,CACL,KAAM,SACN,KAAM,SACN,UAAWjB,GACX,QAAS,SACT,MAAO,GACP,QAAAiB,EACA,KAAKwlC,EAASZ,EAAS,CACrB,OAAI,OAAOY,EAAQ,OAAU,SAC3BA,EAAQ,MAAQ,GAEhBF,GAAU,KAAM,OAAQE,EAASZ,CAAO,EAEnCY,CACT,CACJ,CACA,CAorBA,SAASe,GAAMjkC,EAAQwE,EAAO89B,EAAS,CACrC,MAAMY,EAAUljC,EAAO,KACrB,CAAE,MAAO,GAAO,MAAOwE,CAAK,EAC5B69B,GAAgBC,CAAO,CAC3B,EACE,GAAIY,EAAQ,OACV,MAAM,IAAIG,GAAUH,EAAQ,MAAM,EAEpC,OAAOA,EAAQ,KACjB,CA0DA,SAASgB,MAAQC,EAAO,CACtB,MAAO,CACL,GAAGA,EAAM,CAAC,EACV,KAAMA,EACN,KAAKjB,EAASZ,EAAS,CACrB,UAAW1R,KAAQuT,EACjB,GAAIvT,EAAK,OAAS,WAAY,CAC5B,GAAIsS,EAAQ,SAAWtS,EAAK,OAAS,UAAYA,EAAK,OAAS,kBAAmB,CAChFsS,EAAQ,MAAQ,GAChB,KACF,EACI,CAACA,EAAQ,QAAU,CAACZ,EAAQ,YAAc,CAACA,EAAQ,kBACrDY,EAAUtS,EAAK,KAAKsS,EAASZ,CAAO,EAExC,CAEF,OAAOY,CACT,CACJ,CACA,CCttKO,MAAMkB,GAAeC,GAAOC,GAAQ,EAAIC,GAAS,EAAIC,GAAW,CAAC,EAAGC,GAAW,UAAU,CAAC,EACpFC,GAAeL,GAAOC,GAAQ,EAAIC,GAAS,EAAIC,GAAW,CAAC,EAAGC,GAAW,UAAU,CAAC,EAC3FE,GAAcN,GAAOC,GAAQ,EAAIC,GAAS,EAAIC,GAAW,CAAC,EAAGC,GAAW,GAAI,CAAC,EACtEG,GAAeP,GAAOQ,GAAW,UAAU,EAAGC,GAAS,EAAE,CAAC,EAC1DC,GAAgBV,GAAOQ,GAAW,UAAU,EAAGC,GAAS,EAAE,CAAC,EAC3DE,GAAgBC,GAAS,CAClC,IAAKN,GACL,MAAOM,GAAS,CACZ,OAAQb,GACR,QAASA,EACjB,CAAK,CACL,CAAC,EACYc,GAAkBb,GAAOc,GAAQ,EAAIC,GAAQ,yBAAyB,CAAC,ECRpF,SAASvZ,GAAMC,EAAU,CACvB,GAAIA,EAAS,QAAU,IAAO,MAAM,IAAI,UAAU,mBAAmB,EACrE,MAAMC,EAAW,IAAI,WAAW,GAAG,EACnC,QAAS/W,EAAI,EAAGA,EAAI+W,EAAS,OAAQ/W,IACnC+W,EAAS/W,CAAC,EAAI,IAEhB,QAAShW,EAAI,EAAGA,EAAI8sB,EAAS,OAAQ9sB,IAAK,CACxC,MAAMpF,EAAIkyB,EAAS,OAAO9sB,CAAC,EACrBgtB,EAAKpyB,EAAE,WAAW,CAAC,EACzB,GAAImyB,EAASC,CAAE,IAAM,IAAO,MAAM,IAAI,UAAUpyB,EAAI,eAAe,EACnEmyB,EAASC,CAAE,EAAIhtB,CACjB,CACA,MAAMitB,EAAOH,EAAS,OAChBI,EAASJ,EAAS,OAAO,CAAC,EAC1BK,EAAS,KAAK,IAAIF,CAAI,EAAI,KAAK,IAAI,GAAG,EACtCG,EAAU,KAAK,IAAI,GAAG,EAAI,KAAK,IAAIH,CAAI,EAC7C,SAASI,EAAQlwB,EAAQ,CAOvB,GALIA,aAAkB,aAAyB,YAAY,OAAOA,CAAM,EACtEA,EAAS,IAAI,WAAWA,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,EAClE,MAAM,QAAQA,CAAM,IAC7BA,EAAS,WAAW,KAAKA,CAAM,IAE7B,EAAEA,aAAkB,YAAe,MAAM,IAAI,UAAU,qBAAqB,EAChF,GAAIA,EAAO,SAAW,EAAK,MAAO,GAElC,IAAImwB,EAAS,EACTjwB,EAAS,EACTkwB,EAAS,EACb,MAAMC,EAAOrwB,EAAO,OACpB,KAAOowB,IAAWC,GAAQrwB,EAAOowB,CAAM,IAAM,GAC3CA,IACAD,IAGF,MAAM9Z,GAASga,EAAOD,GAAUH,EAAU,IAAO,EAC3CK,EAAM,IAAI,WAAWja,CAAI,EAE/B,KAAO+Z,IAAWC,GAAM,CACtB,IAAIE,EAAQvwB,EAAOowB,CAAM,EAErBvtB,EAAI,EACR,QAAS2tB,EAAMna,EAAO,GAAIka,IAAU,GAAK1tB,EAAI3C,IAAYswB,IAAQ,GAAKA,IAAO3tB,IAC3E0tB,GAAU,IAAMD,EAAIE,CAAG,IAAO,EAC9BF,EAAIE,CAAG,EAAKD,EAAQT,IAAU,EAC9BS,EAASA,EAAQT,IAAU,EAE7B,GAAIS,IAAU,EAAK,MAAM,IAAI,MAAM,gBAAgB,EACnDrwB,EAAS2C,EACTutB,GACF,CAEA,IAAIK,EAAMpa,EAAOnW,EACjB,KAAOuwB,IAAQpa,GAAQia,EAAIG,CAAG,IAAM,GAClCA,IAGF,IAAIhsB,EAAMsrB,EAAO,OAAOI,CAAM,EAC9B,KAAOM,EAAMpa,EAAM,EAAEoa,EAAOhsB,GAAOkrB,EAAS,OAAOW,EAAIG,CAAG,CAAC,EAC3D,OAAOhsB,CACT,CACA,SAASisB,EAAc1wB,EAAQ,CAC7B,GAAI,OAAOA,GAAW,SAAY,MAAM,IAAI,UAAU,iBAAiB,EACvE,GAAIA,EAAO,SAAW,EAAK,OAAO,IAAI,WACtC,IAAI2wB,EAAM,EAENR,EAAS,EACTjwB,EAAS,EACb,KAAOF,EAAO2wB,CAAG,IAAMZ,GACrBI,IACAQ,IAGF,MAAMta,GAAUrW,EAAO,OAAS2wB,GAAOX,EAAU,IAAO,EAClDY,EAAO,IAAI,WAAWva,CAAI,EAEhC,KAAOsa,EAAM3wB,EAAO,QAAQ,CAE1B,MAAM6wB,EAAW7wB,EAAO,WAAW2wB,CAAG,EAEtC,GAAIE,EAAW,IAAO,OAEtB,IAAIN,EAAQX,EAASiB,CAAQ,EAE7B,GAAIN,IAAU,IAAO,OACrB,IAAI1tB,EAAI,EACR,QAASiuB,EAAMza,EAAO,GAAIka,IAAU,GAAK1tB,EAAI3C,IAAY4wB,IAAQ,GAAKA,IAAOjuB,IAC3E0tB,GAAUT,EAAOc,EAAKE,CAAG,IAAO,EAChCF,EAAKE,CAAG,EAAKP,EAAQ,MAAS,EAC9BA,EAASA,EAAQ,MAAS,EAE5B,GAAIA,IAAU,EAAK,MAAM,IAAI,MAAM,gBAAgB,EACnDrwB,EAAS2C,EACT8tB,GACF,CAEA,IAAII,EAAM1a,EAAOnW,EACjB,KAAO6wB,IAAQ1a,GAAQua,EAAKG,CAAG,IAAM,GACnCA,IAEF,MAAMC,EAAM,IAAI,WAAWb,GAAU9Z,EAAO0a,EAAI,EAChD,IAAIlY,EAAIsX,EACR,KAAOY,IAAQ1a,GACb2a,EAAInY,GAAG,EAAI+X,EAAKG,GAAK,EAEvB,OAAOC,CACT,CACA,SAASC,EAAQ3wB,EAAQ,CACvB,MAAMsB,EAAS8uB,EAAapwB,CAAM,EAClC,GAAIsB,EAAU,OAAOA,EACrB,MAAM,IAAI,MAAM,WAAakuB,EAAO,YAAY,CAClD,CACA,MAAO,CACL,OAAAI,EACA,aAAAQ,EACA,OAAAO,CACJ,CACA,CCzHA,IAAItB,GAAW,6DACf,MAAAwB,GAAe+X,GAAMvZ,EAAQ,ECAd,SAAAgC,GAAUP,EAAY,CAEjC,SAASlB,EAAOmB,EAAS,CACrB,IAAIC,EAAY,WAAW,KAAKD,CAAO,EACnCE,EAAWH,EAAWE,CAAS,EAC/BpxB,EAASoxB,EAAU,OAAS,EAC5BE,EAAO,IAAI,WAAWtxB,CAAM,EAChC,OAAAsxB,EAAK,IAAIF,EAAW,CAAC,EACrBE,EAAK,IAAID,EAAS,SAAS,EAAG,CAAC,EAAGD,EAAU,MAAM,EAC3CH,GAAO,OAAOK,CAAI,CAC7B,CACA,SAASC,EAAU7vB,EAAQ,CACvB,IAAIyvB,EAAUzvB,EAAO,MAAM,EAAG,EAAE,EAC5B2vB,EAAW3vB,EAAO,MAAM,EAAE,EAC1B8vB,EAAcN,EAAWC,CAAO,EAEpC,GAAI,EAAAE,EAAS,CAAC,EAAIG,EAAY,CAAC,EAC3BH,EAAS,CAAC,EAAIG,EAAY,CAAC,EAC3BH,EAAS,CAAC,EAAIG,EAAY,CAAC,EAC3BH,EAAS,CAAC,EAAIG,EAAY,CAAC,GAE/B,OAAOL,CACX,CAEA,SAASX,EAAajsB,EAAK,CACvB,IAAI7C,EAASuvB,GAAO,aAAa1sB,CAAG,EACpC,GAAI7C,GAAU,KAEd,OAAO6vB,EAAU7vB,CAAM,CAC3B,CACA,SAASqvB,EAAOxsB,EAAK,CACjB,IAAI7C,EAASuvB,GAAO,OAAO1sB,CAAG,EAC1B4sB,EAAUI,EAAU7vB,CAAM,EAC9B,GAAIyvB,GAAW,KACX,MAAM,IAAI,MAAM,kBAAkB,EACtC,OAAOA,CACX,CACA,MAAO,CACH,OAAQnB,EACR,OAAQe,EACR,aAAcP,CACtB,CACA,CCxCA,SAASkB,GAAShwB,EAAQ,CACtB,OAAO4tB,GAAOA,GAAO5tB,CAAM,CAAC,CAChC,CACA,MAAAunC,GAAexX,GAAcC,EAAQ,ECkB9B,SAASwX,GAAUpJ,EAASqJ,EAAYC,EAAY,CACvD,GAAID,EAAW,SAAW,GACtB,MAAM,IAAI,UAAU,2BAA2B,EACnD,IAAI7oC,EAAS,IAAI,WAAwB,EAAO,EAC5CmlB,EAAO,IAAI,SAASnlB,EAAO,MAAM,EACrC,OAAAmlB,EAAK,SAAS,EAAGqa,CAAO,EACxBx/B,EAAO,IAAI6oC,EAAY,CAAC,EAEpB7oC,EAAO,EAAE,EAAI,EAEVA,CACX,CAIO,SAAS0vB,GAAOqZ,EAAK,CACxB,OAAOJ,GAAU,OAAOC,GAAUG,EAAI,QAASA,EAAI,UAA0B,CAAC,CAClF,CClCA,MAAMC,GAAaxD,GAAYxW,EAAM,EAC/BqC,GAAY,CACd,OAASnuB,GAAS8lC,GAAW,OAAO9lC,CAAI,EACxC,OAASe,GAAQ+kC,GAAW,OAAO/kC,CAAG,CAC1C,EACO,SAASglC,GAAa5F,EAAK,CAC9BD,GAAQC,CAAG,EACX,MAAM6F,EAAU,CACZ,cAAe;AAAA,EACf,OAAQ,KACR,MAAO,CACH,OAAQ,SACR,QAAS,QACrB,EACQ,WAAY,EACZ,WAAY,EACZ,IAAK,GACb,EACUC,EAAc,WACpB,SAASC,EAAQC,EAAQ,CACrB,OAAOA,EAAO,SAAW,GAAKA,EAASA,EAAO,MAAM,EAAG,EAAE,CAC7D,CACA,MAAMC,CAAY,CACd,IACA,IACA,KAAO,GACP,YAAYC,EAAKC,EAAK,CAClB,KAAK,IAAMD,EACX,KAAK,IAAMC,CACf,CACA,IAAI,WAAY,CACZ,OAAI,KAAK,MAAQ,SACb,KAAK,IAAMnG,EAAI,gBAAgB,KAAK,IAAK,EAAI,GAC1C,KAAK,GAChB,CACA,IAAI,YAAa,CACb,OAAO,KAAK,GAChB,CACA,KAAK9C,EAAMkJ,EAAM,CACb,GAAI,CAAC,KAAK,WACN,MAAM,IAAI,MAAM,qBAAqB,EAGzC,GAFIA,IAAS,SACTA,EAAO,KAAK,MACZA,IAAS,GACT,OAAOpG,EAAI,KAAK9C,EAAM,KAAK,UAAU,EAEpC,CACD,IAAImJ,EAAMrG,EAAI,KAAK9C,EAAM,KAAK,UAAU,EACxC,MAAMoJ,EAAY,IAAI,WAAW,EAAE,EACnC,IAAIC,EAAU,EAGd,KAAOF,EAAI,CAAC,EAAI,KACZE,IACAC,GAAkBF,EAAW,EAAGC,EAAS,IAAI,EAC7CF,EAAMrG,EAAI,KAAK9C,EAAM,KAAK,WAAYoJ,CAAS,EAEnD,OAAOD,CACX,CACJ,CACA,YAAYnJ,EAAM,CACd,GAAI,CAAC,KAAK,WACN,MAAM,IAAI,MAAM,qBAAqB,EACzC,GAAI,CAAC8C,EAAI,YACL,MAAM,IAAI,MAAM,0CAA0C,EAC9D,OAAOA,EAAI,YAAY9C,EAAM,KAAK,UAAU,CAChD,CACA,OAAOA,EAAMuJ,EAAW,CACpB,OAAOzG,EAAI,OAAO9C,EAAM,KAAK,UAAWuJ,CAAS,CACrD,CACA,cAAcvJ,EAAMuJ,EAAW,CAC3B,GAAI,CAACzG,EAAI,cACL,MAAM,IAAI,MAAM,4CAA4C,EAChE,OAAOA,EAAI,cAAc9C,EAAM,KAAK,UAAU,SAAS,EAAG,EAAE,EAAGuJ,CAAS,CAC5E,CACR,CACI,MAAMC,UAAcT,CAAY,CAC5B,UACA,QACA,QACA,QACA,qBACA,YAAYC,EAAKC,EAAKQ,EAAWC,EAASC,EAAU,EAAGC,EAAU,EAAGC,EAAuB,EAAY,CACnG,MAAMb,EAAKC,CAAG,EACd,KAAK,UAAYQ,EACjB,KAAK,QAAUC,EACf,KAAK,QAAUC,EACf,KAAK,QAAUC,EACf,KAAK,qBAAuBC,EAC5BC,GAAQhC,GAAe4B,CAAO,CAClC,CACA,IAAI,OAAQ,CACR,OAAO,KAAK,OAChB,CACA,IAAI,OAAQ,CACR,OAAO,KAAK,OAChB,CACA,IAAI,mBAAoB,CACpB,OAAO,KAAK,oBAChB,CACA,IAAI,YAAa,CACb,OAAOK,GAAe,KAAK,SAAS,CACxC,CACA,IAAI,aAAc,CACd,OAAO,KAAK,WAAW,MAAM,EAAG,CAAC,CACrC,CACA,IAAI,YAAa,CACb,MAAO,EACX,CAGA,YAAa,CACT,OAAO,KAAK,MAAQ,MACxB,CACA,UAAW,CACP,OAAOC,EAAmB,KAAK,UAAW,KAAK,UAAW,KAAK,QAAS,KAAK,MAAO,KAAK,MAAO,KAAK,iBAAiB,CAC1H,CACA,UAAW,CACP,MAAMN,EAAU,KAAK,QACfzK,EAAW,KAAK,WAAU,EAE1ByK,EAAQ,MAAM,OADdA,EAAQ,MAAM,QAEd7oC,EAAS,IAAI,WAAW,EAAE,EAEhCyoC,OAAAA,GAAkBzoC,EAAQ,EAAGo+B,EAAS,IAAI,EAE1CgL,GAAiBppC,EAAQ,EAAG,KAAK,KAAK,EAEtCyoC,GAAkBzoC,EAAQ,EAAG,KAAK,kBAAmB,IAAI,EAGzDyoC,GAAkBzoC,EAAQ,EAAG,KAAK,MAAO,IAAI,EAE7CA,EAAO,IAAI,KAAK,UAAW,EAAE,EAExB,KAAK,aAQNA,EAAO,IAAI,KAAK,UAAW,EAAE,GAN7BopC,GAAiBppC,EAAQ,GAAI,CAAC,EAC9BA,EAAO,IAAI,KAAK,WAAY,EAAE,GAO3BiwB,GAAU,OAAOjwB,CAAM,CAClC,CACA,OAAQ,CACJ,GAAI,CAAC,KAAK,WACN,MAAM,IAAI,UAAU,qBAAqB,EAC7C,OAAOqpC,GAAW,CACd,QAAS,KAAK,QAAQ,IACtB,WAAY,KAAK,UAErB,CAAC,CACL,CAEA,OAAOhrC,EAAO,CACV4qC,GAAQ5C,GAAchoC,CAAK,EAC3B,MAAMirC,EAAajrC,GAAS0pC,EACtBjmC,EAAO,IAAI,WAAW,EAAE,EAE9B,GAAIwnC,EAAY,CACZ,GAAI,KAAK,WAAU,EACf,MAAM,IAAI,UAAU,4CAA4C,EAEpExnC,EAAK,CAAC,EAAI,EACVA,EAAK,IAAI,KAAK,WAAY,CAAC,EAC3B2mC,GAAkB3mC,EAAM,GAAIzD,EAAO,IAAI,CAE3C,MAIIyD,EAAK,IAAI,KAAK,UAAW,CAAC,EAC1B2mC,GAAkB3mC,EAAM,GAAIzD,EAAO,IAAI,EAE3C,MAAMvB,EAAIysC,GAAkB,KAAK,UAAWznC,CAAI,EAC1C0nC,EAAK1sC,EAAE,MAAM,EAAG,EAAE,EAClB2sC,EAAK3sC,EAAE,MAAM,EAAE,EAErB,GAAI,CAACmlC,EAAI,UAAUuH,CAAE,EACjB,OAAO,KAAK,OAAOnrC,EAAQ,CAAC,EAEhC,IAAIqrC,EACJ,GAAK,KAAK,aASL,CAGD,MAAMC,EAAK1H,EAAI,eAAe,KAAK,UAAWuH,EAAI,EAAI,EAEtD,GAAIG,IAAO,KACP,OAAO,KAAK,OAAOtrC,EAAQ,CAAC,EAChCqrC,EAAKP,EAAmBQ,EAAIF,EAAI,KAAK,QAAS,KAAK,MAAQ,EAAGprC,EAAOurC,GAAiB,KAAK,YAAa,EAAG,IAAI,CAAC,CACpH,KAjBwB,CAEpB,MAAMC,EAAK5H,EAAI,WAAW,KAAK,WAAYuH,CAAE,EAE7C,GAAIK,GAAM,KACN,OAAO,KAAK,OAAOxrC,EAAQ,CAAC,EAChCqrC,EAAKI,EAAoBD,EAAIJ,EAAI,KAAK,QAAS,KAAK,MAAQ,EAAGprC,EAAOurC,GAAiB,KAAK,YAAa,EAAG,IAAI,CAAC,CAErH,CAUA,OAAOF,CACX,CACA,eAAerrC,EAAO,CAClB,GAAI,OAAO4qC,GAAQtC,GAActoC,CAAK,GAAM,SAExC,OAAO,KAAK,OAAOA,EAAQ0pC,CAAW,EAC1C,MAAM,IAAI,UAAU,wBAA0B1pC,CAAK,CACvD,CACA,WAAW0rC,EAAM,CACbd,GAAQ9B,GAAiB4C,CAAI,EAC7B,IAAIxX,EAAYwX,EAAK,MAAM,GAAG,EAC9B,GAAIxX,EAAU,CAAC,IAAM,IAAK,CACtB,GAAI,KAAK,kBACL,MAAM,IAAI,UAAU,4BAA4B,EACpDA,EAAYA,EAAU,MAAM,CAAC,CACjC,CACA,OAAOA,EAAU,OAAO,CAACyX,EAAQC,IAAa,CAC1C,IAAI5rC,EACJ,OAAI4rC,EAAS,MAAM,EAAE,IAAM,KACvB5rC,EAAQ,SAAS4rC,EAAS,MAAM,EAAG,EAAE,EAAG,EAAE,EACnCD,EAAO,eAAe3rC,CAAK,IAGlCA,EAAQ,SAAS4rC,EAAU,EAAE,EACtBD,EAAO,OAAO3rC,CAAK,EAElC,EAAG,IAAI,CACX,CACA,MAAMlC,EAAG,CACL,OAAI,KAAK,WACE,KAAK,oBAAoBA,CAAC,EAC9B,KAAK,mBAAmBA,CAAC,CACpC,CACA,mBAAmBA,EAAG,CAClB,MAAM+tC,EAAclC,EAAQ,KAAK,SAAS,EAC1C,GAAI,CAAC/F,EAAI,mBACL,MAAM,IAAI,MAAM,iDAAiD,EACrE,MAAMkI,EAAmBlI,EAAI,mBAAmBiI,EAAa/tC,CAAC,EAC9D,GAAI,CAACguC,GAAoBA,EAAiB,cAAgB,KACtD,MAAM,IAAI,MAAM,0BAA0B,EAC9C,MAAMC,EAAa,WAAW,KAAK,CAC/BD,EAAiB,SAAW,EAAI,EAAO,CACvD,CAAa,EACKE,EAA4BC,GAAa,CAC3CF,EACAD,EAAiB,WACjC,CAAa,EACD,OAAO,IAAIjC,EAAY,OAAWmC,CAAyB,CAC/D,CACA,oBAAoBluC,EAAG,CACnB,MAAMouC,EAAU,KAAK,UAAU,CAAC,IAAM,GACjC,KAAK,UAAU,CAAC,IAAM,IAAM,KAAK,UAAU,EAAE,EAAI,KAAO,EACvD9C,GAAc,IAAM,CACtB,GAAK8C,EAEA,IAAKtI,EAAI,cAGV,OAAOA,EAAI,cAAc,KAAK,UAAU,EAFxC,MAAM,IAAI,MAAM,4CAA4C,MAF5D,QAAO,KAAK,UAKpB,GAAC,EACKuI,EAAoBvI,EAAI,WAAWwF,EAAYtrC,CAAC,EACtD,GAAI,CAACquC,EACD,MAAM,IAAI,MAAM,8BAA8B,EAClD,OAAO,IAAItC,EAAYsC,EAAmB,MAAS,CACvD,CACR,CACI,SAASC,EAAWC,EAAU7B,EAAS,CACnC,MAAM7oC,EAASiwB,GAAU,OAAOya,CAAQ,EACxC,GAAI1qC,EAAO,SAAW,GAClB,MAAM,IAAI,UAAU,uBAAuB,EAC/C6oC,EAAUA,GAAWf,EAErB,MAAM1J,EAAUwL,GAAiB5pC,EAAQ,EAAG,IAAI,EAChD,GAAIo+B,IAAYyK,EAAQ,MAAM,SAAWzK,IAAYyK,EAAQ,MAAM,OAC/D,MAAM,IAAI,UAAU,yBAAyB,EAEjD,MAAM9S,EAAQ/1B,EAAO,CAAC,EAEhB2qC,EAAoBf,GAAiB5pC,EAAQ,EAAG,IAAI,EAC1D,GAAI+1B,IAAU,GACN4U,IAAsB,EACtB,MAAM,IAAI,UAAU,4BAA4B,EAIxD,MAAMtsC,EAAQurC,GAAiB5pC,EAAQ,EAAG,IAAI,EAC9C,GAAI+1B,IAAU,GAAK13B,IAAU,EACzB,MAAM,IAAI,UAAU,eAAe,EAEvC,MAAMuqC,EAAY5oC,EAAO,MAAM,GAAI,EAAE,EACrC,IAAI0pC,EAEJ,GAAItL,IAAYyK,EAAQ,MAAM,QAAS,CACnC,GAAI7oC,EAAO,EAAE,IAAM,EACf,MAAM,IAAI,UAAU,qBAAqB,EAC7C,MAAMxE,EAAIwE,EAAO,MAAM,GAAI,EAAE,EAC7B0pC,EAAKI,EAAoBtuC,EAAGotC,EAAWC,EAAS9S,EAAO13B,EAAOssC,CAAiB,CAEnF,KACK,CACD,MAAMC,EAAI5qC,EAAO,MAAM,GAAI,EAAE,EAC7B0pC,EAAKP,EAAmByB,EAAGhC,EAAWC,EAAS9S,EAAO13B,EAAOssC,CAAiB,CAClF,CACA,OAAOjB,CACX,CACA,SAASmB,EAAepD,EAAYmB,EAAWC,EAAS,CACpD,OAAOiB,EAAoBrC,EAAYmB,EAAWC,CAAO,CAC7D,CACA,SAASiB,EAAoBrC,EAAYmB,EAAWC,EAAS9S,EAAO13B,EAAOssC,EAAmB,CAI1F,GAHA1B,GAAQpC,GAAcY,CAAU,EAChCwB,GAAQpC,GAAc+B,CAAS,EAC/BC,EAAUA,GAAWf,EACjB,CAAC7F,EAAI,UAAUwF,CAAU,EACzB,MAAM,IAAI,UAAU,iCAAiC,EACzD,OAAO,IAAIkB,EAAMlB,EAAY,OAAWmB,EAAWC,EAAS9S,EAAO13B,EAAOssC,CAAiB,CAC/F,CACA,SAASG,EAAcC,EAAWnC,EAAWC,EAAS,CAClD,OAAOM,EAAmB4B,EAAWnC,EAAWC,CAAO,CAC3D,CACA,SAASM,EAAmB4B,EAAWnC,EAAWC,EAAS9S,EAAO13B,EAAOssC,EAAmB,CAKxF,GAJA1B,GAAQjC,GAAe+D,CAAS,EAChC9B,GAAQpC,GAAc+B,CAAS,EAC/BC,EAAUA,GAAWf,EAEjB,CAAC7F,EAAI,QAAQ8I,CAAS,EACtB,MAAM,IAAI,UAAU,2BAA2B,EACnD,OAAO,IAAIpC,EAAM,OAAWoC,EAAWnC,EAAWC,EAAS9S,EAAO13B,EAAOssC,CAAiB,CAC9F,CACA,SAASK,EAASC,EAAMpC,EAAS,CAE7B,GADAI,GAAQnC,GAAW,UAAU,EAAGmE,CAAI,EAChCA,EAAK,OAAS,GACd,MAAM,IAAI,UAAU,kCAAkC,EAC1D,GAAIA,EAAK,OAAS,GACd,MAAM,IAAI,UAAU,iCAAiC,EACzDpC,EAAUA,GAAWf,EACrB,MAAMhrC,EAAIysC,GAAkB2B,GAAe,cAAc,EAAGD,CAAI,EAC1DzB,EAAK1sC,EAAE,MAAM,EAAG,EAAE,EAClB2sC,EAAK3sC,EAAE,MAAM,EAAE,EACrB,OAAO+tC,EAAerB,EAAIC,EAAIZ,CAAO,CACzC,CACA,MAAO,CACH,SAAAmC,EACA,WAAAP,EACA,cAAAK,EACA,eAAAD,CACR,CACA,uDCpWA,OAAO,eAAepK,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,WAAqBA,GAAA,WAAqBA,GAAA,WAAqBA,cAAqBA,GAAA,OAAiBA,GAAA,OAAiBA,GAAA,OAAiBA,GAAA,OAAiB,OASxJ,MAAM5S,EAAYjwB,GAAA,EAElB,OAAA6iC,GAAA,OAAiB5S,EAAU,OAE3B4S,GAAA,OAAiB5S,EAAU,OAE3B4S,GAAA,OAAiB5S,EAAU,OAE3B4S,GAAA,OAAiB5S,EAAU,OAE3B4S,GAAA,WAAqB5S,EAAU,WAE/B4S,GAAA,WAAqB5S,EAAU,WAE/B4S,GAAA,WAAqB5S,EAAU,WAE/B4S,GAAA,WAAqB5S,EAAU,6EC1B/B,OAAO,eAAc9xB,EAAU,aAAc,CAAE,MAAO,GAAM,EAC5DA,EAAA,KAAeA,EAAA,KAAe,OAK9B,MAAM+nB,EAAalmB,GAAA,EACnB,MAAMshC,UAAapb,EAAW,IAAK,CAC/B,YAAYqb,EAAMC,EAAM,CACpB,MAAK,EACL,KAAK,SAAW,GAChB,KAAK,UAAY,MACbtb,EAAW,OAAOqb,CAAI,EAC1B,MAAM5gC,KAAUulB,EAAW,SAASsb,CAAI,EAExC,GADA,KAAK,MAAQD,EAAK,OAAM,EACpB,OAAO,KAAK,MAAM,QAAW,WAC7B,MAAM,IAAI,MAAM,qDAAqD,EACzE,KAAK,SAAW,KAAK,MAAM,SAC3B,KAAK,UAAY,KAAK,MAAM,UAC5B,MAAM9a,EAAW,KAAK,SAChBlB,EAAM,IAAI,WAAWkB,CAAQ,EAEnClB,EAAI,IAAI5kB,EAAI,OAAS8lB,EAAW8a,EAAK,OAAM,EAAG,OAAO5gC,CAAG,EAAE,OAAM,EAAKA,CAAG,EACxE,QAAS0C,EAAI,EAAGA,EAAIkiB,EAAI,OAAQliB,IAC5BkiB,EAAIliB,CAAC,GAAK,GACd,KAAK,MAAM,OAAOkiB,CAAG,EAErB,KAAK,MAAQgc,EAAK,OAAM,EAExB,QAASl+B,EAAI,EAAGA,EAAIkiB,EAAI,OAAQliB,IAC5BkiB,EAAIliB,CAAC,GAAK,IACd,KAAK,MAAM,OAAOkiB,CAAG,KACjBW,EAAW,OAAOX,CAAG,CACjC,CACI,OAAOtP,EAAK,CACR,SAAIiQ,EAAW,SAAS,IAAI,EAC5B,KAAK,MAAM,OAAOjQ,CAAG,EACd,IACf,CACI,WAAW2E,EAAK,IACRsL,EAAW,SAAS,IAAI,KACxBA,EAAW,QAAQtL,EAAK,KAAK,SAAS,EAC1C,KAAK,SAAW,GAChB,KAAK,MAAM,WAAWA,CAAG,EACzB,KAAK,MAAM,OAAOA,CAAG,EACrB,KAAK,MAAM,WAAWA,CAAG,EACzB,KAAK,QAAO,CACpB,CACI,QAAS,CACL,MAAMA,EAAM,IAAI,WAAW,KAAK,MAAM,SAAS,EAC/C,YAAK,WAAWA,CAAG,EACZA,CACf,CACI,WAAWoM,EAAI,CAEXA,IAAOA,EAAK,OAAO,OAAO,OAAO,eAAe,IAAI,EAAG,CAAA,CAAE,GACzD,KAAM,CAAE,MAAAya,EAAO,MAAAC,EAAO,SAAAza,EAAU,UAAAC,EAAW,SAAAT,EAAU,UAAAC,CAAS,EAAK,KACnE,OAAAM,EAAKA,EACLA,EAAG,SAAWC,EACdD,EAAG,UAAYE,EACfF,EAAG,SAAWP,EACdO,EAAG,UAAYN,EACfM,EAAG,MAAQya,EAAM,WAAWza,EAAG,KAAK,EACpCA,EAAG,MAAQ0a,EAAM,WAAW1a,EAAG,KAAK,EAC7BA,CACf,CACI,OAAQ,CACJ,OAAO,KAAK,WAAU,CAC9B,CACI,SAAU,CACN,KAAK,UAAY,GACjB,KAAK,MAAM,QAAO,EAClB,KAAK,MAAM,QAAO,CAC1B,CACA,CACA7oB,EAAA,KAAemjC,EAWf,MAAMK,EAAO,CAACJ,EAAM5gC,EAAKoB,IAAY,IAAIu/B,EAAKC,EAAM5gC,CAAG,EAAE,OAAOoB,CAAO,EAAE,OAAM,EAC/E5D,EAAA,KAAewjC,EACfxjC,EAAQ,KAAK,OAAS,CAACojC,EAAM5gC,IAAQ,IAAI2gC,EAAKC,EAAM5gC,CAAG,sDCxFvD,OAAO,eAAe4sC,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,OAAiBC,EACjBD,GAAA,YAAsBE,EAKtB,MAAMC,EAAY1tC,GAAA,EAEZkmB,EAAa/G,GAAA,EAEnB,SAASwuB,EAAWpM,EAAMqM,EAAWC,EAAOC,EAAO,IAC3C5nB,EAAW,OAAOqb,CAAI,EAC1B,MAAM9b,KAAWS,EAAW,WAAW,CAAE,MAAO,GAAI,UAAW,EAAE,EAAI4nB,CAAK,EACpE,CAAE,EAAAvwC,EAAG,MAAAwwC,EAAO,UAAAC,CAAS,EAAKvoB,EAIhC,MAHIS,EAAW,SAAS3oB,CAAC,KACrB2oB,EAAW,SAAS6nB,CAAK,KACzB7nB,EAAW,SAAS8nB,CAAS,EAC7BzwC,EAAI,EACJ,MAAM,IAAI,MAAM,+BAA+B,EACnD,MAAM0wC,KAAe/nB,EAAW,iBAAiB0nB,CAAS,EACpDM,KAAWhoB,EAAW,iBAAiB2nB,CAAK,EAE5CM,EAAK,IAAI,WAAWJ,CAAK,EAEzBK,EAAMV,EAAU,KAAK,OAAOnM,EAAM0M,CAAQ,EAC1CI,EAAUD,EAAI,WAAU,EAAG,OAAOF,CAAI,EAC5C,MAAO,CAAE,EAAA3wC,EAAG,MAAAwwC,EAAO,UAAAC,EAAW,GAAAG,EAAI,IAAAC,EAAK,QAAAC,CAAO,CAClD,CACA,SAASC,EAAaF,EAAKC,EAASF,EAAII,EAAM/vC,EAAG,CAC7C,OAAA4vC,EAAI,QAAO,EACXC,EAAQ,QAAO,EACXE,GACAA,EAAK,QAAO,KACZroB,EAAW,OAAO1nB,CAAC,EAChB2vC,CACX,CAUA,SAASX,EAAOjM,EAAM0M,EAAUC,EAAMzoB,EAAM,CACxC,KAAM,CAAE,EAAAloB,EAAG,MAAAwwC,EAAO,GAAAI,EAAI,IAAAC,EAAK,QAAAC,GAAYV,EAAWpM,EAAM0M,EAAUC,EAAMzoB,CAAI,EAC5E,IAAI8oB,EACJ,MAAMx6B,EAAM,IAAI,WAAW,CAAC,EACtBoS,KAAWD,EAAW,YAAYnS,CAAG,EACrCvV,EAAI,IAAI,WAAW4vC,EAAI,SAAS,EAEtC,QAASI,EAAK,EAAG92B,EAAM,EAAGA,EAAMq2B,EAAOS,IAAM92B,GAAO02B,EAAI,UAAW,CAE/D,MAAMK,EAAKN,EAAG,SAASz2B,EAAKA,EAAM02B,EAAI,SAAS,EAC/CjoB,EAAK,SAAS,EAAGqoB,EAAI,EAAK,GAGzBD,EAAOF,EAAQ,WAAWE,CAAI,GAAG,OAAOx6B,CAAG,EAAE,WAAWvV,CAAC,EAC1DiwC,EAAG,IAAIjwC,EAAE,SAAS,EAAGiwC,EAAG,MAAM,CAAC,EAC/B,QAASC,EAAK,EAAGA,EAAKnxC,EAAGmxC,IAAM,CAE3BN,EAAI,WAAWG,CAAI,EAAE,OAAO/vC,CAAC,EAAE,WAAWA,CAAC,EAC3C,QAAS6E,EAAI,EAAGA,EAAIorC,EAAG,OAAQprC,IAC3BorC,EAAGprC,CAAC,GAAK7E,EAAE6E,CAAC,CAC5B,CACA,CACI,OAAOirC,EAAaF,EAAKC,EAASF,EAAII,EAAM/vC,CAAC,CACjD,CAMA,eAAeivC,EAAYlM,EAAM0M,EAAUC,EAAMzoB,EAAM,CACnD,KAAM,CAAE,EAAAloB,EAAG,MAAAwwC,EAAO,UAAAC,EAAW,GAAAG,EAAI,IAAAC,EAAK,QAAAC,CAAO,EAAKV,EAAWpM,EAAM0M,EAAUC,EAAMzoB,CAAI,EACvF,IAAI8oB,EACJ,MAAMx6B,EAAM,IAAI,WAAW,CAAC,EACtBoS,KAAWD,EAAW,YAAYnS,CAAG,EACrCvV,EAAI,IAAI,WAAW4vC,EAAI,SAAS,EAEtC,QAASI,EAAK,EAAG92B,EAAM,EAAGA,EAAMq2B,EAAOS,IAAM92B,GAAO02B,EAAI,UAAW,CAE/D,MAAMK,EAAKN,EAAG,SAASz2B,EAAKA,EAAM02B,EAAI,SAAS,EAC/CjoB,EAAK,SAAS,EAAGqoB,EAAI,EAAK,GAGzBD,EAAOF,EAAQ,WAAWE,CAAI,GAAG,OAAOx6B,CAAG,EAAE,WAAWvV,CAAC,EAC1DiwC,EAAG,IAAIjwC,EAAE,SAAS,EAAGiwC,EAAG,MAAM,CAAC,EAC/B,QAAUvoB,EAAW,WAAW3oB,EAAI,EAAGywC,EAAW,IAAM,CAEpDI,EAAI,WAAWG,CAAI,EAAE,OAAO/vC,CAAC,EAAE,WAAWA,CAAC,EAC3C,QAAS6E,EAAI,EAAGA,EAAIorC,EAAG,OAAQprC,IAC3BorC,EAAGprC,CAAC,GAAK7E,EAAE6E,CAAC,CAC5B,CAAS,CACT,CACI,OAAOirC,EAAaF,EAAKC,EAASF,EAAII,EAAM/vC,CAAC,CACjD,6i/JClGA,OAAO,eAAemwC,GAAS,aAAc,CAAE,MAAO,GAAM,EAI5D,MAAMC,EAAY,CAAA,EAClBD,GAAA,UAAoBC,EACpB,IAAIxkC,EACJukC,GAAA,SAAmBvkC,EACnB,GAAI,CACAukC,GAAA,SAAmBvkC,EAAWpK,GAC9B4uC,EAAU,MAAQxkC,CACtB,MACY,CAAA,CACZ,GAAI,CACAukC,GAAA,SAAmBvkC,EAAW+U,GAC9ByvB,EAAU,mBAAqBxkC,CACnC,MACY,CAAA,CACZ,GAAI,CACAukC,GAAA,SAAmBvkC,EAAW4X,GAC9B4sB,EAAU,oBAAsBxkC,CACpC,MACY,CAAA,CACZ,GAAI,CACAukC,GAAA,SAAmBvkC,EAAWsvB,GAC9BkV,EAAU,OAASxkC,CACvB,MACY,CAAA,CACZ,GAAI,CACAukC,GAAA,SAAmBvkC,EAAWuvB,GAC9BiV,EAAU,OAASxkC,CACvB,MACY,CAAA,CACZ,GAAI,CACAukC,GAAA,SAAmBvkC,EAAWwvB,GAC9BgV,EAAU,QAAUxkC,CACxB,MACY,CAAA,CACZ,GAAI,CACAukC,GAAA,SAAmBvkC,EAAWyvB,GAC9B+U,EAAU,QAAUxkC,CACxB,MACY,CAAA,CACZ,GAAI,CACAukC,GAAA,SAAmBvkC,EAAW0vB,GAC9B8U,EAAU,SAAWxkC,EACrBwkC,EAAU,GAAKxkC,CACnB,MACY,CAAA,CACZ,GAAI,CACAukC,GAAA,SAAmBvkC,EAAW2vB,GAC9B6U,EAAU,WAAaxkC,CAC3B,MACY,CAAA,CACZ,GAAI,CACAukC,GAAA,SAAmBvkC,EAAW4vB,GAC9B4U,EAAU,QAAUxkC,EACpBwkC,EAAU,GAAKxkC,CACnB,MACY,CAAA,qDC3DZ,OAAO,eAAekT,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5D,MAAMuxB,EAAW7uC,GAAA,EACX8uC,EAAW3vB,GAAA,EACXouB,EAAWvrB,GAAA,EACX6e,EAAUnH,GAAA,EACVqV,EAAepV,GAAA,EACrB,IAAIqV,EAAmBD,EAAa,SACpC,MAAME,EAAmB,mBACnBC,EAAkB,kBAClBC,EAAmB,4BACnBC,EAAoB;AAAA,2CAE1B,SAASC,EAAUpqC,EAAK,CACpB,OAAQA,GAAO,IAAI,UAAU,MAAM,CACvC,CACA,SAASqqC,EAAKrqC,EAAKsqC,EAAW7uC,EAAQ,CAClC,KAAOuE,EAAI,OAASvE,GAChBuE,EAAMsqC,EAAYtqC,EAEtB,OAAOA,CACX,CACA,SAASuqC,EAAaC,EAAK,CACvB,OAAO,SAASA,EAAK,CAAC,CAC1B,CACA,SAASC,EAAc50B,EAAO,CAC1B,OAAOA,EAAM,IAAK7c,GAAMqxC,EAAKrxC,EAAE,SAAS,CAAC,EAAG,IAAK,CAAC,CAAC,EAAE,KAAK,EAAE,CAChE,CACA,SAAS0xC,EAAmBC,EAAe,CAEvC,MAAMC,EADMD,EAAc,OAAS,EAClB,GACXrO,EAAOsN,EAAS,OAAO,WAAW,KAAKe,CAAa,CAAC,EAC3D,OAAOF,EAAc,MAAM,KAAKnO,CAAI,CAAC,EAAE,MAAM,EAAGsO,CAAE,CACtD,CACA,SAAS3B,EAAKD,EAAU,CACpB,MAAO,YAAcA,GAAY,GACrC,CACA,SAAS6B,EAAmBC,EAAU9B,EAAU,CAC5C,MAAM+B,EAAiB,WAAW,KAAKx6B,GAAO,KAAK65B,EAAUU,CAAQ,EAAG,MAAM,CAAC,EACzEE,EAAa,WAAW,KAAKz6B,GAAO,KAAK04B,EAAKmB,EAAUpB,CAAQ,CAAC,EAAG,MAAM,CAAC,EAC3EnnC,EAAMymC,EAAS,OAAOuB,EAAS,OAAQkB,EAAgBC,EAAY,CACrE,EAAG,KACH,MAAO,EACf,CAAK,EACD,OAAOz6B,GAAO,KAAK1O,CAAG,CAC1B,CACAwW,GAAA,mBAA6BwyB,EAC7B,SAASI,EAAeH,EAAU9B,EAAU,CACxC,MAAM+B,EAAiB,WAAW,KAAKx6B,GAAO,KAAK65B,EAAUU,CAAQ,EAAG,MAAM,CAAC,EACzEE,EAAa,WAAW,KAAKz6B,GAAO,KAAK04B,EAAKmB,EAAUpB,CAAQ,CAAC,EAAG,MAAM,CAAC,EACjF,OAAOV,EAAS,YAAYuB,EAAS,OAAQkB,EAAgBC,EAAY,CACrE,EAAG,KACH,MAAO,EACf,CAAK,EAAE,KAAMnpC,GAAQ0O,GAAO,KAAK1O,CAAG,CAAC,CACrC,CACAwW,GAAA,eAAyB4yB,EACzB,SAASC,EAAkBJ,EAAUK,EAAU,CAE3C,GADAA,EAAWA,GAAYpB,EACnB,CAACoB,EACD,MAAM,IAAI,MAAMhB,CAAiB,EAErC,MAAMjc,EAAQkc,EAAUU,CAAQ,EAAE,MAAM,GAAG,EAC3C,GAAI5c,EAAM,OAAS,IAAM,EACrB,MAAM,IAAI,MAAM8b,CAAgB,EAGpC,MAAMnmC,EAAOqqB,EACR,IAAKjP,GAAS,CACf,MAAMzjB,EAAQ2vC,EAAS,QAAQlsB,CAAI,EACnC,GAAIzjB,IAAU,GACV,MAAM,IAAI,MAAMwuC,CAAgB,EAEpC,OAAOK,EAAK7uC,EAAM,SAAS,CAAC,EAAG,IAAK,EAAE,CAC9C,CAAK,EACI,KAAK,EAAE,EAEN4vC,EAAe,KAAK,MAAMvnC,EAAK,OAAS,EAAE,EAAI,GAC9CwnC,EAAcxnC,EAAK,MAAM,EAAGunC,CAAY,EACxCE,EAAeznC,EAAK,MAAMunC,CAAY,EAEtCG,EAAeF,EAAY,MAAM,WAAW,EAAE,IAAId,CAAY,EACpE,GAAIgB,EAAa,OAAS,GACtB,MAAM,IAAI,MAAMtB,CAAe,EAEnC,GAAIsB,EAAa,OAAS,GACtB,MAAM,IAAI,MAAMtB,CAAe,EAEnC,GAAIsB,EAAa,OAAS,IAAM,EAC5B,MAAM,IAAI,MAAMtB,CAAe,EAEnC,MAAMuB,EAAUj7B,GAAO,KAAKg7B,CAAY,EAExC,GADoBb,EAAmBc,CAAO,IAC1BF,EAChB,MAAM,IAAI,MAAMpB,CAAgB,EAEpC,OAAOsB,EAAQ,SAAS,KAAK,CACjC,CACAnzB,GAAA,kBAA4B6yB,EAC5B,SAASO,EAAkBD,EAASL,EAAU,CAK1C,GAJK56B,GAAO,SAASi7B,CAAO,IACxBA,EAAUj7B,GAAO,KAAKi7B,EAAS,KAAK,GAExCL,EAAWA,GAAYpB,EACnB,CAACoB,EACD,MAAM,IAAI,MAAMhB,CAAiB,EAGrC,GAAIqB,EAAQ,OAAS,GACjB,MAAM,IAAI,UAAUvB,CAAe,EAEvC,GAAIuB,EAAQ,OAAS,GACjB,MAAM,IAAI,UAAUvB,CAAe,EAEvC,GAAIuB,EAAQ,OAAS,IAAM,EACvB,MAAM,IAAI,UAAUvB,CAAe,EAEvC,MAAMoB,EAAcZ,EAAc,MAAM,KAAKe,CAAO,CAAC,EAC/CF,EAAeZ,EAAmBc,CAAO,EAGzCtd,GAFOmd,EAAcC,GACP,MAAM,YAAY,EACjB,IAAKtnC,GAAW,CACjC,MAAMxI,EAAQ+uC,EAAavmC,CAAM,EACjC,OAAOmnC,EAAS3vC,CAAK,CAC7B,CAAK,EACD,OAAO2vC,EAAS,CAAC,IAAM,SACjBjd,EAAM,KAAK,GAAQ,EACnBA,EAAM,KAAK,GAAG,CACxB,CACA7V,GAAA,kBAA4BozB,EAC5B,SAASC,EAAiBC,EAAUC,EAAKT,EAAU,CAE/C,GADAQ,EAAWA,GAAY,IACnBA,EAAW,KAAO,EAClB,MAAM,IAAI,UAAU1B,CAAe,EAEvC,OAAA2B,EAAMA,IAASh6B,GAASrB,GAAO,KAAKqrB,EAAQ,YAAYhqB,CAAI,CAAC,GACtD65B,EAAkBG,EAAID,EAAW,CAAC,EAAGR,CAAQ,CACxD,CACA9yB,GAAA,iBAA2BqzB,EAC3B,SAASG,EAAiBf,EAAUK,EAAU,CAC1C,GAAI,CACAD,EAAkBJ,EAAUK,CAAQ,CAC5C,MACc,CACN,MAAO,EACf,CACI,MAAO,EACX,CACA9yB,GAAA,iBAA2BwzB,EAC3B,SAASC,EAAmBC,EAAU,CAClC,MAAMhwC,EAAS+tC,EAAa,UAAUiC,CAAQ,EAC9C,GAAIhwC,EACAguC,EAAmBhuC,MAGnB,OAAM,IAAI,MAAM,yCAA2CgwC,EAAW,GAAG,CAEjF,CACA1zB,GAAA,mBAA6ByzB,EAC7B,SAASE,GAAqB,CAC1B,GAAI,CAACjC,EACD,MAAM,IAAI,MAAM,yBAAyB,EAE7C,OAAO,OAAO,KAAKD,EAAa,SAAS,EAAE,OAAQjI,GAC3CA,IAAS,MAAQA,IAAS,KACnB,GAEJiI,EAAa,UAAUjI,CAAI,EAAE,MAAM,CAAC5iB,EAAMzjB,IAAUyjB,IAAS8qB,EAAiBvuC,CAAK,CAAC,CAC9F,EAAE,CAAC,CACR,CACA6c,GAAA,mBAA6B2zB,EAC7B,IAAIC,EAAevX,GAAA,EACnB,OAAArc,GAAA,UAAoB4zB,EAAa,gGC1KjC,OAAO,eAAc/yC,EAAU,aAAc,CAAE,MAAO,GAAM,EAC5DA,EAAA,eAAyBA,EAAA,QAAkBA,EAAA,YAAsBA,EAAA,YAAsBA,EAAA,QAAkBA,EAAA,WAAqBA,EAAA,YAAsBA,EAAA,YAAsBA,EAAA,WAAqBA,EAAA,QAAkBA,EAAA,OAAiB,OAClOA,EAAA,MAAgBgzC,EAChBhzC,EAAA,QAAkBizC,EAClBjzC,EAAA,SAAmBkzC,EACnBlzC,EAAA,oBAA8BmzC,EAC9BnzC,EAAA,YAAsBozC,EACtBpzC,EAAA,gBAA0BqzC,EAC1BrzC,EAAA,gBAA0BszC,EAC1BtzC,EAAA,gBAA0BuzC,EAC1BvzC,EAAA,gBAA0BwzC,EAC1BxzC,EAAA,mBAA6ByzC,EAC7BzzC,EAAA,YAAsB0zC,EACtB1zC,EAAA,WAAqB2zC,EACrB3zC,EAAA,UAAoB4zC,EACpB5zC,EAAA,aAAuB0b,EACvB1b,EAAA,QAAkB6zC,EAClB7zC,EAAA,SAAmB8zC,EACnB9zC,EAAA,OAAiB+zC,EACjB/zC,EAAA,OAAiBg0C,EACjBh0C,EAAA,OAAiBi0C,EACjBj0C,EAAA,eAAyBk0C,EACzBl0C,EAAA,eAAyBm0C,EACzBn0C,EAAA,OAAiBo0C,EACjBp0C,EAAA,gBAA0Bq0C,EAC1Br0C,EAAA,SAAmBs0C,EAKnB,sEACA,MAAMC,EAAa1yC,GAAA,EACnB,IAAI2yC,EAAa3yC,GAAA,EACjB,OAAO,eAAe7B,EAAS,SAAU,CAAE,WAAY,GAAM,IAAK,UAAY,CAAE,OAAOw0C,EAAW,MAAO,CAAE,CAAE,EAC7G,OAAO,eAAex0C,EAAS,UAAW,CAAE,WAAY,GAAM,IAAK,UAAY,CAAE,OAAOw0C,EAAW,OAAQ,CAAE,CAAE,EAC/G,OAAO,eAAex0C,EAAS,aAAc,CAAE,WAAY,GAAM,IAAK,UAAY,CAAE,OAAOw0C,EAAW,UAAW,CAAE,CAAE,EACrH,OAAO,eAAex0C,EAAS,cAAe,CAAE,WAAY,GAAM,IAAK,UAAY,CAAE,OAAOw0C,EAAW,WAAY,CAAE,CAAE,EACvH,OAAO,eAAex0C,EAAS,cAAe,CAAE,WAAY,GAAM,IAAK,UAAY,CAAE,OAAOw0C,EAAW,WAAY,CAAE,CAAE,EACvH,OAAO,eAAex0C,EAAS,aAAc,CAAE,WAAY,GAAM,IAAK,UAAY,CAAE,OAAOw0C,EAAW,UAAW,CAAE,CAAE,EACrH,OAAO,eAAex0C,EAAS,UAAW,CAAE,WAAY,GAAM,IAAK,UAAY,CAAE,OAAOw0C,EAAW,OAAQ,CAAE,CAAE,EAC/G,OAAO,eAAex0C,EAAS,cAAe,CAAE,WAAY,GAAM,IAAK,UAAY,CAAE,OAAOw0C,EAAW,WAAY,CAAE,CAAE,EACvH,OAAO,eAAex0C,EAAS,cAAe,CAAE,WAAY,GAAM,IAAK,UAAY,CAAE,OAAOw0C,EAAW,WAAY,CAAE,CAAE,EACvH,MAAMC,EAAsB,OAAO,CAAC,EAC9BC,EAAsB,OAAO,CAAC,EACpC,SAAS1B,EAAM2B,EAAO1sC,EAAO,CACzB,GAAI,OAAOA,GAAU,UACjB,MAAM,IAAI,MAAM0sC,EAAQ,0BAA4B1sC,CAAK,CACjE,CAEA,SAASgrC,EAAQhrC,EAAO0sC,EAAQ,GAAI,CAChC,GAAI,OAAO1sC,GAAU,UAAW,CAC5B,MAAMsG,EAASomC,GAAS,IAAIA,CAAK,IACjC,MAAM,IAAI,MAAMpmC,EAAS,8BAAgC,OAAOtG,CAAK,CAC7E,CACI,OAAOA,CACX,CAGA,SAASirC,EAASjrC,EAAO1F,EAAQoyC,EAAQ,GAAI,CACzC,MAAMh4B,KAAY43B,EAAW,SAAStsC,CAAK,EACrCoN,EAAMpN,GAAO,OACb2sC,EAAWryC,IAAW,OAC5B,GAAI,CAACoa,GAAUi4B,GAAYv/B,IAAQ9S,EAAS,CACxC,MAAMgM,EAASomC,GAAS,IAAIA,CAAK,KAC3BE,EAAQD,EAAW,cAAcryC,CAAM,GAAK,GAC5CuyC,GAAMn4B,EAAQ,UAAUtH,CAAG,GAAK,QAAQ,OAAOpN,CAAK,GAC1D,MAAM,IAAI,MAAMsG,EAAS,sBAAwBsmC,EAAQ,SAAWC,EAAG,CAC/E,CACI,OAAO7sC,CACX,CAEA,SAASkrC,EAAoBp9B,EAAK,CAC9B,MAAMqQ,EAAMrQ,EAAI,SAAS,EAAE,EAC3B,OAAOqQ,EAAI,OAAS,EAAI,IAAMA,EAAMA,CACxC,CACA,SAASgtB,EAAYhtB,EAAK,CACtB,GAAI,OAAOA,GAAQ,SACf,MAAM,IAAI,MAAM,4BAA8B,OAAOA,CAAG,EAC5D,OAAOA,IAAQ,GAAKquB,EAAM,OAAO,KAAOruB,CAAG,CAC/C,CAEA,SAASitB,EAAgB12B,EAAO,CAC5B,OAAOy2B,KAAgBmB,EAAW,YAAY53B,CAAK,CAAC,CACxD,CACA,SAAS22B,EAAgB32B,EAAO,CAC5B,SAAI43B,EAAW,QAAQ53B,CAAK,EACrBy2B,KAAgBmB,EAAW,YAAY,WAAW,KAAK53B,CAAK,EAAE,QAAO,CAAE,CAAC,CACnF,CACA,SAAS42B,EAAgB1zC,EAAGwV,EAAK,CAC7B,SAAWk/B,EAAW,YAAY10C,EAAE,SAAS,EAAE,EAAE,SAASwV,EAAM,EAAG,GAAG,CAAC,CAC3E,CACA,SAASm+B,EAAgB3zC,EAAGwV,EAAK,CAC7B,OAAOk+B,EAAgB1zC,EAAGwV,CAAG,EAAE,QAAO,CAC1C,CAEA,SAASo+B,EAAmB5zC,EAAG,CAC3B,SAAW00C,EAAW,YAAYpB,EAAoBtzC,CAAC,CAAC,CAC5D,CAUA,SAAS6zC,EAAYiB,EAAOvuB,EAAK2uB,EAAgB,CAC7C,IAAIpsC,EACJ,GAAI,OAAOyd,GAAQ,SACf,GAAI,CACAzd,KAAU4rC,EAAW,YAAYnuB,CAAG,CAChD,OACe9mB,EAAG,CACN,MAAM,IAAI,MAAMq1C,EAAQ,6CAA+Cr1C,CAAC,CACpF,YAEiBi1C,EAAW,SAASnuB,CAAG,EAGhCzd,EAAM,WAAW,KAAKyd,CAAG,MAGzB,OAAM,IAAI,MAAMuuB,EAAQ,mCAAmC,EAE/D,MAAMt/B,EAAM1M,EAAI,OAChB,GAAI,OAAOosC,GAAmB,UAAY1/B,IAAQ0/B,EAC9C,MAAM,IAAI,MAAMJ,EAAQ,cAAgBI,EAAiB,kBAAoB1/B,CAAG,EACpF,OAAO1M,CACX,CAEA,SAASgrC,EAAWz0C,EAAGC,EAAG,CACtB,GAAID,EAAE,SAAWC,EAAE,OACf,MAAO,GACX,IAAI+nB,EAAO,EACX,QAAShiB,EAAI,EAAGA,EAAIhG,EAAE,OAAQgG,IAC1BgiB,GAAQhoB,EAAEgG,CAAC,EAAI/F,EAAE+F,CAAC,EACtB,OAAOgiB,IAAS,CACpB,CAKA,SAAS0sB,EAAUj3B,EAAO,CACtB,OAAO,WAAW,KAAKA,CAAK,CAChC,CAMA,SAASjB,EAAas5B,EAAO,CACzB,OAAO,WAAW,KAAKA,EAAO,CAAC51C,EAAG8F,IAAM,CACpC,MAAMguB,EAAW9zB,EAAE,WAAW,CAAC,EAC/B,GAAIA,EAAE,SAAW,GAAK8zB,EAAW,IAC7B,MAAM,IAAI,MAAM,wCAAwC8hB,EAAM9vC,CAAC,CAAC,eAAeguB,CAAQ,gBAAgBhuB,CAAC,EAAE,EAE9G,OAAOguB,CACf,CAAK,CACL,CAWA,MAAM+hB,EAAYp1C,GAAM,OAAOA,GAAM,UAAY40C,GAAO50C,EACxD,SAASg0C,EAAQh0C,EAAG4d,EAAK/Y,EAAK,CAC1B,OAAOuwC,EAASp1C,CAAC,GAAKo1C,EAASx3B,CAAG,GAAKw3B,EAASvwC,CAAG,GAAK+Y,GAAO5d,GAAKA,EAAI6E,CAC5E,CAMA,SAASovC,EAASa,EAAO90C,EAAG4d,EAAK/Y,EAAK,CAMlC,GAAI,CAACmvC,EAAQh0C,EAAG4d,EAAK/Y,CAAG,EACpB,MAAM,IAAI,MAAM,kBAAoBiwC,EAAQ,KAAOl3B,EAAM,WAAa/Y,EAAM,SAAW7E,CAAC,CAChG,CAOA,SAASk0C,EAAOl0C,EAAG,CACf,IAAIwV,EACJ,IAAKA,EAAM,EAAGxV,EAAI40C,EAAK50C,IAAM60C,EAAKr/B,GAAO,EACrC,CACJ,OAAOA,CACX,CAMA,SAAS2+B,EAAOn0C,EAAG0Z,EAAK,CACpB,OAAQ1Z,GAAK,OAAO0Z,CAAG,EAAKm7B,CAChC,CAIA,SAAST,EAAOp0C,EAAG0Z,EAAKtR,EAAO,CAC3B,OAAOpI,GAAMoI,EAAQysC,EAAMD,IAAQ,OAAOl7B,CAAG,CACjD,CAKA,MAAM27B,EAAWr1C,IAAO60C,GAAO,OAAO70C,CAAC,GAAK60C,EAC5C10C,EAAA,QAAkBk1C,EAQlB,SAAShB,EAAeiB,EAASC,EAAUC,EAAQ,CAC/C,GAAI,OAAOF,GAAY,UAAYA,EAAU,EACzC,MAAM,IAAI,MAAM,0BAA0B,EAC9C,GAAI,OAAOC,GAAa,UAAYA,EAAW,EAC3C,MAAM,IAAI,MAAM,2BAA2B,EAC/C,GAAI,OAAOC,GAAW,WAClB,MAAM,IAAI,MAAM,2BAA2B,EAE/C,MAAMC,EAAOjgC,IAAQ,IAAI,WAAWA,EAAG,EACjCkgC,EAAQC,IAAS,WAAW,GAAGA,EAAI,EACzC,IAAI/gB,EAAI6gB,EAAIH,CAAO,EACf11C,EAAI61C,EAAIH,CAAO,EACfjwC,EAAI,EACR,MAAMuwC,GAAQ,IAAM,CAChBhhB,EAAE,KAAK,CAAC,EACRh1B,EAAE,KAAK,CAAC,EACRyF,EAAI,CACZ,EACU1F,GAAI,IAAIL,KAAMk2C,EAAO51C,EAAGg1B,EAAG,GAAGt1B,EAAC,EAC/Bu2C,GAAS,CAACxG,GAAOoG,EAAI,CAAC,IAAM,CAE9B71C,EAAID,GAAE+1C,EAAK,CAAI,EAAGrG,EAAI,EACtBza,EAAIj1B,GAAC,EACD0vC,GAAK,SAAW,IAEpBzvC,EAAID,GAAE+1C,EAAK,CAAI,EAAGrG,EAAI,EACtBza,EAAIj1B,GAAC,EACb,EACUm2C,GAAM,IAAM,CAEd,GAAIzwC,KAAO,IACP,MAAM,IAAI,MAAM,yBAAyB,EAC7C,IAAImQ,GAAM,EACV,MAAMoH,GAAM,CAAA,EACZ,KAAOpH,GAAM+/B,GAAU,CACnB3gB,EAAIj1B,GAAC,EACL,MAAMmsB,GAAK8I,EAAE,MAAK,EAClBhY,GAAI,KAAKkP,EAAE,EACXtW,IAAOof,EAAE,MACrB,CACQ,SAAW8f,EAAW,aAAa,GAAG93B,EAAG,CACjD,EAUI,MATiB,CAACyyB,GAAM0G,KAAS,CAC7BH,GAAK,EACLC,GAAOxG,EAAI,EACX,IAAIvmC,GACJ,KAAO,EAAEA,GAAMitC,GAAKD,GAAG,CAAE,IACrBD,GAAM,EACV,OAAAD,GAAK,EACE9sC,EACf,CAEA,CAEA,MAAMktC,EAAe,CACjB,OAASp7B,GAAQ,OAAOA,GAAQ,SAChC,SAAWA,GAAQ,OAAOA,GAAQ,WAClC,QAAUA,GAAQ,OAAOA,GAAQ,UACjC,OAASA,GAAQ,OAAOA,GAAQ,SAChC,mBAAqBA,GAAQ,OAAOA,GAAQ,aAAgB85B,EAAW,SAAS95B,CAAG,EACnF,cAAgBA,GAAQ,OAAO,cAAcA,CAAG,EAChD,MAAQA,GAAQ,MAAM,QAAQA,CAAG,EACjC,MAAO,CAACA,EAAKrT,IAAWA,EAAO,GAAG,QAAQqT,CAAG,EAC7C,KAAOA,GAAQ,OAAOA,GAAQ,YAAc,OAAO,cAAcA,EAAI,SAAS,GAGlF,SAAS05B,EAAe/sC,EAAQ0uC,EAAYC,EAAgB,CAAA,EAAI,CAC5D,MAAMC,EAAa,CAACC,EAAWjwC,EAAMkwC,IAAe,CAChD,MAAMC,EAAWN,EAAa7vC,CAAI,EAClC,GAAI,OAAOmwC,GAAa,WACpB,MAAM,IAAI,MAAM,4BAA4B,EAChD,MAAM17B,GAAMrT,EAAO6uC,CAAS,EAC5B,GAAI,EAAAC,GAAcz7B,KAAQ,SAEtB,CAAC07B,EAAS17B,GAAKrT,CAAM,EACrB,MAAM,IAAI,MAAM,SAAW,OAAO6uC,CAAS,EAAI,yBAA2BjwC,EAAO,SAAWyU,EAAG,CAE3G,EACI,SAAW,CAACw7B,EAAWjwC,CAAI,IAAK,OAAO,QAAQ8vC,CAAU,EACrDE,EAAWC,EAAWjwC,EAAM,EAAK,EACrC,SAAW,CAACiwC,EAAWjwC,CAAI,IAAK,OAAO,QAAQ+vC,CAAa,EACxDC,EAAWC,EAAWjwC,EAAM,EAAI,EACpC,OAAOoB,CACX,CASA,SAASgtC,EAAO35B,EAAK,CACjB,OAAO,OAAOA,GAAQ,YAAc,OAAO,cAAcA,EAAI,SAAS,CAC1E,CACA,SAAS45B,EAAgBjtC,EAAQgvC,EAAQC,EAAY,CAAA,EAAI,CACrD,GAAI,CAACjvC,GAAU,OAAOA,GAAW,SAC7B,MAAM,IAAI,MAAM,+BAA+B,EACnD,SAAS4uC,EAAWC,EAAWK,EAAcC,EAAO,CAChD,MAAM97B,EAAMrT,EAAO6uC,CAAS,EAC5B,GAAIM,GAAS97B,IAAQ,OACjB,OACJ,MAAM+7B,GAAU,OAAO/7B,EACvB,GAAI+7B,KAAYF,GAAgB77B,IAAQ,KACpC,MAAM,IAAI,MAAM,UAAUw7B,CAAS,0BAA0BK,CAAY,SAASE,EAAO,EAAE,CACvG,CACI,OAAO,QAAQJ,CAAM,EAAE,QAAQ,CAAC,CAAC32C,EAAGg1B,CAAC,IAAMuhB,EAAWv2C,EAAGg1B,EAAG,EAAK,CAAC,EAClE,OAAO,QAAQ4hB,CAAS,EAAE,QAAQ,CAAC,CAAC52C,EAAGg1B,CAAC,IAAMuhB,EAAWv2C,EAAGg1B,EAAG,EAAI,CAAC,CACxE,CAIA,MAAMgiB,EAAiB,IAAM,CACzB,MAAM,IAAI,MAAM,iBAAiB,CACrC,EACAz2C,EAAA,eAAyBy2C,EAKzB,SAASnC,EAAS90B,EAAI,CAClB,MAAM/Z,EAAM,IAAI,QAChB,MAAO,CAACsS,KAAQ5J,IAAS,CACrB,MAAMsM,EAAMhV,EAAI,IAAIsS,CAAG,EACvB,GAAI0C,IAAQ,OACR,OAAOA,EACX,MAAMi8B,EAAWl3B,EAAGzH,EAAK,GAAG5J,CAAI,EAChC,OAAA1I,EAAI,IAAIsS,EAAK2+B,CAAQ,EACdA,CACf,CACA,kECrWA,OAAO,eAAeC,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,aAAuB,OACvBA,GAAA,IAAcC,EACdD,GAAA,IAAcE,EACdF,GAAA,KAAeG,EACfH,GAAA,OAAiBI,EACjBJ,GAAA,cAAwBK,EACxBL,GAAA,OAAiBM,EACjBN,GAAA,cAAwBO,EACxBP,GAAA,MAAgBQ,EAChBR,GAAA,cAAwBS,EACxBT,GAAA,MAAgBU,EAChBV,GAAA,WAAqBW,EACrBX,GAAA,WAAqBY,EACrBZ,GAAA,QAAkBa,EAClBb,GAAA,MAAgBc,EAChBd,GAAA,UAAoBe,EACpBf,GAAA,WAAqBgB,EACrBhB,GAAA,oBAA8BiB,EAC9BjB,GAAA,oBAA8BkB,EAC9BlB,GAAA,iBAA2BmB,EAC3BnB,GAAA,eAAyBoB,EAOzB,sEACA,MAAMhwB,EAAalmB,GAAA,EAEb4yC,EAAM,OAAO,CAAC,EAAGC,EAAM,OAAO,CAAC,EAAGsD,EAAsB,OAAO,CAAC,EAAGC,EAAsB,OAAO,CAAC,EAEjGC,EAAsB,OAAO,CAAC,EAAGC,EAAsB,OAAO,CAAC,EAAGC,EAAsB,OAAO,CAAC,EAEhGC,EAAsB,OAAO,CAAC,EAAGC,EAAsB,OAAO,CAAC,EAAGC,EAAuB,OAAO,EAAE,EAExG,SAAS3B,EAAI13C,EAAGC,EAAG,CACf,MAAM0D,EAAS3D,EAAIC,EACnB,OAAO0D,GAAU4xC,EAAM5xC,EAAS1D,EAAI0D,CACxC,CAOA,SAASg0C,EAAI9gC,EAAKyiC,EAAOC,EAAQ,CAC7B,OAAOtB,EAAMM,EAAMgB,CAAM,EAAG1iC,EAAKyiC,CAAK,CAC1C,CAEA,SAAS1B,EAAKh3C,EAAG04C,EAAOC,EAAQ,CAC5B,IAAI9vC,EAAM7I,EACV,KAAO04C,KAAU/D,GACb9rC,GAAOA,EACPA,GAAO8vC,EAEX,OAAO9vC,CACX,CAKA,SAASouC,EAAO/zC,EAAQy1C,EAAQ,CAC5B,GAAIz1C,IAAWyxC,EACX,MAAM,IAAI,MAAM,kCAAkC,EACtD,GAAIgE,GAAUhE,EACV,MAAM,IAAI,MAAM,0CAA4CgE,CAAM,EAEtE,IAAIv5C,EAAI03C,EAAI5zC,EAAQy1C,CAAM,EACtBt5C,EAAIs5C,EAEJ34C,GAAI20C,EAAcp0C,GAAIq0C,EAC1B,KAAOx1C,IAAMu1C,GAAK,CAEd,MAAMv0C,GAAIf,EAAID,EACRiB,GAAIhB,EAAID,EACRS,GAAIG,GAAIO,GAAIH,GAGlBf,EAAID,EAAGA,EAAIiB,GAAGL,GAAIO,GAAUA,GAAIV,EACxC,CAEI,GADYR,IACAu1C,EACR,MAAM,IAAI,MAAM,wBAAwB,EAC5C,OAAOkC,EAAI92C,GAAG24C,CAAM,CACxB,CACA,SAASC,EAAeC,EAAIC,EAAM/4C,EAAG,CACjC,GAAI,CAAC84C,EAAG,IAAIA,EAAG,IAAIC,CAAI,EAAG/4C,CAAC,EACvB,MAAM,IAAI,MAAM,yBAAyB,CACjD,CAKA,SAASg5C,EAAUF,EAAI94C,EAAG,CACtB,MAAMi5C,GAAUH,EAAG,MAAQjE,GAAOwD,EAC5BU,EAAOD,EAAG,IAAI94C,EAAGi5C,CAAM,EAC7B,OAAAJ,EAAeC,EAAIC,EAAM/4C,CAAC,EACnB+4C,CACX,CACA,SAASG,EAAUJ,EAAI94C,EAAG,CACtB,MAAMm5C,GAAUL,EAAG,MAAQR,GAAOE,EAC5B1xB,EAAKgyB,EAAG,IAAI94C,EAAGm4C,CAAG,EAClBvjB,GAAIkkB,EAAG,IAAIhyB,EAAIqyB,CAAM,EACrBC,GAAKN,EAAG,IAAI94C,EAAG40B,EAAC,EAChBvvB,GAAIyzC,EAAG,IAAIA,EAAG,IAAIM,GAAIjB,CAAG,EAAGvjB,EAAC,EAC7BmkB,GAAOD,EAAG,IAAIM,GAAIN,EAAG,IAAIzzC,GAAGyzC,EAAG,GAAG,CAAC,EACzC,OAAAD,EAAeC,EAAIC,GAAM/4C,CAAC,EACnB+4C,EACX,CAGA,SAASM,EAAW53C,EAAG,CACnB,MAAM63C,EAAM1B,EAAMn2C,CAAC,EACb83C,EAAKpC,EAAc11C,CAAC,EACpB+3C,EAAKD,EAAGD,EAAKA,EAAI,IAAIA,EAAI,GAAG,CAAC,EAC7BG,GAAKF,EAAGD,EAAKE,CAAE,EACfE,GAAKH,EAAGD,EAAKA,EAAI,IAAIE,CAAE,CAAC,EACxBG,IAAMl4C,EAAI82C,GAAOG,EACvB,MAAO,CAACI,GAAI94C,KAAM,CACd,IAAI45C,GAAMd,GAAG,IAAI94C,GAAG25C,EAAE,EAClBE,GAAMf,GAAG,IAAIc,GAAKJ,CAAE,EACxB,MAAMM,GAAMhB,GAAG,IAAIc,GAAKH,EAAE,EACpBM,GAAMjB,GAAG,IAAIc,GAAKF,EAAE,EACpBM,GAAKlB,GAAG,IAAIA,GAAG,IAAIe,EAAG,EAAG75C,EAAC,EAC1Bi6C,GAAKnB,GAAG,IAAIA,GAAG,IAAIgB,EAAG,EAAG95C,EAAC,EAChC45C,GAAMd,GAAG,KAAKc,GAAKC,GAAKG,EAAE,EAC1BH,GAAMf,GAAG,KAAKiB,GAAKD,GAAKG,EAAE,EAC1B,MAAMC,GAAKpB,GAAG,IAAIA,GAAG,IAAIe,EAAG,EAAG75C,EAAC,EAC1B+4C,GAAOD,GAAG,KAAKc,GAAKC,GAAKK,EAAE,EACjC,OAAArB,EAAeC,GAAIC,GAAM/4C,EAAC,EACnB+4C,EACf,CACA,CAQA,SAAS5B,EAAc11C,EAAG,CAGtB,GAAIA,EAAI22C,EACJ,MAAM,IAAI,MAAM,qCAAqC,EAEzD,IAAI12C,EAAID,EAAIozC,EACRjzC,EAAI,EACR,KAAOF,EAAIy2C,IAAQvD,GACflzC,GAAKy2C,EACLv2C,IAGJ,IAAI,EAAIu2C,EACR,MAAMgC,GAAMvC,EAAMn2C,CAAC,EACnB,KAAOg2C,EAAW0C,GAAK,CAAC,IAAM,GAG1B,GAAI,IAAM,IACN,MAAM,IAAI,MAAM,+CAA+C,EAGvE,GAAIv4C,IAAM,EACN,OAAOo3C,EAGX,IAAIoB,GAAKD,GAAI,IAAI,EAAGz4C,CAAC,EACrB,MAAM24C,IAAU34C,EAAImzC,GAAOsD,EAC3B,OAAO,SAAqBW,GAAI94C,GAAG,CAC/B,GAAI84C,GAAG,IAAI94C,EAAC,EACR,OAAOA,GAEX,GAAIy3C,EAAWqB,GAAI94C,EAAC,IAAM,EACtB,MAAM,IAAI,MAAM,yBAAyB,EAE7C,IAAIsB,GAAIM,EACJrC,GAAIu5C,GAAG,IAAIA,GAAG,IAAKsB,EAAE,EACrB75C,GAAIu4C,GAAG,IAAI94C,GAAG0B,CAAC,EACfC,GAAIm3C,GAAG,IAAI94C,GAAGq6C,EAAM,EAGxB,KAAO,CAACvB,GAAG,IAAIv4C,GAAGu4C,GAAG,GAAG,GAAG,CACvB,GAAIA,GAAG,IAAIv4C,EAAC,EACR,OAAOu4C,GAAG,KACd,IAAIzzC,GAAI,EAEJi1C,GAAQxB,GAAG,IAAIv4C,EAAC,EACpB,KAAO,CAACu4C,GAAG,IAAIwB,GAAOxB,GAAG,GAAG,GAGxB,GAFAzzC,KACAi1C,GAAQxB,GAAG,IAAIwB,EAAK,EAChBj1C,KAAM/D,GACN,MAAM,IAAI,MAAM,yBAAyB,EAGjD,MAAMi5C,GAAW1F,GAAO,OAAOvzC,GAAI+D,GAAI,CAAC,EAClC/F,GAAIw5C,GAAG,IAAIv5C,GAAGg7C,EAAQ,EAE5Bj5C,GAAI+D,GACJ9F,GAAIu5C,GAAG,IAAIx5C,EAAC,EACZiB,GAAIu4C,GAAG,IAAIv4C,GAAGhB,EAAC,EACfoC,GAAIm3C,GAAG,IAAIn3C,GAAGrC,EAAC,CAC3B,CACQ,OAAOqC,EACf,CACA,CAYA,SAASy1C,EAAO31C,EAAG,CAEf,OAAIA,EAAI42C,IAAQD,EACLY,EAEPv3C,EAAI+2C,IAAQF,EACLY,EAEPz3C,EAAIi3C,IAASD,EACNY,EAAW53C,CAAC,EAEhB01C,EAAc11C,CAAC,CAC1B,CAEA,MAAM+4C,EAAe,CAACtkC,EAAK0iC,KAAY7B,EAAI7gC,EAAK0iC,CAAM,EAAI/D,KAASA,EACnEiC,GAAA,aAAuB0D,EAEvB,MAAMC,EAAe,CACjB,SAAU,UAAW,MAAO,MAAO,MAAO,OAAQ,MAClD,MAAO,MAAO,MAAO,MAAO,MAAO,MACnC,OAAQ,OAAQ,OAAQ,QAE5B,SAASpD,EAAcqD,EAAO,CAC1B,MAAMC,EAAU,CACZ,MAAO,SACP,KAAM,SACN,MAAO,SACP,KAAM,UAEJlzB,EAAOgzB,EAAa,OAAO,CAAC70C,EAAKgV,MACnChV,EAAIgV,EAAG,EAAI,WACJhV,GACR+0C,CAAO,EACV,SAAIzyB,EAAW,iBAAiBwyB,EAAOjzB,CAAI,EAIpCizB,CACX,CAMA,SAASpD,EAAMwB,EAAI5iC,EAAKyiC,EAAO,CAC3B,GAAIA,EAAQ/D,EACR,MAAM,IAAI,MAAM,yCAAyC,EAC7D,GAAI+D,IAAU/D,EACV,OAAOkE,EAAG,IACd,GAAIH,IAAU9D,EACV,OAAO3+B,EACX,IAAI9V,EAAI04C,EAAG,IACPt5C,GAAI0W,EACR,KAAOyiC,EAAQ/D,GACP+D,EAAQ9D,IACRz0C,EAAI04C,EAAG,IAAI14C,EAAGZ,EAAC,GACnBA,GAAIs5C,EAAG,IAAIt5C,EAAC,EACZm5C,IAAU9D,EAEd,OAAOz0C,CACX,CAMA,SAASm3C,EAAcuB,EAAI8B,EAAMC,EAAW,GAAO,CAC/C,MAAMC,EAAW,IAAI,MAAMF,EAAK,MAAM,EAAE,KAAKC,EAAW/B,EAAG,KAAO,MAAS,EAErEiC,GAAgBH,EAAK,OAAO,CAACI,GAAK9kC,GAAK7Q,KACrCyzC,EAAG,IAAI5iC,EAAG,EACH8kC,IACXF,EAASz1C,EAAC,EAAI21C,GACPlC,EAAG,IAAIkC,GAAK9kC,EAAG,GACvB4iC,EAAG,GAAG,EAEHmC,GAAcnC,EAAG,IAAIiC,EAAa,EAExC,OAAAH,EAAK,YAAY,CAACI,GAAK9kC,GAAK7Q,KACpByzC,EAAG,IAAI5iC,EAAG,EACH8kC,IACXF,EAASz1C,EAAC,EAAIyzC,EAAG,IAAIkC,GAAKF,EAASz1C,EAAC,CAAC,EAC9ByzC,EAAG,IAAIkC,GAAK9kC,EAAG,GACvB+kC,EAAW,EACPH,CACX,CAEA,SAAStD,EAAMsB,EAAIoC,EAAKC,EAAK,CACzB,OAAOrC,EAAG,IAAIoC,EAAK,OAAOC,GAAQ,SAAWjE,EAAOiE,EAAKrC,EAAG,KAAK,EAAIA,EAAG,IAAIqC,CAAG,CAAC,CACpF,CAUA,SAAS1D,EAAWqB,EAAI94C,EAAG,CAGvB,MAAMo7C,GAAUtC,EAAG,MAAQjE,GAAOsD,EAC5BkD,EAAUvC,EAAG,IAAI94C,EAAGo7C,CAAM,EAC1BE,GAAMxC,EAAG,IAAIuC,EAASvC,EAAG,GAAG,EAC5ByC,GAAOzC,EAAG,IAAIuC,EAASvC,EAAG,IAAI,EAC9B0C,GAAK1C,EAAG,IAAIuC,EAASvC,EAAG,IAAIA,EAAG,GAAG,CAAC,EACzC,GAAI,CAACwC,IAAO,CAACC,IAAQ,CAACC,GAClB,MAAM,IAAI,MAAM,gCAAgC,EACpD,OAAOF,GAAM,EAAIC,GAAO,EAAI,EAChC,CAEA,SAAS7D,EAAWoB,EAAI94C,EAAG,CAEvB,OADUy3C,EAAWqB,EAAI94C,CAAC,IACb,CACjB,CAEA,SAAS23C,EAAQ33C,EAAGy7C,EAAY,CAExBA,IAAe,WACXvzB,EAAW,SAASuzB,CAAU,EACtC,MAAMC,EAAcD,IAAe,OAAYA,EAAaz7C,EAAE,SAAS,CAAC,EAAE,OACpE27C,EAAc,KAAK,KAAKD,EAAc,CAAC,EAC7C,MAAO,CAAE,WAAYA,EAAa,YAAAC,CAAW,CACjD,CAoBA,SAAS/D,EAAMgE,EAAOC,EACtBjlC,EAAO,GAAO6Q,EAAO,GAAI,CACrB,GAAIm0B,GAAShH,EACT,MAAM,IAAI,MAAM,0CAA4CgH,CAAK,EACrE,IAAIE,GACAC,GACAC,GAAe,GACfC,GACJ,GAAI,OAAOJ,GAAiB,UAAYA,GAAgB,KAAM,CAC1D,GAAIp0B,EAAK,MAAQ7Q,EACb,MAAM,IAAI,MAAM,sCAAsC,EAC1D,MAAMk5B,GAAQ+L,EACV/L,GAAM,OACNgM,GAAchM,GAAM,MACpBA,GAAM,OACNiM,GAAQjM,GAAM,MACd,OAAOA,GAAM,MAAS,YACtBl5B,EAAOk5B,GAAM,MACb,OAAOA,GAAM,cAAiB,YAC9BkM,GAAelM,GAAM,cACzBmM,GAAiBnM,GAAM,cAC/B,MAEY,OAAO+L,GAAiB,WACxBC,GAAcD,GACdp0B,EAAK,OACLs0B,GAAQt0B,EAAK,MAErB,KAAM,CAAE,WAAYy0B,GAAM,YAAaC,EAAK,EAAKxE,EAAQiE,EAAOE,EAAW,EAC3E,GAAIK,GAAQ,KACR,MAAM,IAAI,MAAM,gDAAgD,EACpE,IAAIC,GACJ,MAAMh9C,GAAI,OAAO,OAAO,CACpB,MAAAw8C,EACA,KAAAhlC,EACA,KAAAslC,GACA,MAAAC,GACA,QAAUj0B,EAAW,SAASg0B,EAAI,EAClC,KAAMtH,EACN,IAAKC,EACL,eAAgBoH,GAChB,OAAS/lC,IAAQ6gC,EAAI7gC,GAAK0lC,CAAK,EAC/B,QAAU1lC,IAAQ,CACd,GAAI,OAAOA,IAAQ,SACf,MAAM,IAAI,MAAM,+CAAiD,OAAOA,EAAG,EAC/E,OAAO0+B,GAAO1+B,IAAOA,GAAM0lC,CACvC,EACQ,IAAM1lC,IAAQA,KAAQ0+B,EAEtB,YAAc1+B,IAAQ,CAAC9W,GAAE,IAAI8W,EAAG,GAAK9W,GAAE,QAAQ8W,EAAG,EAClD,MAAQA,KAASA,GAAM2+B,KAASA,EAChC,IAAM3+B,IAAQ6gC,EAAI,CAAC7gC,GAAK0lC,CAAK,EAC7B,IAAK,CAACV,GAAKC,KAAQD,KAAQC,GAC3B,IAAMjlC,IAAQ6gC,EAAI7gC,GAAMA,GAAK0lC,CAAK,EAClC,IAAK,CAACV,GAAKC,KAAQpE,EAAImE,GAAMC,GAAKS,CAAK,EACvC,IAAK,CAACV,GAAKC,KAAQpE,EAAImE,GAAMC,GAAKS,CAAK,EACvC,IAAK,CAACV,GAAKC,KAAQpE,EAAImE,GAAMC,GAAKS,CAAK,EACvC,IAAK,CAAC1lC,GAAKyiC,KAAUrB,EAAMl4C,GAAG8W,GAAKyiC,EAAK,EACxC,IAAK,CAACuC,GAAKC,KAAQpE,EAAImE,GAAMhE,EAAOiE,GAAKS,CAAK,EAAGA,CAAK,EAEtD,KAAO1lC,IAAQA,GAAMA,GACrB,KAAM,CAACglC,GAAKC,KAAQD,GAAMC,GAC1B,KAAM,CAACD,GAAKC,KAAQD,GAAMC,GAC1B,KAAM,CAACD,GAAKC,KAAQD,GAAMC,GAC1B,IAAMjlC,IAAQghC,EAAOhhC,GAAK0lC,CAAK,EAC/B,KAAMG,KACA/7C,KACOo8C,KACDA,GAAQhF,EAAOwE,CAAK,GACjBQ,GAAMh9C,GAAGY,EAAC,IAEzB,QAAUkW,IAASU,KAAWsR,EAAW,iBAAiBhS,GAAKimC,EAAK,KAAQj0B,EAAW,iBAAiBhS,GAAKimC,EAAK,EAClH,UAAW,CAACr/B,GAAOu/B,GAAiB,KAAS,CACzC,GAAIJ,GAAgB,CAChB,GAAI,CAACA,GAAe,SAASn/B,GAAM,MAAM,GAAKA,GAAM,OAASq/B,GACzD,MAAM,IAAI,MAAM,6BAA+BF,GAAiB,eAAiBn/B,GAAM,MAAM,EAEjG,MAAMw/B,GAAS,IAAI,WAAWH,EAAK,EAEnCG,GAAO,IAAIx/B,GAAOlG,EAAO,EAAI0lC,GAAO,OAASx/B,GAAM,MAAM,EACzDA,GAAQw/B,EACxB,CACY,GAAIx/B,GAAM,SAAWq/B,GACjB,MAAM,IAAI,MAAM,6BAA+BA,GAAQ,eAAiBr/B,GAAM,MAAM,EACxF,IAAIy/B,GAAS3lC,KAAWsR,EAAW,iBAAiBpL,EAAK,KAAQoL,EAAW,iBAAiBpL,EAAK,EAGlG,GAFIk/B,KACAO,GAASxF,EAAIwF,GAAQX,CAAK,GAC1B,CAACS,IACG,CAACj9C,GAAE,QAAQm9C,EAAM,EACjB,MAAM,IAAI,MAAM,kDAAkD,EAG1E,OAAOA,EACnB,EAEQ,YAAc5vB,IAAQ4qB,EAAcn4C,GAAGutB,EAAG,EAG1C,KAAM,CAACttB,GAAGC,GAAGC,KAAOA,GAAID,GAAID,EACpC,CAAK,EACD,OAAO,OAAO,OAAOD,EAAC,CAC1B,CAcA,SAASy4C,EAAUiB,EAAI0D,EAAK,CACxB,GAAI,CAAC1D,EAAG,MACJ,MAAM,IAAI,MAAM,0BAA0B,EAC9C,MAAMC,EAAOD,EAAG,KAAK0D,CAAG,EACxB,OAAO1D,EAAG,MAAMC,CAAI,EAAIA,EAAOD,EAAG,IAAIC,CAAI,CAC9C,CACA,SAASjB,EAAWgB,EAAI0D,EAAK,CACzB,GAAI,CAAC1D,EAAG,MACJ,MAAM,IAAI,MAAM,0BAA0B,EAC9C,MAAMC,EAAOD,EAAG,KAAK0D,CAAG,EACxB,OAAO1D,EAAG,MAAMC,CAAI,EAAID,EAAG,IAAIC,CAAI,EAAIA,CAC3C,CAOA,SAAShB,EAAoBxU,EAAMkZ,EAAY7lC,EAAO,GAAO,CACzD2sB,KAAWrb,EAAW,aAAa,cAAeqb,CAAI,EACtD,MAAM+R,EAAU/R,EAAK,OACfmZ,GAAS/E,EAAQ8E,CAAU,EAAE,YAAc,EACjD,GAAIC,GAAS,IAAMpH,EAAUoH,IAAUpH,EAAU,KAC7C,MAAM,IAAI,MAAM,iCAAmCoH,GAAS,6BAA+BpH,CAAO,EACtG,MAAMp/B,GAAMU,KAAWsR,EAAW,iBAAiBqb,CAAI,KAAQrb,EAAW,iBAAiBqb,CAAI,EAC/F,OAAOwT,EAAI7gC,GAAKumC,EAAa5H,CAAG,EAAIA,CACxC,CAOA,SAASmD,EAAoB2E,EAAY,CACrC,GAAI,OAAOA,GAAe,SACtB,MAAM,IAAI,MAAM,4BAA4B,EAChD,MAAMC,EAAYD,EAAW,SAAS,CAAC,EAAE,OACzC,OAAO,KAAK,KAAKC,EAAY,CAAC,CAClC,CAQA,SAAS3E,EAAiB0E,EAAY,CAClC,MAAMj6C,EAASs1C,EAAoB2E,CAAU,EAC7C,OAAOj6C,EAAS,KAAK,KAAKA,EAAS,CAAC,CACxC,CAcA,SAASw1C,EAAev1C,EAAKg6C,EAAY/lC,EAAO,GAAO,CACnD,MAAMpB,EAAM7S,EAAI,OACVk6C,GAAW7E,EAAoB2E,CAAU,EACzCD,GAASzE,EAAiB0E,CAAU,EAE1C,GAAInnC,EAAM,IAAMA,EAAMknC,IAAUlnC,EAAM,KAClC,MAAM,IAAI,MAAM,YAAcknC,GAAS,6BAA+BlnC,CAAG,EAC7E,MAAMU,GAAMU,KAAWsR,EAAW,iBAAiBvlB,CAAG,KAAQulB,EAAW,iBAAiBvlB,CAAG,EAEvFm6C,GAAU/F,EAAI7gC,GAAKymC,EAAa9H,CAAG,EAAIA,EAC7C,OAAOj+B,KAAWsR,EAAW,iBAAiB40B,GAASD,EAAQ,KAAQ30B,EAAW,iBAAiB40B,GAASD,EAAQ,CACxH,qDCviBA,OAAO,eAAeE,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,KAAe,OACfA,GAAA,SAAmBC,EACnBD,GAAA,WAAqBE,EACrBF,GAAA,cAAwBG,EACxBH,GAAA,UAAoBI,EACpBJ,GAAA,oBAA8BK,EAC9BL,GAAA,cAAwBM,EACxBN,GAAA,mBAA6BO,EAM7B,sEACA,MAAMp1B,EAAalmB,GAAA,EACbu7C,EAAep8B,GAAA,EACfyzB,EAAM,OAAO,CAAC,EACdC,EAAM,OAAO,CAAC,EACpB,SAASmI,EAASQ,EAAWvmB,EAAM,CAC/B,MAAMwmB,EAAMxmB,EAAK,OAAM,EACvB,OAAOumB,EAAYC,EAAMxmB,CAC7B,CAOA,SAASgmB,EAAW19C,EAAGm+C,EAAQ,CAC3B,MAAMC,KAAiBJ,EAAa,eAAeh+C,EAAE,GAAIm+C,EAAO,IAAKt9C,GAAMA,EAAE,CAAC,CAAC,EAC/E,OAAOs9C,EAAO,IAAI,CAACt9C,EAAGiF,IAAM9F,EAAE,WAAWa,EAAE,SAASu9C,EAAWt4C,CAAC,CAAC,CAAC,CAAC,CACvE,CACA,SAASu4C,EAAUC,EAAG/yC,EAAM,CACxB,GAAI,CAAC,OAAO,cAAc+yC,CAAC,GAAKA,GAAK,GAAKA,EAAI/yC,EAC1C,MAAM,IAAI,MAAM,qCAAuCA,EAAO,YAAc+yC,CAAC,CACrF,CACA,SAASC,EAAUD,EAAGE,EAAY,CAC9BH,EAAUC,EAAGE,CAAU,EACvB,MAAMC,EAAU,KAAK,KAAKD,EAAaF,CAAC,EAAI,EACtCI,EAAa,IAAMJ,EAAI,GACvBK,EAAY,GAAKL,EACjBM,KAAWj2B,EAAW,SAAS21B,CAAC,EAChCO,EAAU,OAAOP,CAAC,EACxB,MAAO,CAAE,QAAAG,EAAS,WAAAC,EAAY,KAAAE,EAAM,UAAAD,EAAW,QAAAE,CAAO,CAC1D,CACA,SAASC,EAAYr+C,EAAGs+C,EAAQC,EAAO,CACnC,KAAM,CAAE,WAAAN,EAAY,KAAAE,EAAM,UAAAD,EAAW,QAAAE,CAAO,EAAKG,EACjD,IAAIC,EAAQ,OAAOx+C,EAAIm+C,CAAI,EACvBM,EAAQz+C,GAAKo+C,EAMbI,EAAQP,IAERO,GAASN,EACTO,GAAS5J,GAEb,MAAM6J,EAAcJ,EAASL,EACvBtnC,EAAS+nC,EAAc,KAAK,IAAIF,CAAK,EAAI,EACzCG,EAASH,IAAU,EACnBI,EAAQJ,EAAQ,EAChBK,EAASP,EAAS,IAAM,EAE9B,MAAO,CAAE,MAAAG,EAAO,OAAA9nC,EAAQ,OAAAgoC,EAAQ,MAAAC,EAAO,OAAAC,EAAQ,QAD/BH,CACsC,CAC1D,CACA,SAASI,EAAkBpB,EAAQn+C,EAAG,CAClC,GAAI,CAAC,MAAM,QAAQm+C,CAAM,EACrB,MAAM,IAAI,MAAM,gBAAgB,EACpCA,EAAO,QAAQ,CAACt9C,EAAGiF,IAAM,CACrB,GAAI,EAAEjF,aAAab,GACf,MAAM,IAAI,MAAM,0BAA4B8F,CAAC,CACzD,CAAK,CACL,CACA,SAAS05C,EAAmBC,EAAStE,EAAO,CACxC,GAAI,CAAC,MAAM,QAAQsE,CAAO,EACtB,MAAM,IAAI,MAAM,2BAA2B,EAC/CA,EAAQ,QAAQ,CAAC7nC,EAAG9R,IAAM,CACtB,GAAI,CAACq1C,EAAM,QAAQvjC,CAAC,EAChB,MAAM,IAAI,MAAM,2BAA6B9R,CAAC,CAC1D,CAAK,CACL,CAIA,MAAM45C,EAAmB,IAAI,QACvBC,EAAmB,IAAI,QAC7B,SAASC,EAAK19C,EAAG,CAGb,OAAOy9C,EAAiB,IAAIz9C,CAAC,GAAK,CACtC,CACA,SAAS29C,EAAQp/C,EAAG,CAChB,GAAIA,IAAM40C,EACN,MAAM,IAAI,MAAM,cAAc,CACtC,CAmBA,MAAMyK,CAAK,CAEP,YAAYC,EAAOx0C,EAAM,CACrB,KAAK,KAAOw0C,EAAM,KAClB,KAAK,KAAOA,EAAM,KAClB,KAAK,GAAKA,EAAM,GAChB,KAAK,KAAOx0C,CACpB,CAEI,cAAc0xC,EAAKx8C,EAAGI,EAAI,KAAK,KAAM,CACjC,IAAIZ,EAAIg9C,EACR,KAAOx8C,EAAI40C,GACH50C,EAAI60C,IACJz0C,EAAIA,EAAE,IAAIZ,CAAC,GACfA,EAAIA,EAAE,OAAM,EACZQ,IAAM60C,EAEV,OAAOz0C,CACf,CAaI,iBAAiBm/C,EAAO1B,EAAG,CACvB,KAAM,CAAE,QAAAG,EAAS,WAAAC,CAAU,EAAKH,EAAUD,EAAG,KAAK,IAAI,EAChDH,EAAS,CAAA,EACf,IAAIt9C,EAAIm/C,EACJrtB,EAAO9xB,EACX,QAASk+C,EAAS,EAAGA,EAASN,EAASM,IAAU,CAC7CpsB,EAAO9xB,EACPs9C,EAAO,KAAKxrB,CAAI,EAEhB,QAAS7sB,EAAI,EAAGA,EAAI44C,EAAY54C,IAC5B6sB,EAAOA,EAAK,IAAI9xB,CAAC,EACjBs9C,EAAO,KAAKxrB,CAAI,EAEpB9xB,EAAI8xB,EAAK,OAAM,CAC3B,CACQ,OAAOwrB,CACf,CAOI,KAAKG,EAAG2B,EAAax/C,EAAG,CAEpB,GAAI,CAAC,KAAK,GAAG,QAAQA,CAAC,EAClB,MAAM,IAAI,MAAM,gBAAgB,EAEpC,IAAII,EAAI,KAAK,KACThB,EAAI,KAAK,KAMb,MAAMqgD,EAAK3B,EAAUD,EAAG,KAAK,IAAI,EACjC,QAASS,EAAS,EAAGA,EAASmB,EAAG,QAASnB,IAAU,CAEhD,KAAM,CAAE,MAAAG,EAAO,OAAA9nC,EAAQ,OAAAgoC,EAAQ,MAAAC,EAAO,OAAAC,EAAQ,QAAAa,CAAO,EAAKrB,EAAYr+C,EAAGs+C,EAAQmB,CAAE,EACnFz/C,EAAIy+C,EACAE,EAGAv/C,EAAIA,EAAE,IAAI49C,EAAS6B,EAAQW,EAAYE,CAAO,CAAC,CAAC,EAIhDt/C,EAAIA,EAAE,IAAI48C,EAAS4B,EAAOY,EAAY7oC,CAAM,CAAC,CAAC,CAE9D,CACQ,OAAAyoC,EAAQp/C,CAAC,EAIF,CAAE,EAAAI,EAAG,EAAAhB,CAAC,CACrB,CAMI,WAAWy+C,EAAG2B,EAAax/C,EAAGg7C,EAAM,KAAK,KAAM,CAC3C,MAAMyE,EAAK3B,EAAUD,EAAG,KAAK,IAAI,EACjC,QAASS,EAAS,EAAGA,EAASmB,EAAG,SACzBz/C,IAAM40C,EAD4B0J,IAAU,CAGhD,KAAM,CAAE,MAAAG,EAAO,OAAA9nC,EAAQ,OAAAgoC,EAAQ,MAAAC,CAAK,EAAKP,EAAYr+C,EAAGs+C,EAAQmB,CAAE,EAElE,GADAz/C,EAAIy+C,EACA,CAAAE,EAKC,CACD,MAAM1nB,EAAOuoB,EAAY7oC,CAAM,EAC/BqkC,EAAMA,EAAI,IAAI4D,EAAQ3nB,EAAK,OAAM,EAAKA,CAAI,CAC1D,CACA,CACQ,OAAAmoB,EAAQp/C,CAAC,EACFg7C,CACf,CACI,eAAe6C,EAAG0B,EAAOI,EAAW,CAEhC,IAAIC,EAAOX,EAAiB,IAAIM,CAAK,EACrC,OAAKK,IACDA,EAAO,KAAK,iBAAiBL,EAAO1B,CAAC,EACjCA,IAAM,IAEF,OAAO8B,GAAc,aACrBC,EAAOD,EAAUC,CAAI,GACzBX,EAAiB,IAAIM,EAAOK,CAAI,IAGjCA,CACf,CACI,OAAOL,EAAOhD,EAAQoD,EAAW,CAC7B,MAAM9B,EAAIsB,EAAKI,CAAK,EACpB,OAAO,KAAK,KAAK1B,EAAG,KAAK,eAAeA,EAAG0B,EAAOI,CAAS,EAAGpD,CAAM,CAC5E,CACI,OAAOgD,EAAOhD,EAAQoD,EAAWE,EAAM,CACnC,MAAMhC,EAAIsB,EAAKI,CAAK,EACpB,OAAI1B,IAAM,EACC,KAAK,cAAc0B,EAAOhD,EAAQsD,CAAI,EAC1C,KAAK,WAAWhC,EAAG,KAAK,eAAeA,EAAG0B,EAAOI,CAAS,EAAGpD,EAAQsD,CAAI,CACxF,CAII,YAAYp+C,EAAGo8C,EAAG,CACdD,EAAUC,EAAG,KAAK,IAAI,EACtBqB,EAAiB,IAAIz9C,EAAGo8C,CAAC,EACzBoB,EAAiB,OAAOx9C,CAAC,CACjC,CACI,SAAS+6C,EAAK,CACV,OAAO2C,EAAK3C,CAAG,IAAM,CAC7B,CACA,CACAO,GAAA,KAAesC,EAKf,SAASnC,EAAcoC,EAAOC,EAAOO,EAAIC,EAAI,CACzC,IAAI/E,EAAMuE,EACNS,EAAKV,EAAM,KACXW,EAAKX,EAAM,KACf,KAAOQ,EAAKlL,GAAOmL,EAAKnL,GAChBkL,EAAKjL,IACLmL,EAAKA,EAAG,IAAIhF,CAAG,GACf+E,EAAKlL,IACLoL,EAAKA,EAAG,IAAIjF,CAAG,GACnBA,EAAMA,EAAI,OAAM,EAChB8E,IAAOjL,EACPkL,IAAOlL,EAEX,MAAO,CAAE,GAAAmL,EAAI,GAAAC,CAAE,CACnB,CAWA,SAAS9C,EAAU59C,EAAG2gD,EAAQxC,EAAQsB,EAAS,CAO3CF,EAAkBpB,EAAQn+C,CAAC,EAC3Bw/C,EAAmBC,EAASkB,CAAM,EAClC,MAAMC,EAAUzC,EAAO,OACjB0C,EAAUpB,EAAQ,OACxB,GAAImB,IAAYC,EACZ,MAAM,IAAI,MAAM,qDAAqD,EAEzE,MAAM7E,EAAOh8C,EAAE,KACTi/C,KAAYt2B,EAAW,QAAQ,OAAOi4B,CAAO,CAAC,EACpD,IAAIlC,EAAa,EACbO,EAAQ,GACRP,EAAaO,EAAQ,EAChBA,EAAQ,EACbP,EAAaO,EAAQ,EAChBA,EAAQ,IACbP,EAAa,GACjB,MAAMoC,KAAWn4B,EAAW,SAAS+1B,CAAU,EACzCqC,EAAU,IAAI,MAAM,OAAOD,CAAI,EAAI,CAAC,EAAE,KAAK9E,CAAI,EAC/CgF,EAAW,KAAK,OAAOL,EAAO,KAAO,GAAKjC,CAAU,EAAIA,EAC9D,IAAI32B,EAAMi0B,EACV,QAASl2C,EAAIk7C,EAAUl7C,GAAK,EAAGA,GAAK44C,EAAY,CAC5CqC,EAAQ,KAAK/E,CAAI,EACjB,QAASlgC,EAAI,EAAGA,EAAI+kC,EAAS/kC,IAAK,CAC9B,MAAMkhC,EAASyC,EAAQ3jC,CAAC,EAClBmjC,EAAQ,OAAQjC,GAAU,OAAOl3C,CAAC,EAAKg7C,CAAI,EACjDC,EAAQ9B,CAAK,EAAI8B,EAAQ9B,CAAK,EAAE,IAAId,EAAOriC,CAAC,CAAC,CACzD,CACQ,IAAImlC,EAAOjF,EAEX,QAASlgC,EAAIilC,EAAQ,OAAS,EAAGG,EAAOlF,EAAMlgC,EAAI,EAAGA,IACjDolC,EAAOA,EAAK,IAAIH,EAAQjlC,CAAC,CAAC,EAC1BmlC,EAAOA,EAAK,IAAIC,CAAI,EAGxB,GADAn5B,EAAMA,EAAI,IAAIk5B,CAAI,EACdn7C,IAAM,EACN,QAASgW,EAAI,EAAGA,EAAI4iC,EAAY5iC,IAC5BiM,EAAMA,EAAI,OAAM,CAChC,CACI,OAAOA,CACX,CAQA,SAAS81B,EAAoB79C,EAAG2gD,EAAQxC,EAAQO,EAAY,CAoCxDL,EAAUK,EAAYiC,EAAO,IAAI,EACjCpB,EAAkBpB,EAAQn+C,CAAC,EAC3B,MAAMg8C,EAAOh8C,EAAE,KACTmhD,EAAY,GAAKzC,EAAa,EAC9B0C,EAAS,KAAK,KAAKT,EAAO,KAAOjC,CAAU,EAC3CoC,KAAWn4B,EAAW,SAAS+1B,CAAU,EACzC2C,EAASlD,EAAO,IAAKt9C,GAAM,CAC7B,MAAM0I,EAAM,CAAA,EACZ,QAASzD,EAAI,EAAG21C,EAAM56C,EAAGiF,EAAIq7C,EAAWr7C,IACpCyD,EAAI,KAAKkyC,CAAG,EACZA,EAAMA,EAAI,IAAI56C,CAAC,EAEnB,OAAO0I,CACf,CAAK,EACD,OAAQk2C,GAAY,CAEhB,GADAD,EAAmBC,EAASkB,CAAM,EAC9BlB,EAAQ,OAAStB,EAAO,OACxB,MAAM,IAAI,MAAM,uDAAuD,EAC3E,IAAI50C,EAAMyyC,EACV,QAASl2C,EAAI,EAAGA,EAAIs7C,EAAQt7C,IAAK,CAE7B,GAAIyD,IAAQyyC,EACR,QAASlgC,EAAI,EAAGA,EAAI4iC,EAAY5iC,IAC5BvS,EAAMA,EAAI,OAAM,EACxB,MAAMs1C,EAAU,OAAOuC,EAAS1C,GAAc54C,EAAI,GAAK44C,CAAU,EACjE,QAAS5iC,EAAI,EAAGA,EAAI2jC,EAAQ,OAAQ3jC,IAAK,CACrC,MAAMrb,EAAIg/C,EAAQ3jC,CAAC,EACbwlC,EAAO,OAAQ7gD,GAAKo+C,EAAWiC,CAAI,EACpCQ,IAEL/3C,EAAMA,EAAI,IAAI83C,EAAOvlC,CAAC,EAAEwlC,EAAO,CAAC,CAAC,EACjD,CACA,CACQ,OAAO/3C,CACf,CACA,CAGA,SAASu0C,EAAcN,EAAO,CAC1B,SAAIQ,EAAa,eAAeR,EAAM,EAAE,KACpC70B,EAAW,gBAAgB60B,EAAO,CAClC,EAAG,SACH,EAAG,SACH,GAAI,QACJ,GAAI,OACZ,EAAO,CACC,WAAY,gBACZ,YAAa,eACrB,CAAK,EAEM,OAAO,OAAO,CACjB,MAAOQ,EAAa,SAASR,EAAM,EAAGA,EAAM,UAAU,EACtD,GAAGA,EACE,EAAGA,EAAM,GAAG,KACzB,CAAK,CACL,CACA,SAAS+D,EAAYC,EAAOrG,EAAO9jC,EAAM,CACrC,GAAI8jC,EAAO,CACP,GAAIA,EAAM,QAAUqG,EAChB,MAAM,IAAI,MAAM,gDAAgD,EACpE,SAAIxD,EAAa,eAAe7C,CAAK,EAC9BA,CACf,KAEQ,UAAW6C,EAAa,OAAOwD,EAAO,CAAE,KAAAnqC,CAAI,CAAE,CAEtD,CAEA,SAAS0mC,EAAmBn3C,EAAM66C,EAAOC,EAAY,CAAA,EAAIC,EAAQ,CAG7D,GAFIA,IAAW,SACXA,EAAS/6C,IAAS,WAClB,CAAC66C,GAAS,OAAOA,GAAU,SAC3B,MAAM,IAAI,MAAM,kBAAkB76C,CAAI,eAAe,EACzD,UAAW/F,IAAK,CAAC,IAAK,IAAK,GAAG,EAAG,CAC7B,MAAMwa,EAAMomC,EAAM5gD,CAAC,EACnB,GAAI,EAAE,OAAOwa,GAAQ,UAAYA,EAAMg6B,GACnC,MAAM,IAAI,MAAM,SAASx0C,CAAC,0BAA0B,CAChE,CACI,MAAM04C,EAAKgI,EAAYE,EAAM,EAAGC,EAAU,GAAIC,CAAM,EAC9CC,EAAKL,EAAYE,EAAM,EAAGC,EAAU,GAAIC,CAAM,EAE9CE,EAAS,CAAC,KAAM,KAAM,IADjBj7C,IAAS,cAAgB,IAAM,GACP,EACnC,UAAW/F,KAAKghD,EAEZ,GAAI,CAACtI,EAAG,QAAQkI,EAAM5gD,CAAC,CAAC,EACpB,MAAM,IAAI,MAAM,SAASA,CAAC,0CAA0C,EAE5E,OAAA4gD,EAAQ,OAAO,OAAO,OAAO,OAAO,CAAA,EAAIA,CAAK,CAAC,EACvC,CAAE,MAAAA,EAAO,GAAAlI,EAAI,GAAAqI,CAAE,CAC1B,8DCzdA,OAAO,eAAchhD,EAAU,aAAc,CAAE,MAAO,GAAM,EAC5DA,EAAA,IAAcA,EAAA,OAAiB,OAC/BA,EAAA,iBAA2BkhD,EAC3BlhD,EAAA,eAAyBmhD,EACzBnhD,EAAA,aAAuBohD,EACvBphD,EAAA,eAAyBqhD,EACzBrhD,EAAA,oBAA8BshD,EAC9BthD,EAAA,KAAeuhD,EACfvhD,EAAA,MAAgBwhD,EAChBxhD,EAAA,kBAA4ByhD,EAC5BzhD,EAAA,mBAA6B0hD,EAC7B1hD,EAAA,YAAsB2hD,EA2BtB,sEACA,MAAMC,EAAY//C,GAAA,EACZ6gC,EAAU1hB,GAAA,EACV+G,EAAalE,GAAA,EACbg+B,EAAatmB,GAAA,EACb6hB,EAAe5hB,GAAA,EAEfsmB,EAAa,CAAC/rC,EAAKgsC,KAAShsC,GAAOA,GAAO,EAAIgsC,EAAM,CAACA,GAAO/J,GAAO+J,EAIzE,SAASb,EAAiBzhD,EAAGuiD,EAAOniD,EAAG,CAInC,KAAM,CAAC,CAACoiD,EAAIC,CAAE,EAAG,CAACC,EAAIC,CAAE,CAAC,EAAIJ,EACvB3I,EAAKyI,EAAWM,EAAK3iD,EAAGI,CAAC,EACzBy5C,EAAKwI,EAAW,CAACI,EAAKziD,EAAGI,CAAC,EAGhC,IAAI8/C,EAAKlgD,EAAI45C,EAAK4I,EAAK3I,EAAK6I,EACxBvC,GAAK,CAACvG,EAAK6I,EAAK5I,EAAK8I,EACzB,MAAMC,GAAQ1C,EAAKlL,EACb6N,GAAQ1C,GAAKnL,EACf4N,KACA1C,EAAK,CAACA,GACN2C,KACA1C,GAAK,CAACA,IAGV,MAAM2C,MAAcx6B,EAAW,SAAS,KAAK,QAASA,EAAW,QAAQloB,CAAC,EAAI,CAAC,CAAC,EAAI60C,EACpF,GAAIiL,EAAKlL,GAAOkL,GAAM4C,IAAW3C,GAAKnL,GAAOmL,IAAM2C,GAC/C,MAAM,IAAI,MAAM,yCAA2C9iD,CAAC,EAEhE,MAAO,CAAE,MAAA4iD,GAAO,GAAA1C,EAAI,MAAA2C,GAAO,GAAA1C,EAAE,CACjC,CACA,SAAS4C,EAAkBC,EAAQ,CAC/B,GAAI,CAAC,CAAC,UAAW,YAAa,KAAK,EAAE,SAASA,CAAM,EAChD,MAAM,IAAI,MAAM,2DAA2D,EAC/E,OAAOA,CACX,CACA,SAASC,EAAgBp7B,EAAMq7B,EAAK,CAChC,MAAMC,EAAQ,CAAA,EACd,QAASC,KAAW,OAAO,KAAKF,CAAG,EAE/BC,EAAMC,CAAO,EAAIv7B,EAAKu7B,CAAO,IAAM,OAAYF,EAAIE,CAAO,EAAIv7B,EAAKu7B,CAAO,EAE9E,SAAI96B,EAAW,SAAS66B,EAAM,KAAM,MAAM,KACtC76B,EAAW,SAAS66B,EAAM,QAAS,SAAS,EAC5CA,EAAM,SAAW,QACjBJ,EAAkBI,EAAM,MAAM,EAC3BA,CACX,CACA,MAAME,UAAe,KAAM,CACvB,YAAYnjD,EAAI,GAAI,CAChB,MAAMA,CAAC,CACf,CACA,CACAK,EAAA,OAAiB8iD,EAQjB9iD,EAAA,IAAc,CAEV,IAAK8iD,EAEL,KAAM,CACF,OAAQ,CAACj9C,EAAKE,IAAS,CACnB,KAAM,CAAE,IAAKpF,CAAC,EAAKX,EAAQ,IAC3B,GAAI6F,EAAM,GAAKA,EAAM,IACjB,MAAM,IAAIlF,EAAE,uBAAuB,EACvC,GAAIoF,EAAK,OAAS,EACd,MAAM,IAAIpF,EAAE,2BAA2B,EAC3C,MAAMoiD,EAAUh9C,EAAK,OAAS,EACxBsP,KAAU0S,EAAW,qBAAqBg7B,CAAO,EACvD,GAAK1tC,EAAI,OAAS,EAAK,IACnB,MAAM,IAAI1U,EAAE,sCAAsC,EAEtD,MAAMqiD,EAASD,EAAU,OAAUh7B,EAAW,qBAAsB1S,EAAI,OAAS,EAAK,GAAG,EAAI,GAE7F,SADc0S,EAAW,qBAAqBliB,CAAG,EACtCm9C,EAAS3tC,EAAMtP,CACtC,EAEQ,OAAOF,EAAKE,EAAM,CACd,KAAM,CAAE,IAAKpF,CAAC,EAAKX,EAAQ,IAC3B,IAAIuZ,EAAM,EACV,GAAI1T,EAAM,GAAKA,EAAM,IACjB,MAAM,IAAIlF,EAAE,uBAAuB,EACvC,GAAIoF,EAAK,OAAS,GAAKA,EAAKwT,GAAK,IAAM1T,EACnC,MAAM,IAAIlF,EAAE,uBAAuB,EACvC,MAAMwc,EAAQpX,EAAKwT,GAAK,EAClB0pC,EAAS,CAAC,EAAE9lC,EAAQ,KAC1B,IAAI5a,EAAS,EACb,GAAI,CAAC0gD,EACD1gD,EAAS4a,MACR,CAED,MAAM6lC,EAAS7lC,EAAQ,IACvB,GAAI,CAAC6lC,EACD,MAAM,IAAIriD,EAAE,mDAAmD,EACnE,GAAIqiD,EAAS,EACT,MAAM,IAAIriD,EAAE,0CAA0C,EAC1D,MAAMuiD,EAAcn9C,EAAK,SAASwT,EAAKA,EAAMypC,CAAM,EACnD,GAAIE,EAAY,SAAWF,EACvB,MAAM,IAAIriD,EAAE,uCAAuC,EACvD,GAAIuiD,EAAY,CAAC,IAAM,EACnB,MAAM,IAAIviD,EAAE,sCAAsC,EACtD,UAAWxB,MAAK+jD,EACZ3gD,EAAUA,GAAU,EAAKpD,GAE7B,GADAoa,GAAOypC,EACHzgD,EAAS,IACT,MAAM,IAAI5B,EAAE,wCAAwC,CACxE,CACY,MAAM8zB,EAAI1uB,EAAK,SAASwT,EAAKA,EAAMhX,CAAM,EACzC,GAAIkyB,EAAE,SAAWlyB,EACb,MAAM,IAAI5B,EAAE,gCAAgC,EAChD,MAAO,CAAE,EAAA8zB,EAAG,EAAG1uB,EAAK,SAASwT,EAAMhX,CAAM,CAAC,CACtD,GAMI,KAAM,CACF,OAAOwT,EAAK,CACR,KAAM,CAAE,IAAKpV,CAAC,EAAKX,EAAQ,IAC3B,GAAI+V,EAAM0+B,EACN,MAAM,IAAI9zC,EAAE,4CAA4C,EAC5D,IAAIylB,KAAU2B,EAAW,qBAAqBhS,CAAG,EAIjD,GAFI,OAAO,SAASqQ,EAAI,CAAC,EAAG,EAAE,EAAI,IAC9BA,EAAM,KAAOA,GACbA,EAAI,OAAS,EACb,MAAM,IAAIzlB,EAAE,gDAAgD,EAChE,OAAOylB,CACnB,EACQ,OAAOrgB,EAAM,CACT,KAAM,CAAE,IAAKpF,CAAC,EAAKX,EAAQ,IAC3B,GAAI+F,EAAK,CAAC,EAAI,IACV,MAAM,IAAIpF,EAAE,qCAAqC,EACrD,GAAIoF,EAAK,CAAC,IAAM,GAAQ,EAAEA,EAAK,CAAC,EAAI,KAChC,MAAM,IAAIpF,EAAE,qDAAqD,EACrE,SAAWonB,EAAW,iBAAiBhiB,CAAI,CACvD,GAEI,MAAMqgB,EAAK,CAEP,KAAM,CAAE,IAAKzlB,EAAG,KAAMyH,EAAK,KAAM+6C,GAAQnjD,EAAQ,IAC3C+F,KAAWgiB,EAAW,aAAa,YAAa3B,CAAG,EACnD,CAAE,EAAGg9B,EAAU,EAAGC,CAAY,EAAKF,EAAI,OAAO,GAAMp9C,CAAI,EAC9D,GAAIs9C,EAAa,OACb,MAAM,IAAI1iD,EAAE,6CAA6C,EAC7D,KAAM,CAAE,EAAG2iD,EAAQ,EAAGC,CAAU,EAAKJ,EAAI,OAAO,EAAMC,CAAQ,EACxD,CAAE,EAAGI,EAAQ,EAAGC,EAAU,EAAKN,EAAI,OAAO,EAAMI,CAAU,EAChE,GAAIE,GAAW,OACX,MAAM,IAAI9iD,EAAE,6CAA6C,EAC7D,MAAO,CAAE,EAAGyH,EAAI,OAAOk7C,CAAM,EAAG,EAAGl7C,EAAI,OAAOo7C,CAAM,CAAC,CAC7D,EACI,WAAWjX,EAAK,CACZ,KAAM,CAAE,KAAM4W,EAAK,KAAM/6C,CAAG,EAAKpI,EAAQ,IACnC0jD,EAAKP,EAAI,OAAO,EAAM/6C,EAAI,OAAOmkC,EAAI,CAAC,CAAC,EACvCoX,EAAKR,EAAI,OAAO,EAAM/6C,EAAI,OAAOmkC,EAAI,CAAC,CAAC,EACvCxlC,EAAM28C,EAAKC,EACjB,OAAOR,EAAI,OAAO,GAAMp8C,CAAG,CACnC,GAIA,MAAM0tC,EAAM,OAAO,CAAC,EAAGC,EAAM,OAAO,CAAC,EAAGsD,EAAM,OAAO,CAAC,EAAGC,EAAM,OAAO,CAAC,EAAGC,EAAM,OAAO,CAAC,EACxF,SAASiJ,EAAeH,EAAIx+C,EAAK,CAC7B,KAAM,CAAE,MAAOoe,CAAQ,EAAKogC,EAC5B,IAAIjrC,EACJ,GAAI,OAAOvT,GAAQ,SACfuT,EAAMvT,MAEL,CACD,IAAIma,KAAYoL,EAAW,aAAa,cAAevlB,CAAG,EAC1D,GAAI,CACAuT,EAAMirC,EAAG,UAAUrkC,CAAK,CACpC,MACsB,CACV,MAAM,IAAI,MAAM,8CAA8CiE,CAAQ,SAAS,OAAOpe,CAAG,EAAE,CACvG,CACA,CACI,GAAI,CAACw+C,EAAG,YAAYjrC,CAAG,EACnB,MAAM,IAAI,MAAM,4CAA4C,EAChE,OAAOA,CACX,CAkBA,SAASqrC,EAAaH,EAAQ2C,EAAY,GAAI,CAC1C,MAAMC,KAAgBhC,EAAW,oBAAoB,cAAeZ,EAAQ2C,CAAS,EAC/E,CAAE,GAAAjL,EAAI,GAAAqI,CAAE,EAAK6C,EACnB,IAAIhD,EAAQgD,EAAU,MACtB,KAAM,CAAE,EAAGC,EAAU,EAAGC,CAAW,EAAKlD,KACpC94B,EAAW,iBAAiB67B,EAAW,GAAI,CAC3C,mBAAoB,UACpB,cAAe,WACf,cAAe,WACf,UAAW,WACX,QAAS,WACT,KAAM,SACN,eAAgB,SACxB,CAAK,EACD,KAAM,CAAE,KAAAI,CAAI,EAAKJ,EACjB,GAAII,IAEI,CAACrL,EAAG,IAAIkI,EAAM,CAAC,GAAK,OAAOmD,EAAK,MAAS,UAAY,CAAC,MAAM,QAAQA,EAAK,OAAO,GAChF,MAAM,IAAI,MAAM,4DAA4D,EAGpF,MAAMr+B,EAAUs+B,EAAYtL,EAAIqI,CAAE,EAClC,SAASkD,IAA+B,CACpC,GAAI,CAACvL,EAAG,MACJ,MAAM,IAAI,MAAM,4DAA4D,CACxF,CAEI,SAASwL,GAAaC,GAAIhF,GAAOiF,GAAc,CAC3C,KAAM,CAAE,EAAAvkD,GAAG,EAAAQ,IAAM8+C,GAAM,SAAQ,EACzBkF,GAAK3L,EAAG,QAAQ74C,EAAC,EAEvB,MADIioB,EAAW,SAASs8B,GAAc,cAAc,EAChDA,GAAc,CACdH,GAA4B,EAC5B,MAAMK,GAAW,CAAC5L,EAAG,MAAMr4C,EAAC,EAC5B,SAAWynB,EAAW,aAAay8B,EAAQD,EAAQ,EAAGD,EAAE,CACpE,KAEY,UAAWv8B,EAAW,aAAa,WAAW,GAAG,CAAI,EAAGu8B,GAAI3L,EAAG,QAAQr4C,EAAC,CAAC,CAErF,CACI,SAASmkD,GAAe9nC,GAAO,IACvBoL,EAAW,UAAUpL,GAAO,OAAW,OAAO,EAClD,KAAM,CAAE,UAAW8iC,GAAM,sBAAuBiF,EAAM,EAAK/+B,EACrDpjB,GAASoa,GAAM,OACfrY,GAAOqY,GAAM,CAAC,EACdpY,GAAOoY,GAAM,SAAS,CAAC,EAE7B,GAAIpa,KAAWk9C,KAASn7C,KAAS,GAAQA,KAAS,GAAO,CACrD,MAAMxE,GAAI64C,EAAG,UAAUp0C,EAAI,EAC3B,GAAI,CAACo0C,EAAG,QAAQ74C,EAAC,EACb,MAAM,IAAI,MAAM,qCAAqC,EACzD,MAAM6kD,EAAKC,GAAoB9kD,EAAC,EAChC,IAAIQ,EACJ,GAAI,CACAA,EAAIq4C,EAAG,KAAKgM,CAAE,CAC9B,OACmBE,EAAW,CACd,MAAMC,EAAMD,aAAqB,MAAQ,KAAOA,EAAU,QAAU,GACpE,MAAM,IAAI,MAAM,yCAA2CC,CAAG,CAC9E,CACYZ,GAA4B,EAC5B,MAAMa,EAASpM,EAAG,MAAMr4C,CAAC,EAEzB,OADmBgE,GAAO,KAAO,IACfygD,IACdzkD,EAAIq4C,EAAG,IAAIr4C,CAAC,GACT,CAAE,EAAAR,GAAG,EAAAQ,CAAC,CACzB,SACiBiC,KAAWmiD,IAAUpgD,KAAS,EAAM,CAEzC,MAAMpD,GAAIy3C,EAAG,MACP74C,EAAI64C,EAAG,UAAUp0C,GAAK,SAAS,EAAGrD,EAAC,CAAC,EACpCZ,EAAIq4C,EAAG,UAAUp0C,GAAK,SAASrD,GAAGA,GAAI,CAAC,CAAC,EAC9C,GAAI,CAAC8jD,GAAUllD,EAAGQ,CAAC,EACf,MAAM,IAAI,MAAM,4BAA4B,EAChD,MAAO,CAAE,EAAAR,EAAG,EAAAQ,CAAC,CACzB,KAEY,OAAM,IAAI,MAAM,yBAAyBiC,EAAM,yBAAyBk9C,EAAI,oBAAoBiF,EAAM,EAAE,CAEpH,CACI,MAAMO,GAAcrB,EAAU,SAAWO,GACnCe,GAActB,EAAU,WAAaa,GAC3C,SAASG,GAAoB9kD,GAAG,CAC5B,MAAMqlD,GAAKxM,EAAG,IAAI74C,EAAC,EACbslD,GAAKzM,EAAG,IAAIwM,GAAIrlD,EAAC,EACvB,OAAO64C,EAAG,IAAIA,EAAG,IAAIyM,GAAIzM,EAAG,IAAI74C,GAAG+gD,EAAM,CAAC,CAAC,EAAGA,EAAM,CAAC,CAC7D,CAGI,SAASmE,GAAUllD,GAAGQ,GAAG,CACrB,MAAM+kD,GAAO1M,EAAG,IAAIr4C,EAAC,EACfglD,GAAQV,GAAoB9kD,EAAC,EACnC,OAAO64C,EAAG,IAAI0M,GAAMC,EAAK,CACjC,CAGI,GAAI,CAACN,GAAUnE,EAAM,GAAIA,EAAM,EAAE,EAC7B,MAAM,IAAI,MAAM,mCAAmC,EAGvD,MAAM0E,GAAO5M,EAAG,IAAIA,EAAG,IAAIkI,EAAM,EAAG5I,CAAG,EAAGC,CAAG,EACvCsN,GAAQ7M,EAAG,IAAIA,EAAG,IAAIkI,EAAM,CAAC,EAAG,OAAO,EAAE,CAAC,EAChD,GAAIlI,EAAG,IAAIA,EAAG,IAAI4M,GAAMC,EAAK,CAAC,EAC1B,MAAM,IAAI,MAAM,0BAA0B,EAE9C,SAASC,GAAO9Q,GAAO90C,GAAG6lD,GAAU,GAAO,CACvC,GAAI,CAAC/M,EAAG,QAAQ94C,EAAC,GAAM6lD,IAAW/M,EAAG,IAAI94C,EAAC,EACtC,MAAM,IAAI,MAAM,wBAAwB80C,EAAK,EAAE,EACnD,OAAO90C,EACf,CACI,SAAS8lD,GAAUtlB,GAAO,CACtB,GAAI,EAAEA,cAAiB8e,IACnB,MAAM,IAAI,MAAM,0BAA0B,CACtD,CACI,SAASyG,GAAiBnmD,GAAG,CACzB,GAAI,CAACukD,GAAQ,CAACA,EAAK,QACf,MAAM,IAAI,MAAM,SAAS,EAC7B,OAAO9C,EAAiBzhD,GAAGukD,EAAK,QAAShD,EAAG,KAAK,CACzD,CAKI,MAAM6E,MAAmB99B,EAAW,UAAU,CAAC9nB,GAAG6lD,KAAO,CACrD,KAAM,CAAE,EAAAjX,GAAG,EAAAkX,GAAG,EAAAC,EAAC,EAAK/lD,GAEpB,GAAI04C,EAAG,IAAIqN,GAAGrN,EAAG,GAAG,EAChB,MAAO,CAAE,EAAG9J,GAAG,EAAGkX,EAAC,EACvB,MAAME,GAAMhmD,GAAE,IAAG,EAGb6lD,IAAM,OACNA,GAAKG,GAAMtN,EAAG,IAAMA,EAAG,IAAIqN,EAAC,GAChC,MAAMlmD,GAAI64C,EAAG,IAAI9J,GAAGiX,EAAE,EAChBxlD,EAAIq4C,EAAG,IAAIoN,GAAGD,EAAE,EAChBI,EAAKvN,EAAG,IAAIqN,GAAGF,EAAE,EACvB,GAAIG,GACA,MAAO,CAAE,EAAGtN,EAAG,KAAM,EAAGA,EAAG,IAAI,EACnC,GAAI,CAACA,EAAG,IAAIuN,EAAIvN,EAAG,GAAG,EAClB,MAAM,IAAI,MAAM,kBAAkB,EACtC,MAAO,CAAE,EAAA74C,GAAG,EAAAQ,CAAC,CACrB,CAAK,EAGK6lD,MAAsBp+B,EAAW,UAAW9nB,IAAM,CACpD,GAAIA,GAAE,MAAO,CAIT,GAAI2jD,EAAU,oBAAsB,CAACjL,EAAG,IAAI14C,GAAE,CAAC,EAC3C,OACJ,MAAM,IAAI,MAAM,iBAAiB,CAC7C,CAEQ,KAAM,CAAE,EAAAH,GAAG,EAAAQ,IAAML,GAAE,SAAQ,EAC3B,GAAI,CAAC04C,EAAG,QAAQ74C,EAAC,GAAK,CAAC64C,EAAG,QAAQr4C,EAAC,EAC/B,MAAM,IAAI,MAAM,sCAAsC,EAC1D,GAAI,CAAC0kD,GAAUllD,GAAGQ,EAAC,EACf,MAAM,IAAI,MAAM,mCAAmC,EACvD,GAAI,CAACL,GAAE,cAAa,EAChB,MAAM,IAAI,MAAM,wCAAwC,EAC5D,MAAO,EACf,CAAK,EACD,SAASmmD,GAAWC,GAAUC,GAAKC,GAAKlE,GAAOC,GAAO,CAClD,OAAAiE,GAAM,IAAIpH,GAAMxG,EAAG,IAAI4N,GAAI,EAAGF,EAAQ,EAAGE,GAAI,EAAGA,GAAI,CAAC,EACrDD,MAAUzE,EAAW,UAAUQ,GAAOiE,EAAG,EACzCC,MAAU1E,EAAW,UAAUS,GAAOiE,EAAG,EAClCD,GAAI,IAAIC,EAAG,CAC1B,CAMI,MAAMpH,EAAM,CAER,YAAYtQ,GAAGkX,GAAGC,GAAG,CACjB,KAAK,EAAIP,GAAO,IAAK5W,EAAC,EACtB,KAAK,EAAI4W,GAAO,IAAKM,GAAG,EAAI,EAC5B,KAAK,EAAIN,GAAO,IAAKO,EAAC,EACtB,OAAO,OAAO,IAAI,CAC9B,CACQ,OAAO,OAAQ,CACX,OAAOnF,CACnB,CAEQ,OAAO,WAAW5gD,GAAG,CACjB,KAAM,CAAE,EAAAH,GAAG,EAAAQ,EAAC,EAAKL,IAAK,CAAA,EACtB,GAAI,CAACA,IAAK,CAAC04C,EAAG,QAAQ74C,EAAC,GAAK,CAAC64C,EAAG,QAAQr4C,EAAC,EACrC,MAAM,IAAI,MAAM,sBAAsB,EAC1C,GAAIL,cAAak/C,GACb,MAAM,IAAI,MAAM,8BAA8B,EAElD,OAAIxG,EAAG,IAAI74C,EAAC,GAAK64C,EAAG,IAAIr4C,EAAC,EACd6+C,GAAM,KACV,IAAIA,GAAMr/C,GAAGQ,GAAGq4C,EAAG,GAAG,CACzC,CACQ,OAAO,UAAUh8B,GAAO,CACpB,MAAMrb,GAAI69C,GAAM,WAAW+F,MAAgBn9B,EAAW,UAAUpL,GAAO,OAAW,OAAO,CAAC,CAAC,EAC3F,OAAArb,GAAE,eAAc,EACTA,EACnB,CACQ,OAAO,QAAQ8kB,GAAK,CAChB,OAAO+4B,GAAM,aAAcp3B,EAAW,aAAa,WAAY3B,EAAG,CAAC,CAC/E,CACQ,IAAI,GAAI,CACJ,OAAO,KAAK,SAAQ,EAAG,CACnC,CACQ,IAAI,GAAI,CACJ,OAAO,KAAK,SAAQ,EAAG,CACnC,CAOQ,WAAW03B,GAAa,EAAG0I,GAAS,GAAM,CACtC,OAAAC,GAAK,YAAY,KAAM3I,EAAU,EAC5B0I,IACD,KAAK,SAASvO,CAAG,EACd,IACnB,CAGQ,gBAAiB,CACbkO,GAAgB,IAAI,CAChC,CACQ,UAAW,CACP,KAAM,CAAE,EAAA7lD,EAAC,EAAK,KAAK,SAAQ,EAC3B,GAAI,CAACq4C,EAAG,MACJ,MAAM,IAAI,MAAM,6BAA6B,EACjD,MAAO,CAACA,EAAG,MAAMr4C,EAAC,CAC9B,CAEQ,OAAO+/B,GAAO,CACVslB,GAAUtlB,EAAK,EACf,KAAM,CAAE,EAAGqmB,GAAI,EAAGC,GAAI,EAAGC,EAAE,EAAK,KAC1B,CAAE,EAAGC,GAAI,EAAGC,GAAI,EAAGC,CAAE,EAAK1mB,GAC1B2mB,EAAKrO,EAAG,IAAIA,EAAG,IAAI+N,GAAIK,CAAE,EAAGpO,EAAG,IAAIkO,GAAID,EAAE,CAAC,EAC1CK,EAAKtO,EAAG,IAAIA,EAAG,IAAIgO,GAAII,CAAE,EAAGpO,EAAG,IAAImO,GAAIF,EAAE,CAAC,EAChD,OAAOI,GAAMC,CACzB,CAEQ,QAAS,CACL,OAAO,IAAI9H,GAAM,KAAK,EAAGxG,EAAG,IAAI,KAAK,CAAC,EAAG,KAAK,CAAC,CAC3D,CAKQ,QAAS,CACL,KAAM,CAAE,EAAAz5C,GAAG,EAAAC,EAAC,EAAK0hD,EACXqG,GAAKvO,EAAG,IAAIx5C,GAAG84C,CAAG,EAClB,CAAE,EAAGyO,GAAI,EAAGC,GAAI,EAAGC,EAAE,EAAK,KAChC,IAAIO,EAAKxO,EAAG,KAAMyO,EAAKzO,EAAG,KAAM0O,EAAK1O,EAAG,KACpC2O,EAAK3O,EAAG,IAAI+N,GAAIA,EAAE,EAClBa,EAAK5O,EAAG,IAAIgO,GAAIA,EAAE,EAClBa,EAAK7O,EAAG,IAAIiO,GAAIA,EAAE,EAClBa,EAAK9O,EAAG,IAAI+N,GAAIC,EAAE,EACtB,OAAAc,EAAK9O,EAAG,IAAI8O,EAAIA,CAAE,EAClBJ,EAAK1O,EAAG,IAAI+N,GAAIE,EAAE,EAClBS,EAAK1O,EAAG,IAAI0O,EAAIA,CAAE,EAClBF,EAAKxO,EAAG,IAAIz5C,GAAGmoD,CAAE,EACjBD,EAAKzO,EAAG,IAAIuO,GAAIM,CAAE,EAClBJ,EAAKzO,EAAG,IAAIwO,EAAIC,CAAE,EAClBD,EAAKxO,EAAG,IAAI4O,EAAIH,CAAE,EAClBA,EAAKzO,EAAG,IAAI4O,EAAIH,CAAE,EAClBA,EAAKzO,EAAG,IAAIwO,EAAIC,CAAE,EAClBD,EAAKxO,EAAG,IAAI8O,EAAIN,CAAE,EAClBE,EAAK1O,EAAG,IAAIuO,GAAIG,CAAE,EAClBG,EAAK7O,EAAG,IAAIz5C,GAAGsoD,CAAE,EACjBC,EAAK9O,EAAG,IAAI2O,EAAIE,CAAE,EAClBC,EAAK9O,EAAG,IAAIz5C,GAAGuoD,CAAE,EACjBA,EAAK9O,EAAG,IAAI8O,EAAIJ,CAAE,EAClBA,EAAK1O,EAAG,IAAI2O,EAAIA,CAAE,EAClBA,EAAK3O,EAAG,IAAI0O,EAAIC,CAAE,EAClBA,EAAK3O,EAAG,IAAI2O,EAAIE,CAAE,EAClBF,EAAK3O,EAAG,IAAI2O,EAAIG,CAAE,EAClBL,EAAKzO,EAAG,IAAIyO,EAAIE,CAAE,EAClBE,EAAK7O,EAAG,IAAIgO,GAAIC,EAAE,EAClBY,EAAK7O,EAAG,IAAI6O,EAAIA,CAAE,EAClBF,EAAK3O,EAAG,IAAI6O,EAAIC,CAAE,EAClBN,EAAKxO,EAAG,IAAIwO,EAAIG,CAAE,EAClBD,EAAK1O,EAAG,IAAI6O,EAAID,CAAE,EAClBF,EAAK1O,EAAG,IAAI0O,EAAIA,CAAE,EAClBA,EAAK1O,EAAG,IAAI0O,EAAIA,CAAE,EACX,IAAIlI,GAAMgI,EAAIC,EAAIC,CAAE,CACvC,CAKQ,IAAIhnB,GAAO,CACPslB,GAAUtlB,EAAK,EACf,KAAM,CAAE,EAAGqmB,GAAI,EAAGC,GAAI,EAAGC,EAAE,EAAK,KAC1B,CAAE,EAAGC,GAAI,EAAGC,GAAI,EAAGC,CAAE,EAAK1mB,GAChC,IAAI8mB,EAAKxO,EAAG,KAAMyO,EAAKzO,EAAG,KAAM0O,EAAK1O,EAAG,KACxC,MAAMz5C,EAAI2hD,EAAM,EACVqG,EAAKvO,EAAG,IAAIkI,EAAM,EAAG5I,CAAG,EAC9B,IAAIqP,EAAK3O,EAAG,IAAI+N,GAAIG,EAAE,EAClBU,GAAK5O,EAAG,IAAIgO,GAAIG,EAAE,EAClBU,GAAK7O,EAAG,IAAIiO,GAAIG,CAAE,EAClBU,GAAK9O,EAAG,IAAI+N,GAAIC,EAAE,EAClBe,GAAK/O,EAAG,IAAIkO,GAAIC,EAAE,EACtBW,GAAK9O,EAAG,IAAI8O,GAAIC,EAAE,EAClBA,GAAK/O,EAAG,IAAI2O,EAAIC,EAAE,EAClBE,GAAK9O,EAAG,IAAI8O,GAAIC,EAAE,EAClBA,GAAK/O,EAAG,IAAI+N,GAAIE,EAAE,EAClB,IAAIe,GAAKhP,EAAG,IAAIkO,GAAIE,CAAE,EACtB,OAAAW,GAAK/O,EAAG,IAAI+O,GAAIC,EAAE,EAClBA,GAAKhP,EAAG,IAAI2O,EAAIE,EAAE,EAClBE,GAAK/O,EAAG,IAAI+O,GAAIC,EAAE,EAClBA,GAAKhP,EAAG,IAAIgO,GAAIC,EAAE,EAClBO,EAAKxO,EAAG,IAAImO,GAAIC,CAAE,EAClBY,GAAKhP,EAAG,IAAIgP,GAAIR,CAAE,EAClBA,EAAKxO,EAAG,IAAI4O,GAAIC,EAAE,EAClBG,GAAKhP,EAAG,IAAIgP,GAAIR,CAAE,EAClBE,EAAK1O,EAAG,IAAIz5C,EAAGwoD,EAAE,EACjBP,EAAKxO,EAAG,IAAIuO,EAAIM,EAAE,EAClBH,EAAK1O,EAAG,IAAIwO,EAAIE,CAAE,EAClBF,EAAKxO,EAAG,IAAI4O,GAAIF,CAAE,EAClBA,EAAK1O,EAAG,IAAI4O,GAAIF,CAAE,EAClBD,EAAKzO,EAAG,IAAIwO,EAAIE,CAAE,EAClBE,GAAK5O,EAAG,IAAI2O,EAAIA,CAAE,EAClBC,GAAK5O,EAAG,IAAI4O,GAAID,CAAE,EAClBE,GAAK7O,EAAG,IAAIz5C,EAAGsoD,EAAE,EACjBE,GAAK/O,EAAG,IAAIuO,EAAIQ,EAAE,EAClBH,GAAK5O,EAAG,IAAI4O,GAAIC,EAAE,EAClBA,GAAK7O,EAAG,IAAI2O,EAAIE,EAAE,EAClBA,GAAK7O,EAAG,IAAIz5C,EAAGsoD,EAAE,EACjBE,GAAK/O,EAAG,IAAI+O,GAAIF,EAAE,EAClBF,EAAK3O,EAAG,IAAI4O,GAAIG,EAAE,EAClBN,EAAKzO,EAAG,IAAIyO,EAAIE,CAAE,EAClBA,EAAK3O,EAAG,IAAIgP,GAAID,EAAE,EAClBP,EAAKxO,EAAG,IAAI8O,GAAIN,CAAE,EAClBA,EAAKxO,EAAG,IAAIwO,EAAIG,CAAE,EAClBA,EAAK3O,EAAG,IAAI8O,GAAIF,EAAE,EAClBF,EAAK1O,EAAG,IAAIgP,GAAIN,CAAE,EAClBA,EAAK1O,EAAG,IAAI0O,EAAIC,CAAE,EACX,IAAInI,GAAMgI,EAAIC,EAAIC,CAAE,CACvC,CACQ,SAAShnB,GAAO,CACZ,OAAO,KAAK,IAAIA,GAAM,OAAM,CAAE,CAC1C,CACQ,KAAM,CACF,OAAO,KAAK,OAAO8e,GAAM,IAAI,CACzC,CAUQ,SAAS/C,GAAQ,CACb,KAAM,CAAE,KAAA4H,EAAI,EAAKJ,EACjB,GAAI,CAAC5C,EAAG,YAAY5E,EAAM,EACtB,MAAM,IAAI,MAAM,8BAA8B,EAClD,IAAIgD,GAAOwI,GACX,MAAM5qC,GAAOnd,IAAM4mD,GAAK,OAAO,KAAM5mD,GAAII,MAAU4hD,EAAW,YAAY1C,GAAOl/C,CAAC,CAAC,EAEnF,GAAI+jD,GAAM,CACN,KAAM,CAAE,MAAA3B,GAAO,GAAA1C,EAAI,MAAA2C,EAAO,GAAA1C,CAAE,EAAKgG,GAAiBxJ,EAAM,EAClD,CAAE,EAAGkK,EAAK,EAAGuB,CAAG,EAAK7qC,GAAI2iC,CAAE,EAC3B,CAAE,EAAG4G,EAAK,EAAGuB,CAAG,EAAK9qC,GAAI4iC,CAAE,EACjCgI,GAAOC,EAAI,IAAIC,CAAG,EAClB1I,GAAQgH,GAAWpC,GAAK,KAAMsC,EAAKC,EAAKlE,GAAOC,CAAK,CACpE,KACiB,CACD,KAAM,CAAE,EAAAriD,GAAG,EAAAhB,GAAM+d,GAAIo/B,EAAM,EAC3BgD,GAAQn/C,GACR2nD,GAAO3oD,CACvB,CAEY,SAAW4iD,EAAW,YAAY1C,GAAO,CAACC,GAAOwI,EAAI,CAAC,EAAE,CAAC,CACrE,CAMQ,eAAeG,GAAI,CACf,KAAM,CAAE,KAAA/D,EAAI,EAAKJ,EACX3jD,GAAI,KACV,GAAI,CAAC+gD,EAAG,QAAQ+G,EAAE,EACd,MAAM,IAAI,MAAM,8BAA8B,EAClD,GAAIA,KAAOtT,GAAOx0C,GAAE,IAAG,EACnB,OAAOk/C,GAAM,KACjB,GAAI4I,KAAOrT,EACP,OAAOz0C,GACX,GAAIwmD,GAAK,SAAS,IAAI,EAClB,OAAO,KAAK,SAASsB,EAAE,EAC3B,GAAI/D,GAAM,CACN,KAAM,CAAE,MAAA3B,GAAO,GAAA1C,GAAI,MAAA2C,GAAO,GAAA1C,CAAE,EAAKgG,GAAiBmC,EAAE,EAC9C,CAAE,GAAAlI,EAAI,GAAAC,CAAE,KAAS+B,EAAW,eAAe1C,GAAOl/C,GAAG0/C,GAAIC,CAAE,EACjE,OAAOwG,GAAWpC,GAAK,KAAMnE,EAAIC,EAAIuC,GAAOC,EAAK,CACjE,KAEgB,QAAOmE,GAAK,OAAOxmD,GAAG8nD,EAAE,CAExC,CACQ,qBAAqBxmD,GAAGrC,GAAGC,GAAG,CAC1B,MAAMgoB,GAAM,KAAK,eAAejoB,EAAC,EAAE,IAAIqC,GAAE,eAAepC,EAAC,CAAC,EAC1D,OAAOgoB,GAAI,MAAQ,OAAYA,EAC3C,CAKQ,SAAS6gC,GAAW,CAChB,OAAOnC,GAAa,KAAMmC,EAAS,CAC/C,CAKQ,eAAgB,CACZ,KAAM,CAAE,cAAAC,EAAa,EAAKrE,EAC1B,OAAIE,IAAapP,EACN,GACPuT,GACOA,GAAc9I,GAAO,IAAI,EAC7BsH,GAAK,OAAO,KAAM1C,CAAW,EAAE,IAAG,CACrD,CACQ,eAAgB,CACZ,KAAM,CAAE,cAAAmE,EAAa,EAAKtE,EAC1B,OAAIE,IAAapP,EACN,KACPwT,GACOA,GAAc/I,GAAO,IAAI,EAC7B,KAAK,eAAe2E,CAAQ,CAC/C,CACQ,cAAe,CAEX,OAAO,KAAK,eAAeA,CAAQ,EAAE,IAAG,CACpD,CACQ,QAAQO,GAAe,GAAM,CACzB,SAAIt8B,EAAW,SAASs8B,GAAc,cAAc,EACpD,KAAK,eAAc,EACZY,GAAY9F,GAAO,KAAMkF,EAAY,CACxD,CACQ,MAAMA,GAAe,GAAM,CACvB,SAAWt8B,EAAW,YAAY,KAAK,QAAQs8B,EAAY,CAAC,CACxE,CACQ,UAAW,CACP,MAAO,UAAU,KAAK,IAAG,EAAK,OAAS,KAAK,MAAK,CAAE,GAC/D,CAEQ,IAAI,IAAK,CACL,OAAO,KAAK,CACxB,CACQ,IAAI,IAAK,CACL,OAAO,KAAK,CACxB,CACQ,IAAI,IAAK,CACL,OAAO,KAAK,CACxB,CACQ,WAAWA,GAAe,GAAM,CAC5B,OAAO,KAAK,QAAQA,EAAY,CAC5C,CACQ,eAAevG,GAAY,CACvB,KAAK,WAAWA,EAAU,CACtC,CACQ,OAAO,WAAWP,GAAQ,CACtB,SAAWsE,EAAW,YAAY1C,GAAO5B,EAAM,CAC3D,CACQ,OAAO,IAAIA,GAAQsB,GAAS,CACxB,SAAWgD,EAAW,WAAW1C,GAAO6B,EAAIzD,GAAQsB,EAAO,CACvE,CACQ,OAAO,eAAenT,GAAY,CAC9B,OAAOyT,GAAM,KAAK,SAASgC,EAAeH,EAAItV,EAAU,CAAC,CACrE,CACA,CAEIyT,GAAM,KAAO,IAAIA,GAAM0B,EAAM,GAAIA,EAAM,GAAIlI,EAAG,GAAG,EAEjDwG,GAAM,KAAO,IAAIA,GAAMxG,EAAG,KAAMA,EAAG,IAAKA,EAAG,IAAI,EAE/CwG,GAAM,GAAKxG,EAEXwG,GAAM,GAAK6B,EACX,MAAMr2C,GAAOq2C,EAAG,KACVyF,GAAO,IAAI5E,EAAW,KAAK1C,GAAOyE,EAAU,KAAO,KAAK,KAAKj5C,GAAO,CAAC,EAAIA,EAAI,EACnF,OAAAw0C,GAAM,KAAK,WAAW,CAAC,EAChBA,EACX,CAEA,SAASqF,EAAQD,EAAU,CACvB,OAAO,WAAW,GAAGA,EAAW,EAAO,CAAI,CAC/C,CAUA,SAASlD,EAAe1I,EAAIqN,EAAG,CAE3B,MAAM9lD,EAAIy4C,EAAG,MACb,IAAI54C,EAAI00C,EACR,QAASnV,GAAIp/B,EAAIw0C,EAAKpV,GAAI0Y,IAAQvD,EAAKnV,IAAK0Y,EACxCj4C,GAAK20C,EACT,MAAM2E,EAAKt5C,EAGLooD,EAAenQ,GAAQqB,EAAK3E,EAAMA,EAClC0T,EAAaD,EAAenQ,EAC5BsB,GAAMp5C,EAAIw0C,GAAO0T,EACjB7O,GAAMD,EAAK5E,GAAOsD,EAClBwB,EAAK4O,EAAa1T,EAClB2T,GAAKF,EACLG,GAAK3P,EAAG,IAAIqN,EAAG1M,CAAE,EACjBiP,GAAK5P,EAAG,IAAIqN,GAAI1M,EAAK5E,GAAOsD,CAAG,EACrC,IAAIwQ,GAAY,CAACnoD,GAAGo0B,KAAM,CACtB,IAAIglB,GAAM6O,GACN5O,GAAMf,EAAG,IAAIlkB,GAAG+kB,CAAE,EAClBG,GAAMhB,EAAG,IAAIe,EAAG,EACpBC,GAAMhB,EAAG,IAAIgB,GAAKllB,EAAC,EACnB,IAAIg0B,GAAM9P,EAAG,IAAIt4C,GAAGs5C,EAAG,EACvB8O,GAAM9P,EAAG,IAAI8P,GAAKlP,CAAE,EACpBkP,GAAM9P,EAAG,IAAI8P,GAAK/O,EAAG,EACrBA,GAAMf,EAAG,IAAI8P,GAAKh0B,EAAC,EACnBklB,GAAMhB,EAAG,IAAI8P,GAAKpoD,EAAC,EACnB,IAAIu5C,GAAMjB,EAAG,IAAIgB,GAAKD,EAAG,EACzB+O,GAAM9P,EAAG,IAAIiB,GAAKyO,EAAE,EACpB,IAAIK,GAAO/P,EAAG,IAAI8P,GAAK9P,EAAG,GAAG,EAC7Be,GAAMf,EAAG,IAAIgB,GAAK4O,EAAE,EACpBE,GAAM9P,EAAG,IAAIiB,GAAKH,EAAG,EACrBE,GAAMhB,EAAG,KAAKe,GAAKC,GAAK+O,EAAI,EAC5B9O,GAAMjB,EAAG,KAAK8P,GAAK7O,GAAK8O,EAAI,EAE5B,QAASxjD,GAAIm0C,EAAIn0C,GAAIwvC,EAAKxvC,KAAK,CAC3B,IAAIujD,GAAMvjD,GAAI8yC,EACdyQ,GAAMzQ,GAAQyQ,GAAM/T,EACpB,IAAIiU,GAAOhQ,EAAG,IAAIiB,GAAK6O,EAAG,EAC1B,MAAM5O,GAAKlB,EAAG,IAAIgQ,GAAMhQ,EAAG,GAAG,EAC9Be,GAAMf,EAAG,IAAIgB,GAAKF,EAAG,EACrBA,GAAMd,EAAG,IAAIc,GAAKA,EAAG,EACrBkP,GAAOhQ,EAAG,IAAIiB,GAAKH,EAAG,EACtBE,GAAMhB,EAAG,KAAKe,GAAKC,GAAKE,EAAE,EAC1BD,GAAMjB,EAAG,KAAKgQ,GAAM/O,GAAKC,EAAE,CACvC,CACQ,MAAO,CAAE,QAAS6O,GAAM,MAAO/O,EAAG,CAC1C,EACI,GAAIhB,EAAG,MAAQT,IAAQD,EAAK,CAExB,MAAMoB,IAAMV,EAAG,MAAQV,GAAOC,EACxBoB,GAAKX,EAAG,KAAKA,EAAG,IAAIqN,CAAC,CAAC,EAC5BwC,GAAY,CAACnoD,GAAGo0B,KAAM,CAClB,IAAIglB,GAAMd,EAAG,IAAIlkB,EAAC,EAClB,MAAMilB,GAAMf,EAAG,IAAIt4C,GAAGo0B,EAAC,EACvBglB,GAAMd,EAAG,IAAIc,GAAKC,EAAG,EACrB,IAAIkP,GAAKjQ,EAAG,IAAIc,GAAKJ,EAAE,EACvBuP,GAAKjQ,EAAG,IAAIiQ,GAAIlP,EAAG,EACnB,MAAMiL,GAAKhM,EAAG,IAAIiQ,GAAItP,EAAE,EAClBK,GAAMhB,EAAG,IAAIA,EAAG,IAAIiQ,EAAE,EAAGn0B,EAAC,EAC1Bi0B,GAAO/P,EAAG,IAAIgB,GAAKt5C,EAAC,EAC1B,IAAIC,GAAIq4C,EAAG,KAAKgM,GAAIiE,GAAIF,EAAI,EAC5B,MAAO,CAAE,QAASA,GAAM,MAAOpoD,EAAC,CAC5C,CACA,CAGI,OAAOkoD,EACX,CAKA,SAASlH,EAAoB3I,EAAIrxB,EAAM,IAC/B81B,EAAa,eAAezE,CAAE,EAClC,KAAM,CAAE,EAAAn4C,EAAG,EAAAC,EAAG,EAAAulD,CAAC,EAAK1+B,EACpB,GAAI,CAACqxB,EAAG,QAAQn4C,CAAC,GAAK,CAACm4C,EAAG,QAAQl4C,CAAC,GAAK,CAACk4C,EAAG,QAAQqN,CAAC,EACjD,MAAM,IAAI,MAAM,mCAAmC,EACvD,MAAMwC,EAAYnH,EAAe1I,EAAIqN,CAAC,EACtC,GAAI,CAACrN,EAAG,MACJ,MAAM,IAAI,MAAM,8BAA8B,EAGlD,OAAQt4C,GAAM,CAEV,IAAIo5C,EAAKC,EAAKC,EAAKC,GAAK6O,GAAKI,GAAK/oD,GAAGQ,GACrCm5C,EAAMd,EAAG,IAAIt4C,CAAC,EACdo5C,EAAMd,EAAG,IAAIc,EAAKuM,CAAC,EACnBtM,EAAMf,EAAG,IAAIc,CAAG,EAChBC,EAAMf,EAAG,IAAIe,EAAKD,CAAG,EACrBE,EAAMhB,EAAG,IAAIe,EAAKf,EAAG,GAAG,EACxBgB,EAAMhB,EAAG,IAAIgB,EAAKl5C,CAAC,EACnBm5C,GAAMjB,EAAG,KAAKqN,EAAGrN,EAAG,IAAIe,CAAG,EAAG,CAACf,EAAG,IAAIe,EAAKf,EAAG,IAAI,CAAC,EACnDiB,GAAMjB,EAAG,IAAIiB,GAAKp5C,CAAC,EACnBk5C,EAAMf,EAAG,IAAIgB,CAAG,EAChBkP,GAAMlQ,EAAG,IAAIiB,EAAG,EAChB6O,GAAM9P,EAAG,IAAIkQ,GAAKroD,CAAC,EACnBk5C,EAAMf,EAAG,IAAIe,EAAK+O,EAAG,EACrB/O,EAAMf,EAAG,IAAIe,EAAKC,CAAG,EACrBkP,GAAMlQ,EAAG,IAAIkQ,GAAKjP,EAAG,EACrB6O,GAAM9P,EAAG,IAAIkQ,GAAKpoD,CAAC,EACnBi5C,EAAMf,EAAG,IAAIe,EAAK+O,EAAG,EACrB3oD,GAAI64C,EAAG,IAAIc,EAAKE,CAAG,EACnB,KAAM,CAAE,QAAAmP,GAAS,MAAA7gD,EAAK,EAAKugD,EAAU9O,EAAKmP,EAAG,EAC7CvoD,GAAIq4C,EAAG,IAAIc,EAAKp5C,CAAC,EACjBC,GAAIq4C,EAAG,IAAIr4C,GAAG2H,EAAK,EACnBnI,GAAI64C,EAAG,KAAK74C,GAAG65C,EAAKmP,EAAO,EAC3BxoD,GAAIq4C,EAAG,KAAKr4C,GAAG2H,GAAO6gD,EAAO,EAC7B,MAAMjP,GAAKlB,EAAG,MAAMt4C,CAAC,IAAMs4C,EAAG,MAAMr4C,EAAC,EACrCA,GAAIq4C,EAAG,KAAKA,EAAG,IAAIr4C,EAAC,EAAGA,GAAGu5C,EAAE,EAC5B,MAAMkP,MAAc3L,EAAa,eAAezE,EAAI,CAACiB,EAAG,EAAG,EAAI,EAAE,CAAC,EAClE,OAAA95C,GAAI64C,EAAG,IAAI74C,GAAGipD,EAAO,EACd,CAAE,EAAAjpD,GAAG,EAAAQ,EAAC,CACrB,CACA,CACA,SAAS2jD,EAAYtL,EAAIqI,EAAI,CACzB,MAAO,CACH,UAAWA,EAAG,MACd,UAAW,EAAIrI,EAAG,MAClB,sBAAuB,EAAI,EAAIA,EAAG,MAClC,mBAAoB,GACpB,UAAW,EAAIqI,EAAG,MAE1B,CAKA,SAASO,EAAKpC,EAAO6J,EAAW,GAAI,CAChC,KAAM,CAAE,GAAAhI,CAAE,EAAK7B,EACT8J,EAAeD,EAAS,aAAejhC,EAAW,YAClDpC,EAAU,OAAO,OAAOs+B,EAAY9E,EAAM,GAAI6B,CAAE,EAAG,CAAE,QAAU5D,EAAa,kBAAkB4D,EAAG,KAAK,EAAG,EAC/G,SAASkI,EAAiBC,GAAW,CACjC,GAAI,CACA,MAAO,CAAC,CAAChI,EAAeH,EAAImI,EAAS,CACjD,MACsB,CACV,MAAO,EACnB,CACA,CACI,SAASC,EAAiBpa,GAAWqV,GAAc,CAC/C,KAAM,CAAE,UAAW5E,GAAM,sBAAA4J,EAAqB,EAAK1jC,EACnD,GAAI,CACA,MAAM5lB,GAAIivC,GAAU,OAGpB,OAFIqV,KAAiB,IAAQtkD,KAAM0/C,IAE/B4E,KAAiB,IAAStkD,KAAMspD,GACzB,GACJ,CAAC,CAAClK,EAAM,UAAUnQ,EAAS,CAC9C,MACsB,CACV,MAAO,EACnB,CACA,CAKI,SAASsa,EAAgBpa,GAAO+Z,EAAatjC,EAAQ,IAAI,EAAG,CACxD,SAAWy3B,EAAa,mBAAoBr1B,EAAW,UAAUmnB,GAAMvpB,EAAQ,KAAM,MAAM,EAAGq7B,EAAG,KAAK,CAC9G,CAMI,SAASuI,EAAaJ,GAAW9E,GAAe,GAAM,CAClD,OAAOlF,EAAM,KAAK,SAASgC,EAAeH,EAAImI,EAAS,CAAC,EAAE,QAAQ9E,EAAY,CACtF,CACI,SAASmF,EAAOta,GAAM,CAClB,MAAMia,GAAYG,EAAgBpa,EAAI,EACtC,MAAO,CAAE,UAAAia,GAAW,UAAWI,EAAaJ,EAAS,CAAC,CAC9D,CAII,SAASM,GAAU3yB,GAAM,CACrB,GAAI,OAAOA,IAAS,SAChB,MAAO,GACX,GAAIA,cAAgBqoB,EAChB,MAAO,GACX,KAAM,CAAE,UAAAgK,GAAW,UAAAna,GAAW,sBAAAqa,EAAqB,EAAK1jC,EACxD,GAAIq7B,EAAG,gBAAkBmI,KAAcna,GACnC,OACJ,MAAMjvC,MAAQgoB,EAAW,aAAa,MAAO+O,EAAI,EAAE,OACnD,OAAO/2B,KAAMivC,IAAajvC,KAAMspD,EACxC,CASI,SAASK,GAAgBC,GAAYC,GAAYvF,GAAe,GAAM,CAClE,GAAIoF,GAAUE,EAAU,IAAM,GAC1B,MAAM,IAAI,MAAM,+BAA+B,EACnD,GAAIF,GAAUG,EAAU,IAAM,GAC1B,MAAM,IAAI,MAAM,+BAA+B,EACnD,MAAM5yC,GAAImqC,EAAeH,EAAI2I,EAAU,EAEvC,OADUxK,EAAM,QAAQyK,EAAU,EACzB,SAAS5yC,EAAC,EAAE,QAAQqtC,EAAY,CACjD,CAaI,OAAO,OAAO,OAAO,CAAE,aAAAkF,EAAc,gBAAAG,GAAiB,OAAAF,EAAQ,MAAArK,EAAO,MAZvD,CACV,iBAAA+J,EACA,iBAAAE,EACA,gBAAAE,EAEA,kBAAmBJ,EACnB,iBAAkBI,EAClB,uBAAyB9mD,IAAQ2+C,EAAeH,EAAIx+C,EAAG,EACvD,WAAWs7C,GAAa,EAAGsB,GAAQD,EAAM,KAAM,CAC3C,OAAOC,GAAM,WAAWtB,GAAY,EAAK,CACrD,GAEgF,QAAAn4B,EAAS,CACzF,CAiBA,SAAS67B,EAAMrC,EAAO/b,EAAMymB,EAAY,CAAA,EAAI,IACpCnnB,EAAQ,OAAOU,CAAI,KACnBrb,EAAW,iBAAiB8hC,EAAW,GAAI,CAC3C,KAAM,WACN,KAAM,UACN,YAAa,WACb,SAAU,WACV,cAAe,UACvB,CAAK,EACD,MAAMpkC,EAAcokC,EAAU,aAAe9hC,EAAW,YAClDyb,EAAOqmB,EAAU,OAClB,CAACrnD,MAAQsnD,QAAalI,EAAU,MAAMxe,EAAM5gC,MAASulB,EAAW,aAAa,GAAG+hC,EAAI,CAAC,GACpF,CAAE,GAAAnR,EAAI,GAAAqI,CAAE,EAAK7B,EACb,CAAE,MAAO4E,EAAa,KAAMgG,CAAM,EAAK/I,EACvC,CAAE,OAAAwI,EAAQ,aAAAD,GAAc,gBAAAG,GAAiB,MAAAM,GAAO,QAAArkC,IAAY47B,EAAKpC,EAAO0K,CAAS,EACjFI,GAAiB,CACnB,QAAS,GACT,KAAM,OAAOJ,EAAU,MAAS,UAAYA,EAAU,KAAO,GAC7D,OAAQ,OACR,aAAc,IAEZK,GAAwB,UAC9B,SAASC,GAAsBnnD,GAAQ,CACnC,MAAMonD,GAAOrG,GAAerP,EAC5B,OAAO1xC,GAASonD,EACxB,CACI,SAASC,GAAW1V,GAAO5+B,GAAK,CAC5B,GAAI,CAACirC,EAAG,YAAYjrC,EAAG,EACnB,MAAM,IAAI,MAAM,qBAAqB4+B,EAAK,kCAAkC,EAChF,OAAO5+B,EACf,CACI,SAASu0C,GAAkB3tC,GAAO8lC,GAAQ,CACtCD,EAAkBC,EAAM,EACxB,MAAM/pC,GAAOiN,GAAQ,UACf4kC,GAAQ9H,KAAW,UAAY/pC,GAAO+pC,KAAW,YAAc/pC,GAAO,EAAI,OAChF,SAAWqP,EAAW,UAAUpL,GAAO4tC,GAAO,GAAG9H,EAAM,YAAY,CAC3E,CAII,MAAM+H,EAAU,CACZ,YAAYrqD,GAAG6W,GAAGyzC,GAAU,CACxB,KAAK,EAAIJ,GAAW,IAAKlqD,EAAC,EAC1B,KAAK,EAAIkqD,GAAW,IAAKrzC,EAAC,EACtByzC,IAAY,OACZ,KAAK,SAAWA,IACpB,OAAO,OAAO,IAAI,CAC9B,CACQ,OAAO,UAAU9tC,GAAO8lC,GAASyH,GAAuB,CACpDI,GAAkB3tC,GAAO8lC,EAAM,EAC/B,IAAIiI,GACJ,GAAIjI,KAAW,MAAO,CAClB,KAAM,CAAE,EAAAtiD,EAAG,EAAA6W,CAAC,EAAKhX,EAAQ,IAAI,SAAU+nB,EAAW,UAAUpL,EAAK,CAAC,EAClE,OAAO,IAAI6tC,GAAUrqD,EAAG6W,CAAC,CACzC,CACgByrC,KAAW,cACXiI,GAAQ/tC,GAAM,CAAC,EACf8lC,GAAS,UACT9lC,GAAQA,GAAM,SAAS,CAAC,GAE5B,MAAMzb,GAAI8/C,EAAG,MACP7gD,EAAIwc,GAAM,SAAS,EAAGzb,EAAC,EACvB8V,EAAI2F,GAAM,SAASzb,GAAGA,GAAI,CAAC,EACjC,OAAO,IAAIspD,GAAUxJ,EAAG,UAAU7gD,CAAC,EAAG6gD,EAAG,UAAUhqC,CAAC,EAAG0zC,EAAK,CACxE,CACQ,OAAO,QAAQtkC,GAAKq8B,GAAQ,CACxB,OAAO,KAAK,aAAc16B,EAAW,YAAY3B,EAAG,EAAGq8B,EAAM,CACzE,CACQ,eAAegI,GAAU,CACrB,OAAO,IAAID,GAAU,KAAK,EAAG,KAAK,EAAGC,EAAQ,CACzD,CACQ,iBAAiBE,GAAa,CAC1B,MAAMC,GAAcjS,EAAG,MACjB,CAAE,EAAAx4C,GAAG,EAAA6W,GAAG,SAAU6zC,CAAG,EAAK,KAChC,GAAIA,GAAO,MAAQ,CAAC,CAAC,EAAG,EAAG,EAAG,CAAC,EAAE,SAASA,CAAG,EACzC,MAAM,IAAI,MAAM,qBAAqB,EAUzC,GADoB9G,EAAc/L,EAAM4S,IACrBC,EAAM,EACrB,MAAM,IAAI,MAAM,wCAAwC,EAC5D,MAAMC,EAAOD,IAAQ,GAAKA,IAAQ,EAAI1qD,GAAI4jD,EAAc5jD,GACxD,GAAI,CAACw4C,EAAG,QAAQmS,CAAI,EAChB,MAAM,IAAI,MAAM,4BAA4B,EAChD,MAAMhrD,EAAI64C,EAAG,QAAQmS,CAAI,EACnBtpD,EAAI29C,EAAM,aAAcp3B,EAAW,aAAay8B,GAASqG,EAAM,KAAO,CAAC,EAAG/qD,CAAC,CAAC,EAC5EirD,EAAK/J,EAAG,IAAI8J,CAAI,EAChBtrD,EAAIwrD,MAAkBjjC,EAAW,aAAa,UAAW4iC,EAAW,CAAC,EACrEM,GAAKjK,EAAG,OAAO,CAACxhD,EAAIurD,CAAE,EACtBG,GAAKlK,EAAG,OAAOhqC,GAAI+zC,CAAE,EAErBxpD,GAAI49C,EAAM,KAAK,eAAe8L,EAAE,EAAE,IAAIzpD,EAAE,eAAe0pD,EAAE,CAAC,EAChE,GAAI3pD,GAAE,IAAG,EACL,MAAM,IAAI,MAAM,mBAAmB,EACvC,OAAAA,GAAE,eAAc,EACTA,EACnB,CAEQ,UAAW,CACP,OAAO4oD,GAAsB,KAAK,CAAC,CAC/C,CACQ,QAAQ1H,GAASyH,GAAuB,CAEpC,GADA1H,EAAkBC,EAAM,EACpBA,KAAW,MACX,SAAW16B,EAAW,YAAY/nB,EAAQ,IAAI,WAAW,IAAI,CAAC,EAClE,MAAMG,GAAI6gD,EAAG,QAAQ,KAAK,CAAC,EACrBhqC,GAAIgqC,EAAG,QAAQ,KAAK,CAAC,EAC3B,GAAIyB,KAAW,YAAa,CACxB,GAAI,KAAK,UAAY,KACjB,MAAM,IAAI,MAAM,8BAA8B,EAClD,SAAW16B,EAAW,aAAa,WAAW,GAAG,KAAK,QAAQ,EAAG5nB,GAAG6W,EAAC,CACrF,CACY,SAAW+Q,EAAW,aAAa5nB,GAAG6W,EAAC,CACnD,CACQ,MAAMyrC,GAAQ,CACV,SAAW16B,EAAW,YAAY,KAAK,QAAQ06B,EAAM,CAAC,CAClE,CAEQ,gBAAiB,CAAA,CACjB,OAAO,YAAYr8B,GAAK,CACpB,OAAOokC,GAAU,aAAcziC,EAAW,aAAa,MAAO3B,EAAG,EAAG,SAAS,CACzF,CACQ,OAAO,QAAQA,GAAK,CAChB,OAAOokC,GAAU,aAAcziC,EAAW,aAAa,MAAO3B,EAAG,EAAG,KAAK,CACrF,CACQ,YAAa,CACT,OAAO,KAAK,SAAQ,EAAK,IAAIokC,GAAU,KAAK,EAAGxJ,EAAG,IAAI,KAAK,CAAC,EAAG,KAAK,QAAQ,EAAI,IAC5F,CACQ,eAAgB,CACZ,OAAO,KAAK,QAAQ,KAAK,CACrC,CACQ,UAAW,CACP,SAAWj5B,EAAW,YAAY,KAAK,QAAQ,KAAK,CAAC,CACjE,CACQ,mBAAoB,CAChB,OAAO,KAAK,QAAQ,SAAS,CACzC,CACQ,cAAe,CACX,SAAWA,EAAW,YAAY,KAAK,QAAQ,SAAS,CAAC,CACrE,CACA,CAKI,MAAMojC,GAAWtB,EAAU,UACvB,SAAsBltC,GAAO,CAEzB,GAAIA,GAAM,OAAS,KACf,MAAM,IAAI,MAAM,oBAAoB,EAGxC,MAAM5G,MAAUgS,EAAW,iBAAiBpL,EAAK,EAC3ChT,GAAQgT,GAAM,OAAS,EAAIotC,EACjC,OAAOpgD,GAAQ,EAAIoM,IAAO,OAAOpM,EAAK,EAAIoM,EACtD,EACUi1C,GAAgBnB,EAAU,eAC5B,SAA2BltC,GAAO,CAC9B,OAAOqkC,EAAG,OAAOmK,GAASxuC,EAAK,CAAC,CAC5C,EAEUyuC,MAAiBrjC,EAAW,SAASgiC,CAAM,EAEjD,SAASsB,GAAWt1C,GAAK,CAErB,SAAIgS,EAAW,UAAU,WAAagiC,EAAQh0C,GAAK0+B,EAAK2W,EAAU,EAC3DpK,EAAG,QAAQjrC,EAAG,CAC7B,CACI,SAASu1C,GAAmB1nD,GAAS2nD,GAAS,CAC1C,SAAIxjC,EAAW,UAAUnkB,GAAS,OAAW,SAAS,EAC/C2nD,MAAcxjC,EAAW,UAAUqb,EAAKx/B,EAAO,EAAG,OAAW,mBAAmB,EAAIA,EACnG,CASI,SAAS4nD,GAAQ5nD,GAAS8nC,GAAYpkB,GAAM,CACxC,GAAI,CAAC,YAAa,WAAW,EAAE,KAAM7nB,IAAMA,MAAK6nB,EAAI,EAChD,MAAM,IAAI,MAAM,qCAAqC,EACzD,KAAM,CAAE,KAAAmkC,GAAM,QAAAF,GAAS,aAAAG,CAAY,EAAKhJ,EAAgBp7B,GAAM2iC,EAAc,EAC5ErmD,GAAU0nD,GAAmB1nD,GAAS2nD,EAAO,EAI7C,MAAMI,EAAQX,GAAcpnD,EAAO,EAC7BvE,EAAI8hD,EAAeH,EAAItV,EAAU,EACjCkgB,EAAW,CAACP,GAAWhsD,CAAC,EAAGgsD,GAAWM,CAAK,CAAC,EAElD,GAAID,GAAgB,MAAQA,IAAiB,GAAO,CAGhD,MAAMpsD,GAAIosD,IAAiB,GAAOjmC,EAAYE,GAAQ,SAAS,EAAI+lC,EACnEE,EAAS,QAAS7jC,EAAW,aAAa,eAAgBzoB,EAAC,CAAC,CACxE,CACQ,MAAM4vC,KAAWnnB,EAAW,aAAa,GAAG6jC,CAAQ,EAC9CjsD,EAAIgsD,EASV,SAASE,EAAMC,GAAQ,CAGnB,MAAMrsD,GAAI0rD,GAASW,EAAM,EACzB,GAAI,CAAC9K,EAAG,YAAYvhD,EAAC,EACjB,OACJ,MAAMssD,GAAK/K,EAAG,IAAIvhD,EAAC,EACbS,GAAIi/C,EAAM,KAAK,SAAS1/C,EAAC,EAAE,WAC3BU,GAAI6gD,EAAG,OAAO9gD,GAAE,CAAC,EACvB,GAAIC,KAAMs0C,EACN,OACJ,MAAMz9B,GAAIgqC,EAAG,OAAO+K,GAAK/K,EAAG,OAAOrhD,EAAIQ,GAAId,CAAC,CAAC,EAC7C,GAAI2X,KAAMy9B,EACN,OACJ,IAAIgW,IAAYvqD,GAAE,IAAMC,GAAI,EAAI,GAAK,OAAOD,GAAE,EAAIw0C,CAAG,EACjDsX,GAAQh1C,GACZ,OAAIy0C,IAAQtB,GAAsBnzC,EAAC,IAC/Bg1C,GAAQhL,EAAG,IAAIhqC,EAAC,EAChByzC,IAAY,GAET,IAAID,GAAUrqD,GAAG6rD,GAAOvB,EAAQ,CACnD,CACQ,MAAO,CAAE,KAAAvb,EAAM,MAAA2c,CAAK,CAC5B,CAYI,SAAS3jD,GAAKtE,GAASulD,GAAW7hC,GAAO,CAAA,EAAI,CACzC1jB,MAAcmkB,EAAW,aAAa,UAAWnkB,EAAO,EACxD,KAAM,CAAE,KAAAsrC,GAAM,MAAA2c,EAAK,EAAKL,GAAQ5nD,GAASulD,GAAW7hC,EAAI,EAGxD,SAFiBS,EAAW,gBAAgBqb,EAAK,UAAW4d,EAAG,MAAOxd,CAAI,EACzD0L,GAAM2c,EAAK,CAEpC,CACI,SAASI,GAAcC,GAAI,CAEvB,IAAI3f,GACJ,MAAM4f,GAAQ,OAAOD,IAAO,aAAgBnkC,EAAW,SAASmkC,EAAE,EAC5DE,GAAQ,CAACD,IACXD,KAAO,MACP,OAAOA,IAAO,UACd,OAAOA,GAAG,GAAM,UAChB,OAAOA,GAAG,GAAM,SACpB,GAAI,CAACC,IAAS,CAACC,GACX,MAAM,IAAI,MAAM,0EAA0E,EAC9F,GAAIA,GACA7f,GAAM,IAAIie,GAAU0B,GAAG,EAAGA,GAAG,CAAC,UAEzBC,GAAO,CACZ,GAAI,CACA5f,GAAMie,GAAU,aAAcziC,EAAW,aAAa,MAAOmkC,EAAE,EAAG,KAAK,CACvF,OACmBG,GAAU,CACb,GAAI,EAAEA,cAAoBrsD,EAAQ,IAAI,KAClC,MAAMqsD,EAC1B,CACY,GAAI,CAAC9f,GACD,GAAI,CACAA,GAAMie,GAAU,aAAcziC,EAAW,aAAa,MAAOmkC,EAAE,EAAG,SAAS,CAC/F,MAC8B,CACV,MAAO,EAC3B,CAEA,CACQ,OAAK3f,IACM,EAEnB,CAcI,SAAS+f,GAAO3f,GAAW/oC,GAASorC,GAAW1nB,GAAO,CAAA,EAAI,CACtD,KAAM,CAAE,KAAAmkC,GAAM,QAAAF,EAAS,OAAA9I,CAAM,EAAKC,EAAgBp7B,GAAM2iC,EAAc,EAGtE,GAFAjb,MAAgBjnB,EAAW,aAAa,YAAainB,EAAS,EAC9DprC,GAAU0nD,MAAuBvjC,EAAW,aAAa,UAAWnkB,EAAO,EAAG2nD,CAAO,EACjF,WAAYjkC,GACZ,MAAM,IAAI,MAAM,oCAAoC,EACxD,MAAMilB,EAAMkW,IAAW,OACjBwJ,GAActf,EAAS,EACvB6d,GAAU,aAAcziC,EAAW,aAAa,MAAO4kB,EAAS,EAAG8V,CAAM,EAC/E,GAAIlW,IAAQ,GACR,MAAO,GACX,GAAI,CACA,MAAMjrC,EAAI69C,EAAM,UAAUnQ,EAAS,EACnC,GAAIyc,IAAQlf,EAAI,SAAQ,EACpB,MAAO,GACX,KAAM,CAAE,EAAApsC,EAAG,EAAA6W,CAAC,EAAKu1B,EACX/sC,EAAIwrD,GAAcpnD,EAAO,EACzB2oD,GAAKvL,EAAG,IAAIhqC,CAAC,EACbi0C,GAAKjK,EAAG,OAAOxhD,EAAI+sD,EAAE,EACrBrB,GAAKlK,EAAG,OAAO7gD,EAAIosD,EAAE,EACrB/qD,GAAI29C,EAAM,KAAK,eAAe8L,EAAE,EAAE,IAAI3pD,EAAE,eAAe4pD,EAAE,CAAC,EAChE,OAAI1pD,GAAE,IAAG,EACE,GACDw/C,EAAG,OAAOx/C,GAAE,CAAC,IACVrB,CACzB,MACkB,CACN,MAAO,EACnB,CACA,CACI,SAASqsD,GAAiB7f,GAAW/oC,GAAS0jB,GAAO,CAAA,EAAI,CACrD,KAAM,CAAE,QAAAikC,EAAO,EAAK7I,EAAgBp7B,GAAM2iC,EAAc,EACxD,OAAArmD,GAAU0nD,GAAmB1nD,GAAS2nD,EAAO,EACtCf,GAAU,UAAU7d,GAAW,WAAW,EAAE,iBAAiB/oC,EAAO,EAAE,QAAO,CAC5F,CACI,OAAO,OAAO,OAAO,CACjB,OAAA4lD,EACA,aAAAD,GACA,gBAAAG,GACA,MAAAM,GACA,QAAArkC,GACA,MAAAw5B,EACA,KAAAj3C,GACA,OAAAokD,GACA,iBAAAE,GACA,UAAAhC,GACA,KAAApnB,CACR,CAAK,CACL,CAEA,SAASqe,EAAkBriD,EAAG,CAC1B,KAAM,CAAE,MAAAyhD,EAAO,UAAAC,GAAc2L,EAAgCrtD,CAAC,EACxD+/C,EAAQiC,EAAaP,EAAOC,CAAS,EAC3C,OAAO4L,EAAkCttD,EAAG+/C,CAAK,CACrD,CACA,SAASsN,EAAgCrtD,EAAG,CACxC,MAAMyhD,EAAQ,CACV,EAAGzhD,EAAE,EACL,EAAGA,EAAE,EACL,EAAGA,EAAE,GAAG,MACR,EAAGA,EAAE,EACL,EAAGA,EAAE,EACL,GAAIA,EAAE,GACN,GAAIA,EAAE,IAEJu5C,EAAKv5C,EAAE,GACb,IAAI08C,EAAiB18C,EAAE,yBACjB,MAAM,KAAK,IAAI,IAAIA,EAAE,yBAAyB,IAAKW,GAAM,KAAK,KAAKA,EAAI,CAAC,CAAC,CAAC,CAAC,EAC3E,OACN,MAAMihD,KAAS5D,EAAa,OAAOyD,EAAM,EAAG,CACxC,KAAMzhD,EAAE,WACR,eAAgB08C,EAChB,aAAc18C,EAAE,cACxB,CAAK,EACK0hD,EAAY,CACd,GAAAnI,EACA,GAAAqI,EACA,mBAAoB5hD,EAAE,mBACtB,KAAMA,EAAE,KACR,cAAeA,EAAE,cACjB,cAAeA,EAAE,cACjB,UAAWA,EAAE,UACb,QAASA,EAAE,SAEf,MAAO,CAAE,MAAAyhD,EAAO,UAAAC,CAAS,CAC7B,CACA,SAAS6L,EAA0BvtD,EAAG,CAClC,KAAM,CAAE,MAAAyhD,EAAO,UAAAC,GAAc2L,EAAgCrtD,CAAC,EACxDyqD,EAAY,CACd,KAAMzqD,EAAE,KACR,YAAaA,EAAE,YACf,KAAMA,EAAE,KACR,SAAUA,EAAE,SACZ,cAAeA,EAAE,eAErB,MAAO,CAAE,MAAAyhD,EAAO,UAAAC,EAAW,KAAM1hD,EAAE,KAAM,UAAAyqD,CAAS,CACtD,CACA,SAASnI,EAAmB/I,EAAIz5C,EAAGC,EAAG,CAKlC,SAASylD,EAAoB9kD,EAAG,CAC5B,MAAMqlD,EAAKxM,EAAG,IAAI74C,CAAC,EACbslD,EAAKzM,EAAG,IAAIwM,EAAIrlD,CAAC,EACvB,OAAO64C,EAAG,IAAIA,EAAG,IAAIyM,EAAIzM,EAAG,IAAI74C,EAAGZ,CAAC,CAAC,EAAGC,CAAC,CACjD,CACI,OAAOylD,CACX,CACA,SAAS8H,EAAkCttD,EAAG+/C,EAAO,CACjD,KAAM,CAAE,GAAAxG,EAAI,GAAAqI,CAAE,EAAK7B,EACnB,SAASyN,EAAmB72C,EAAK,CAC7B,SAAWgS,EAAW,SAAShS,EAAK2+B,EAAKsM,EAAG,KAAK,CACzD,CACI,MAAM4D,EAAsBlD,EAAmB/I,EAAIv5C,EAAE,EAAGA,EAAE,CAAC,EAC3D,OAAO,OAAO,OAAO,GAAI,CACrB,MAAOA,EACP,MAAO+/C,EACP,gBAAiBA,EACjB,uBAAyB38C,GAAQ2+C,EAAeH,EAAIx+C,CAAG,EACvD,oBAAAoiD,EACA,mBAAAgI,CACR,CAAK,CACL,CACA,SAASC,EAA4BztD,EAAG0tD,EAAQ,CAC5C,MAAM3N,EAAQ2N,EAAO,MACrB,OAAO,OAAO,OAAO,CAAA,EAAIA,EAAQ,CAC7B,gBAAiB3N,EACjB,MAAO,OAAO,OAAO,CAAA,EAAI//C,KAAOg+C,EAAa,SAAS+B,EAAM,GAAG,MAAOA,EAAM,GAAG,IAAI,CAAC,CAC5F,CAAK,CACL,CAEA,SAASwC,EAAYviD,EAAG,CACpB,KAAM,CAAE,MAAAyhD,EAAO,UAAAC,EAAW,KAAA1d,EAAM,UAAAymB,CAAS,EAAK8C,EAA0BvtD,CAAC,EACnE+/C,EAAQiC,EAAaP,EAAOC,CAAS,EACrCiM,EAAQvL,EAAMrC,EAAO/b,EAAMymB,CAAS,EAC1C,OAAOgD,EAA4BztD,EAAG2tD,CAAK,CAC/C,sDCh5CA,OAAO,eAAeC,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,QAAkBC,EAClBD,GAAA,YAAsBE,EAKtB,sEACA,MAAMC,EAAmBtrD,GAAA,EAEzB,SAASorD,EAAQ7pB,EAAM,CACnB,MAAO,CAAE,KAAAA,CAAI,CACjB,CAEA,SAAS8pB,EAAYE,EAAUC,EAAS,CACpC,MAAMC,EAAUlqB,MAAa+pB,EAAiB,aAAa,CAAE,GAAGC,EAAU,KAAMhqB,EAAM,EACtF,MAAO,CAAE,GAAGkqB,EAAOD,CAAO,EAAG,OAAAC,CAAM,CACvC,oECjBA,OAAO,eAActtD,EAAU,aAAc,CAAE,MAAO,GAAM,EAC5DA,EAAA,YAAsB,OACtBA,EAAA,mBAA6ButD,EAC7BvtD,EAAA,mBAA6BwtD,EAC7BxtD,EAAA,cAAwBytD,EACxBztD,EAAA,WAAqB0tD,EACrB1tD,EAAA,aAAuBslB,EACvB,MAAMyC,EAAalmB,GAAA,EACbu7C,EAAep8B,GAAA,EAEf2sC,EAAQ5lC,EAAW,gBAEzB,SAAS6lC,EAAM3lD,EAAO1F,EAAQ,CAG1B,GAFAsrD,EAAK5lD,CAAK,EACV4lD,EAAKtrD,CAAM,EACP0F,EAAQ,GAAKA,GAAS,GAAM,EAAI1F,EAChC,MAAM,IAAI,MAAM,wBAA0B0F,CAAK,EACnD,MAAMU,EAAM,MAAM,KAAK,CAAE,OAAApG,EAAQ,EAAE,KAAK,CAAC,EACzC,QAAS2C,EAAI3C,EAAS,EAAG2C,GAAK,EAAGA,IAC7ByD,EAAIzD,CAAC,EAAI+C,EAAQ,IACjBA,KAAW,EAEf,OAAO,IAAI,WAAWU,CAAG,CAC7B,CACA,SAASmlD,EAAO5uD,EAAGC,EAAG,CAClB,MAAMyW,EAAM,IAAI,WAAW1W,EAAE,MAAM,EACnC,QAASgG,EAAI,EAAGA,EAAIhG,EAAE,OAAQgG,IAC1B0Q,EAAI1Q,CAAC,EAAIhG,EAAEgG,CAAC,EAAI/F,EAAE+F,CAAC,EAEvB,OAAO0Q,CACX,CACA,SAASi4C,EAAK/2B,EAAM,CAChB,GAAI,CAAC,OAAO,cAAcA,CAAI,EAC1B,MAAM,IAAI,MAAM,iBAAiB,CACzC,CACA,SAASi3B,EAAQC,EAAK,CAClB,GAAI,IAAKjmC,EAAW,SAASimC,CAAG,GAAK,OAAOA,GAAQ,SAChD,MAAM,IAAI,MAAM,kCAAkC,EACtD,OAAO,OAAOA,GAAQ,YAAejmC,EAAW,aAAaimC,CAAG,EAAIA,CACxE,CAKA,SAAST,EAAmB7uC,EAAKsvC,EAAKC,EAAYntD,EAAG,IAC7CinB,EAAW,QAAQrJ,CAAG,EAC1BmvC,EAAKI,CAAU,EACfD,EAAMD,EAAQC,CAAG,EAEbA,EAAI,OAAS,MACbA,EAAMltD,KAAMinB,EAAW,gBAAiBA,EAAW,aAAa,mBAAmB,EAAGimC,CAAG,CAAC,GAC9F,KAAM,CAAE,UAAWE,EAAY,SAAUC,CAAU,EAAKrtD,EAClDstD,EAAM,KAAK,KAAKH,EAAaC,CAAU,EAC7C,GAAID,EAAa,OAASG,EAAM,IAC5B,MAAM,IAAI,MAAM,wCAAwC,EAC5D,MAAMC,KAAgBtmC,EAAW,aAAaimC,EAAKJ,EAAMI,EAAI,OAAQ,CAAC,CAAC,EACjEM,EAAQV,EAAM,EAAGO,CAAU,EAC3BI,EAAYX,EAAMK,EAAY,CAAC,EAC/B9uD,EAAI,IAAI,MAAMivD,CAAG,EACjBI,EAAM1tD,KAAMinB,EAAW,aAAaumC,EAAO5vC,EAAK6vC,EAAWX,EAAM,EAAG,CAAC,EAAGS,CAAS,CAAC,EACxFlvD,EAAE,CAAC,EAAI2B,KAAMinB,EAAW,aAAaymC,EAAKZ,EAAM,EAAG,CAAC,EAAGS,CAAS,CAAC,EACjE,QAASnpD,EAAI,EAAGA,GAAKkpD,EAAKlpD,IAAK,CAC3B,MAAMiJ,EAAO,CAAC2/C,EAAOU,EAAKrvD,EAAE+F,EAAI,CAAC,CAAC,EAAG0oD,EAAM1oD,EAAI,EAAG,CAAC,EAAGmpD,CAAS,EAC/DlvD,EAAE+F,CAAC,EAAIpE,KAAMinB,EAAW,aAAa,GAAG5Z,CAAI,CAAC,CACrD,CAEI,SADgC4Z,EAAW,aAAa,GAAG5oB,CAAC,EACjC,MAAM,EAAG8uD,CAAU,CAClD,CAQA,SAAST,EAAmB9uC,EAAKsvC,EAAKC,EAAYxuD,EAAGqB,EAAG,CAMpD,MALIinB,EAAW,QAAQrJ,CAAG,EAC1BmvC,EAAKI,CAAU,EACfD,EAAMD,EAAQC,CAAG,EAGbA,EAAI,OAAS,IAAK,CAClB,MAAMpe,EAAQ,KAAK,KAAM,EAAInwC,EAAK,CAAC,EACnCuuD,EAAMltD,EAAE,OAAO,CAAE,MAAA8uC,CAAK,CAAE,EAAE,UAAW7nB,EAAW,aAAa,mBAAmB,CAAC,EAAE,OAAOimC,CAAG,EAAE,OAAM,CAC7G,CACI,GAAIC,EAAa,OAASD,EAAI,OAAS,IACnC,MAAM,IAAI,MAAM,wCAAwC,EAC5D,OAAQltD,EAAE,OAAO,CAAE,MAAOmtD,CAAU,CAAE,EACjC,OAAOvvC,CAAG,EACV,OAAOkvC,EAAMK,EAAY,CAAC,CAAC,EAE3B,OAAOD,CAAG,EACV,OAAOJ,EAAMI,EAAI,OAAQ,CAAC,CAAC,EAC3B,OAAM,CACf,CASA,SAASP,EAAc/uC,EAAK9b,EAAOgC,EAAS,IACpCmjB,EAAW,iBAAiBnjB,EAAS,CACrC,EAAG,SACH,EAAG,SACH,EAAG,SACH,KAAM,UACd,CAAK,EACD,KAAM,CAAE,EAAA3E,EAAG,EAAAR,EAAG,EAAAE,EAAG,KAAAyjC,EAAM,OAAAqrB,EAAQ,IAAAT,CAAG,EAAKppD,EACvC,GAAI,IAAKmjB,EAAW,QAAQnjB,EAAQ,IAAI,EACpC,MAAM,IAAI,MAAM,qBAAqB,KACrCmjB,EAAW,QAAQrJ,CAAG,EAC1BmvC,EAAKjrD,CAAK,EACV,MAAM8rD,EAAQzuD,EAAE,SAAS,CAAC,EAAE,OACtBiB,EAAI,KAAK,MAAMwtD,EAAQjvD,GAAK,CAAC,EAC7BkvD,EAAe/rD,EAAQjD,EAAIuB,EACjC,IAAI0tD,EACJ,GAAIH,IAAW,MACXG,EAAMrB,EAAmB7uC,EAAKsvC,EAAKW,EAAcvrB,CAAI,UAEhDqrB,IAAW,MAChBG,EAAMpB,EAAmB9uC,EAAKsvC,EAAKW,EAAclvD,EAAG2jC,CAAI,UAEnDqrB,IAAW,iBAEhBG,EAAMlwC,MAGN,OAAM,IAAI,MAAM,+BAA+B,EAEnD,MAAMre,EAAI,IAAI,MAAMuC,CAAK,EACzB,QAASsC,EAAI,EAAGA,EAAItC,EAAOsC,IAAK,CAC5B,MAAM5F,EAAI,IAAI,MAAMK,CAAC,EACrB,QAASub,EAAI,EAAGA,EAAIvb,EAAGub,IAAK,CACxB,MAAM2zC,EAAa3tD,GAAKga,EAAIhW,EAAIvF,GAC1BmvD,EAAKF,EAAI,SAASC,EAAYA,EAAa3tD,CAAC,EAClD5B,EAAE4b,CAAC,KAAQkiC,EAAa,KAAKuQ,EAAMmB,CAAE,EAAG7uD,CAAC,CACrD,CACQI,EAAE6E,CAAC,EAAI5F,CACf,CACI,OAAOe,CACX,CACA,SAASqtD,EAAWnT,EAAO90C,EAAK,CAE5B,MAAMspD,EAAQtpD,EAAI,IAAKP,GAAM,MAAM,KAAKA,CAAC,EAAE,SAAS,EACpD,MAAO,CAACpF,EAAGQ,IAAM,CACb,KAAM,CAAC0uD,EAAIC,EAAIC,EAAIC,CAAE,EAAIJ,EAAM,IAAKt0C,GAAQA,EAAI,OAAO,CAACogC,EAAK31C,IAAMq1C,EAAM,IAAIA,EAAM,IAAIM,EAAK/6C,CAAC,EAAGoF,CAAC,CAAC,CAAC,EAK7F,CAACkqD,EAAQC,CAAM,KAAQjS,EAAa,eAAe7C,EAAO,CAAC0U,EAAIE,CAAE,EAAG,EAAI,EAC9E,OAAArvD,EAAIy6C,EAAM,IAAIyU,EAAII,CAAM,EACxB9uD,EAAIi6C,EAAM,IAAIj6C,EAAGi6C,EAAM,IAAI2U,EAAIG,CAAM,CAAC,EAC/B,CAAE,EAAAvvD,EAAG,EAAAQ,CAAC,CACrB,CACA,CACAN,EAAA,eAA0B+nB,EAAW,aAAa,eAAe,EAEjE,SAASzC,EAAa65B,EAAOmQ,EAAYjoC,EAAU,CAC/C,GAAI,OAAOioC,GAAe,WACtB,MAAM,IAAI,MAAM,8BAA8B,EAClD,SAAS7pD,EAAIsQ,EAAK,CACd,OAAOopC,EAAM,WAAWmQ,EAAWv5C,CAAG,CAAC,CAC/C,CACI,SAASw5C,EAAM/U,EAAS,CACpB,MAAMl5C,EAAIk5C,EAAQ,cAAa,EAC/B,OAAIl5C,EAAE,OAAO69C,EAAM,IAAI,EACZA,EAAM,MACjB79C,EAAE,eAAc,EACTA,EACf,CACI,MAAO,CACH,SAAA+lB,EACA,YAAY3I,EAAK9Z,EAAS,CACtB,MAAM0iB,EAAO,OAAO,OAAO,CAAA,EAAID,EAAUziB,CAAO,EAC1CvE,EAAIotD,EAAc/uC,EAAK,EAAG4I,CAAI,EAC9BkoC,EAAK/pD,EAAIpF,EAAE,CAAC,CAAC,EACb4qD,EAAKxlD,EAAIpF,EAAE,CAAC,CAAC,EACnB,OAAOkvD,EAAMC,EAAG,IAAIvE,CAAE,CAAC,CACnC,EACQ,cAAcvsC,EAAK9Z,EAAS,CACxB,MAAM6qD,EAAUpoC,EAAS,UAAY,CAAE,IAAKA,EAAS,SAAS,EAAK,CAAA,EAC7DC,EAAO,OAAO,OAAO,CAAA,EAAID,EAAUooC,EAAS7qD,CAAO,EACnDvE,EAAIotD,EAAc/uC,EAAK,EAAG4I,CAAI,EAC9BkoC,EAAK/pD,EAAIpF,EAAE,CAAC,CAAC,EACnB,OAAOkvD,EAAMC,CAAE,CAC3B,EAEQ,WAAW3Q,EAAS,CAChB,GAAI,CAAC,MAAM,QAAQA,CAAO,EACtB,MAAM,IAAI,MAAM,2BAA2B,EAC/C,UAAW35C,KAAK25C,EACZ,GAAI,OAAO35C,GAAM,SACb,MAAM,IAAI,MAAM,2BAA2B,EACnD,OAAOqqD,EAAM9pD,EAAIo5C,CAAO,CAAC,CACrC,EAGQ,aAAangC,EAAK9Z,EAAS,CAEvB,MAAMxD,EAAI+9C,EAAM,GAAG,MACb73B,EAAO,OAAO,OAAO,CAAA,EAAID,EAAU,CAAE,EAAGjmB,EAAG,EAAG,EAAG,IAAKpB,EAAQ,WAAW,EAAI4E,CAAO,EAC1F,OAAO6oD,EAAc/uC,EAAK,EAAG4I,CAAI,EAAE,CAAC,EAAE,CAAC,CACnD,EAEA,+DChNA,OAAO,eAActnB,EAAU,aAAc,CAAE,MAAO,GAAM,EAC5DA,EAAA,cAAwBA,EAAA,YAAsBA,EAAA,iBAA2BA,EAAA,QAAkBA,EAAA,UAAoB,OAQ/G,sEACA,MAAM0vD,EAAY7tD,GAAA,EACZ0yC,EAAavzB,GAAA,EACb2uC,EAAqB9rC,GAAA,EACrB+rC,EAAqBr0B,GAAA,EACrB6hB,EAAe5hB,GAAA,EACf2xB,EAAmB1xB,GAAA,EACnB1T,EAAa2T,GAAA,EAIbm0B,EAAkB,CACpB,EAAG,OAAO,oEAAoE,EAC9E,EAAG,OAAO,oEAAoE,EAC9E,EAAG,OAAO,CAAC,EACX,EAAG,OAAO,CAAC,EACX,EAAG,OAAO,CAAC,EACX,GAAI,OAAO,oEAAoE,EAC/E,GAAI,OAAO,oEAAoE,GAE7EC,EAAiB,CACnB,KAAM,OAAO,oEAAoE,EACjF,QAAS,CACL,CAAC,OAAO,oCAAoC,EAAG,CAAC,OAAO,oCAAoC,CAAC,EAC5F,CAAC,OAAO,qCAAqC,EAAG,OAAO,oCAAoC,CAAC,IAG9Frb,EAAsB,OAAO,CAAC,EAC9BC,EAAsB,OAAO,CAAC,EAC9BsD,EAAsB,OAAO,CAAC,EAKpC,SAAS+X,EAAQzvD,EAAG,CAChB,MAAMgB,EAAIuuD,EAAgB,EAEpB5X,EAAM,OAAO,CAAC,EAAG+X,EAAM,OAAO,CAAC,EAAGC,EAAO,OAAO,EAAE,EAAGC,EAAO,OAAO,EAAE,EAErEC,EAAO,OAAO,EAAE,EAAGC,EAAO,OAAO,EAAE,EAAGC,EAAO,OAAO,EAAE,EACtDjO,EAAM9hD,EAAIA,EAAIA,EAAKgB,EACnB4lD,EAAM9E,EAAKA,EAAK9hD,EAAKgB,EACrBgvD,KAAUlT,EAAa,MAAM8J,EAAIjP,EAAK32C,CAAC,EAAI4lD,EAAM5lD,EACjDivD,MAAUnT,EAAa,MAAMkT,EAAIrY,EAAK32C,CAAC,EAAI4lD,EAAM5lD,EACjDkvD,MAAWpT,EAAa,MAAMmT,GAAIvY,EAAK12C,CAAC,EAAI8gD,EAAM9gD,EAClDmvD,MAAWrT,EAAa,MAAMoT,GAAKP,EAAM3uD,CAAC,EAAIkvD,GAAOlvD,EACrDovD,MAAWtT,EAAa,MAAMqT,GAAKP,EAAM5uD,CAAC,EAAImvD,GAAOnvD,EACrDqvD,MAAWvT,EAAa,MAAMsT,GAAKN,EAAM9uD,CAAC,EAAIovD,GAAOpvD,EACrDsvD,MAAYxT,EAAa,MAAMuT,GAAKN,EAAM/uD,CAAC,EAAIqvD,GAAOrvD,EACtDuvD,MAAYzT,EAAa,MAAMwT,GAAMR,EAAM9uD,CAAC,EAAIovD,GAAOpvD,EACvDwvD,MAAY1T,EAAa,MAAMyT,GAAM5Y,EAAK32C,CAAC,EAAI4lD,EAAM5lD,EACrDimD,MAAUnK,EAAa,MAAM0T,GAAMX,EAAM7uD,CAAC,EAAImvD,GAAOnvD,EACrDkmD,MAAUpK,EAAa,MAAMmK,GAAIyI,EAAK1uD,CAAC,EAAI8gD,EAAM9gD,EACjDs3C,MAAWwE,EAAa,MAAMoK,GAAIxP,EAAK12C,CAAC,EAC9C,GAAI,CAACyvD,EAAK,IAAIA,EAAK,IAAInY,EAAI,EAAGt4C,CAAC,EAC3B,MAAM,IAAI,MAAM,yBAAyB,EAC7C,OAAOs4C,EACX,CACA,MAAMmY,KAAW3T,EAAa,OAAOyS,EAAgB,EAAG,CAAE,KAAME,EAAS,EAezE/vD,EAAA,aAAwB2vD,EAAmB,aAAa,CAAE,GAAGE,EAAiB,GAAIkB,EAAM,KAAM,GAAM,KAAMjB,CAAc,EAAIJ,EAAU,MAAM,EAI5I,MAAMsB,EAAuB,CAAA,EAC7B,SAASC,EAAWprD,KAAQqrD,EAAU,CAClC,IAAIC,EAAOH,EAAqBnrD,CAAG,EACnC,GAAIsrD,IAAS,OAAW,CACpB,MAAMC,KAAW1B,EAAU,WAAY3nC,EAAW,aAAaliB,CAAG,CAAC,EACnEsrD,KAAWppC,EAAW,aAAaqpC,EAAMA,CAAI,EAC7CJ,EAAqBnrD,CAAG,EAAIsrD,CACpC,CACI,SAAWzB,EAAU,WAAY3nC,EAAW,aAAaopC,EAAM,GAAGD,CAAQ,CAAC,CAC/E,CAEA,MAAM/M,EAAgB/E,GAAUA,EAAM,QAAQ,EAAI,EAAE,MAAM,CAAC,EACrDiS,EAAiCrxD,EAAQ,UAAU,MACnDsxD,EAAWhxD,GAAMA,EAAI03C,IAAQvD,EAEnC,SAAS8c,EAAoBC,EAAM,CAC/B,KAAM,CAAE,GAAAxQ,EAAI,KAAA7uB,CAAI,EAAKk/B,EACfI,KAAStE,EAAiB,gBAAgBnM,EAAIwQ,CAAI,EAClDvxD,EAAIkyB,EAAK,SAASs/B,CAAE,EAE1B,MAAO,CAAE,OADMH,EAAQrxD,EAAE,CAAC,EAAIwxD,EAAKzQ,EAAG,IAAIyQ,CAAE,EAC3B,MAAOtN,EAAalkD,CAAC,CAAC,CAC3C,CAKA,SAASyxD,EAAO5xD,EAAG,CACf,MAAM64C,EAAKoY,EACX,GAAI,CAACpY,EAAG,YAAY74C,CAAC,EACjB,MAAM,IAAI,MAAM,0BAA0B,EAC9C,MAAM6xD,EAAKhZ,EAAG,OAAO74C,EAAIA,CAAC,EACpBV,EAAIu5C,EAAG,OAAOgZ,EAAK7xD,EAAI,OAAO,CAAC,CAAC,EACtC,IAAIQ,EAAIq4C,EAAG,KAAKv5C,CAAC,EAGZkyD,EAAQhxD,CAAC,IACVA,EAAIq4C,EAAG,IAAIr4C,CAAC,GAChB,MAAML,EAAIoxD,EAAQ,WAAW,CAAE,EAAAvxD,EAAG,EAAAQ,CAAC,CAAE,EACrC,OAAAL,EAAE,eAAc,EACTA,CACX,CACA,MAAM8V,EAAMgS,EAAW,gBAIvB,SAAS6pC,KAAazjD,EAAM,CACxB,OAAOkjD,EAAQ,GAAG,OAAOt7C,EAAIk7C,EAAW,oBAAqB,GAAG9iD,CAAI,CAAC,CAAC,CAC1E,CAIA,SAAS0jD,EAAoB1I,EAAW,CACpC,OAAOoI,EAAoBpI,CAAS,EAAE,KAC1C,CAKA,SAAS2I,EAAYluD,EAASulD,EAAW4I,KAAcxd,EAAW,aAAa,EAAE,EAAG,CAChF,KAAM,CAAE,GAAAyM,CAAE,EAAKqQ,EACT1xD,KAAQooB,EAAW,aAAa,UAAWnkB,CAAO,EAClD,CAAE,MAAOouD,EAAI,OAAQ3yD,GAAMkyD,EAAoBpI,CAAS,EACxDjqD,KAAQ6oB,EAAW,aAAa,UAAWgqC,EAAS,EAAE,EACtD3xD,EAAI4gD,EAAG,QAAQ3hD,EAAI0W,EAAIk7C,EAAW,cAAe/xD,CAAC,CAAC,CAAC,EACpD+yD,EAAOhB,EAAW,gBAAiB7wD,EAAG4xD,EAAIryD,CAAC,EAE3C,CAAE,MAAOuyD,EAAI,OAAQzyD,CAAC,EAAK8xD,EAAoBU,CAAI,EACnD3yD,GAAIsyD,EAAUM,EAAIF,EAAIryD,CAAC,EACvB4sC,GAAM,IAAI,WAAW,EAAE,EAI7B,GAHAA,GAAI,IAAI2lB,EAAI,CAAC,EACb3lB,GAAI,IAAIyU,EAAG,QAAQA,EAAG,OAAOvhD,EAAIH,GAAID,CAAC,CAAC,EAAG,EAAE,EAExC,CAAC8yD,EAAc5lB,GAAK5sC,EAAGqyD,CAAE,EACzB,MAAM,IAAI,MAAM,kCAAkC,EACtD,OAAOzlB,EACX,CAKA,SAAS4lB,EAAcxlB,EAAW/oC,EAASorC,EAAW,CAClD,KAAM,CAAE,GAAAgS,EAAI,KAAA7uB,CAAI,EAAKk/B,EACf9kB,KAAUxkB,EAAW,aAAa,YAAa4kB,EAAW,EAAE,EAC5DhtC,KAAQooB,EAAW,aAAa,UAAWnkB,CAAO,EAClDwuD,KAAUrqC,EAAW,aAAa,YAAainB,EAAW,EAAE,EAClE,GAAI,CACA,MAAM1tC,EAAIowD,EAAO37C,EAAIq8C,CAAG,CAAC,EACnBjyD,EAAI4V,EAAIw2B,EAAI,SAAS,EAAG,EAAE,CAAC,EACjC,GAAI,IAAKxkB,EAAW,SAAS5nB,EAAGu0C,EAAKmb,EAAgB,CAAC,EAClD,MAAO,GACX,MAAM74C,EAAIjB,EAAIw2B,EAAI,SAAS,GAAI,EAAE,CAAC,EAClC,GAAI,IAAKxkB,EAAW,SAAS/Q,EAAG09B,EAAKmb,EAAgB,CAAC,EAClD,MAAO,GAEX,MAAMvwD,EAAIsyD,EAAU5Q,EAAG,QAAQ7gD,CAAC,EAAGgkD,EAAa7iD,CAAC,EAAG3B,CAAC,EAE/C6B,GAAI2wB,EAAK,eAAenb,CAAC,EAAE,IAAI1V,EAAE,eAAe0/C,EAAG,IAAI1hD,CAAC,CAAC,CAAC,EAC1D,CAAE,EAAAQ,GAAG,EAAAQ,IAAMkB,GAAE,SAAQ,EAE3B,MAAI,EAAAA,GAAE,OAAS,CAAC8vD,EAAQhxD,EAAC,GAAKR,KAAMK,EAG5C,MACkB,CACV,MAAO,EACf,CACA,CAcAH,EAAA,SAAmB,IAAM,CAGrB,MAAMspD,EAAkB,CAACpa,KAAWqF,EAAW,aAAa,EAAU,OACvD6I,EAAa,gBAAgBlO,EAAM2gB,EAAgB,CAAC,EAGnE7vD,EAAQ,UAAU,MAAM,gBACxB,SAASwpD,EAAOta,EAAM,CAClB,MAAMia,EAAYG,EAAgBpa,CAAI,EACtC,MAAO,CAAE,UAAAia,EAAW,UAAW0I,EAAoB1I,CAAS,CAAC,CACrE,CACI,MAAO,CACH,OAAAK,EACA,aAAcqI,EACd,KAAMC,EACN,OAAQK,EACR,MAAOd,EACP,MAAO,CACH,gBAAiB/H,EACjB,iBAAkBA,EAClB,WAAA2H,EAEA,OAAAS,EACA,aAAAvN,EACA,gBAAiBp8B,EAAW,gBAC5B,gBAAiBA,EAAW,gBAC5B,IAAKq1B,EAAa,KAEtB,QAAS,CACL,UAAW,GACX,UAAW,GACX,mBAAoB,GACpB,UAAW,GACX,KAAM,IAGlB,GAAC,EACD,MAAMiV,KAAoCzC,EAAmB,YAAYmB,EAAM,CAE3E,CACI,qEACA,oEACA,qEACA,sEAGJ,CACI,qEACA,qEACA,sEAGJ,CACI,qEACA,qEACA,qEACA,sEAGJ,CACI,qEACA,qEACA,qEACA,uEAEN,IAAK7rD,GAAMA,EAAE,IAAKgW,GAAM,OAAOA,CAAC,CAAC,CAAC,CAAC,EAC/Bo3C,KAAoCnF,EAAiB,qBAAqB4D,EAAM,CAClF,EAAG,OAAO,oEAAoE,EAC9E,EAAG,OAAO,MAAM,EAChB,EAAGA,EAAK,OAAO,OAAO,KAAK,CAAC,CAChC,CAAC,EAED/wD,EAAA,oBAAsC4vD,EAAmB,cAAc5vD,EAAQ,UAAU,MAAQ6+C,GAAY,CACzG,KAAM,CAAE,EAAA/+C,EAAG,EAAAQ,CAAC,EAAKgyD,EAAOvB,EAAK,OAAOlS,EAAQ,CAAC,CAAC,CAAC,EAC/C,OAAOwT,EAAOvyD,EAAGQ,CAAC,CACtB,EAAG,CACC,IAAK,iCACL,UAAW,iCACX,EAAGywD,EAAK,MACR,EAAG,EACH,EAAG,IACH,OAAQ,MACR,KAAMrB,EAAU,MACpB,CAAC,EAED1vD,EAAA,YAA6BA,EAAQ,iBAAiB,YAEtDA,EAAA,cAA+BA,EAAQ,iBAAiB,wECtSxD,OAAO,eAAegqD,GAAS,aAAc,CAAE,MAAO,GAAM,EAC5DA,GAAA,OAAiBA,GAAA,eAAyBA,GAAA,SAAmBA,GAAA,eAAyBA,GAAA,eAAyBA,GAAA,QAAkBA,GAAA,OAAiBA,GAAA,OAAiBA,GAAA,OAAiBA,GAAA,SAAmBA,GAAA,QAAkBA,GAAA,aAAuBA,GAAA,UAAoBA,GAAA,WAAqBA,GAAA,YAAsBA,sBAA6BA,GAAA,gBAA0BA,GAAA,gBAA0BA,GAAA,gBAA0BA,GAAA,gBAA0BA,GAAA,YAAsBA,GAAA,oBAA8BA,GAAA,MAAgBA,GAAA,YAAsBA,GAAA,YAAsBA,GAAA,QAAkBA,GAAA,WAAqBA,GAAA,YAAsBA,GAAA,YAAsBA,GAAA,WAAqBA,GAAA,QAAkBA,GAAA,OAAiB,OAK/qB,MAAM3pD,EAAIwB,GAAA,EAEVmoD,OAAAA,GAAA,OAAiB3pD,EAAE,OAEnB2pD,GAAA,QAAkB3pD,EAAE,QAEpB2pD,GAAA,WAAqB3pD,EAAE,WAEvB2pD,GAAA,YAAsB3pD,EAAE,YAExB2pD,GAAA,YAAsB3pD,EAAE,YAExB2pD,GAAA,WAAqB3pD,EAAE,WAEvB2pD,GAAA,QAAkB3pD,EAAE,QAEpB2pD,GAAA,YAAsB3pD,EAAE,YAExB2pD,GAAA,YAAsB3pD,EAAE,YAExB2pD,GAAA,MAAgB3pD,EAAE,MAElB2pD,GAAA,oBAA8B3pD,EAAE,oBAEhC2pD,GAAA,YAAsB3pD,EAAE,YAExB2pD,GAAA,gBAA0B3pD,EAAE,gBAE5B2pD,GAAA,gBAA0B3pD,EAAE,gBAE5B2pD,GAAA,gBAA0B3pD,EAAE,gBAE5B2pD,GAAA,gBAA0B3pD,EAAE,gBAE5B2pD,GAAA,mBAA6B3pD,EAAE,mBAE/B2pD,GAAA,YAAsB3pD,EAAE,YAExB2pD,GAAA,WAAqB3pD,EAAE,WAEvB2pD,GAAA,UAAoB3pD,EAAE,UAEtB2pD,GAAA,aAAuB3pD,EAAE,aAEzB2pD,GAAA,QAAkB3pD,EAAE,QAEpB2pD,GAAA,SAAmB3pD,EAAE,SAErB2pD,GAAA,OAAiB3pD,EAAE,OAEnB2pD,GAAA,OAAiB3pD,EAAE,OAEnB2pD,GAAA,OAAiB3pD,EAAE,OAEnB2pD,GAAA,QAAkB3pD,EAAE,QAEpB2pD,GAAA,eAAyB3pD,EAAE,eAE3B2pD,GAAA,eAAyB3pD,EAAE,eAE3B2pD,GAAA,SAAmB3pD,EAAE,SAErB2pD,GAAA,eAAyB3pD,EAAE,eAE3B2pD,GAAA,OAAiB3pD,EAAE,yDCnEnBkyD,GAAiB,UAAY,CAC3B,OAAO,OAAO,SAAY,YAAc,QAAQ,WAAa,QAAQ,UAAU,IACjF,4DCNA,IAAIC,EACJ,MAAMC,EAAkB,CACtB,EACA,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC1C,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAC7C,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACtD,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IACxD,EAQAzI,OAAAA,GAAA,cAAwB,SAAwB3nB,EAAS,CACvD,GAAI,CAACA,EAAS,MAAM,IAAI,MAAM,uCAAuC,EACrE,GAAIA,EAAU,GAAKA,EAAU,GAAI,MAAM,IAAI,MAAM,2CAA2C,EAC5F,OAAOA,EAAU,EAAI,EACvB,EAQA2nB,GAAA,wBAAkC,SAAkC3nB,EAAS,CAC3E,OAAOowB,EAAgBpwB,CAAO,CAChC,EAQA2nB,GAAA,YAAsB,SAAUjkD,EAAM,CACpC,IAAI2hC,EAAQ,EAEZ,KAAO3hC,IAAS,GACd2hC,IACA3hC,KAAU,EAGZ,OAAO2hC,CACT,EAEAsiB,GAAA,kBAA4B,SAA4B/qD,EAAG,CACzD,GAAI,OAAOA,GAAM,WACf,MAAM,IAAI,MAAM,uCAAuC,EAGzDuzD,EAAiBvzD,CACnB,EAEA+qD,GAAA,mBAA6B,UAAY,CACvC,OAAO,OAAOwI,EAAmB,GACnC,EAEAxI,GAAA,OAAiB,SAAiB0I,EAAO,CACvC,OAAOF,EAAeE,CAAK,CAC7B,8DC9DA1yD,EAAA,EAAY,CAAE,IAAK,CAAC,EACpBA,EAAA,EAAY,CAAE,IAAK,CAAC,EACpBA,EAAA,EAAY,CAAE,IAAK,CAAC,EACpBA,EAAA,EAAY,CAAE,IAAK,CAAC,EAEpB,SAASmY,EAAYxV,EAAQ,CAC3B,GAAI,OAAOA,GAAW,SACpB,MAAM,IAAI,MAAM,uBAAuB,EAKzC,OAFcA,EAAO,YAAW,EAEnB,CACX,IAAK,IACL,IAAK,MACH,OAAO3C,EAAQ,EAEjB,IAAK,IACL,IAAK,SACH,OAAOA,EAAQ,EAEjB,IAAK,IACL,IAAK,WACH,OAAOA,EAAQ,EAEjB,IAAK,IACL,IAAK,OACH,OAAOA,EAAQ,EAEjB,QACE,MAAM,IAAI,MAAM,qBAAuB2C,CAAM,CACnD,CACA,CAEA3C,EAAA,QAAkB,SAAkBy2B,EAAO,CACzC,OAAOA,GAAS,OAAOA,EAAM,IAAQ,KACnCA,EAAM,KAAO,GAAKA,EAAM,IAAM,CAClC,EAEAz2B,EAAA,KAAe,SAAeiI,EAAO0qD,EAAc,CACjD,GAAI3yD,EAAQ,QAAQiI,CAAK,EACvB,OAAOA,EAGT,GAAI,CACF,OAAOkQ,EAAWlQ,CAAK,CAC3B,MAAc,CACV,OAAO0qD,CACX,CACA,yDCjDA,SAASC,GAAa,CACpB,KAAK,OAAS,CAAA,EACd,KAAK,OAAS,CAChB,CAEA,OAAAA,EAAU,UAAY,CAEpB,IAAK,SAAUtwD,EAAO,CACpB,MAAMuwD,EAAW,KAAK,MAAMvwD,EAAQ,CAAC,EACrC,OAAS,KAAK,OAAOuwD,CAAQ,IAAO,EAAIvwD,EAAQ,EAAM,KAAO,CACjE,EAEE,IAAK,SAAUyT,EAAKxT,EAAQ,CAC1B,QAAS2C,EAAI,EAAGA,EAAI3C,EAAQ2C,IAC1B,KAAK,QAAS6Q,IAASxT,EAAS2C,EAAI,EAAM,KAAO,CAAC,CAExD,EAEE,gBAAiB,UAAY,CAC3B,OAAO,KAAK,MAChB,EAEE,OAAQ,SAAU4tD,EAAK,CACrB,MAAMD,EAAW,KAAK,MAAM,KAAK,OAAS,CAAC,EACvC,KAAK,OAAO,QAAUA,GACxB,KAAK,OAAO,KAAK,CAAC,EAGhBC,IACF,KAAK,OAAOD,CAAQ,GAAM,MAAU,KAAK,OAAS,GAGpD,KAAK,QACT,CACA,EAEAE,GAAiBH,kDC/BjB,SAASI,EAAWt6C,EAAM,CACxB,GAAI,CAACA,GAAQA,EAAO,EAClB,MAAM,IAAI,MAAM,mDAAmD,EAGrE,KAAK,KAAOA,EACZ,KAAK,KAAO,IAAI,WAAWA,EAAOA,CAAI,EACtC,KAAK,YAAc,IAAI,WAAWA,EAAOA,CAAI,CAC/C,CAWA,OAAAs6C,EAAU,UAAU,IAAM,SAAUC,EAAKC,EAAKjrD,EAAOkrD,EAAU,CAC7D,MAAM7wD,EAAQ2wD,EAAM,KAAK,KAAOC,EAChC,KAAK,KAAK5wD,CAAK,EAAI2F,EACfkrD,IAAU,KAAK,YAAY7wD,CAAK,EAAI,GAC1C,EASA0wD,EAAU,UAAU,IAAM,SAAUC,EAAKC,EAAK,CAC5C,OAAO,KAAK,KAAKD,EAAM,KAAK,KAAOC,CAAG,CACxC,EAUAF,EAAU,UAAU,IAAM,SAAUC,EAAKC,EAAKjrD,EAAO,CACnD,KAAK,KAAKgrD,EAAM,KAAK,KAAOC,CAAG,GAAKjrD,CACtC,EASA+qD,EAAU,UAAU,WAAa,SAAUC,EAAKC,EAAK,CACnD,OAAO,KAAK,YAAYD,EAAM,KAAK,KAAOC,CAAG,CAC/C,EAEAE,GAAiBJ,8DCtDjB,MAAMK,EAAgBxxD,KAAmB,cAgBzC7B,EAAA,gBAA0B,SAA0BqiC,EAAS,CAC3D,GAAIA,IAAY,EAAG,MAAO,CAAA,EAE1B,MAAMixB,EAAW,KAAK,MAAMjxB,EAAU,CAAC,EAAI,EACrC3pB,EAAO26C,EAAchxB,CAAO,EAC5BkxB,EAAY76C,IAAS,IAAM,GAAK,KAAK,MAAMA,EAAO,KAAO,EAAI46C,EAAW,EAAE,EAAI,EAC9EE,EAAY,CAAC96C,EAAO,CAAC,EAE3B,QAASxT,EAAI,EAAGA,EAAIouD,EAAW,EAAGpuD,IAChCsuD,EAAUtuD,CAAC,EAAIsuD,EAAUtuD,EAAI,CAAC,EAAIquD,EAGpC,OAAAC,EAAU,KAAK,CAAC,EAETA,EAAU,QAAO,CAC1B,EAsBAxzD,EAAA,aAAuB,SAAuBqiC,EAAS,CACrD,MAAMoxB,EAAS,CAAA,EACTl6C,EAAMvZ,EAAQ,gBAAgBqiC,CAAO,EACrCqxB,EAAYn6C,EAAI,OAEtB,QAASrU,EAAI,EAAGA,EAAIwuD,EAAWxuD,IAC7B,QAASgW,EAAI,EAAGA,EAAIw4C,EAAWx4C,IAExBhW,IAAM,GAAKgW,IAAM,GACjBhW,IAAM,GAAKgW,IAAMw4C,EAAY,GAC7BxuD,IAAMwuD,EAAY,GAAKx4C,IAAM,GAIlCu4C,EAAO,KAAK,CAACl6C,EAAIrU,CAAC,EAAGqU,EAAI2B,CAAC,CAAC,CAAC,EAIhC,OAAOu4C,CACT,4DClFA,MAAMJ,EAAgBxxD,KAAmB,cACnC8xD,EAAsB,EAS5B,OAAAC,GAAA,aAAuB,SAAuBvxB,EAAS,CACrD,MAAM3pB,EAAO26C,EAAchxB,CAAO,EAElC,MAAO,CAEL,CAAC,EAAG,CAAC,EAEL,CAAC3pB,EAAOi7C,EAAqB,CAAC,EAE9B,CAAC,EAAGj7C,EAAOi7C,CAAmB,CAClC,CACA,8DCjBA3zD,EAAA,SAAmB,CACjB,WAAY,EACZ,WAAY,EACZ,WAAY,EACZ,WAAY,EACZ,WAAY,EACZ,WAAY,EACZ,WAAY,EACZ,WAAY,CACd,EAMA,MAAM6zD,EAAgB,CACpB,GAAI,EACJ,GAAI,EACJ,GAAI,GACJ,GAAI,EACN,EAQA7zD,EAAA,QAAkB,SAAkBg+C,EAAM,CACxC,OAAOA,GAAQ,MAAQA,IAAS,IAAM,CAAC,MAAMA,CAAI,GAAKA,GAAQ,GAAKA,GAAQ,CAC7E,EASAh+C,EAAA,KAAe,SAAeiI,EAAO,CACnC,OAAOjI,EAAQ,QAAQiI,CAAK,EAAI,SAASA,EAAO,EAAE,EAAI,MACxD,EASAjI,EAAA,aAAuB,SAAuB+F,EAAM,CAClD,MAAM2S,EAAO3S,EAAK,KAClB,IAAIw3C,EAAS,EACTuW,EAAe,EACfC,EAAe,EACfC,EAAU,KACVC,EAAU,KAEd,QAAShB,EAAM,EAAGA,EAAMv6C,EAAMu6C,IAAO,CACnCa,EAAeC,EAAe,EAC9BC,EAAUC,EAAU,KAEpB,QAASf,EAAM,EAAGA,EAAMx6C,EAAMw6C,IAAO,CACnC,IAAIx9B,EAAS3vB,EAAK,IAAIktD,EAAKC,CAAG,EAC1Bx9B,IAAWs+B,EACbF,KAEIA,GAAgB,IAAGvW,GAAUsW,EAAc,IAAMC,EAAe,IACpEE,EAAUt+B,EACVo+B,EAAe,GAGjBp+B,EAAS3vB,EAAK,IAAImtD,EAAKD,CAAG,EACtBv9B,IAAWu+B,EACbF,KAEIA,GAAgB,IAAGxW,GAAUsW,EAAc,IAAME,EAAe,IACpEE,EAAUv+B,EACVq+B,EAAe,EAEvB,CAEQD,GAAgB,IAAGvW,GAAUsW,EAAc,IAAMC,EAAe,IAChEC,GAAgB,IAAGxW,GAAUsW,EAAc,IAAME,EAAe,GACxE,CAEE,OAAOxW,CACT,EAOAv9C,EAAA,aAAuB,SAAuB+F,EAAM,CAClD,MAAM2S,EAAO3S,EAAK,KAClB,IAAIw3C,EAAS,EAEb,QAAS0V,EAAM,EAAGA,EAAMv6C,EAAO,EAAGu6C,IAChC,QAASC,EAAM,EAAGA,EAAMx6C,EAAO,EAAGw6C,IAAO,CACvC,MAAM91C,EAAOrX,EAAK,IAAIktD,EAAKC,CAAG,EAC5BntD,EAAK,IAAIktD,EAAKC,EAAM,CAAC,EACrBntD,EAAK,IAAIktD,EAAM,EAAGC,CAAG,EACrBntD,EAAK,IAAIktD,EAAM,EAAGC,EAAM,CAAC,GAEvB91C,IAAS,GAAKA,IAAS,IAAGmgC,GACpC,CAGE,OAAOA,EAASsW,EAAc,EAChC,EAQA7zD,EAAA,aAAuB,SAAuB+F,EAAM,CAClD,MAAM2S,EAAO3S,EAAK,KAClB,IAAIw3C,EAAS,EACT2W,EAAU,EACVC,EAAU,EAEd,QAASlB,EAAM,EAAGA,EAAMv6C,EAAMu6C,IAAO,CACnCiB,EAAUC,EAAU,EACpB,QAASjB,EAAM,EAAGA,EAAMx6C,EAAMw6C,IAC5BgB,EAAYA,GAAW,EAAK,KAASnuD,EAAK,IAAIktD,EAAKC,CAAG,EAClDA,GAAO,KAAOgB,IAAY,MAASA,IAAY,KAAQ3W,IAE3D4W,EAAYA,GAAW,EAAK,KAASpuD,EAAK,IAAImtD,EAAKD,CAAG,EAClDC,GAAO,KAAOiB,IAAY,MAASA,IAAY,KAAQ5W,GAEjE,CAEE,OAAOA,EAASsW,EAAc,EAChC,EAUA7zD,EAAA,aAAuB,SAAuB+F,EAAM,CAClD,IAAIquD,EAAY,EAChB,MAAMC,EAAetuD,EAAK,KAAK,OAE/B,QAASb,EAAI,EAAGA,EAAImvD,EAAcnvD,IAAKkvD,GAAaruD,EAAK,KAAKb,CAAC,EAI/D,OAFU,KAAK,IAAI,KAAK,KAAMkvD,EAAY,IAAMC,EAAgB,CAAC,EAAI,EAAE,EAE5DR,EAAc,EAC3B,EAUA,SAASS,EAAWC,EAAarvD,EAAGgW,EAAG,CACrC,OAAQq5C,EAAW,CACjB,KAAKv0D,EAAQ,SAAS,WAAY,OAAQkF,EAAIgW,GAAK,IAAM,EACzD,KAAKlb,EAAQ,SAAS,WAAY,OAAOkF,EAAI,IAAM,EACnD,KAAKlF,EAAQ,SAAS,WAAY,OAAOkb,EAAI,IAAM,EACnD,KAAKlb,EAAQ,SAAS,WAAY,OAAQkF,EAAIgW,GAAK,IAAM,EACzD,KAAKlb,EAAQ,SAAS,WAAY,OAAQ,KAAK,MAAMkF,EAAI,CAAC,EAAI,KAAK,MAAMgW,EAAI,CAAC,GAAK,IAAM,EACzF,KAAKlb,EAAQ,SAAS,WAAY,OAAQkF,EAAIgW,EAAK,EAAKhW,EAAIgW,EAAK,IAAM,EACvE,KAAKlb,EAAQ,SAAS,WAAY,OAASkF,EAAIgW,EAAK,EAAKhW,EAAIgW,EAAK,GAAK,IAAM,EAC7E,KAAKlb,EAAQ,SAAS,WAAY,OAASkF,EAAIgW,EAAK,GAAKhW,EAAIgW,GAAK,GAAK,IAAM,EAE7E,QAAS,MAAM,IAAI,MAAM,mBAAqBq5C,CAAW,CAC7D,CACA,CAQAv0D,EAAA,UAAoB,SAAoBw0D,EAASzuD,EAAM,CACrD,MAAM2S,EAAO3S,EAAK,KAElB,QAASmtD,EAAM,EAAGA,EAAMx6C,EAAMw6C,IAC5B,QAASD,EAAM,EAAGA,EAAMv6C,EAAMu6C,IACxBltD,EAAK,WAAWktD,EAAKC,CAAG,GAC5BntD,EAAK,IAAIktD,EAAKC,EAAKoB,EAAUE,EAASvB,EAAKC,CAAG,CAAC,CAGrD,EAQAlzD,EAAA,YAAsB,SAAsB+F,EAAM0uD,EAAiB,CACjE,MAAMC,EAAc,OAAO,KAAK10D,EAAQ,QAAQ,EAAE,OAClD,IAAI20D,EAAc,EACdC,EAAe,IAEnB,QAAS30D,EAAI,EAAGA,EAAIy0D,EAAaz0D,IAAK,CACpCw0D,EAAgBx0D,CAAC,EACjBD,EAAQ,UAAUC,EAAG8F,CAAI,EAGzB,MAAM8uD,EACJ70D,EAAQ,aAAa+F,CAAI,EACzB/F,EAAQ,aAAa+F,CAAI,EACzB/F,EAAQ,aAAa+F,CAAI,EACzB/F,EAAQ,aAAa+F,CAAI,EAG3B/F,EAAQ,UAAUC,EAAG8F,CAAI,EAErB8uD,EAAUD,IACZA,EAAeC,EACfF,EAAc10D,EAEpB,CAEE,OAAO00D,CACT,4DCzOA,MAAMG,EAAUjzD,GAAA,EAEVkzD,EAAkB,CAEtB,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,GACT,EAAG,EAAG,GAAI,GACV,EAAG,EAAG,GAAI,GACV,EAAG,EAAG,GAAI,GACV,EAAG,GAAI,GAAI,GACX,EAAG,GAAI,GAAI,GACX,EAAG,GAAI,GAAI,GACX,EAAG,GAAI,GAAI,GACX,EAAG,GAAI,GAAI,GACX,EAAG,GAAI,GAAI,GACX,EAAG,GAAI,GAAI,GACX,EAAG,GAAI,GAAI,GACX,EAAG,GAAI,GAAI,GACX,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,IAGRC,EAAqB,CAEzB,EAAG,GAAI,GAAI,GACX,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,GACZ,GAAI,GAAI,GAAI,IACZ,GAAI,GAAI,IAAK,IACb,GAAI,GAAI,IAAK,IACb,GAAI,IAAK,IAAK,IACd,GAAI,IAAK,IAAK,IACd,GAAI,IAAK,IAAK,IACd,GAAI,IAAK,IAAK,IACd,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,IACf,IAAK,IAAK,IAAK,KACf,IAAK,IAAK,IAAK,KACf,IAAK,IAAK,KAAM,KAChB,IAAK,IAAK,KAAM,KAChB,IAAK,IAAK,KAAM,KAChB,IAAK,IAAK,KAAM,KAChB,IAAK,IAAK,KAAM,KAChB,IAAK,IAAK,KAAM,KAChB,IAAK,IAAK,KAAM,KAChB,IAAK,KAAM,KAAM,KACjB,IAAK,KAAM,KAAM,KACjB,IAAK,KAAM,KAAM,KACjB,IAAK,KAAM,KAAM,KACjB,IAAK,KAAM,KAAM,KACjB,IAAK,KAAM,KAAM,KACjB,IAAK,KAAM,KAAM,MAWnB,OAAAC,GAAA,eAAyB,SAAyB5yB,EAAS6yB,EAAsB,CAC/E,OAAQA,EAAoB,CAC1B,KAAKJ,EAAQ,EACX,OAAOC,GAAiB1yB,EAAU,GAAK,EAAI,CAAC,EAC9C,KAAKyyB,EAAQ,EACX,OAAOC,GAAiB1yB,EAAU,GAAK,EAAI,CAAC,EAC9C,KAAKyyB,EAAQ,EACX,OAAOC,GAAiB1yB,EAAU,GAAK,EAAI,CAAC,EAC9C,KAAKyyB,EAAQ,EACX,OAAOC,GAAiB1yB,EAAU,GAAK,EAAI,CAAC,EAC9C,QACE,OAEN,EAUA4yB,GAAA,uBAAiC,SAAiC5yB,EAAS6yB,EAAsB,CAC/F,OAAQA,EAAoB,CAC1B,KAAKJ,EAAQ,EACX,OAAOE,GAAoB3yB,EAAU,GAAK,EAAI,CAAC,EACjD,KAAKyyB,EAAQ,EACX,OAAOE,GAAoB3yB,EAAU,GAAK,EAAI,CAAC,EACjD,KAAKyyB,EAAQ,EACX,OAAOE,GAAoB3yB,EAAU,GAAK,EAAI,CAAC,EACjD,KAAKyyB,EAAQ,EACX,OAAOE,GAAoB3yB,EAAU,GAAK,EAAI,CAAC,EACjD,QACE,OAEN,2DCtIA,MAAM8yB,EAAY,IAAI,WAAW,GAAG,EAC9BC,EAAY,IAAI,WAAW,GAAG,EASnC,OAAC,UAAuB,CACvB,IAAIt1D,EAAI,EACR,QAASoF,EAAI,EAAGA,EAAI,IAAKA,IACvBiwD,EAAUjwD,CAAC,EAAIpF,EACfs1D,EAAUt1D,CAAC,EAAIoF,EAEfpF,IAAM,EAIFA,EAAI,MACNA,GAAK,KAQT,QAASoF,EAAI,IAAKA,EAAI,IAAKA,IACzBiwD,EAAUjwD,CAAC,EAAIiwD,EAAUjwD,EAAI,GAAG,CAEpC,GAAC,EAQDmwD,GAAA,IAAc,SAAc,EAAG,CAC7B,GAAI,EAAI,EAAG,MAAM,IAAI,MAAM,OAAS,EAAI,GAAG,EAC3C,OAAOD,EAAU,CAAC,CACpB,EAQAC,GAAA,IAAc,SAAc,EAAG,CAC7B,OAAOF,EAAU,CAAC,CACpB,EASAE,GAAA,IAAc,SAAcv1D,EAAGQ,EAAG,CAChC,OAAIR,IAAM,GAAKQ,IAAM,EAAU,EAIxB60D,EAAUC,EAAUt1D,CAAC,EAAIs1D,EAAU90D,CAAC,CAAC,CAC9C,wDCpEA,MAAMg1D,EAAKzzD,GAAA,EASX7B,EAAA,IAAc,SAAc6/C,EAAIC,EAAI,CAClC,MAAMiP,EAAQ,IAAI,WAAWlP,EAAG,OAASC,EAAG,OAAS,CAAC,EAEtD,QAAS,EAAI,EAAG,EAAID,EAAG,OAAQ,IAC7B,QAAS3kC,EAAI,EAAGA,EAAI4kC,EAAG,OAAQ5kC,IAC7B6zC,EAAM,EAAI7zC,CAAC,GAAKo6C,EAAG,IAAIzV,EAAG,CAAC,EAAGC,EAAG5kC,CAAC,CAAC,EAIvC,OAAO6zC,CACT,EASA/uD,EAAA,IAAc,SAAcu1D,EAAUC,EAAS,CAC7C,IAAI3yD,EAAS,IAAI,WAAW0yD,CAAQ,EAEpC,KAAQ1yD,EAAO,OAAS2yD,EAAQ,QAAW,GAAG,CAC5C,MAAMzG,EAAQlsD,EAAO,CAAC,EAEtB,QAASqC,EAAI,EAAGA,EAAIswD,EAAQ,OAAQtwD,IAClCrC,EAAOqC,CAAC,GAAKowD,EAAG,IAAIE,EAAQtwD,CAAC,EAAG6pD,CAAK,EAIvC,IAAIv4C,EAAS,EACb,KAAOA,EAAS3T,EAAO,QAAUA,EAAO2T,CAAM,IAAM,GAAGA,IACvD3T,EAASA,EAAO,MAAM2T,CAAM,CAChC,CAEE,OAAO3T,CACT,EASA7C,EAAA,qBAA+B,SAA+By1D,EAAQ,CACpE,IAAIC,EAAO,IAAI,WAAW,CAAC,CAAC,CAAC,EAC7B,QAASxwD,EAAI,EAAGA,EAAIuwD,EAAQvwD,IAC1BwwD,EAAO11D,EAAQ,IAAI01D,EAAM,IAAI,WAAW,CAAC,EAAGJ,EAAG,IAAIpwD,CAAC,CAAC,CAAC,CAAC,EAGzD,OAAOwwD,CACT,yDC7DA,MAAMC,EAAa9zD,GAAA,EAEnB,SAAS+zD,EAAoBH,EAAQ,CACnC,KAAK,QAAU,OACf,KAAK,OAASA,EAEV,KAAK,QAAQ,KAAK,WAAW,KAAK,MAAM,CAC9C,CAQA,OAAAG,EAAmB,UAAU,WAAa,SAAqBH,EAAQ,CAErE,KAAK,OAASA,EACd,KAAK,QAAUE,EAAW,qBAAqB,KAAK,MAAM,CAC5D,EAQAC,EAAmB,UAAU,OAAS,SAAiB7vD,EAAM,CAC3D,GAAI,CAAC,KAAK,QACR,MAAM,IAAI,MAAM,yBAAyB,EAK3C,MAAM8vD,EAAa,IAAI,WAAW9vD,EAAK,OAAS,KAAK,MAAM,EAC3D8vD,EAAW,IAAI9vD,CAAI,EAInB,MAAM+vD,EAAYH,EAAW,IAAIE,EAAY,KAAK,OAAO,EAKnDpnD,EAAQ,KAAK,OAASqnD,EAAU,OACtC,GAAIrnD,EAAQ,EAAG,CACb,MAAMsnD,EAAO,IAAI,WAAW,KAAK,MAAM,EACvC,OAAAA,EAAK,IAAID,EAAWrnD,CAAK,EAElBsnD,CACX,CAEE,OAAOD,CACT,EAEAE,GAAiBJ,6DCjDjBK,GAAA,QAAkB,SAAkB5zB,EAAS,CAC3C,MAAO,CAAC,MAAMA,CAAO,GAAKA,GAAW,GAAKA,GAAW,EACvD,sDCRA,MAAM6zB,EAAU,SACVC,EAAe,oBACrB,IAAIzD,EAAQ,mNAIZA,EAAQA,EAAM,QAAQ,KAAM,KAAK,EAEjC,MAAMld,EAAO,6BAA+Bkd,EAAQ;AAAA,MAEpD7oB,GAAA,MAAgB,IAAI,OAAO6oB,EAAO,GAAG,EACrC7oB,GAAA,WAAqB,IAAI,OAAO,wBAAyB,GAAG,EAC5DA,GAAA,KAAe,IAAI,OAAO2L,EAAM,GAAG,EACnC3L,GAAA,QAAkB,IAAI,OAAOqsB,EAAS,GAAG,EACzCrsB,GAAA,aAAuB,IAAI,OAAOssB,EAAc,GAAG,EAEnD,MAAMC,EAAa,IAAI,OAAO,IAAM1D,EAAQ,GAAG,EACzC2D,EAAe,IAAI,OAAO,IAAMH,EAAU,GAAG,EAC7CI,EAAoB,IAAI,OAAO,wBAAwB,EAE7D,OAAAzsB,GAAA,UAAoB,SAAoB/iC,EAAK,CAC3C,OAAOsvD,EAAW,KAAKtvD,CAAG,CAC5B,EAEA+iC,GAAA,YAAsB,SAAsB/iC,EAAK,CAC/C,OAAOuvD,EAAa,KAAKvvD,CAAG,CAC9B,EAEA+iC,GAAA,iBAA2B,SAA2B/iC,EAAK,CACzD,OAAOwvD,EAAkB,KAAKxvD,CAAG,CACnC,wDC9BA,MAAMyvD,EAAe10D,GAAA,EACf20D,EAAQx1C,GAAA,EASdhhB,EAAA,QAAkB,CAChB,GAAI,UACJ,IAAK,EACL,OAAQ,CAAC,GAAI,GAAI,EAAE,CACrB,EAWAA,EAAA,aAAuB,CACrB,GAAI,eACJ,IAAK,EACL,OAAQ,CAAC,EAAG,GAAI,EAAE,CACpB,EAOAA,EAAA,KAAe,CACb,GAAI,OACJ,IAAK,EACL,OAAQ,CAAC,EAAG,GAAI,EAAE,CACpB,EAWAA,EAAA,MAAgB,CACd,GAAI,QACJ,IAAK,EACL,OAAQ,CAAC,EAAG,GAAI,EAAE,CACpB,EAQAA,EAAA,MAAgB,CACd,IAAK,EACP,EAUAA,EAAA,sBAAgC,SAAgCy2D,EAAMp0B,EAAS,CAC7E,GAAI,CAACo0B,EAAK,OAAQ,MAAM,IAAI,MAAM,iBAAmBA,CAAI,EAEzD,GAAI,CAACF,EAAa,QAAQl0B,CAAO,EAC/B,MAAM,IAAI,MAAM,oBAAsBA,CAAO,EAG/C,OAAIA,GAAW,GAAKA,EAAU,GAAWo0B,EAAK,OAAO,CAAC,EAC7Cp0B,EAAU,GAAWo0B,EAAK,OAAO,CAAC,EACpCA,EAAK,OAAO,CAAC,CACtB,EAQAz2D,EAAA,mBAA6B,SAA6B02D,EAAS,CACjE,OAAIF,EAAM,YAAYE,CAAO,EAAU12D,EAAQ,QACtCw2D,EAAM,iBAAiBE,CAAO,EAAU12D,EAAQ,aAChDw2D,EAAM,UAAUE,CAAO,EAAU12D,EAAQ,MACtCA,EAAQ,IACtB,EAQAA,EAAA,SAAmB,SAAmBy2D,EAAM,CAC1C,GAAIA,GAAQA,EAAK,GAAI,OAAOA,EAAK,GACjC,MAAM,IAAI,MAAM,cAAc,CAChC,EAQAz2D,EAAA,QAAkB,SAAkBy2D,EAAM,CACxC,OAAOA,GAAQA,EAAK,KAAOA,EAAK,MAClC,EAQA,SAASt+C,EAAYxV,EAAQ,CAC3B,GAAI,OAAOA,GAAW,SACpB,MAAM,IAAI,MAAM,uBAAuB,EAKzC,OAFcA,EAAO,YAAW,EAEnB,CACX,IAAK,UACH,OAAO3C,EAAQ,QACjB,IAAK,eACH,OAAOA,EAAQ,aACjB,IAAK,QACH,OAAOA,EAAQ,MACjB,IAAK,OACH,OAAOA,EAAQ,KACjB,QACE,MAAM,IAAI,MAAM,iBAAmB2C,CAAM,CAC/C,CACA,CAUA3C,EAAA,KAAe,SAAeiI,EAAO0qD,EAAc,CACjD,GAAI3yD,EAAQ,QAAQiI,CAAK,EACvB,OAAOA,EAGT,GAAI,CACF,OAAOkQ,EAAWlQ,CAAK,CAC3B,MAAc,CACV,OAAO0qD,CACX,CACA,+DCtKA,MAAMgE,EAAQ90D,GAAA,EACR+0D,EAAS51C,GAAA,EACT8zC,EAAUjxC,GAAA,EACVgzC,EAAOt7B,GAAA,EACPg7B,EAAe/6B,GAAA,EAGfs7B,EAAO,KACPC,EAAUJ,EAAM,YAAYG,CAAG,EAErC,SAASE,EAA6BP,EAAMl0D,EAAQ2yD,EAAsB,CACxE,QAAS+B,EAAiB,EAAGA,GAAkB,GAAIA,IACjD,GAAI10D,GAAUvC,EAAQ,YAAYi3D,EAAgB/B,EAAsBuB,CAAI,EAC1E,OAAOQ,CAKb,CAEA,SAASC,EAAsBT,EAAMp0B,EAAS,CAE5C,OAAOw0B,EAAK,sBAAsBJ,EAAMp0B,CAAO,EAAI,CACrD,CAEA,SAAS80B,EAA2BC,EAAU/0B,EAAS,CACrD,IAAIg1B,EAAY,EAEhB,OAAAD,EAAS,QAAQ,SAAUrxD,EAAM,CAC/B,MAAMuxD,EAAeJ,EAAqBnxD,EAAK,KAAMs8B,CAAO,EAC5Dg1B,GAAaC,EAAevxD,EAAK,cAAa,CAClD,CAAG,EAEMsxD,CACT,CAEA,SAASE,EAA4BH,EAAUlC,EAAsB,CACnE,QAAS+B,EAAiB,EAAGA,GAAkB,GAAIA,IAEjD,GADeE,EAA0BC,EAAUH,CAAc,GACnDj3D,EAAQ,YAAYi3D,EAAgB/B,EAAsB2B,EAAK,KAAK,EAChF,OAAOI,CAKb,CAUAj3D,EAAA,KAAe,SAAeiI,EAAO0qD,EAAc,CACjD,OAAI4D,EAAa,QAAQtuD,CAAK,EACrB,SAASA,EAAO,EAAE,EAGpB0qD,CACT,EAWA3yD,EAAA,YAAsB,SAAsBqiC,EAAS6yB,EAAsBuB,EAAM,CAC/E,GAAI,CAACF,EAAa,QAAQl0B,CAAO,EAC/B,MAAM,IAAI,MAAM,yBAAyB,EAIvC,OAAOo0B,EAAS,MAAaA,EAAOI,EAAK,MAG7C,MAAMW,EAAiBb,EAAM,wBAAwBt0B,CAAO,EAGtDo1B,EAAmBb,EAAO,uBAAuBv0B,EAAS6yB,CAAoB,EAG9EwC,GAA0BF,EAAiBC,GAAoB,EAErE,GAAIhB,IAASI,EAAK,MAAO,OAAOa,EAEhC,MAAMC,EAAaD,EAAyBR,EAAqBT,EAAMp0B,CAAO,EAG9E,OAAQo0B,EAAI,CACV,KAAKI,EAAK,QACR,OAAO,KAAK,MAAOc,EAAa,GAAM,CAAC,EAEzC,KAAKd,EAAK,aACR,OAAO,KAAK,MAAOc,EAAa,GAAM,CAAC,EAEzC,KAAKd,EAAK,MACR,OAAO,KAAK,MAAMc,EAAa,EAAE,EAEnC,KAAKd,EAAK,KACV,QACE,OAAO,KAAK,MAAMc,EAAa,CAAC,CACtC,CACA,EAUA33D,EAAA,sBAAgC,SAAgC+F,EAAMmvD,EAAsB,CAC1F,IAAI0C,EAEJ,MAAMC,EAAM/C,EAAQ,KAAKI,EAAsBJ,EAAQ,CAAC,EAExD,GAAI,MAAM,QAAQ/uD,CAAI,EAAG,CACvB,GAAIA,EAAK,OAAS,EAChB,OAAOwxD,EAA2BxxD,EAAM8xD,CAAG,EAG7C,GAAI9xD,EAAK,SAAW,EAClB,MAAO,GAGT6xD,EAAM7xD,EAAK,CAAC,CAChB,MACI6xD,EAAM7xD,EAGR,OAAOixD,EAA4BY,EAAI,KAAMA,EAAI,UAAS,EAAIC,CAAG,CACnE,EAYA73D,EAAA,eAAyB,SAAyBqiC,EAAS,CACzD,GAAI,CAACk0B,EAAa,QAAQl0B,CAAO,GAAKA,EAAU,EAC9C,MAAM,IAAI,MAAM,yBAAyB,EAG3C,IAAIhjC,EAAIgjC,GAAW,GAEnB,KAAOs0B,EAAM,YAAYt3D,CAAC,EAAI03D,GAAW,GACvC13D,GAAMy3D,GAAQH,EAAM,YAAYt3D,CAAC,EAAI03D,EAGvC,OAAQ10B,GAAW,GAAMhjC,CAC3B,4DClKA,MAAMs3D,EAAQ90D,GAAA,EAERi2D,EAAO,KACPC,EAAY,MACZC,EAAUrB,EAAM,YAAYmB,CAAG,EAYrC,OAAAG,GAAA,eAAyB,SAAyB/C,EAAsBlX,EAAM,CAC5E,MAAMj4C,EAASmvD,EAAqB,KAAO,EAAKlX,EAChD,IAAI3+C,EAAI0G,GAAQ,GAEhB,KAAO4wD,EAAM,YAAYt3D,CAAC,EAAI24D,GAAW,GACvC34D,GAAMy4D,GAAQnB,EAAM,YAAYt3D,CAAC,EAAI24D,EAMvC,OAASjyD,GAAQ,GAAM1G,GAAK04D,CAC9B,wDC5BA,MAAMlB,EAAOh1D,GAAA,EAEb,SAASq2D,EAAanyD,EAAM,CAC1B,KAAK,KAAO8wD,EAAK,QACjB,KAAK,KAAO9wD,EAAK,SAAQ,CAC3B,CAEA,OAAAmyD,EAAY,cAAgB,SAAwB31D,EAAQ,CAC1D,MAAO,IAAK,KAAK,MAAMA,EAAS,CAAC,GAAMA,EAAS,EAAOA,EAAS,EAAK,EAAI,EAAK,EAChF,EAEA21D,EAAY,UAAU,UAAY,UAAsB,CACtD,OAAO,KAAK,KAAK,MACnB,EAEAA,EAAY,UAAU,cAAgB,UAA0B,CAC9D,OAAOA,EAAY,cAAc,KAAK,KAAK,MAAM,CACnD,EAEAA,EAAY,UAAU,MAAQ,SAAgBnF,EAAW,CACvD,IAAI7tD,EAAGmlB,EAAOpiB,EAId,IAAK/C,EAAI,EAAGA,EAAI,GAAK,KAAK,KAAK,OAAQA,GAAK,EAC1CmlB,EAAQ,KAAK,KAAK,OAAOnlB,EAAG,CAAC,EAC7B+C,EAAQ,SAASoiB,EAAO,EAAE,EAE1B0oC,EAAU,IAAI9qD,EAAO,EAAE,EAKzB,MAAMkwD,EAAe,KAAK,KAAK,OAASjzD,EACpCizD,EAAe,IACjB9tC,EAAQ,KAAK,KAAK,OAAOnlB,CAAC,EAC1B+C,EAAQ,SAASoiB,EAAO,EAAE,EAE1B0oC,EAAU,IAAI9qD,EAAOkwD,EAAe,EAAI,CAAC,EAE7C,EAEAC,GAAiBF,kDC1CjB,MAAMrB,EAAOh1D,GAAA,EAWPw2D,EAAkB,CACtB,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC7C,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC5D,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC5D,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAC1C,EAEA,SAASC,EAAkBvyD,EAAM,CAC/B,KAAK,KAAO8wD,EAAK,aACjB,KAAK,KAAO9wD,CACd,CAEA,OAAAuyD,EAAiB,cAAgB,SAAwB/1D,EAAQ,CAC/D,MAAO,IAAK,KAAK,MAAMA,EAAS,CAAC,EAAI,GAAKA,EAAS,EACrD,EAEA+1D,EAAiB,UAAU,UAAY,UAAsB,CAC3D,OAAO,KAAK,KAAK,MACnB,EAEAA,EAAiB,UAAU,cAAgB,UAA0B,CACnE,OAAOA,EAAiB,cAAc,KAAK,KAAK,MAAM,CACxD,EAEAA,EAAiB,UAAU,MAAQ,SAAgBvF,EAAW,CAC5D,IAAI7tD,EAIJ,IAAKA,EAAI,EAAGA,EAAI,GAAK,KAAK,KAAK,OAAQA,GAAK,EAAG,CAE7C,IAAI+C,EAAQowD,EAAgB,QAAQ,KAAK,KAAKnzD,CAAC,CAAC,EAAI,GAGpD+C,GAASowD,EAAgB,QAAQ,KAAK,KAAKnzD,EAAI,CAAC,CAAC,EAGjD6tD,EAAU,IAAI9qD,EAAO,EAAE,CAC3B,CAIM,KAAK,KAAK,OAAS,GACrB8qD,EAAU,IAAIsF,EAAgB,QAAQ,KAAK,KAAKnzD,CAAC,CAAC,EAAG,CAAC,CAE1D,EAEAqzD,GAAiBD,kDC1DjB,MAAMzB,EAAOh1D,GAAA,EAEb,SAAS22D,EAAUzyD,EAAM,CACvB,KAAK,KAAO8wD,EAAK,KACb,OAAQ9wD,GAAU,SACpB,KAAK,KAAO,IAAI,YAAW,EAAG,OAAOA,CAAI,EAEzC,KAAK,KAAO,IAAI,WAAWA,CAAI,CAEnC,CAEA,OAAAyyD,EAAS,cAAgB,SAAwBj2D,EAAQ,CACvD,OAAOA,EAAS,CAClB,EAEAi2D,EAAS,UAAU,UAAY,UAAsB,CACnD,OAAO,KAAK,KAAK,MACnB,EAEAA,EAAS,UAAU,cAAgB,UAA0B,CAC3D,OAAOA,EAAS,cAAc,KAAK,KAAK,MAAM,CAChD,EAEAA,EAAS,UAAU,MAAQ,SAAUzF,EAAW,CAC9C,QAAS7tD,EAAI,EAAGnF,EAAI,KAAK,KAAK,OAAQmF,EAAInF,EAAGmF,IAC3C6tD,EAAU,IAAI,KAAK,KAAK7tD,CAAC,EAAG,CAAC,CAEjC,EAEAuzD,GAAiBD,kDC7BjB,MAAM3B,EAAOh1D,GAAA,EACP80D,EAAQ31C,GAAA,EAEd,SAAS03C,EAAW3yD,EAAM,CACxB,KAAK,KAAO8wD,EAAK,MACjB,KAAK,KAAO9wD,CACd,CAEA,OAAA2yD,EAAU,cAAgB,SAAwBn2D,EAAQ,CACxD,OAAOA,EAAS,EAClB,EAEAm2D,EAAU,UAAU,UAAY,UAAsB,CACpD,OAAO,KAAK,KAAK,MACnB,EAEAA,EAAU,UAAU,cAAgB,UAA0B,CAC5D,OAAOA,EAAU,cAAc,KAAK,KAAK,MAAM,CACjD,EAEAA,EAAU,UAAU,MAAQ,SAAU3F,EAAW,CAC/C,IAAI7tD,EAKJ,IAAKA,EAAI,EAAGA,EAAI,KAAK,KAAK,OAAQA,IAAK,CACrC,IAAI+C,EAAQ0uD,EAAM,OAAO,KAAK,KAAKzxD,CAAC,CAAC,EAGrC,GAAI+C,GAAS,OAAUA,GAAS,MAE9BA,GAAS,cAGAA,GAAS,OAAUA,GAAS,MAErCA,GAAS,UAET,OAAM,IAAI,MACR,2BAA6B,KAAK,KAAK/C,CAAC,EAAI;AAAA,gCACX,EAKrC+C,GAAWA,IAAU,EAAK,KAAQ,KAASA,EAAQ,KAGnD8qD,EAAU,IAAI9qD,EAAO,EAAE,CAC3B,CACA,EAEA0wD,GAAiBD,wEC9BjB,IAAIE,EAAW,CACb,6BAA8B,SAASC,EAAO7hD,EAAG3X,EAAG,CAGlD,IAAIy5D,EAAe,CAAA,EAIfC,EAAQ,CAAA,EACZA,EAAM/hD,CAAC,EAAI,EAMX,IAAIgiD,EAAOJ,EAAS,cAAc,KAAI,EACtCI,EAAK,KAAKhiD,EAAG,CAAC,EAUd,QARIiiD,EACA54D,EAAGo0B,EACHykC,EACAC,EACAC,EACAC,EACAC,EACAC,EACG,CAACP,EAAK,SAAS,CAGpBC,EAAUD,EAAK,IAAG,EAClB34D,EAAI44D,EAAQ,MACZC,EAAiBD,EAAQ,KAGzBE,EAAiBN,EAAMx4D,CAAC,GAAK,CAAA,EAK7B,IAAKo0B,KAAK0kC,EACJA,EAAe,eAAe1kC,CAAC,IAEjC2kC,EAAYD,EAAe1kC,CAAC,EAK5B4kC,EAAgCH,EAAiBE,EAMjDE,EAAiBP,EAAMtkC,CAAC,EACxB8kC,EAAe,OAAOR,EAAMtkC,CAAC,EAAM,KAC/B8kC,GAAeD,EAAiBD,KAClCN,EAAMtkC,CAAC,EAAI4kC,EACXL,EAAK,KAAKvkC,EAAG4kC,CAA6B,EAC1CP,EAAarkC,CAAC,EAAIp0B,GAI9B,CAEI,GAAI,OAAOhB,EAAM,KAAe,OAAO05D,EAAM15D,CAAC,EAAM,IAAa,CAC/D,IAAIqf,EAAM,CAAC,8BAA+B1H,EAAG,OAAQ3X,EAAG,GAAG,EAAE,KAAK,EAAE,EACpE,MAAM,IAAI,MAAMqf,CAAG,CACzB,CAEI,OAAOo6C,CACX,EAEE,4CAA6C,SAASA,EAAcz5D,EAAG,CAIrE,QAHIm6D,EAAQ,CAAA,EACRn5D,EAAIhB,EAEDgB,GACLm5D,EAAM,KAAKn5D,CAAC,EACEy4D,EAAaz4D,CAAC,EAC5BA,EAAIy4D,EAAaz4D,CAAC,EAEpB,OAAAm5D,EAAM,QAAO,EACNA,CACX,EAEE,UAAW,SAASX,EAAO7hD,EAAG3X,EAAG,CAC/B,IAAIy5D,EAAeF,EAAS,6BAA6BC,EAAO7hD,EAAG3X,CAAC,EACpE,OAAOu5D,EAAS,4CACdE,EAAcz5D,CAAC,CACrB,EAKE,cAAe,CACb,KAAM,SAAUioB,EAAM,CACpB,IAAI5lB,EAAIk3D,EAAS,cACbx4D,EAAI,CAAA,EACJoC,EACJ8kB,EAAOA,GAAQ,CAAA,EACf,IAAK9kB,KAAOd,EACNA,EAAE,eAAec,CAAG,IACtBpC,EAAEoC,CAAG,EAAId,EAAEc,CAAG,GAGlB,OAAApC,EAAE,MAAQ,CAAA,EACVA,EAAE,OAASknB,EAAK,QAAU5lB,EAAE,eACrBtB,CACb,EAEI,eAAgB,SAAUlB,EAAGC,EAAG,CAC9B,OAAOD,EAAE,KAAOC,EAAE,IACxB,EAMI,KAAM,SAAU8I,EAAOwxD,EAAM,CAC3B,IAAI3iC,EAAO,CAAC,MAAO7uB,EAAO,KAAMwxD,CAAI,EACpC,KAAK,MAAM,KAAK3iC,CAAI,EACpB,KAAK,MAAM,KAAK,KAAK,MAAM,CACjC,EAKI,IAAK,UAAY,CACf,OAAO,KAAK,MAAM,MAAK,CAC7B,EAEI,MAAO,UAAY,CACjB,OAAO,KAAK,MAAM,SAAW,CACnC,CACA,GAMEpB,UAAiBkjC,uECnKnB,MAAM/B,EAAOh1D,GAAA,EACPq2D,EAAcl3C,GAAA,EACds3C,EAAmBz0C,GAAA,EACnB20C,EAAWj9B,GAAA,EACXm9B,EAAYl9B,GAAA,EACZg7B,EAAQ/6B,GAAA,EACRk7B,EAAQj7B,GAAA,EACRk9B,EAAWj9B,GAAA,EAQjB,SAAS+9B,EAAqB5yD,EAAK,CACjC,OAAO,SAAS,mBAAmBA,CAAG,CAAC,EAAE,MAC3C,CAUA,SAAS6yD,EAAa9vB,EAAO4sB,EAAM3vD,EAAK,CACtC,MAAMswD,EAAW,CAAA,EACjB,IAAIv0D,EAEJ,MAAQA,EAASgnC,EAAM,KAAK/iC,CAAG,KAAO,MACpCswD,EAAS,KAAK,CACZ,KAAMv0D,EAAO,CAAC,EACd,MAAOA,EAAO,MACd,KAAM4zD,EACN,OAAQ5zD,EAAO,CAAC,EAAE,OACnB,EAGH,OAAOu0D,CACT,CASA,SAASwC,EAAuBlD,EAAS,CACvC,MAAMmD,EAAUF,EAAYnD,EAAM,QAASK,EAAK,QAASH,CAAO,EAC1DoD,EAAeH,EAAYnD,EAAM,aAAcK,EAAK,aAAcH,CAAO,EAC/E,IAAIqD,EACAC,EAEJ,OAAIrD,EAAM,sBACRoD,EAAWJ,EAAYnD,EAAM,KAAMK,EAAK,KAAMH,CAAO,EACrDsD,EAAYL,EAAYnD,EAAM,MAAOK,EAAK,MAAOH,CAAO,IAExDqD,EAAWJ,EAAYnD,EAAM,WAAYK,EAAK,KAAMH,CAAO,EAC3DsD,EAAY,CAAA,GAGDH,EAAQ,OAAOC,EAAcC,EAAUC,CAAS,EAG1D,KAAK,SAAU/qC,EAAIgrC,EAAI,CACtB,OAAOhrC,EAAG,MAAQgrC,EAAG,KAC3B,CAAK,EACA,IAAI,SAAU5xD,EAAK,CAClB,MAAO,CACL,KAAMA,EAAI,KACV,KAAMA,EAAI,KACV,OAAQA,EAAI,MACpB,CACA,CAAK,CACL,CAUA,SAAS6xD,EAAsB33D,EAAQk0D,EAAM,CAC3C,OAAQA,EAAI,CACV,KAAKI,EAAK,QACR,OAAOqB,EAAY,cAAc31D,CAAM,EACzC,KAAKs0D,EAAK,aACR,OAAOyB,EAAiB,cAAc/1D,CAAM,EAC9C,KAAKs0D,EAAK,MACR,OAAO6B,EAAU,cAAcn2D,CAAM,EACvC,KAAKs0D,EAAK,KACR,OAAO2B,EAAS,cAAcj2D,CAAM,CAC1C,CACA,CAQA,SAAS43D,EAAeC,EAAM,CAC5B,OAAOA,EAAK,OAAO,SAAUvf,EAAK6F,EAAM,CACtC,MAAM2Z,EAAUxf,EAAI,OAAS,GAAK,EAAIA,EAAIA,EAAI,OAAS,CAAC,EAAI,KAC5D,OAAIwf,GAAWA,EAAQ,OAAS3Z,EAAK,MACnC7F,EAAIA,EAAI,OAAS,CAAC,EAAE,MAAQ6F,EAAK,KAC1B7F,IAGTA,EAAI,KAAK6F,CAAI,EACN7F,EACX,EAAK,CAAA,CAAE,CACP,CAkBA,SAASyf,EAAYF,EAAM,CACzB,MAAMZ,EAAQ,CAAA,EACd,QAASt0D,EAAI,EAAGA,EAAIk1D,EAAK,OAAQl1D,IAAK,CACpC,MAAM0yD,EAAMwC,EAAKl1D,CAAC,EAElB,OAAQ0yD,EAAI,KAAI,CACd,KAAKf,EAAK,QACR2C,EAAM,KAAK,CAAC5B,EACV,CAAE,KAAMA,EAAI,KAAM,KAAMf,EAAK,aAAc,OAAQe,EAAI,MAAM,EAC7D,CAAE,KAAMA,EAAI,KAAM,KAAMf,EAAK,KAAM,OAAQe,EAAI,MAAM,EACtD,EACD,MACF,KAAKf,EAAK,aACR2C,EAAM,KAAK,CAAC5B,EACV,CAAE,KAAMA,EAAI,KAAM,KAAMf,EAAK,KAAM,OAAQe,EAAI,MAAM,EACtD,EACD,MACF,KAAKf,EAAK,MACR2C,EAAM,KAAK,CAAC5B,EACV,CAAE,KAAMA,EAAI,KAAM,KAAMf,EAAK,KAAM,OAAQ6C,EAAoB9B,EAAI,IAAI,CAAC,EACzE,EACD,MACF,KAAKf,EAAK,KACR2C,EAAM,KAAK,CACT,CAAE,KAAM5B,EAAI,KAAM,KAAMf,EAAK,KAAM,OAAQ6C,EAAoB9B,EAAI,IAAI,CAAC,EACzE,CACT,CACA,CAEE,OAAO4B,CACT,CAcA,SAASe,EAAYf,EAAOn3B,EAAS,CACnC,MAAM/iB,EAAQ,CAAA,EACRu5C,EAAQ,CAAE,MAAO,CAAA,CAAE,EACzB,IAAI2B,EAAc,CAAC,OAAO,EAE1B,QAASt1D,EAAI,EAAGA,EAAIs0D,EAAM,OAAQt0D,IAAK,CACrC,MAAMu1D,EAAYjB,EAAMt0D,CAAC,EACnBw1D,EAAiB,CAAA,EAEvB,QAASx/C,EAAI,EAAGA,EAAIu/C,EAAU,OAAQv/C,IAAK,CACzC,MAAMy/C,EAAOF,EAAUv/C,CAAC,EAClB1Y,EAAM,GAAK0C,EAAIgW,EAErBw/C,EAAe,KAAKl4D,CAAG,EACvB8c,EAAM9c,CAAG,EAAI,CAAE,KAAMm4D,EAAM,UAAW,CAAC,EACvC9B,EAAMr2D,CAAG,EAAI,CAAA,EAEb,QAAS3C,EAAI,EAAGA,EAAI26D,EAAY,OAAQ36D,IAAK,CAC3C,MAAM+6D,EAAaJ,EAAY36D,CAAC,EAE5Byf,EAAMs7C,CAAU,GAAKt7C,EAAMs7C,CAAU,EAAE,KAAK,OAASD,EAAK,MAC5D9B,EAAM+B,CAAU,EAAEp4D,CAAG,EACnB03D,EAAqB56C,EAAMs7C,CAAU,EAAE,UAAYD,EAAK,OAAQA,EAAK,IAAI,EACzET,EAAqB56C,EAAMs7C,CAAU,EAAE,UAAWD,EAAK,IAAI,EAE7Dr7C,EAAMs7C,CAAU,EAAE,WAAaD,EAAK,SAEhCr7C,EAAMs7C,CAAU,IAAGt7C,EAAMs7C,CAAU,EAAE,UAAYD,EAAK,QAE1D9B,EAAM+B,CAAU,EAAEp4D,CAAG,EAAI03D,EAAqBS,EAAK,OAAQA,EAAK,IAAI,EAClE,EAAI9D,EAAK,sBAAsB8D,EAAK,KAAMt4B,CAAO,EAE7D,CACA,CAEIm4B,EAAcE,CAClB,CAEE,QAAS76D,EAAI,EAAGA,EAAI26D,EAAY,OAAQ36D,IACtCg5D,EAAM2B,EAAY36D,CAAC,CAAC,EAAE,IAAM,EAG9B,MAAO,CAAE,IAAKg5D,EAAO,MAAOv5C,CAAK,CACnC,CAUA,SAASu7C,EAAoB90D,EAAM+0D,EAAW,CAC5C,IAAIrE,EACJ,MAAMsE,EAAWlE,EAAK,mBAAmB9wD,CAAI,EAK7C,GAHA0wD,EAAOI,EAAK,KAAKiE,EAAWC,CAAQ,EAGhCtE,IAASI,EAAK,MAAQJ,EAAK,IAAMsE,EAAS,IAC5C,MAAM,IAAI,MAAM,IAAMh1D,EAAO,iCACO8wD,EAAK,SAASJ,CAAI,EACpD;AAAA,sBAA4BI,EAAK,SAASkE,CAAQ,CAAC,EAQvD,OAJItE,IAASI,EAAK,OAAS,CAACF,EAAM,mBAAkB,IAClDF,EAAOI,EAAK,MAGNJ,EAAI,CACV,KAAKI,EAAK,QACR,OAAO,IAAIqB,EAAYnyD,CAAI,EAE7B,KAAK8wD,EAAK,aACR,OAAO,IAAIyB,EAAiBvyD,CAAI,EAElC,KAAK8wD,EAAK,MACR,OAAO,IAAI6B,EAAU3yD,CAAI,EAE3B,KAAK8wD,EAAK,KACR,OAAO,IAAI2B,EAASzyD,CAAI,CAC9B,CACA,CAiBA/F,EAAA,UAAoB,SAAoBiZ,EAAO,CAC7C,OAAOA,EAAM,OAAO,SAAU4hC,EAAK+c,EAAK,CACtC,OAAI,OAAOA,GAAQ,SACjB/c,EAAI,KAAKggB,EAAmBjD,EAAK,IAAI,CAAC,EAC7BA,EAAI,MACb/c,EAAI,KAAKggB,EAAmBjD,EAAI,KAAMA,EAAI,IAAI,CAAC,EAG1C/c,CACX,EAAK,CAAA,CAAE,CACP,EAUA76C,EAAA,WAAqB,SAAqB+F,EAAMs8B,EAAS,CACvD,MAAM+3B,EAAOR,EAAsB7zD,EAAM4wD,EAAM,mBAAkB,CAAE,EAE7D6C,EAAQc,EAAWF,CAAI,EACvBvB,EAAQ0B,EAAWf,EAAOn3B,CAAO,EACjC2L,EAAO4qB,EAAS,UAAUC,EAAM,IAAK,QAAS,KAAK,EAEnDmC,EAAgB,CAAA,EACtB,QAAS91D,EAAI,EAAGA,EAAI8oC,EAAK,OAAS,EAAG9oC,IACnC81D,EAAc,KAAKnC,EAAM,MAAM7qB,EAAK9oC,CAAC,CAAC,EAAE,IAAI,EAG9C,OAAOlF,EAAQ,UAAUm6D,EAAca,CAAa,CAAC,CACvD,EAYAh7D,EAAA,SAAmB,SAAmB+F,EAAM,CAC1C,OAAO/F,EAAQ,UACb45D,EAAsB7zD,EAAM4wD,EAAM,mBAAkB,CAAE,CAC1D,CACA,sDCzUA,MAAMA,EAAQ90D,GAAA,EACRizD,EAAU9zC,GAAA,EACV4xC,EAAY/uC,GAAA,EACZmvC,EAAYz3B,GAAA,EACZ0/B,EAAmBz/B,GAAA,EACnB0/B,EAAgBz/B,GAAA,EAChB0/B,EAAcz/B,GAAA,EACdk7B,EAASj7B,GAAA,EACTi6B,EAAqBh6B,GAAA,EACrBw/B,EAAUv/B,GAAA,EACVw/B,EAAav/B,GAAA,EACb+6B,EAAO96B,GAAA,EACPu/B,EAAWt/B,GAAA,EAkCjB,SAASu/B,EAAoBC,EAAQn5B,EAAS,CAC5C,MAAM3pB,EAAO8iD,EAAO,KACdjiD,EAAM2hD,EAAc,aAAa74B,CAAO,EAE9C,QAASn9B,EAAI,EAAGA,EAAIqU,EAAI,OAAQrU,IAAK,CACnC,MAAM+tD,EAAM15C,EAAIrU,CAAC,EAAE,CAAC,EACdguD,EAAM35C,EAAIrU,CAAC,EAAE,CAAC,EAEpB,QAAS/E,EAAI,GAAIA,GAAK,EAAGA,IACvB,GAAI,EAAA8yD,EAAM9yD,GAAK,IAAMuY,GAAQu6C,EAAM9yD,GAEnC,QAASf,EAAI,GAAIA,GAAK,EAAGA,IACnB8zD,EAAM9zD,GAAK,IAAMsZ,GAAQw6C,EAAM9zD,IAE9Be,GAAK,GAAKA,GAAK,IAAMf,IAAM,GAAKA,IAAM,IACxCA,GAAK,GAAKA,GAAK,IAAMe,IAAM,GAAKA,IAAM,IACtCA,GAAK,GAAKA,GAAK,GAAKf,GAAK,GAAKA,GAAK,EACpCo8D,EAAO,IAAIvI,EAAM9yD,EAAG+yD,EAAM9zD,EAAG,GAAM,EAAI,EAEvCo8D,EAAO,IAAIvI,EAAM9yD,EAAG+yD,EAAM9zD,EAAG,GAAO,EAAI,EAIlD,CACA,CASA,SAASq8D,EAAoBD,EAAQ,CACnC,MAAM9iD,EAAO8iD,EAAO,KAEpB,QAASr7D,EAAI,EAAGA,EAAIuY,EAAO,EAAGvY,IAAK,CACjC,MAAM8H,EAAQ9H,EAAI,IAAM,EACxBq7D,EAAO,IAAIr7D,EAAG,EAAG8H,EAAO,EAAI,EAC5BuzD,EAAO,IAAI,EAAGr7D,EAAG8H,EAAO,EAAI,CAChC,CACA,CAUA,SAASyzD,EAAuBF,EAAQn5B,EAAS,CAC/C,MAAM9oB,EAAM0hD,EAAiB,aAAa54B,CAAO,EAEjD,QAASn9B,EAAI,EAAGA,EAAIqU,EAAI,OAAQrU,IAAK,CACnC,MAAM+tD,EAAM15C,EAAIrU,CAAC,EAAE,CAAC,EACdguD,EAAM35C,EAAIrU,CAAC,EAAE,CAAC,EAEpB,QAAS/E,EAAI,GAAIA,GAAK,EAAGA,IACvB,QAASf,EAAI,GAAIA,GAAK,EAAGA,IACnBe,IAAM,IAAMA,IAAM,GAAKf,IAAM,IAAMA,IAAM,GAC1Ce,IAAM,GAAKf,IAAM,EAClBo8D,EAAO,IAAIvI,EAAM9yD,EAAG+yD,EAAM9zD,EAAG,GAAM,EAAI,EAEvCo8D,EAAO,IAAIvI,EAAM9yD,EAAG+yD,EAAM9zD,EAAG,GAAO,EAAI,CAIlD,CACA,CAQA,SAASu8D,EAAkBH,EAAQn5B,EAAS,CAC1C,MAAM3pB,EAAO8iD,EAAO,KACd7wD,EAAOywD,EAAQ,eAAe/4B,CAAO,EAC3C,IAAI4wB,EAAKC,EAAKtc,EAEd,QAAS1xC,EAAI,EAAGA,EAAI,GAAIA,IACtB+tD,EAAM,KAAK,MAAM/tD,EAAI,CAAC,EACtBguD,EAAMhuD,EAAI,EAAIwT,EAAO,EAAI,EACzBk+B,GAAQjsC,GAAQzF,EAAK,KAAO,EAE5Bs2D,EAAO,IAAIvI,EAAKC,EAAKtc,EAAK,EAAI,EAC9B4kB,EAAO,IAAItI,EAAKD,EAAKrc,EAAK,EAAI,CAElC,CASA,SAASglB,EAAiBJ,EAAQtG,EAAsBX,EAAa,CACnE,MAAM77C,EAAO8iD,EAAO,KACd7wD,EAAO0wD,EAAW,eAAenG,EAAsBX,CAAW,EACxE,IAAIrvD,EAAG0xC,EAEP,IAAK1xC,EAAI,EAAGA,EAAI,GAAIA,IAClB0xC,GAAQjsC,GAAQzF,EAAK,KAAO,EAGxBA,EAAI,EACNs2D,EAAO,IAAIt2D,EAAG,EAAG0xC,EAAK,EAAI,EACjB1xC,EAAI,EACbs2D,EAAO,IAAIt2D,EAAI,EAAG,EAAG0xC,EAAK,EAAI,EAE9B4kB,EAAO,IAAI9iD,EAAO,GAAKxT,EAAG,EAAG0xC,EAAK,EAAI,EAIpC1xC,EAAI,EACNs2D,EAAO,IAAI,EAAG9iD,EAAOxT,EAAI,EAAG0xC,EAAK,EAAI,EAC5B1xC,EAAI,EACbs2D,EAAO,IAAI,EAAG,GAAKt2D,EAAI,EAAI,EAAG0xC,EAAK,EAAI,EAEvC4kB,EAAO,IAAI,EAAG,GAAKt2D,EAAI,EAAG0xC,EAAK,EAAI,EAKvC4kB,EAAO,IAAI9iD,EAAO,EAAG,EAAG,EAAG,EAAI,CACjC,CAQA,SAASmjD,EAAWL,EAAQz1D,EAAM,CAChC,MAAM2S,EAAO8iD,EAAO,KACpB,IAAIM,EAAM,GACN7I,EAAMv6C,EAAO,EACbqjD,EAAW,EACXC,EAAY,EAEhB,QAAS9I,EAAMx6C,EAAO,EAAGw6C,EAAM,EAAGA,GAAO,EAGvC,IAFIA,IAAQ,GAAGA,MAEF,CACX,QAAS9zD,EAAI,EAAGA,EAAI,EAAGA,IACrB,GAAI,CAACo8D,EAAO,WAAWvI,EAAKC,EAAM9zD,CAAC,EAAG,CACpC,IAAI68D,EAAO,GAEPD,EAAYj2D,EAAK,SACnBk2D,GAAUl2D,EAAKi2D,CAAS,IAAMD,EAAY,KAAO,GAGnDP,EAAO,IAAIvI,EAAKC,EAAM9zD,EAAG68D,CAAI,EAC7BF,IAEIA,IAAa,KACfC,IACAD,EAAW,EAEvB,CAKM,GAFA9I,GAAO6I,EAEH7I,EAAM,GAAKv6C,GAAQu6C,EAAK,CAC1BA,GAAO6I,EACPA,EAAM,CAACA,EACP,KACR,CACA,CAEA,CAUA,SAASI,EAAY75B,EAAS6yB,EAAsBkC,EAAU,CAE5D,MAAMnzD,EAAS,IAAI2uD,EAEnBwE,EAAS,QAAQ,SAAUrxD,EAAM,CAE/B9B,EAAO,IAAI8B,EAAK,KAAK,IAAK,CAAC,EAS3B9B,EAAO,IAAI8B,EAAK,UAAS,EAAI8wD,EAAK,sBAAsB9wD,EAAK,KAAMs8B,CAAO,CAAC,EAG3Et8B,EAAK,MAAM9B,CAAM,CACrB,CAAG,EAGD,MAAMuzD,EAAiBb,EAAM,wBAAwBt0B,CAAO,EACtDo1B,EAAmBb,EAAO,uBAAuBv0B,EAAS6yB,CAAoB,EAC9EwC,GAA0BF,EAAiBC,GAAoB,EAgBrE,IATIxzD,EAAO,kBAAoB,GAAKyzD,GAClCzzD,EAAO,IAAI,EAAG,CAAC,EAQVA,EAAO,kBAAoB,IAAM,GACtCA,EAAO,OAAO,CAAC,EAOjB,MAAMk4D,GAAiBzE,EAAyBzzD,EAAO,gBAAe,GAAM,EAC5E,QAASiB,EAAI,EAAGA,EAAIi3D,EAAej3D,IACjCjB,EAAO,IAAIiB,EAAI,EAAI,GAAO,IAAM,CAAC,EAGnC,OAAOk3D,EAAgBn4D,EAAQo+B,EAAS6yB,CAAoB,CAC9D,CAWA,SAASkH,EAAiBrJ,EAAW1wB,EAAS6yB,EAAsB,CAElE,MAAMsC,EAAiBb,EAAM,wBAAwBt0B,CAAO,EAGtDo1B,EAAmBb,EAAO,uBAAuBv0B,EAAS6yB,CAAoB,EAG9EmH,EAAqB7E,EAAiBC,EAGtC6E,EAAgB1F,EAAO,eAAev0B,EAAS6yB,CAAoB,EAGnEqH,EAAiB/E,EAAiB8E,EAClCE,EAAiBF,EAAgBC,EAEjCE,EAAyB,KAAK,MAAMjF,EAAiB8E,CAAa,EAElEI,EAAwB,KAAK,MAAML,EAAqBC,CAAa,EACrEK,EAAwBD,EAAwB,EAGhDE,EAAUH,EAAyBC,EAGnChZ,EAAK,IAAIkS,EAAmBgH,CAAO,EAEzC,IAAIpmD,EAAS,EACb,MAAMqmD,EAAS,IAAI,MAAMP,CAAa,EAChCQ,EAAS,IAAI,MAAMR,CAAa,EACtC,IAAIS,EAAc,EAClB,MAAM94D,EAAS,IAAI,WAAW8uD,EAAU,MAAM,EAG9C,QAAS5zD,GAAI,EAAGA,GAAIm9D,EAAen9D,KAAK,CACtC,MAAM69D,GAAW79D,GAAIq9D,EAAiBE,EAAwBC,EAG9DE,EAAO19D,EAAC,EAAI8E,EAAO,MAAMuS,EAAQA,EAASwmD,EAAQ,EAGlDF,EAAO39D,EAAC,EAAIukD,EAAG,OAAOmZ,EAAO19D,EAAC,CAAC,EAE/BqX,GAAUwmD,GACVD,EAAc,KAAK,IAAIA,EAAaC,EAAQ,CAChD,CAIE,MAAMj3D,GAAO,IAAI,WAAWyxD,CAAc,EAC1C,IAAIl1D,GAAQ,EACR4C,GAAG/E,GAGP,IAAK+E,GAAI,EAAGA,GAAI63D,EAAa73D,KAC3B,IAAK/E,GAAI,EAAGA,GAAIm8D,EAAen8D,KACzB+E,GAAI23D,EAAO18D,EAAC,EAAE,SAChB4F,GAAKzD,IAAO,EAAIu6D,EAAO18D,EAAC,EAAE+E,EAAC,GAMjC,IAAKA,GAAI,EAAGA,GAAI03D,EAAS13D,KACvB,IAAK/E,GAAI,EAAGA,GAAIm8D,EAAen8D,KAC7B4F,GAAKzD,IAAO,EAAIw6D,EAAO38D,EAAC,EAAE+E,EAAC,EAI/B,OAAOa,EACT,CAWA,SAASk3D,EAAcl3D,EAAMs8B,EAAS6yB,EAAsBX,EAAa,CACvE,IAAI6C,EAEJ,GAAI,MAAM,QAAQrxD,CAAI,EACpBqxD,EAAWkE,EAAS,UAAUv1D,CAAI,UACzB,OAAOA,GAAS,SAAU,CACnC,IAAIm3D,EAAmB76B,EAEvB,GAAI,CAAC66B,EAAkB,CACrB,MAAMC,EAAc7B,EAAS,SAASv1D,CAAI,EAG1Cm3D,EAAmB9B,EAAQ,sBAAsB+B,EAAajI,CAAoB,CACxF,CAIIkC,EAAWkE,EAAS,WAAWv1D,EAAMm3D,GAAoB,EAAE,CAC/D,KACI,OAAM,IAAI,MAAM,cAAc,EAIhC,MAAME,EAAchC,EAAQ,sBAAsBhE,EAAUlC,CAAoB,EAGhF,GAAI,CAACkI,EACH,MAAM,IAAI,MAAM,yDAAyD,EAI3E,GAAI,CAAC/6B,EACHA,EAAU+6B,UAGD/6B,EAAU+6B,EACnB,MAAM,IAAI,MAAM;AAAA;AAAA,qDAE0CA,EAAc;AAAA,CAC5E,EAGE,MAAMC,EAAWnB,EAAW75B,EAAS6yB,EAAsBkC,CAAQ,EAG7DkG,EAAc3G,EAAM,cAAct0B,CAAO,EACzCk7B,EAAU,IAAIvK,EAAUsK,CAAW,EAGzC,OAAA/B,EAAmBgC,EAASl7B,CAAO,EACnCo5B,EAAmB8B,CAAO,EAC1B7B,EAAsB6B,EAASl7B,CAAO,EAMtCu5B,EAAgB2B,EAASrI,EAAsB,CAAC,EAE5C7yB,GAAW,GACbs5B,EAAiB4B,EAASl7B,CAAO,EAInCw5B,EAAU0B,EAASF,CAAQ,EAEvB,MAAM9I,CAAW,IAEnBA,EAAc4G,EAAY,YAAYoC,EACpC3B,EAAgB,KAAK,KAAM2B,EAASrI,CAAoB,CAAC,GAI7DiG,EAAY,UAAU5G,EAAagJ,CAAO,EAG1C3B,EAAgB2B,EAASrI,EAAsBX,CAAW,EAEnD,CACL,QAASgJ,EACT,QAASl7B,EACT,qBAAsB6yB,EACtB,YAAaX,EACb,SAAU6C,CACd,CACA,CAWA,OAAAoG,GAAA,OAAiB,SAAiBz3D,EAAMnB,EAAS,CAC/C,GAAI,OAAOmB,EAAS,KAAeA,IAAS,GAC1C,MAAM,IAAI,MAAM,eAAe,EAGjC,IAAImvD,EAAuBJ,EAAQ,EAC/BzyB,EACA2b,EAEJ,OAAI,OAAOp5C,EAAY,MAErBswD,EAAuBJ,EAAQ,KAAKlwD,EAAQ,qBAAsBkwD,EAAQ,CAAC,EAC3EzyB,EAAU+4B,EAAQ,KAAKx2D,EAAQ,OAAO,EACtCo5C,EAAOmd,EAAY,KAAKv2D,EAAQ,WAAW,EAEvCA,EAAQ,YACV+xD,EAAM,kBAAkB/xD,EAAQ,UAAU,GAIvCq4D,EAAal3D,EAAMs8B,EAAS6yB,EAAsBlX,CAAI,CAC/D,oEC9eA,SAASyf,EAAUr3C,EAAK,CAKtB,GAJI,OAAOA,GAAQ,WACjBA,EAAMA,EAAI,SAAQ,GAGhB,OAAOA,GAAQ,SACjB,MAAM,IAAI,MAAM,uCAAuC,EAGzD,IAAIs3C,EAAUt3C,EAAI,MAAK,EAAG,QAAQ,IAAK,EAAE,EAAE,MAAM,EAAE,EACnD,GAAIs3C,EAAQ,OAAS,GAAKA,EAAQ,SAAW,GAAKA,EAAQ,OAAS,EACjE,MAAM,IAAI,MAAM,sBAAwBt3C,CAAG,GAIzCs3C,EAAQ,SAAW,GAAKA,EAAQ,SAAW,KAC7CA,EAAU,MAAM,UAAU,OAAO,MAAM,CAAA,EAAIA,EAAQ,IAAI,SAAUt+D,EAAG,CAClE,MAAO,CAACA,EAAGA,CAAC,CAClB,CAAK,CAAC,GAIAs+D,EAAQ,SAAW,GAAGA,EAAQ,KAAK,IAAK,GAAG,EAE/C,MAAMC,EAAW,SAASD,EAAQ,KAAK,EAAE,EAAG,EAAE,EAE9C,MAAO,CACL,EAAIC,GAAY,GAAM,IACtB,EAAIA,GAAY,GAAM,IACtB,EAAIA,GAAY,EAAK,IACrB,EAAGA,EAAW,IACd,IAAK,IAAMD,EAAQ,MAAM,EAAG,CAAC,EAAE,KAAK,EAAE,CAC1C,CACA,CAEA19D,EAAA,WAAqB,SAAqB4E,EAAS,CAC5CA,IAASA,EAAU,CAAA,GACnBA,EAAQ,QAAOA,EAAQ,MAAQ,CAAA,GAEpC,MAAMg5D,EAAS,OAAOh5D,EAAQ,OAAW,KACvCA,EAAQ,SAAW,MACnBA,EAAQ,OAAS,EACf,EACAA,EAAQ,OAENi5D,EAAQj5D,EAAQ,OAASA,EAAQ,OAAS,GAAKA,EAAQ,MAAQ,OAC/Dk5D,EAAQl5D,EAAQ,OAAS,EAE/B,MAAO,CACL,MAAOi5D,EACP,MAAOA,EAAQ,EAAIC,EACnB,OAAQF,EACR,MAAO,CACL,KAAMH,EAAS74D,EAAQ,MAAM,MAAQ,WAAW,EAChD,MAAO64D,EAAS74D,EAAQ,MAAM,OAAS,WAAW,GAEpD,KAAMA,EAAQ,KACd,aAAcA,EAAQ,cAAgB,CAAA,CAC1C,CACA,EAEA5E,EAAA,SAAmB,SAAmB+9D,EAAQz2C,EAAM,CAClD,OAAOA,EAAK,OAASA,EAAK,OAASy2C,EAASz2C,EAAK,OAAS,EACtDA,EAAK,OAASy2C,EAASz2C,EAAK,OAAS,GACrCA,EAAK,KACX,EAEAtnB,EAAA,cAAwB,SAAwB+9D,EAAQz2C,EAAM,CAC5D,MAAMw2C,EAAQ99D,EAAQ,SAAS+9D,EAAQz2C,CAAI,EAC3C,OAAO,KAAK,OAAOy2C,EAASz2C,EAAK,OAAS,GAAKw2C,CAAK,CACtD,EAEA99D,EAAA,cAAwB,SAAwBg+D,EAASC,EAAI32C,EAAM,CACjE,MAAM5O,EAAOulD,EAAG,QAAQ,KAClBl4D,EAAOk4D,EAAG,QAAQ,KAClBH,EAAQ99D,EAAQ,SAAS0Y,EAAM4O,CAAI,EACnC42C,EAAa,KAAK,OAAOxlD,EAAO4O,EAAK,OAAS,GAAKw2C,CAAK,EACxDK,EAAe72C,EAAK,OAASw2C,EAC7BM,EAAU,CAAC92C,EAAK,MAAM,MAAOA,EAAK,MAAM,IAAI,EAElD,QAASpiB,EAAI,EAAGA,EAAIg5D,EAAYh5D,IAC9B,QAASgW,EAAI,EAAGA,EAAIgjD,EAAYhjD,IAAK,CACnC,IAAImjD,GAAUn5D,EAAIg5D,EAAahjD,GAAK,EAChCojD,EAAUh3C,EAAK,MAAM,MAEzB,GAAIpiB,GAAKi5D,GAAgBjjD,GAAKijD,GAC5Bj5D,EAAIg5D,EAAaC,GAAgBjjD,EAAIgjD,EAAaC,EAAc,CAChE,MAAMI,EAAO,KAAK,OAAOr5D,EAAIi5D,GAAgBL,CAAK,EAC5CU,EAAO,KAAK,OAAOtjD,EAAIijD,GAAgBL,CAAK,EAClDQ,EAAUF,EAAQr4D,EAAKw4D,EAAO7lD,EAAO8lD,CAAI,EAAI,EAAI,CAAC,CAC1D,CAEMR,EAAQK,GAAQ,EAAIC,EAAQ,EAC5BN,EAAQK,GAAQ,EAAIC,EAAQ,EAC5BN,EAAQK,GAAQ,EAAIC,EAAQ,EAC5BN,EAAQK,CAAM,EAAIC,EAAQ,CAChC,CAEA,+DClGA,MAAM3H,EAAQ90D,GAAA,EAEd,SAAS48D,EAAaC,EAAKC,EAAQjmD,EAAM,CACvCgmD,EAAI,UAAU,EAAG,EAAGC,EAAO,MAAOA,EAAO,MAAM,EAE1CA,EAAO,QAAOA,EAAO,MAAQ,CAAA,GAClCA,EAAO,OAASjmD,EAChBimD,EAAO,MAAQjmD,EACfimD,EAAO,MAAM,OAASjmD,EAAO,KAC7BimD,EAAO,MAAM,MAAQjmD,EAAO,IAC9B,CAEA,SAASkmD,GAAoB,CAC3B,GAAI,CACF,OAAO,SAAS,cAAc,QAAQ,CAC1C,MAAc,CACV,MAAM,IAAI,MAAM,sCAAsC,CAC1D,CACA,CAEA5+D,EAAA,OAAiB,SAAiB6+D,EAAQF,EAAQ/5D,EAAS,CACzD,IAAI0iB,EAAO1iB,EACPk6D,EAAWH,EAEX,OAAOr3C,EAAS,MAAgB,CAACq3C,GAAU,CAACA,EAAO,cACrDr3C,EAAOq3C,EACPA,EAAS,QAGNA,IACHG,EAAWF,EAAgB,GAG7Bt3C,EAAOqvC,EAAM,WAAWrvC,CAAI,EAC5B,MAAM5O,EAAOi+C,EAAM,cAAckI,EAAO,QAAQ,KAAMv3C,CAAI,EAEpDo3C,EAAMI,EAAS,WAAW,IAAI,EAC9BC,EAAQL,EAAI,gBAAgBhmD,EAAMA,CAAI,EAC5C,OAAAi+C,EAAM,cAAcoI,EAAM,KAAMF,EAAQv3C,CAAI,EAE5Cm3C,EAAYC,EAAKI,EAAUpmD,CAAI,EAC/BgmD,EAAI,aAAaK,EAAO,EAAG,CAAC,EAErBD,CACT,EAEA9+D,EAAA,gBAA0B,SAA0B6+D,EAAQF,EAAQ/5D,EAAS,CAC3E,IAAI0iB,EAAO1iB,EAEP,OAAO0iB,EAAS,MAAgB,CAACq3C,GAAU,CAACA,EAAO,cACrDr3C,EAAOq3C,EACPA,EAAS,QAGNr3C,IAAMA,EAAO,CAAA,GAElB,MAAMw3C,EAAW9+D,EAAQ,OAAO6+D,EAAQF,EAAQr3C,CAAI,EAE9CthB,EAAOshB,EAAK,MAAQ,YACpB03C,EAAe13C,EAAK,cAAgB,CAAA,EAE1C,OAAOw3C,EAAS,UAAU94D,EAAMg5D,EAAa,OAAO,CACtD,4DC9DA,MAAMrI,EAAQ90D,GAAA,EAEd,SAASo9D,EAAgBC,EAAOC,EAAQ,CACtC,MAAMC,EAAQF,EAAM,EAAI,IAClBp4D,EAAMq4D,EAAS,KAAOD,EAAM,IAAM,IAExC,OAAOE,EAAQ,EACXt4D,EAAM,IAAMq4D,EAAS,aAAeC,EAAM,QAAQ,CAAC,EAAE,MAAM,CAAC,EAAI,IAChEt4D,CACN,CAEA,SAASu4D,EAAQC,EAAKx/D,EAAGQ,EAAG,CAC1B,IAAIwG,EAAMw4D,EAAMx/D,EAChB,OAAI,OAAOQ,EAAM,MAAawG,GAAO,IAAMxG,GAEpCwG,CACT,CAEA,SAASy4D,EAAUx5D,EAAM2S,EAAMklD,EAAQ,CACrC,IAAI5vB,EAAO,GACPwxB,EAAS,EACTC,EAAS,GACTC,EAAa,EAEjB,QAASx6D,EAAI,EAAGA,EAAIa,EAAK,OAAQb,IAAK,CACpC,MAAMguD,EAAM,KAAK,MAAMhuD,EAAIwT,CAAI,EACzBu6C,EAAM,KAAK,MAAM/tD,EAAIwT,CAAI,EAE3B,CAACw6C,GAAO,CAACuM,IAAQA,EAAS,IAE1B15D,EAAKb,CAAC,GACRw6D,IAEMx6D,EAAI,GAAKguD,EAAM,GAAKntD,EAAKb,EAAI,CAAC,IAClC8oC,GAAQyxB,EACJJ,EAAO,IAAKnM,EAAM0K,EAAQ,GAAM3K,EAAM2K,CAAM,EAC5CyB,EAAO,IAAKG,EAAQ,CAAC,EAEzBA,EAAS,EACTC,EAAS,IAGLvM,EAAM,EAAIx6C,GAAQ3S,EAAKb,EAAI,CAAC,IAChC8oC,GAAQqxB,EAAO,IAAKK,CAAU,EAC9BA,EAAa,IAGfF,GAEN,CAEE,OAAOxxB,CACT,CAEA,OAAA2xB,GAAA,OAAiB,SAAiBd,EAAQj6D,EAASoiB,EAAI,CACrD,MAAMM,EAAOqvC,EAAM,WAAW/xD,CAAO,EAC/B8T,EAAOmmD,EAAO,QAAQ,KACtB94D,EAAO84D,EAAO,QAAQ,KACtBe,EAAalnD,EAAO4O,EAAK,OAAS,EAElCu4C,EAAMv4C,EAAK,MAAM,MAAM,EAEzB,SAAW23C,EAAe33C,EAAK,MAAM,MAAO,MAAM,EAClD,YAAcs4C,EAAa,IAAMA,EAAa,SAF9C,GAIE5xB,EACJ,SAAWixB,EAAe33C,EAAK,MAAM,KAAM,QAAQ,EACnD,OAASi4C,EAASx5D,EAAM2S,EAAM4O,EAAK,MAAM,EAAI,MAEzCw4C,EAAU,gBAAuBF,EAAa,IAAMA,EAAa,IAIjED,EAAS,4CAFAr4C,EAAK,MAAa,UAAYA,EAAK,MAAQ,aAAeA,EAAK,MAAQ,KAA1D,IAEwCw4C,EAAU,iCAAmCD,EAAK7xB,EAAO;AAAA,EAE7H,OAAI,OAAOhnB,GAAO,YAChBA,EAAG,KAAM24C,CAAM,EAGVA,CACT,+CC/EA,MAAMpN,EAAa1wD,GAAA,EAEbk+D,EAAS/+C,GAAA,EACTg/C,EAAiBn8C,GAAA,EACjBo8C,EAAc1kC,GAAA,EAEpB,SAAS2kC,EAAcC,EAAYxB,EAAQyB,EAAM94C,EAAMN,EAAI,CACzD,MAAM7Y,EAAO,CAAA,EAAG,MAAM,KAAK,UAAW,CAAC,EACjCkyD,EAAUlyD,EAAK,OACfmyD,EAAc,OAAOnyD,EAAKkyD,EAAU,CAAC,GAAM,WAEjD,GAAI,CAACC,GAAe,CAAC/N,IACnB,MAAM,IAAI,MAAM,oCAAoC,EAGtD,GAAI+N,EAAa,CACf,GAAID,EAAU,EACZ,MAAM,IAAI,MAAM,4BAA4B,EAG1CA,IAAY,GACdr5C,EAAKo5C,EACLA,EAAOzB,EACPA,EAASr3C,EAAO,QACP+4C,IAAY,IACjB1B,EAAO,YAAc,OAAO33C,EAAO,KACrCA,EAAKM,EACLA,EAAO,SAEPN,EAAKM,EACLA,EAAO84C,EACPA,EAAOzB,EACPA,EAAS,QAGjB,KAAS,CACL,GAAI0B,EAAU,EACZ,MAAM,IAAI,MAAM,4BAA4B,EAG9C,OAAIA,IAAY,GACdD,EAAOzB,EACPA,EAASr3C,EAAO,QACP+4C,IAAY,GAAK,CAAC1B,EAAO,aAClCr3C,EAAO84C,EACPA,EAAOzB,EACPA,EAAS,QAGJ,IAAI,QAAQ,SAAU4B,EAASC,EAAQ,CAC5C,GAAI,CACF,MAAMz6D,EAAOg6D,EAAO,OAAOK,EAAM94C,CAAI,EACrCi5C,EAAQJ,EAAWp6D,EAAM44D,EAAQr3C,CAAI,CAAC,CAC9C,OAAehoB,EAAG,CACVkhE,EAAOlhE,CAAC,CAChB,CACA,CAAK,CACL,CAEE,GAAI,CACF,MAAMyG,EAAOg6D,EAAO,OAAOK,EAAM94C,CAAI,EACrCN,EAAG,KAAMm5C,EAAWp6D,EAAM44D,EAAQr3C,CAAI,CAAC,CAC3C,OAAWhoB,EAAG,CACV0nB,EAAG1nB,CAAC,CACR,CACA,CAEAmhE,OAAAA,GAAA,OAAiBV,EAAO,OACxBU,GAAA,SAAmBP,EAAa,KAAK,KAAMF,EAAe,MAAM,EAChES,GAAA,UAAoBP,EAAa,KAAK,KAAMF,EAAe,eAAe,EAG1ES,GAAA,SAAmBP,EAAa,KAAK,KAAM,SAAUn6D,EAAMogB,EAAGmB,EAAM,CAClE,OAAO24C,EAAY,OAAOl6D,EAAMuhB,CAAI,CACtC,CAAC","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116]}