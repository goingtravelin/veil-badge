// Test that simulates what the prover does with our JSON input
// Run with: cd charms-app && cargo test prover_simulation --release -- --nocapture

#[cfg(test)]
mod prover_simulation_test {
    use charms_data::Data;
    use serde::{Serialize, Deserialize};
    use veil::types::*;
    use veil::types::proposal::*;
    
    /// The prover receives a JSON spell with `public_args` like:
    /// ```json
    /// {
    ///   "$00": {
    ///     "AcceptProposal": {
    ///       "proposal_id": "abc123...",
    ///       ...
    ///     }
    ///   }
    /// }
    /// ```
    /// 
    /// The prover then:
    /// 1. Parses the spell YAML/JSON
    /// 2. For each app's public_args, converts from JSON to CBOR
    /// 3. Passes the CBOR to the WASM app
    /// 4. The WASM app deserializes via `x.value::<Action>()`
    ///
    /// This test simulates that exact flow.
    #[test]
    fn test_action_json_to_cbor_roundtrip() {
        // The exact JSON the client generates for AcceptProposal public_args
        let action_json = r#"{
            "AcceptProposal": {
                "proposal_id": "17174d5381653821041b8baa6f908de2d091c3154ba073f1b94053d84baf2d08",
                "proposer_badge_id": "deadbeef00000000000000000000000000000000000000000000000000000001",
                "value": 100000,
                "category": "Trade",
                "window_blocks": 144,
                "report_window_blocks": 72,
                "current_block": 117200
            }
        }"#;
        
        println!("=== Testing Action serialization ===");
        println!("Input JSON:\n{}", action_json);
        
        // Step 1: Parse JSON into Action struct
        let action: Action = serde_json::from_str(action_json).expect("parse action from JSON");
        println!("\nParsed Action: {:?}", action);
        
        // Step 2: Convert to Data (CBOR) - this is what the prover does
        let data = Data::from(&action);
        println!("\nConverted to Data (CBOR): OK");
        
        let cbor_bytes = data.bytes();
        println!("CBOR length: {} bytes", cbor_bytes.len());
        println!("CBOR bytes: {:?}", cbor_bytes);
        
        // Step 3: Deserialize from Data - this is what WASM does
        let action_back: Action = data.value().expect("deserialize Action from CBOR");
        println!("\nDeserialized Action: {:?}", action_back);
        
        // Verify
        match action_back {
            Action::AcceptProposal { proposal_id, proposer_badge_id, value, category, window_blocks, report_window_blocks, current_block } => {
                println!("\n✅ AcceptProposal deserialized successfully!");
                println!("  proposal_id: {:?}", proposal_id);
                println!("  proposer_badge_id: {:?}", proposer_badge_id);
                println!("  value: {}", value);
                println!("  category: {:?}", category);
                println!("  window_blocks: {}", window_blocks);
                println!("  report_window_blocks: {}", report_window_blocks);
                println!("  current_block: {}", current_block);
            },
            _ => panic!("Wrong action variant"),
        }
    }
    
    /// Test the exact badge state format from the spell
    #[test]
    fn test_badge_from_spell_format() {
        // The exact format generated by spellGenerator.ts for the charm state
        let badge_json = r#"{
            "id": "17174d5381653821041b8baa6f908de2d091c3154ba073f1b94053d84baf2d08",
            "created_at": 117197,
            "pubkey": "02c46a17827abc6e42b6df542ef3c30091630ae81b3115d29e037376287d086b33",
            "tx_total": 0,
            "tx_positive": 0,
            "tx_negative": 0,
            "volume_total": 0,
            "volume_sum_squares": 0,
            "window_tx_count": 0,
            "window_volume": 0,
            "window_start": 117197,
            "counterparty_count": 0,
            "backing": {
                "backed_count": 0,
                "unbacked_count": 0,
                "backed_volume": 0,
                "unbacked_volume": 0
            },
            "vouches_out": [],
            "vouches_in": [],
            "cascade_damage": 0,
            "active_transactions": [],
            "reporting_transactions": [],
            "outcomes": {
                "mutual_positive": 0,
                "mutual_negative": 0,
                "contested_i_positive": 0,
                "contested_i_negative": 0,
                "timeout": 0,
                "mutual_timeout": 0
            },
            "trust": 15,
            "risk": 35,
            "flags": 36,
            "last_nonce": "0000000000000000000000000000000000000000000000000000000000000000",
            "last_update": 117197
        }"#;
        
        println!("=== Testing Badge serialization ===");
        
        // Step 1: Parse JSON
        let badge: VeilBadge = serde_json::from_str(badge_json).expect("parse badge from JSON");
        println!("Parsed badge from JSON: OK");
        println!("  id: {:?}", badge.id);
        println!("  pubkey: {:?}", badge.pubkey);
        println!("  flags: {:?}", badge.flags);
        
        // Step 2: Convert to Data
        let data = Data::from(&badge);
        println!("\nConverted to Data (CBOR): OK");
        
        let cbor_bytes = data.bytes();
        println!("CBOR length: {} bytes", cbor_bytes.len());
        
        // Step 3: Deserialize back
        let badge_back: VeilBadge = data.value().expect("deserialize badge from CBOR");
        println!("\nDeserialized from CBOR: OK");
        
        // Verify critical fields
        assert_eq!(badge.id, badge_back.id);
        assert_eq!(badge.pubkey, badge_back.pubkey);
        assert_eq!(badge.flags, badge_back.flags);
        println!("✅ Badge roundtrip successful!");
    }
    
    /// Test with an active transaction in the badge (which is what AcceptProposal creates)
    #[test]
    fn test_badge_with_active_transaction() {
        let badge_json = r#"{
            "id": "17174d5381653821041b8baa6f908de2d091c3154ba073f1b94053d84baf2d08",
            "created_at": 117197,
            "pubkey": "02c46a17827abc6e42b6df542ef3c30091630ae81b3115d29e037376287d086b33",
            "tx_total": 0,
            "tx_positive": 0,
            "tx_negative": 0,
            "volume_total": 0,
            "volume_sum_squares": 0,
            "window_tx_count": 0,
            "window_volume": 0,
            "window_start": 117197,
            "counterparty_count": 0,
            "backing": {
                "backed_count": 0,
                "unbacked_count": 0,
                "backed_volume": 0,
                "unbacked_volume": 0
            },
            "vouches_out": [],
            "vouches_in": [],
            "cascade_damage": 0,
            "active_transactions": [
                {
                    "id": "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789",
                    "counterparty_badge_id": "deadbeef00000000000000000000000000000000000000000000000000000001",
                    "value": 100000,
                    "category": "Trade",
                    "started_at": 117200,
                    "window_ends_at": 117344,
                    "report_deadline": 117416,
                    "i_am_proposer": false
                }
            ],
            "reporting_transactions": [],
            "outcomes": {
                "mutual_positive": 0,
                "mutual_negative": 0,
                "contested_i_positive": 0,
                "contested_i_negative": 0,
                "timeout": 0,
                "mutual_timeout": 0
            },
            "trust": 15,
            "risk": 35,
            "flags": 36,
            "last_nonce": "0000000000000000000000000000000000000000000000000000000000000000",
            "last_update": 117200
        }"#;
        
        println!("=== Testing Badge with ActiveTransaction ===");
        
        // Parse JSON
        let badge: VeilBadge = serde_json::from_str(badge_json).expect("parse badge from JSON");
        println!("Parsed badge: OK");
        println!("  active_transactions count: {}", badge.active_transactions.len());
        
        if let Some(tx) = badge.active_transactions.first() {
            println!("  first tx id: {:?}", tx.id);
            println!("  first tx value: {}", tx.value);
            println!("  first tx category: {:?}", tx.category);
            println!("  first tx i_am_proposer: {}", tx.i_am_proposer);
        }
        
        // Convert to Data
        let data = Data::from(&badge);
        println!("\nConverted to Data (CBOR): OK");
        println!("CBOR length: {} bytes", data.bytes().len());
        
        // Deserialize back
        let badge_back: VeilBadge = data.value().expect("deserialize from CBOR");
        println!("\nDeserialized from CBOR: OK");
        println!("  active_transactions count: {}", badge_back.active_transactions.len());
        
        // Verify
        assert_eq!(badge.active_transactions.len(), badge_back.active_transactions.len());
        if let Some(tx) = badge_back.active_transactions.first() {
            assert_eq!(tx.value, 100000);
            assert_eq!(tx.category, TxCategory::Trade);
            assert!(!tx.i_am_proposer);
        }
        
        println!("✅ Badge with ActiveTransaction roundtrip successful!");
    }
}
